From c7cffddfec88f7bc9e489374ff070b6d24e16270 Mon Sep 17 00:00:00 2001
From: Olivier Roussel <olivier.roussel@inria.fr>
Date: Fri, 22 Mar 2024 15:01:28 +0100
Subject: [PATCH 1/3] try to find external qpOASES before falling back on
 embedded version

---
 CMakeLists.txt                                | 22 +++++++++++-------
 cmake/{modules => Modules}/FindHIDAPI.cmake   |  0
 cmake/{modules => Modules}/FindROBOTINO.cmake |  0
 cmake/{modules => Modules}/FindVRPN.cmake     |  0
 cmake/Modules/FindqpOASES.cmake               | 23 +++++++++++++++++++
 5 files changed, 37 insertions(+), 8 deletions(-)
 rename cmake/{modules => Modules}/FindHIDAPI.cmake (100%)
 rename cmake/{modules => Modules}/FindROBOTINO.cmake (100%)
 rename cmake/{modules => Modules}/FindVRPN.cmake (100%)
 create mode 100644 cmake/Modules/FindqpOASES.cmake

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1d15c4d..e55f46f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -139,13 +139,6 @@ endif()
 set(DOC_FILES README.md)
 file(GLOB_RECURSE EXAMPLE_FILES examples "*.pyscn" "*.py" "*.md" "*.psl" "*.pslx" "*.scn" "*.xml")
 
-set(OASES_LIBRARY_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/extlibs/qpOASES-3.2.0/")
-add_subdirectory(${OASES_LIBRARY_DIRECTORY} extlibs/libqpOASES)
-find_package(libqpOASES REQUIRED)
-message("libqpOASES_INCLUDE_DIRS = ${libqpOASES_INCLUDE_DIRS}")
-include_directories(${libqpOASES_INCLUDE_DIRS})
-sofa_install_libraries(PATHS ${libqpOASES_LIBRARY})
-
 option(SOFTROBOTSINVERSE_INSTALL_HEADERS "Install the headers" ON)
 if(SOFTROBOTSINVERSE_INSTALL_HEADERS)
     add_library(${PROJECT_NAME} SHARED ${SOURCE_FILES} ${DOC_FILES} ${EXAMPLE_FILES} ${HEADER_FILES})
@@ -153,11 +146,24 @@ else()
     add_library(${PROJECT_NAME} SHARED ${SOURCE_FILES} ${DOC_FILES} ${EXAMPLE_FILES} "${SRC_DIR}/component/config.h.in")
 endif()
 
+find_package(qpOASES)
+if(qpOASES_FOUND)
+  include_directories(${qpOASES_INCLUDE_DIRS})
+  target_link_libraries(${PROJECT_NAME} ${qpOASES_LIBRARIES})
+else()
+  message("External package qpOASES not found, using embedded version...")
+  set(OASES_LIBRARY_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/extlibs/qpOASES-3.2.0/")
+  add_subdirectory(${OASES_LIBRARY_DIRECTORY} extlibs/libqpOASES)
+  find_package(libqpOASES REQUIRED)
+  include_directories(${libqpOASES_INCLUDE_DIRS})
+  sofa_install_libraries(PATHS ${libqpOASES_LIBRARY})
+  target_link_libraries(${PROJECT_NAME} ${libqpOASES_LIBRARY})
+endif()
+
 target_link_libraries(${PROJECT_NAME}
     SoftRobots
     Sofa.Component.Constraint.Lagrangian.Solver
     Sofa.Component.Collision.Response.Contact)
-target_link_libraries(${PROJECT_NAME} ${libqpOASES_LIBRARY})
 
 # TODO: remove this when SoftRobotsConfig.cmake.in is fixed
 message("SOFTROBOTS_HAVE_SOFA_GL = ${SOFTROBOTS_HAVE_SOFA_GL}")
diff --git a/cmake/modules/FindHIDAPI.cmake b/cmake/Modules/FindHIDAPI.cmake
similarity index 100%
rename from cmake/modules/FindHIDAPI.cmake
rename to cmake/Modules/FindHIDAPI.cmake
diff --git a/cmake/modules/FindROBOTINO.cmake b/cmake/Modules/FindROBOTINO.cmake
similarity index 100%
rename from cmake/modules/FindROBOTINO.cmake
rename to cmake/Modules/FindROBOTINO.cmake
diff --git a/cmake/modules/FindVRPN.cmake b/cmake/Modules/FindVRPN.cmake
similarity index 100%
rename from cmake/modules/FindVRPN.cmake
rename to cmake/Modules/FindVRPN.cmake
diff --git a/cmake/Modules/FindqpOASES.cmake b/cmake/Modules/FindqpOASES.cmake
new file mode 100644
index 0000000..a9706ea
--- /dev/null
+++ b/cmake/Modules/FindqpOASES.cmake
@@ -0,0 +1,23 @@
+# Find the qpOASES includes and libraries.
+# The following variables are set if qpOASES is found.  If qpOASES is not
+# found, qpOASES_FOUND is set to false.
+#  qpOASES_FOUND        - True when the qpOASES include directory is found.
+#  qpOASES_INCLUDE_DIRS - the path to where the qpOASES include files are.
+#  qpOASES_LIBRARIES    - The libraries to link against qpOASES
+
+include(FindPackageHandleStandardArgs)
+
+find_path(qpOASES_INCLUDE_DIR
+  NAMES qpOASES.hpp
+  PATH_SUFFIXES include
+)
+
+find_library(qpOASES_LIBRARY
+  NAMES qpOASES
+  PATH_SUFFIXES lib
+)
+
+set(qpOASES_INCLUDE_DIRS ${qpOASES_INCLUDE_DIR})
+set(qpOASES_LIBRARIES ${qpOASES_LIBRARY})
+
+find_package_handle_standard_args(qpOASES DEFAULT_MSG qpOASES_LIBRARIES qpOASES_INCLUDE_DIRS)
-- 
2.34.1


From e667e8a721f05bde0c496416f2ece7028158d0c0 Mon Sep 17 00:00:00 2001
From: Olivier Roussel <olivier.roussel@inria.fr>
Date: Fri, 22 Mar 2024 15:01:49 +0100
Subject: [PATCH 2/3] remove deprecated FindOASES.cmake

---
 cmake/modules/FindOASES.cmake | 62 -----------------------------------
 1 file changed, 62 deletions(-)
 delete mode 100644 cmake/modules/FindOASES.cmake

diff --git a/cmake/modules/FindOASES.cmake b/cmake/modules/FindOASES.cmake
deleted file mode 100644
index bcddfd3..0000000
--- a/cmake/modules/FindOASES.cmake
+++ /dev/null
@@ -1,62 +0,0 @@
-# Find the OASES includes and libraries.
-# The following variables are set if OASES is found.  If OASES is not
-# found, OASES_FOUND is set to false.
-#  OASES_FOUND        - True when the OASES include directory is found.
-#  OASES_INCLUDE_DIRS - the path to where the OASES include files are.
-#  OASES_LIBRARY_DIRS - The path to where the OASES library files are.
-#  OASES_LIBRARIES    - The libraries to link against OASES
-
-# One may want to use a specific OASES Library by setting
-# OASES_LIBRARY_DIRECTORY before FIND_PACKAGE(OASES)
-INCLUDE(FindPackageHandleStandardArgs)
-
-IF(APPLE)
-	set (extension ".dylib")
-ELSEIF(WIN32)
-	set (extension ".lib") #On Windows, load-time dynamic linking links to the .lib before using the dll at runtime
-ELSE(WIN32)
-	set (extension ".so")
-ENDIF(APPLE)
-
-IF(OASES_LIBRARY_DIRECTORY)
-  MESSAGE(STATUS "Looking for OASES library libqpOASES${extension} in ${OASES_LIBRARY_DIRECTORY}bin/")
-  FIND_LIBRARY(OASES_LIBRARY libqpOASES${extension} PATHS "${OASES_LIBRARY_DIRECTORY}bin/" NO_DEFAULT_PATH)
-  IF(OASES_LIBRARY)
-    MESSAGE(STATUS "Found : OASES_LIBRARY")
-  ENDIF(OASES_LIBRARY)
-ELSE(OASES_LIBRARY_DIRECTORY)
-  FIND_LIBRARY(OASES_LIBRARY libqpOASES${extension} PATHS ENV LD_LIBRARY_PATH ENV DYLD_LIBRARY_PATH)
-ENDIF(OASES_LIBRARY_DIRECTORY)
-
-FIND_PACKAGE_HANDLE_STANDARD_ARGS(qpOASES 
-  REQUIRED_VARS OASES_LIBRARY)
-
-
-IF(OASES_LIBRARY)
-  SET(OASES_LIBRARIES ${OASES_LIBRARY})
-  GET_FILENAME_COMPONENT(OASES_LIBRARY_NAME ${OASES_LIBRARY} NAME)
-  GET_FILENAME_COMPONENT(OASES_LIBRARY_DIRS ${OASES_LIBRARY} PATH)
-  GET_FILENAME_COMPONENT(OASES_LIBRARY_DIRS_DIR ${OASES_LIBRARY_DIRS} PATH)
-  GET_FILENAME_COMPONENT(OASES_LIBRARY_DIRS_DIR_DIR ${OASES_LIBRARY_DIRS_DIR} PATH)
-
-  FIND_PATH(OASES_INCLUDE_DIRS qpOASES.hpp 
-    HINTS ${OASES_LIBRARY_DIRS_DIR} ${OASES_LIBRARY_DIRS_DIR_DIR}
-    ENV PATH
-    PATH_SUFFIXES include)
-  
-  IF(NOT OASES_INCLUDE_DIRS)
-    IF(OASES_FIND_REQUIRED)
-      MESSAGE(FATAL_ERROR
-        "Required OASES headers not found. Please specify headers location in CMAKE_INCLUDE_PATH")
-    ENDIF(OASES_FIND_REQUIRED)
-  ELSE(NOT OASES_INCLUDE_DIRS)
-    SET(OASES_FOUND TRUE)
-  ENDIF(NOT OASES_INCLUDE_DIRS)
-
-ELSE(OASES_LIBRARY)
-  SET(OASES_FOUND FALSE)
-  IF(OASES_FIND_REQUIRED)
-    MESSAGE(FATAL_ERROR
-      "Required OASES library not found. Please specify library location in OASES_LIBRARY_DIRECTORY")
-  ENDIF(OASES_FIND_REQUIRED)
-ENDIF(OASES_LIBRARY)
-- 
2.34.1


From 6daeceaf079427193e9149c67d618225e90eeddc Mon Sep 17 00:00:00 2001
From: Olivier Roussel <olivier.roussel@inria.fr>
Date: Fri, 22 Mar 2024 15:23:39 +0100
Subject: [PATCH 3/3] Force use of external qpOASES

---
 CMakeLists.txt                                |   17 +-
 extlibs/qpOASES-3.2.0/AUTHORS                 |   92 -
 extlibs/qpOASES-3.2.0/AUTHORS.txt             |   92 -
 .../CMakeFiles/example1.dir/depend.internal   |    3 -
 .../CMakeFiles/example1.dir/depend.make       |    3 -
 .../CMakeFiles/example1a.dir/depend.internal  |    3 -
 .../CMakeFiles/example1a.dir/depend.make      |    3 -
 .../CMakeFiles/example1b.dir/depend.internal  |    3 -
 .../CMakeFiles/example1b.dir/depend.make      |    3 -
 .../CMakeFiles/example2.dir/depend.internal   |    3 -
 .../CMakeFiles/example2.dir/depend.make       |    3 -
 .../CMakeFiles/example3.dir/depend.internal   |    3 -
 .../CMakeFiles/example3.dir/depend.make       |    3 -
 .../CMakeFiles/example3b.dir/depend.internal  |    3 -
 .../CMakeFiles/example3b.dir/depend.make      |    3 -
 .../CMakeFiles/example4.dir/depend.internal   |    3 -
 .../CMakeFiles/example4.dir/depend.make       |    3 -
 .../CMakeFiles/example5.dir/depend.internal   |    3 -
 .../CMakeFiles/example5.dir/depend.make       |    3 -
 .../CMakeFiles/exampleLP.dir/depend.internal  |    3 -
 .../CMakeFiles/exampleLP.dir/depend.make      |    3 -
 .../CMakeFiles/qpOASES.dir/depend.internal    |    3 -
 .../CMakeFiles/qpOASES.dir/depend.make        |    3 -
 .../CMakeFiles/qrecipe.dir/depend.internal    |    3 -
 .../CMakeFiles/qrecipe.dir/depend.make        |    3 -
 .../qrecipeSchur.dir/depend.internal          |    3 -
 .../CMakeFiles/qrecipeSchur.dir/depend.make   |    3 -
 extlibs/qpOASES-3.2.0/CMakeLists.txt          |  162 -
 extlibs/qpOASES-3.2.0/INSTALL                 |   79 -
 extlibs/qpOASES-3.2.0/INSTALL.txt             |   79 -
 extlibs/qpOASES-3.2.0/LICENSE                 |  503 --
 extlibs/qpOASES-3.2.0/LICENSE.txt             |  503 --
 extlibs/qpOASES-3.2.0/Makefile                |   94 -
 extlibs/qpOASES-3.2.0/README                  |   84 -
 extlibs/qpOASES-3.2.0/README.txt              |   84 -
 extlibs/qpOASES-3.2.0/VERSIONS                |  124 -
 extlibs/qpOASES-3.2.0/VERSIONS.txt            |  124 -
 extlibs/qpOASES-3.2.0/doc/DoxygenLayout.xml   |  189 -
 extlibs/qpOASES-3.2.0/doc/Makefile            |   66 -
 extlibs/qpOASES-3.2.0/doc/doxygen.config      |  310 -
 extlibs/qpOASES-3.2.0/doc/mainpage.dox        |  134 -
 extlibs/qpOASES-3.2.0/doc/manual.pdf          |  Bin 820879 -> 0 bytes
 extlibs/qpOASES-3.2.0/examples/Makefile       |  107 -
 extlibs/qpOASES-3.2.0/examples/example1.cpp   |   98 -
 extlibs/qpOASES-3.2.0/examples/example1a.cpp  |   85 -
 extlibs/qpOASES-3.2.0/examples/example1b.cpp  |   90 -
 extlibs/qpOASES-3.2.0/examples/example2.cpp   |  123 -
 extlibs/qpOASES-3.2.0/examples/example3.cpp   |   88 -
 extlibs/qpOASES-3.2.0/examples/example3b.cpp  |   88 -
 extlibs/qpOASES-3.2.0/examples/example4.cpp   |  172 -
 extlibs/qpOASES-3.2.0/examples/example4CP.cpp |  112 -
 extlibs/qpOASES-3.2.0/examples/example5.cpp   |  200 -
 extlibs/qpOASES-3.2.0/examples/exampleLP.cpp  |   87 -
 extlibs/qpOASES-3.2.0/examples/qrecipe.cpp    |  118 -
 .../qpOASES-3.2.0/examples/qrecipeSchur.cpp   |  160 -
 .../qpOASES-3.2.0/examples/qrecipe_data.hpp   |  401 -
 extlibs/qpOASES-3.2.0/include/qpOASES.hpp     |   66 -
 .../qpOASES-3.2.0/include/qpOASES/Bounds.hpp  |  256 -
 .../qpOASES-3.2.0/include/qpOASES/Bounds.ipp  |  120 -
 .../include/qpOASES/Constants.hpp             |   77 -
 .../include/qpOASES/ConstraintProduct.hpp     |   91 -
 .../include/qpOASES/Constraints.hpp           |  246 -
 .../include/qpOASES/Constraints.ipp           |  122 -
 .../qpOASES-3.2.0/include/qpOASES/Flipper.hpp |  155 -
 .../include/qpOASES/Indexlist.hpp             |  199 -
 .../include/qpOASES/Indexlist.ipp             |   92 -
 .../include/qpOASES/Matrices.hpp              | 1009 ---
 .../include/qpOASES/MessageHandling.hpp       |  480 --
 .../include/qpOASES/MessageHandling.ipp       |  144 -
 .../qpOASES-3.2.0/include/qpOASES/Options.hpp |  174 -
 .../include/qpOASES/QProblem.hpp              | 1079 ---
 .../include/qpOASES/QProblem.ipp              |  284 -
 .../include/qpOASES/QProblemB.hpp             | 1020 ---
 .../include/qpOASES/QProblemB.ipp             |  496 --
 .../include/qpOASES/SQProblem.hpp             |  358 -
 .../include/qpOASES/SQProblem.ipp             |   51 -
 .../include/qpOASES/SQProblemSchur.hpp        |  475 --
 .../include/qpOASES/SQProblemSchur.ipp        |   57 -
 .../include/qpOASES/SparseSolver.hpp          |  395 -
 .../include/qpOASES/SubjectTo.hpp             |  229 -
 .../include/qpOASES/SubjectTo.ipp             |  158 -
 .../qpOASES-3.2.0/include/qpOASES/Types.hpp   |  335 -
 .../include/qpOASES/UnitTesting.hpp           |   79 -
 .../qpOASES-3.2.0/include/qpOASES/Utils.hpp   |  366 -
 .../qpOASES-3.2.0/include/qpOASES/Utils.ipp   |  174 -
 .../include/qpOASES/extras/OQPinterface.hpp   |  250 -
 .../qpOASES/extras/SolutionAnalysis.hpp       |  166 -
 .../qpOASES/extras/SolutionAnalysis.ipp       |   51 -
 .../qpOASES-3.2.0/interfaces/CUTEst/Makefile  |   79 -
 .../qpOASES-3.2.0/interfaces/CUTEst/makeprob  |   28 -
 .../interfaces/CUTEst/qpoasesCutest.cpp       |  498 --
 .../interfaces/CUTEst/readme.txt              |   39 -
 extlibs/qpOASES-3.2.0/interfaces/c/Makefile   |  128 -
 .../qpOASES-3.2.0/interfaces/c/c_example1.c   |  104 -
 .../qpOASES-3.2.0/interfaces/c/c_example1a.c  |  105 -
 .../qpOASES-3.2.0/interfaces/c/c_example1b.c  |  102 -
 .../interfaces/c/qpOASES_wrapper.cpp          |  576 --
 .../interfaces/c/qpOASES_wrapper.h            |  293 -
 .../qpOASES-3.2.0/interfaces/matlab/Makefile  |   85 -
 .../interfaces/matlab/example1.mat            |  Bin 790 -> 0 bytes
 .../interfaces/matlab/example1a.mat           |  Bin 896 -> 0 bytes
 .../interfaces/matlab/example1b.mat           |  Bin 549 -> 0 bytes
 .../qpOASES-3.2.0/interfaces/matlab/make.m    |  238 -
 .../interfaces/matlab/qpOASES.cpp             |  584 --
 .../qpOASES-3.2.0/interfaces/matlab/qpOASES.m |   75 -
 .../interfaces/matlab/qpOASES_auxInput.m      |  118 -
 .../matlab/qpOASES_matlab_utils.cpp           |  950 ---
 .../matlab/qpOASES_matlab_utils.hpp           |   93 -
 .../interfaces/matlab/qpOASES_options.m       |  251 -
 .../interfaces/matlab/qpOASES_sequence.cpp    | 1104 ---
 .../interfaces/matlab/qpOASES_sequence.m      |  111 -
 extlibs/qpOASES-3.2.0/interfaces/octave/clean |    3 -
 .../qpOASES-3.2.0/interfaces/octave/clean.sh  |    3 -
 .../interfaces/octave/example1.mat            |  Bin 790 -> 0 bytes
 .../interfaces/octave/example1a.mat           |  Bin 896 -> 0 bytes
 .../interfaces/octave/example1b.mat           |  Bin 549 -> 0 bytes
 .../qpOASES-3.2.0/interfaces/octave/make.m    |  238 -
 .../interfaces/octave/qpOASES.cpp             |  584 --
 .../qpOASES-3.2.0/interfaces/octave/qpOASES.m |   75 -
 .../interfaces/octave/qpOASES_auxInput.m      |  118 -
 .../octave/qpOASES_octave_utils.cpp           |  950 ---
 .../octave/qpOASES_octave_utils.hpp           |   93 -
 .../interfaces/octave/qpOASES_options.m       |  251 -
 .../interfaces/octave/qpOASES_sequence.cpp    | 1104 ---
 .../interfaces/octave/qpOASES_sequence.m      |  111 -
 .../interfaces/python/README.rst              |   68 -
 .../python/examples/cython/example1.pyx       |   73 -
 .../python/examples/cython/setup.py           |   16 -
 .../interfaces/python/examples/example1.py    |   76 -
 .../interfaces/python/examples/example1b.py   |   72 -
 .../interfaces/python/examples/example2.py    |   92 -
 .../interfaces/python/qpoases.pxd             |  487 --
 .../interfaces/python/qpoases.pyx             |  929 ---
 .../qpOASES-3.2.0/interfaces/python/setup.py  |   71 -
 .../interfaces/python/tests/__init__.py       |    1 -
 .../interfaces/python/tests/test_examples.py  |  360 -
 .../qpOASES-3.2.0/interfaces/scilab/Makefile  |   93 -
 .../interfaces/scilab/example1.dat            |  Bin 656 -> 0 bytes
 .../interfaces/scilab/example1a.dat           |  Bin 784 -> 0 bytes
 .../interfaces/scilab/example1b.dat           |  Bin 408 -> 0 bytes
 .../interfaces/scilab/qpOASESinterface.c      |  893 ---
 .../interfaces/scilab/qpOASESinterface.sce    |   41 -
 .../interfaces/scilab/qpOASESroutines.cpp     |  369 -
 .../interfaces/simulink/example_QProblem.mdl  |  762 --
 .../interfaces/simulink/example_QProblemB.mdl |  728 --
 .../interfaces/simulink/example_SQProblem.mdl |  797 --
 .../simulink/load_example_QProblem.m          |   86 -
 .../simulink/load_example_QProblemB.m         |   72 -
 .../simulink/load_example_SQProblem.m         |   95 -
 .../qpOASES-3.2.0/interfaces/simulink/make.m  |  239 -
 .../interfaces/simulink/qpOASES_QProblem.cpp  |  506 --
 .../interfaces/simulink/qpOASES_QProblemB.cpp |  431 --
 .../interfaces/simulink/qpOASES_SQProblem.cpp |  475 --
 .../simulink/qpOASES_simulink_utils.cpp       |  121 -
 .../qpOASES-3.2.0/libqpOASESConfig.cmake.in   |   13 -
 extlibs/qpOASES-3.2.0/make.mk                 |   38 -
 extlibs/qpOASES-3.2.0/make_cygwin.mk          |  119 -
 extlibs/qpOASES-3.2.0/make_linux.mk           |  122 -
 extlibs/qpOASES-3.2.0/make_osx.mk             |  124 -
 extlibs/qpOASES-3.2.0/make_windows.mk         |  126 -
 extlibs/qpOASES-3.2.0/src/BLASReplacement.cpp |  146 -
 extlibs/qpOASES-3.2.0/src/Bounds.cpp          |  514 --
 extlibs/qpOASES-3.2.0/src/Constraints.cpp     |  499 --
 extlibs/qpOASES-3.2.0/src/Flipper.cpp         |  259 -
 extlibs/qpOASES-3.2.0/src/Indexlist.cpp       |  319 -
 .../qpOASES-3.2.0/src/LAPACKReplacement.cpp   |  151 -
 extlibs/qpOASES-3.2.0/src/Makefile            |  110 -
 extlibs/qpOASES-3.2.0/src/Matrices.cpp        | 2141 ------
 extlibs/qpOASES-3.2.0/src/MessageHandling.cpp |  632 --
 extlibs/qpOASES-3.2.0/src/OQPinterface.cpp    |  683 --
 extlibs/qpOASES-3.2.0/src/Options.cpp         |  563 --
 extlibs/qpOASES-3.2.0/src/QProblem.cpp        | 6433 -----------------
 extlibs/qpOASES-3.2.0/src/QProblemB.cpp       | 3850 ----------
 extlibs/qpOASES-3.2.0/src/SQProblem.cpp       |  553 --
 extlibs/qpOASES-3.2.0/src/SQProblemSchur.cpp  | 3626 ----------
 .../qpOASES-3.2.0/src/SolutionAnalysis.cpp    |  681 --
 extlibs/qpOASES-3.2.0/src/SparseSolver.cpp    | 1103 ---
 extlibs/qpOASES-3.2.0/src/SubjectTo.cpp       |  289 -
 extlibs/qpOASES-3.2.0/src/Utils.cpp           | 1061 ---
 extlibs/qpOASES-3.2.0/testing/c/Makefile      |   78 -
 .../qpOASES-3.2.0/testing/c/test_c_example1.c |  104 -
 .../testing/c/test_c_example1a.c              |  105 -
 .../testing/c/test_c_example1b.c              |  102 -
 .../qpOASES-3.2.0/testing/checkForMemoryLeaks |  109 -
 extlibs/qpOASES-3.2.0/testing/cpp/Makefile    |  136 -
 .../testing/cpp/data/fetch_cpp_data           |   34 -
 .../qpOASES-3.2.0/testing/cpp/test_bench.cpp  |  310 -
 .../testing/cpp/test_constraintProduct1.cpp   |  200 -
 .../testing/cpp/test_constraintProduct2.cpp   |  197 -
 .../testing/cpp/test_example1.cpp             |  116 -
 .../testing/cpp/test_example1a.cpp            |  111 -
 .../testing/cpp/test_example1b.cpp            |  112 -
 .../testing/cpp/test_example2.cpp             |  131 -
 .../testing/cpp/test_example4.cpp             |  206 -
 .../testing/cpp/test_example5.cpp             |  204 -
 .../testing/cpp/test_example6.cpp             |  109 -
 .../testing/cpp/test_example7.cpp             |   87 -
 .../testing/cpp/test_exampleLP.cpp            |  115 -
 .../testing/cpp/test_externalChol1.cpp        |  101 -
 .../testing/cpp/test_gradientShift.cpp        |  125 -
 .../testing/cpp/test_guessedWS1.cpp           |  153 -
 .../qpOASES-3.2.0/testing/cpp/test_hs268.cpp  |  104 -
 .../testing/cpp/test_indexlist.cpp            |   96 -
 .../testing/cpp/test_infeasible1.cpp          |  104 -
 .../testing/cpp/test_janick1.cpp              |  190 -
 .../testing/cpp/test_janick2.cpp              |  275 -
 .../testing/cpp/test_matrices.cpp             |  903 ---
 .../testing/cpp/test_matrices2.cpp            |  113 -
 .../testing/cpp/test_matrices3.cpp            |   90 -
 .../testing/cpp/test_qrecipe.cpp              |  144 -
 .../testing/cpp/test_qrecipeSchur.cpp         |  167 -
 .../testing/cpp/test_qrecipe_data.hpp         |  401 -
 .../testing/cpp/test_runAllOqpExamples.cpp    |  177 -
 .../testing/cpp/test_sebastien1.cpp           |   74 -
 .../testing/cpp/test_vanBarelsUnboundedQP.cpp |   69 -
 .../testing/matlab/auxFiles/generateExample.m |   25 -
 .../matlab/auxFiles/generateRandomQp.m        |  110 -
 .../testing/matlab/auxFiles/getKktResidual.m  |  134 -
 .../testing/matlab/auxFiles/isoctave.m        |   21 -
 .../matlab/auxFiles/setupQpDataStruct.m       |   18 -
 .../matlab/auxFiles/setupQpFeaturesStruct.m   |   21 -
 .../testing/matlab/data/fetch_matlab_data     |   34 -
 .../testing/matlab/runAllTests.m              |  152 -
 .../testing/matlab/setupTestingPaths.m        |   14 -
 .../testing/matlab/tests/runAlexInfeas1.m     |   30 -
 .../testing/matlab/tests/runAlexInfeas2.m     |   35 -
 .../matlab/tests/runAlternativeX0Test.m       |   84 -
 .../testing/matlab/tests/runBenchmarkCHAIN1.m |   60 -
 .../matlab/tests/runBenchmarkCHAIN1A.m        |   61 -
 .../testing/matlab/tests/runBenchmarkCRANE1.m |   55 -
 .../testing/matlab/tests/runBenchmarkCRANE2.m |   56 -
 .../testing/matlab/tests/runBenchmarkCRANE3.m |   55 -
 .../testing/matlab/tests/runBenchmarkDIESEL.m |   59 -
 .../matlab/tests/runBenchmarkEQUALITY1.m      |   56 -
 .../matlab/tests/runBenchmarkEQUALITY2.m      |   60 -
 .../matlab/tests/runBenchmarkEXAMPLE1.m       |   56 -
 .../matlab/tests/runBenchmarkEXAMPLE1A.m      |   56 -
 .../matlab/tests/runBenchmarkEXAMPLE1B.m      |   56 -
 .../matlab/tests/runBenchmarkIDHESSIAN1.m     |   59 -
 .../matlab/tests/runEmptyHessianTests.m       |  261 -
 .../matlab/tests/runExternalCholeskyTests.m   |  214 -
 .../matlab/tests/runInterfaceSeqTest.m        |  436 --
 .../testing/matlab/tests/runInterfaceTest.m   |  462 --
 .../testing/matlab/tests/runQAP8.m            |   37 -
 .../testing/matlab/tests/runQSHARE1B.m        |   44 -
 .../testing/matlab/tests/runRandomIdHessian.m |  435 --
 .../matlab/tests/runRandomZeroHessian.m       |  433 --
 .../matlab/tests/runSimpleSpringExample.m     |   34 -
 .../matlab/tests/runTestAPrioriKnownSeq1.m    |   87 -
 .../testing/matlab/tests/runTestSeq.m         |  104 -
 .../testing/matlab/tests/runTestSparse.m      |   33 -
 .../testing/matlab/tests/runTestSparse2.m     |   33 -
 .../testing/matlab/tests/runTestSparse3.m     |   39 -
 .../testing/matlab/tests/runTestSparse4.m     |   29 -
 .../matlab/tests/runTestWorkingSetLI.m        |   50 -
 .../matlab/tests/runVanBarelsUnboundedQP.m    |   25 -
 extlibs/qpOASES-3.2.0/testing/runUnitTests    |  110 -
 257 files changed, 4 insertions(+), 65271 deletions(-)
 delete mode 100644 extlibs/qpOASES-3.2.0/AUTHORS
 delete mode 100644 extlibs/qpOASES-3.2.0/AUTHORS.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeLists.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/INSTALL
 delete mode 100644 extlibs/qpOASES-3.2.0/INSTALL.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/LICENSE
 delete mode 100644 extlibs/qpOASES-3.2.0/LICENSE.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/README
 delete mode 100644 extlibs/qpOASES-3.2.0/README.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/VERSIONS
 delete mode 100644 extlibs/qpOASES-3.2.0/VERSIONS.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/doc/DoxygenLayout.xml
 delete mode 100644 extlibs/qpOASES-3.2.0/doc/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/doc/doxygen.config
 delete mode 100644 extlibs/qpOASES-3.2.0/doc/mainpage.dox
 delete mode 100644 extlibs/qpOASES-3.2.0/doc/manual.pdf
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example1a.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example1b.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example2.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example3.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example3b.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example4.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example4CP.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example5.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/exampleLP.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/qrecipe.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/qrecipeSchur.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/qrecipe_data.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Constants.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/ConstraintProduct.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Flipper.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Matrices.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Options.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SparseSolver.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Types.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/UnitTesting.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Utils.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Utils.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/extras/OQPinterface.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/CUTEst/Makefile
 delete mode 100755 extlibs/qpOASES-3.2.0/interfaces/CUTEst/makeprob
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/CUTEst/qpoasesCutest.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/CUTEst/readme.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/c_example1.c
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/c_example1a.c
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/c_example1b.c
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.h
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/example1.mat
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/example1a.mat
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/example1b.mat
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/make.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_auxInput.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_options.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/clean
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/clean.sh
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/example1.mat
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/example1a.mat
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/example1b.mat
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/make.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_auxInput.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_options.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/README.rst
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/example1.pyx
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/setup.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/examples/example1.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/examples/example1b.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/examples/example2.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pxd
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pyx
 delete mode 100755 extlibs/qpOASES-3.2.0/interfaces/python/setup.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/tests/__init__.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/tests/test_examples.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/scilab/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/scilab/example1.dat
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/scilab/example1a.dat
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/scilab/example1b.dat
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.c
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.sce
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESroutines.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblem.mdl
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblemB.mdl
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/example_SQProblem.mdl
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblem.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblemB.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_SQProblem.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/make.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblem.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblemB.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_SQProblem.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_simulink_utils.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/libqpOASESConfig.cmake.in
 delete mode 100644 extlibs/qpOASES-3.2.0/make.mk
 delete mode 100644 extlibs/qpOASES-3.2.0/make_cygwin.mk
 delete mode 100644 extlibs/qpOASES-3.2.0/make_linux.mk
 delete mode 100644 extlibs/qpOASES-3.2.0/make_osx.mk
 delete mode 100644 extlibs/qpOASES-3.2.0/make_windows.mk
 delete mode 100644 extlibs/qpOASES-3.2.0/src/BLASReplacement.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Bounds.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Constraints.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Flipper.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Indexlist.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/LAPACKReplacement.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Matrices.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/MessageHandling.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/OQPinterface.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Options.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/QProblem.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/QProblemB.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/SQProblem.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/SQProblemSchur.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/SolutionAnalysis.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/SparseSolver.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/SubjectTo.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Utils.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/c/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/c/test_c_example1.c
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/c/test_c_example1a.c
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/c/test_c_example1b.c
 delete mode 100755 extlibs/qpOASES-3.2.0/testing/checkForMemoryLeaks
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/Makefile
 delete mode 100755 extlibs/qpOASES-3.2.0/testing/cpp/data/fetch_cpp_data
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_bench.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct2.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example1a.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example1b.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example2.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example4.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example5.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example6.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example7.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_exampleLP.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_externalChol1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_gradientShift.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_guessedWS1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_hs268.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_indexlist.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_infeasible1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_janick1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_janick2.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_matrices.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_matrices2.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_matrices3.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipeSchur.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe_data.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_runAllOqpExamples.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_sebastien1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_vanBarelsUnboundedQP.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateExample.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateRandomQp.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/getKktResidual.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/isoctave.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpDataStruct.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpFeaturesStruct.m
 delete mode 100755 extlibs/qpOASES-3.2.0/testing/matlab/data/fetch_matlab_data
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/runAllTests.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/setupTestingPaths.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas2.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlternativeX0Test.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1A.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE2.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE3.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkDIESEL.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY2.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1A.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1B.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkIDHESSIAN1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runEmptyHessianTests.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runExternalCholeskyTests.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceSeqTest.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceTest.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runQAP8.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runQSHARE1B.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomIdHessian.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomZeroHessian.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runSimpleSpringExample.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestAPrioriKnownSeq1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSeq.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse2.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse3.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse4.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestWorkingSetLI.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runVanBarelsUnboundedQP.m
 delete mode 100755 extlibs/qpOASES-3.2.0/testing/runUnitTests

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e55f46f..4650a68 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -146,19 +146,10 @@ else()
     add_library(${PROJECT_NAME} SHARED ${SOURCE_FILES} ${DOC_FILES} ${EXAMPLE_FILES} "${SRC_DIR}/component/config.h.in")
 endif()
 
-find_package(qpOASES)
-if(qpOASES_FOUND)
-  include_directories(${qpOASES_INCLUDE_DIRS})
-  target_link_libraries(${PROJECT_NAME} ${qpOASES_LIBRARIES})
-else()
-  message("External package qpOASES not found, using embedded version...")
-  set(OASES_LIBRARY_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/extlibs/qpOASES-3.2.0/")
-  add_subdirectory(${OASES_LIBRARY_DIRECTORY} extlibs/libqpOASES)
-  find_package(libqpOASES REQUIRED)
-  include_directories(${libqpOASES_INCLUDE_DIRS})
-  sofa_install_libraries(PATHS ${libqpOASES_LIBRARY})
-  target_link_libraries(${PROJECT_NAME} ${libqpOASES_LIBRARY})
-endif()
+find_package(qpOASES REQUIRED)
+
+include_directories(${qpOASES_INCLUDE_DIRS})
+target_link_libraries(${PROJECT_NAME} ${qpOASES_LIBRARIES})
 
 target_link_libraries(${PROJECT_NAME}
     SoftRobots
diff --git a/extlibs/qpOASES-3.2.0/AUTHORS b/extlibs/qpOASES-3.2.0/AUTHORS
deleted file mode 100644
index f8334b1..0000000
--- a/extlibs/qpOASES-3.2.0/AUTHORS
+++ /dev/null
@@ -1,92 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-MAIN AUTHORS
-============
-
-qpOASES's core functionality and software design have been developed by the
-following main developers (in alphabetical order):
-
-    Hans Joachim Ferreau
-    Christian Kirches
-    Andreas Potschka
-
-
-
-FURTHER AUTHORS
-===============
-
-Moreover, the following developers have contributed code to qpOASES's
-third-party interfaces or provided additional functionality 
-(in alphabetical order):
-
-    Alexander Buchner
-    Holger Diedam
-    Dennis Janka
-    Manuel Kudruss
-    Andreas Waechter
-    Sebastian F. Walter
-
-
-
-CONTRIBUTORS
-============
-
-Finally, the following people have not contributed to the source code,
-but have helped making qpOASES even more useful by testing, reporting
-bugs or proposing algorithmic improvements (in alphabetical order):
-
-    Eckhard Arnold
-    Boris Houska
-    D. Kwame Minde Kufoalor
-    Aude Perrin
-    Milan Vukov
-    Thomas Wiese
-    Leonard Wirsching
-
-
-
-SCIENTIFIC MENTORS
-==================
-
-We also would like to thank two persons who had a major share in making
-qpOASES a success. Not by writing even a single line of code, but by
-establishing the idea of using a homotopy-based approach for high-speed
-QP solutions and by excellent scientific guidance during the development
-process:
-
-    Hans Georg Bock
-    Moritz Diehl
-
-
-
-All users are invited to further improve qpOASES by providing comments,
-code enhancements, bug reports, additional documentation or whatever you
-feel is missing.
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/AUTHORS.txt b/extlibs/qpOASES-3.2.0/AUTHORS.txt
deleted file mode 100644
index 8b1180e..0000000
--- a/extlibs/qpOASES-3.2.0/AUTHORS.txt
+++ /dev/null
@@ -1,92 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-MAIN AUTHORS
-============
-
-qpOASES's core functionality and software design have been developed by the
-following main developers (in alphabetical order):
-
-    Hans Joachim Ferreau
-    Christian Kirches
-    Andreas Potschka
-
-
-
-FURTHER AUTHORS
-===============
-
-Moreover, the following developers have contributed code to qpOASES's
-third-party interfaces or provided additional functionality 
-(in alphabetical order):
-
-    Alexander Buchner
-    Holger Diedam
-    Dennis Janka
-    Manuel Kudruss
-    Andreas Waechter
-    Sebastian F. Walter
-
-
-
-CONTRIBUTORS
-============
-
-Finally, the following people have not contributed to the source code,
-but have helped making qpOASES even more useful by testing, reporting
-bugs or proposing algorithmic improvements (in alphabetical order):
-
-    Eckhard Arnold
-    Boris Houska
-    D. Kwame Minde Kufoalor
-    Aude Perrin
-    Milan Vukov
-    Thomas Wiese
-    Leonard Wirsching
-
-
-
-SCIENTIFIC MENTORS
-==================
-
-We also would like to thank two persons who had a major share in making
-qpOASES a success. Not by writing even a single line of code, but by
-establishing the idea of using a homotopy-based approach for high-speed
-QP solutions and by excellent scientific guidance during the development
-process:
-
-    Hans Georg Bock
-    Moritz Diehl
-
-
-
-All users are invited to further improve qpOASES by providing comments,
-code enhancements, bug reports, additional documentation or whatever you
-feel is missing.
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeLists.txt b/extlibs/qpOASES-3.2.0/CMakeLists.txt
deleted file mode 100644
index a17c482..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeLists.txt
+++ /dev/null
@@ -1,162 +0,0 @@
-##
-##     This file is part of qpOASES.
-##
-##     qpOASES -- An Implementation of the Online Active Set Strategy.
-##     Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##     Christian Kirches et al. All rights reserved.
-##
-##     qpOASES is free software; you can redistribute it and/or
-##     modify it under the terms of the GNU Lesser General Public
-##     License as published by the Free Software Foundation; either
-##     version 2.1 of the License, or (at your option) any later version.
-##
-##     qpOASES is distributed in the hope that it will be useful,
-##     but WITHOUT ANY WARRANTY; without even the implied warranty of
-##     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##     See the GNU Lesser General Public License for more details.
-##
-##     You should have received a copy of the GNU Lesser General Public
-##     License along with qpOASES; if not, write to the Free Software
-##     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##     Filename:  CMakeLists.txt
-##     Author:    Hans Joachim Ferreau (thanks to Milan Vukov)
-##     Version:   3.2
-##     Date:      2007-2015
-##
-
-cmake_minimum_required(VERSION 3.1)
-
-project(libqpOASES VERSION 1.0)
-SET(PACKAGE_NAME "libqpOASES")
-SET(PACKAGE_VERSION "3.2.0")
-SET(PACKAGE_SO_VERSION "3.2")
-SET(PACKAGE_DESCRIPTION "An implementation of the online active set strategy")
-SET(PACKAGE_AUTHOR "Hans Joachim Ferreau, Andreas Potschka, Christian Kirches et al.")
-SET(PACKAGE_MAINTAINER "Hans Joachim Ferreau, Andreas Potschka, Christian Kirches et al.")
-SET(PACKAGE_URL "https://projects.coin-or.org/qpOASES")
-
-SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
-SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/libs)
-
-IF( NOT CMAKE_VERBOSE_MAKEFILE )
-    SET( CMAKE_VERBOSE_MAKEFILE OFF )
-ENDIF( NOT CMAKE_VERBOSE_MAKEFILE )
-
-IF( NOT CMAKE_BUILD_TYPE )
-    SET(CMAKE_BUILD_TYPE Release CACHE STRING
-        "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel."
-        FORCE
-        )
-ENDIF( NOT CMAKE_BUILD_TYPE )
-
-
-############################################################
-#################### compiler flags ########################
-############################################################
-SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D__NO_COPYRIGHT__")
-IF ( UNIX )
-    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -pedantic -Wfloat-equal -Wshadow -DLINUX")
-    SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_DEBUG} -O3 -finline-functions")
-ELSEIF( WINDOWS )
-    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -nologo -EHsc -DWIN32")
-ENDIF()
-
-SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -D__DEBUG__")
-
-############################################################
-######################## rpath #############################
-############################################################
-# use, i.e. don't skip the full RPATH for the build tree
-#set(CMAKE_SKIP_BUILD_RPATH  FALSE)
-
-# when building, don't use the install RPATH already
-# (but later on when installing)
-#set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
-
-#set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib:${CMAKE_INSTALL_PREFIX}/lib/casadi")
-
-# add the automatically determined parts of the RPATH
-# which point to directories outside the build tree to the install RPATH
-#set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
-
-# the RPATH to be used when installing, but only if it's not a system directory
-list(FIND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES "${CMAKE_INSTALL_PREFIX}/lib" isSystemDir)
-if("${isSystemDir}" STREQUAL "-1")
-   set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib:${CMAKE_INSTALL_PREFIX}/lib/casadi")
-endif("${isSystemDir}" STREQUAL "-1")
-
-
-
-############################################################
-#################### build and install #####################
-############################################################
-INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/include)
-
-# compile qpOASES libraries
-FILE(GLOB SRC src/*.cpp)
-FILE(GLOB_RECURSE HEADERS include/*.hpp)
-
-set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS TRUE)
-
-# library
-# ADD_LIBRARY(qpOASES STATIC ${SRC} ${HEADERS})
-ADD_LIBRARY(libqpOASES SHARED ${SRC} ${HEADERS})
-INSTALL(TARGETS libqpOASES
-  LIBRARY DESTINATION lib
-  ARCHIVE DESTINATION lib
-  RUNTIME DESTINATION lib
-)
-SET_TARGET_PROPERTIES(
-    libqpOASES
-    PROPERTIES
-    SOVERSION ${PACKAGE_SO_VERSION}
-    )
-
-# headers
-INSTALL(FILES include/qpOASES.hpp
-  DESTINATION include)
-INSTALL(DIRECTORY include/qpOASES
-  DESTINATION include
-  FILES_MATCHING PATTERN "*.hpp"
-  PATTERN "*.ipp"
-  PATTERN ".svn" EXCLUDE)
-
-sofa_create_package_with_targets(
-        PACKAGE_NAME ${PROJECT_NAME}
-        PACKAGE_VERSION ${PACKAGE_VERSION}
-        TARGETS ${PROJECT_NAME}
-        INCLUDE_INSTALL_DIR "${PROJECT_NAME}"
-        )
-
-############################################################
-######################### examples #########################
-############################################################
-# compile qpOASES examples
-# SET(EXAMPLE_NAMES
-    # example1
-    # example1a
-    # example1b
-    # example2
-    # example3
-    # example3b
-    # example4
-    # example5
-    # exampleLP
-    # qrecipe
-	# qrecipeSchur
-# )
-
-# FOREACH(ELEMENT ${EXAMPLE_NAMES})
-    # ADD_EXECUTABLE(${ELEMENT} examples/${ELEMENT}.cpp)
-    # TARGET_LINK_LIBRARIES(${ELEMENT} qpOASES)
-# ENDFOREACH(ELEMENT ${EXAMPLE_NAMES})
-
-
-##
-##   end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/INSTALL b/extlibs/qpOASES-3.2.0/INSTALL
deleted file mode 100644
index 465c7bb..0000000
--- a/extlibs/qpOASES-3.2.0/INSTALL
+++ /dev/null
@@ -1,79 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-INSTALLATION UNDER LINUX
-========================
-
-0. Obtain qpOASES from COIN-OR:
-
-Download a zipped archive containg the latest stable release and unpack it 
-into <install-dir>. Alternatively, you check out the latest stable branch, 
-e.g. by running
-
-svn co https://projects.coin-or.org/svn/qpOASES/stable/3.2 <install-dir>
-
-from your shell. 
-
-
-1. Compilation of the qpOASES library libqpOASES.a (or .so) and test examples:
-
-cd <install-dir>
-make
-
-The library  libqpOASES.a (or .so)  provides the complete functionality of the 
-qpOASES software package. It can be used by, e.g., linking it against a main 
-function from the examples folder. The make also compiles a couple of test 
-examples; executables are stored within the directory <install-dir>/bin.
-
-
-2. Running a simple test example:
-
-Among others, an executable called  example1  should have been created; run 
-it in order to test your installation:
-
-cd <install-dir>/bin
-./example1
-
-If it terminates after successfully solving two QP problems, qpOASES has been 
-successfully installed!
-
-
-3. Optional, create source code documentation (using doxygen):
-
-cd <install-dir>/doc
-doxygen doxygen.config
-
-Afterwards, you can open the file <install-dir>/doc/html/index.html with
-your favorite browser in order to view qpOASES's source code documentation.
-
-
-NOTE: More detailed installation instructions, including information on how
-      to run unit tests can be found in the qpOASES User's Manual located 
-      at <install-dir>/doc/manual.pdf!
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/INSTALL.txt b/extlibs/qpOASES-3.2.0/INSTALL.txt
deleted file mode 100644
index 9674ff5..0000000
--- a/extlibs/qpOASES-3.2.0/INSTALL.txt
+++ /dev/null
@@ -1,79 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-INSTALLATION UNDER LINUX
-========================
-
-0. Obtain qpOASES from COIN-OR:
-
-Download a zipped archive containg the latest stable release and unpack it 
-into <install-dir>. Alternatively, you check out the latest stable branch, 
-e.g. by running
-
-svn co https://projects.coin-or.org/svn/qpOASES/stable/3.2 <install-dir>
-
-from your shell. 
-
-
-1. Compilation of the qpOASES library libqpOASES.a (or .so) and test examples:
-
-cd <install-dir>
-make
-
-The library  libqpOASES.a (or .so)  provides the complete functionality of the 
-qpOASES software package. It can be used by, e.g., linking it against a main 
-function from the examples folder. The make also compiles a couple of test 
-examples; executables are stored within the directory <install-dir>/bin.
-
-
-2. Running a simple test example:
-
-Among others, an executable called  example1  should have been created; run 
-it in order to test your installation:
-
-cd <install-dir>/bin
-./example1
-
-If it terminates after successfully solving two QP problems, qpOASES has been 
-successfully installed!
-
-
-3. Optional, create source code documentation (using doxygen):
-
-cd <install-dir>/doc
-doxygen doxygen.config
-
-Afterwards, you can open the file <install-dir>/doc/html/index.html with
-your favorite browser in order to view qpOASES's source code documentation.
-
-
-NOTE: More detailed installation instructions, including information on how
-      to run unit tests can be found in the qpOASES User's Manual located 
-      at <install-dir>/doc/manual.pdf!
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/LICENSE b/extlibs/qpOASES-3.2.0/LICENSE
deleted file mode 100644
index 9ef3d70..0000000
--- a/extlibs/qpOASES-3.2.0/LICENSE
+++ /dev/null
@@ -1,503 +0,0 @@
-		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
- 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
-
diff --git a/extlibs/qpOASES-3.2.0/LICENSE.txt b/extlibs/qpOASES-3.2.0/LICENSE.txt
deleted file mode 100644
index 2d59e84..0000000
--- a/extlibs/qpOASES-3.2.0/LICENSE.txt
+++ /dev/null
@@ -1,503 +0,0 @@
-		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
- 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
-
diff --git a/extlibs/qpOASES-3.2.0/Makefile b/extlibs/qpOASES-3.2.0/Makefile
deleted file mode 100644
index 1ae785d..0000000
--- a/extlibs/qpOASES-3.2.0/Makefile
+++ /dev/null
@@ -1,94 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-include make.mk
-
-##
-##	targets
-##
-
-
-all: src examples
-#src_aw testing
-
-src:
-	@cd $@; ${MAKE} -s 
-
-#src_aw:
-#	@cd $@; ${MAKE} -s 
-
-examples: src
-	@cd $@; ${MAKE} -s
-
-doc:
-	@cd $@; ${MAKE} -s 
-
-testing: src
-	@cd testing/cpp; ${MAKE} -s
-
-test: testing
-	@cd testing/cpp; ${MAKE} -s runTests
-
-debugging:
-	@cd $@; ${MAKE} -s 
-
-clean:
-	@cd src               && ${MAKE} -s clean
-	@cd examples          && ${MAKE} -s clean
-	@cd bin               && ${RM} -f *.* *{EXE}
-	@cd testing/cpp       && ${MAKE} -s clean
-
-#	&& cd src_aw            && ${MAKE} -s clean && cd .. \
-#	&& cd debugging         && ${MAKE} -s clean && cd .. \
-
-
-clobber: clean
-
-scilab:
-	@echo Compiling Scilab interface...
-	@cd ./interfaces/scilab/; ${MAKE} -s
-
-python: all
-	cd ./interfaces/python/ && python setup.py build_ext --inplace
-
-pythoninstall: all
-	cd ./interfaces/python/ && python setup.py install
-
-c_wrapper:
-	@echo Compiling C interface...
-	@cd ./interfaces/c/; ${MAKE} -s
-
-.PHONY : all src examples doc testing debugging clean clobber scilab python phythoninstall c_wrapper
-
-
-##
-##   end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/README b/extlibs/qpOASES-3.2.0/README
deleted file mode 100644
index 6a0119e..0000000
--- a/extlibs/qpOASES-3.2.0/README
+++ /dev/null
@@ -1,84 +0,0 @@
-﻿##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-INTRODUCTION
-============
-
-qpOASES is an open-source C++ implementation of the recently proposed 
-online active set strategy, which was inspired by important observations 
-from the field of parametric quadratic programming (QP). It has several 
-theoretical features that make it particularly suited for model predictive 
-control (MPC) applications. Further numerical modifications have made 
-qpOASES a reliable QP solver, even when tackling semi-definite, ill-posed or 
-degenerated QP problems. Moreover, several interfaces to third-party software 
-like ​Matlab or ​Simulink are provided that make qpOASES easy-to-use even for 
-users without knowledge of C/C++.
-
-
-
-GETTING STARTED
-===============
-
-1. For installation, usage and additional information on this software package 
-   see the qpOASES User's Manual located at doc/manual.pdf or check its
-   source code documentation!
-
-
-2. The file LICENSE.txt contains a copy of the GNU Lesser General Public 
-   License (v2.1). Please read it carefully before using qpOASES!
-
-
-3. The whole software package can be obtained from 
-
-       http://www.qpOASES.org/ or
-	   https://projects.coin-or.org/qpOASES/
-
-   On this webpage you will also find further support such as a list of 
-   questions posed by other users.
-
-
-
-CONTACT THE AUTHORS
-===================
-
-If you have got questions, remarks or comments on qpOASES, it is strongly 
-encouraged to report them by creating a new ticket at the qpOASES webpage.
-In case you do not want to disclose your feedback to the public, you may
-send an e-mail to
-
-        support@qpOASES.org
-
-Finally, you may contact one of the main authors directly:
-
-        Hans Joachim Ferreau, joachim.ferreau@ch.abb.com
-        Andreas Potschka,     potschka@iwr.uni-heidelberg.de
-        Christian Kirches,    christian.kirches@iwr.uni-heidelberg.de
-
-Also bug reports, source code enhancements or success stories are most welcome!
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/README.txt b/extlibs/qpOASES-3.2.0/README.txt
deleted file mode 100644
index 4c71c79..0000000
--- a/extlibs/qpOASES-3.2.0/README.txt
+++ /dev/null
@@ -1,84 +0,0 @@
-﻿##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-INTRODUCTION
-============
-
-qpOASES is an open-source C++ implementation of the recently proposed 
-online active set strategy, which was inspired by important observations 
-from the field of parametric quadratic programming (QP). It has several 
-theoretical features that make it particularly suited for model predictive 
-control (MPC) applications. Further numerical modifications have made 
-qpOASES a reliable QP solver, even when tackling semi-definite, ill-posed or 
-degenerated QP problems. Moreover, several interfaces to third-party software 
-like ​Matlab or ​Simulink are provided that make qpOASES easy-to-use even for 
-users without knowledge of C/C++.
-
-
-
-GETTING STARTED
-===============
-
-1. For installation, usage and additional information on this software package 
-   see the qpOASES User's Manual located at doc/manual.pdf or check its
-   source code documentation!
-
-
-2. The file LICENSE.txt contains a copy of the GNU Lesser General Public 
-   License (v2.1). Please read it carefully before using qpOASES!
-
-
-3. The whole software package can be obtained from 
-
-       http://www.qpOASES.org/ or
-	   https://projects.coin-or.org/qpOASES/
-
-   On this webpage you will also find further support such as a list of 
-   questions posed by other users.
-
-
-
-CONTACT THE AUTHORS
-===================
-
-If you have got questions, remarks or comments on qpOASES, it is strongly 
-encouraged to report them by creating a new ticket at the qpOASES webpage.
-In case you do not want to disclose your feedback to the public, you may
-send an e-mail to
-
-        support@qpOASES.org
-
-Finally, you may contact one of the main authors directly:
-
-        Hans Joachim Ferreau, joachim.ferreau@ch.abb.com
-        Andreas Potschka,     potschka@iwr.uni-heidelberg.de
-        Christian Kirches,    christian.kirches@iwr.uni-heidelberg.de
-
-Also bug reports, source code enhancements or success stories are most welcome!
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/VERSIONS b/extlibs/qpOASES-3.2.0/VERSIONS
deleted file mode 100644
index c3c97e3..0000000
--- a/extlibs/qpOASES-3.2.0/VERSIONS
+++ /dev/null
@@ -1,124 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-VERSION HISTORY
-===============
-
-
-3.2 (released on 1st September 2015):
--------------------------------------
-
-+ Addition of SQProblemSchur class implementing Schur complement approach
-  for sparse QP problems
-+ Introduction of data types int_t and uint_t for integer-valued numbers
-+ Minor source code clean-up and bugfixes
-
-
-3.1 (released on 11th February 2015):
--------------------------------------
-
-+ Addition of C interface
-+ Further improved Matlab, Simulink, octave and Python interfaces
-+ Possibility to provide pre-computed Cholesky factor of Hessian matrix
-+ Source code clean-up and bugfixes
-
-
-3.0 (released on 29th July 2014, last updated on 17th December 2014):
----------------------------------------------------------------------
-
-+ Addition of unit testing
-+ Several bugfixes
-
-
-3.0beta (released on 16th August 2011, last updated on 4th April 2014):
------------------------------------------------------------------------
-
-+ Improved ratio tests and termination check for increased reliabilty
-+ Introduction of iterative refinement in step determination and 
-  drift correction to handle ill-conditioned QPs
-+ Introduction of ramping strategy to handle degenerated QPs
-+ Addition of far bounds and flipping bounds strategy to handle 
-  semi-definite and unbounded QPs more reliably
-+ Limited support of sparse QP matrices (also in Matlab interface)
-+ Optional linking of LAPACK/BLAS for linear algebra operations
-+ Addition of a number of algorithmic options, summarised in an option struct
-+ Improved Matlab interface
-+ Python interface added
-+ Several bugfixes
-
-
-2.0 (released on 10th February 2009, last updated on 7th December 2009):
-------------------------------------------------------------------------
-
-+ Implementation of regularisation scheme for treating QPs with 
-  semi-definite Hessians
-+ Addition of convenience functionality for Bounds and Constraints 
-  objects for specifying guessed active sets
-+ Allows to specify a CPU time in addition to an iteration limit
-+ Improved efficiency for QPs comprising many constraints
-+ Source code cleanup and bugfixing
-
-
-1.3 (released on 2nd June 2008, last updated on 13th August 2008):
-------------------------------------------------------------------
-
-+ Implementation of "initialised homotopy" concept
-+ Addition of the SolutionAnalysis class
-+ Utility functions for solving test problems in OQP format added
-+ Flexibility of Matlab(R) interface enhanced
-+ Major source code cleanup
-  (Attention: a few class names and calling interfaces have changed!)
-
-  
-1.2 (released on 9th October 2007):
------------------------------------
-
-+ Special treatment of diagonal Hessians
-+ Improved infeasibility detection
-+ Further improved Matlab(R) interface
-+ Extended Simulink(R) interface
-+ scilab interface added
-+ Code cleanup and several bugfixes
-
-
-1.1 (released on 8th July 2007):
---------------------------------
-
-+ Implementation of the QProblemB class
-+ Basic implementation of the SQProblem class
-+ Improved Matlab(R) interface
-+ Enabling/Disabling of constraints introduced
-+ Several bugfixes
-
-
-1.0 (released on 17th April 2007):
-----------------------------------
-
-Initial release.
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/VERSIONS.txt b/extlibs/qpOASES-3.2.0/VERSIONS.txt
deleted file mode 100644
index 23fbdcb..0000000
--- a/extlibs/qpOASES-3.2.0/VERSIONS.txt
+++ /dev/null
@@ -1,124 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-VERSION HISTORY
-===============
-
-
-3.2 (released on 1st September 2015):
--------------------------------------
-
-+ Addition of SQProblemSchur class implementing Schur complement approach
-  for sparse QP problems
-+ Introduction of data types int_t and uint_t for integer-valued numbers
-+ Minor source code clean-up and bugfixes
-
-
-3.1 (released on 11th February 2015):
--------------------------------------
-
-+ Addition of C interface
-+ Further improved Matlab, Simulink, octave and Python interfaces
-+ Possibility to provide pre-computed Cholesky factor of Hessian matrix
-+ Source code clean-up and bugfixes
-
-
-3.0 (released on 29th July 2014, last updated on 17th December 2014):
----------------------------------------------------------------------
-
-+ Addition of unit testing
-+ Several bugfixes
-
-
-3.0beta (released on 16th August 2011, last updated on 4th April 2014):
------------------------------------------------------------------------
-
-+ Improved ratio tests and termination check for increased reliabilty
-+ Introduction of iterative refinement in step determination and 
-  drift correction to handle ill-conditioned QPs
-+ Introduction of ramping strategy to handle degenerated QPs
-+ Addition of far bounds and flipping bounds strategy to handle 
-  semi-definite and unbounded QPs more reliably
-+ Limited support of sparse QP matrices (also in Matlab interface)
-+ Optional linking of LAPACK/BLAS for linear algebra operations
-+ Addition of a number of algorithmic options, summarised in an option struct
-+ Improved Matlab interface
-+ Python interface added
-+ Several bugfixes
-
-
-2.0 (released on 10th February 2009, last updated on 7th December 2009):
-------------------------------------------------------------------------
-
-+ Implementation of regularisation scheme for treating QPs with 
-  semi-definite Hessians
-+ Addition of convenience functionality for Bounds and Constraints 
-  objects for specifying guessed active sets
-+ Allows to specify a CPU time in addition to an iteration limit
-+ Improved efficiency for QPs comprising many constraints
-+ Source code cleanup and bugfixes
-
-
-1.3 (released on 2nd June 2008, last updated on 13th August 2008):
-------------------------------------------------------------------
-
-+ Implementation of "initialised homotopy" concept
-+ Addition of the SolutionAnalysis class
-+ Utility functions for solving test problems in OQP format added
-+ Flexibility of Matlab(R) interface enhanced
-+ Major source code cleanup
-  (Attention: a few class names and calling interfaces have changed!)
-
-  
-1.2 (released on 9th October 2007):
------------------------------------
-
-+ Special treatment of diagonal Hessians
-+ Improved infeasibility detection
-+ Further improved Matlab(R) interface
-+ Extended Simulink(R) interface
-+ scilab interface added
-+ Code cleanup and several bugfixes
-
-
-1.1 (released on 8th July 2007):
---------------------------------
-
-+ Implementation of the QProblemB class
-+ Basic implementation of the SQProblem class
-+ Improved Matlab(R) interface
-+ Enabling/Disabling of constraints introduced
-+ Several bugfixes
-
-
-1.0 (released on 17th April 2007):
-----------------------------------
-
-Initial release.
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/doc/DoxygenLayout.xml b/extlibs/qpOASES-3.2.0/doc/DoxygenLayout.xml
deleted file mode 100644
index 927d94d..0000000
--- a/extlibs/qpOASES-3.2.0/doc/DoxygenLayout.xml
+++ /dev/null
@@ -1,189 +0,0 @@
-<doxygenlayout version="1.0">
-  <!-- Navigation index tabs for HTML output -->
-  <navindex>
-    <tab type="mainpage" visible="yes" title=""/>
-    <tab type="pages" visible="yes" title="" intro=""/>
-    <tab type="modules" visible="yes" title="" intro=""/>
-    <tab type="namespaces" visible="yes" title="">
-      <tab type="namespacelist" visible="yes" title="" intro=""/>
-      <tab type="namespacemembers" visible="yes" title="" intro=""/>
-    </tab>
-    <tab type="classes" visible="yes" title="">
-      <tab type="classlist" visible="yes" title="" intro=""/>
-      <tab type="classindex" visible="$ALPHABETICAL_INDEX" title=""/> 
-      <tab type="hierarchy" visible="yes" title="" intro=""/>
-      <tab type="classmembers" visible="yes" title="" intro=""/>
-    </tab>
-    <tab type="files" visible="yes" title="">
-      <tab type="filelist" visible="yes" title="" intro=""/>
-      <tab type="globals" visible="yes" title="" intro=""/>
-    </tab>
-    <tab type="dirs" visible="yes" title="" intro=""/>
-    <tab type="examples" visible="yes" title="" intro=""/>
-	<tab type="user" visible="yes" url="../manual.pdf" title="Manual" intro=""/>
-  </navindex>
-
-  <!-- Layout definition for a class page -->
-  <class>
-    <briefdescription visible="yes"/>
-    <includes visible="$SHOW_INCLUDE_FILES"/>
-    <inheritancegraph visible="$CLASS_GRAPH"/>
-    <collaborationgraph visible="$COLLABORATION_GRAPH"/>
-    <allmemberslink visible="yes"/>
-    <memberdecl>
-      <nestedclasses visible="yes" title=""/>
-      <publictypes title=""/>
-      <publicslots title=""/>
-      <signals title=""/>
-      <publicmethods title=""/>
-      <publicstaticmethods title=""/>
-      <publicattributes title=""/>
-      <publicstaticattributes title=""/>
-      <protectedtypes title=""/>
-      <protectedslots title=""/>
-      <protectedmethods title=""/>
-      <protectedstaticmethods title=""/>
-      <protectedattributes title=""/>
-      <protectedstaticattributes title=""/>
-      <packagetypes title=""/>
-      <packagemethods title=""/>
-      <packagestaticmethods title=""/>
-      <packageattributes title=""/>
-      <packagestaticattributes title=""/>
-      <properties title=""/>
-      <events title=""/>
-      <privatetypes title=""/>
-      <privateslots title=""/>
-      <privatemethods title=""/>
-      <privatestaticmethods title=""/>
-      <privateattributes title=""/>
-      <privatestaticattributes title=""/>
-      <friends title=""/>
-      <related title="" subtitle=""/>
-      <membergroups visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-    <memberdef>
-      <inlineclasses title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <constructors title=""/>
-      <functions title=""/>
-      <related title=""/>
-      <variables title=""/>
-      <properties title=""/>
-      <events title=""/>
-    </memberdef>
-    <usedfiles visible="$SHOW_USED_FILES"/>
-    <authorsection visible="yes"/>
-  </class>
-
-  <!-- Layout definition for a namespace page -->
-  <namespace>
-    <briefdescription visible="yes"/>
-    <memberdecl>
-      <nestednamespaces visible="yes" title=""/>
-      <classes visible="yes" title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <membergroups visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-    <memberdef>
-      <inlineclasses title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-    </memberdef>
-    <authorsection visible="yes"/>
-  </namespace>
-
-  <!-- Layout definition for a file page -->
-  <file>
-    <briefdescription visible="yes"/>
-    <includes visible="$SHOW_INCLUDE_FILES"/>
-    <includegraph visible="$INCLUDE_GRAPH"/>
-    <includedbygraph visible="$INCLUDED_BY_GRAPH"/>
-    <sourcelink visible="yes"/>
-    <memberdecl>
-      <classes visible="yes" title=""/>
-      <namespaces visible="yes" title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <membergroups visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-    <memberdef>
-      <inlineclasses title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-    </memberdef>
-    <authorsection/>
-  </file>
-
-  <!-- Layout definition for a group page -->
-  <group>
-    <briefdescription visible="yes"/>
-    <groupgraph visible="$GROUP_GRAPHS"/>
-    <memberdecl>
-      <classes visible="yes" title=""/>
-      <namespaces visible="yes" title=""/>
-      <dirs visible="yes" title=""/>
-      <nestedgroups visible="yes" title=""/>
-      <files visible="yes" title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <enumvalues title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <signals title=""/>
-      <publicslots title=""/>
-      <protectedslots title=""/>
-      <privateslots title=""/>
-      <events title=""/>
-      <properties title=""/>
-      <friends title=""/>
-      <membergroups visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-    <memberdef>
-      <pagedocs/>
-      <inlineclasses title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <enumvalues title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <signals title=""/>
-      <publicslots title=""/>
-      <protectedslots title=""/>
-      <privateslots title=""/>
-      <events title=""/>
-      <properties title=""/>
-      <friends title=""/>
-    </memberdef>
-    <authorsection visible="yes"/>
-  </group>
-
-  <!-- Layout definition for a directory page -->
-  <directory>
-    <briefdescription visible="yes"/>
-    <directorygraph visible="yes"/>
-    <memberdecl>
-      <dirs visible="yes"/>
-      <files visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-  </directory>
-</doxygenlayout>
diff --git a/extlibs/qpOASES-3.2.0/doc/Makefile b/extlibs/qpOASES-3.2.0/doc/Makefile
deleted file mode 100644
index 6267159..0000000
--- a/extlibs/qpOASES-3.2.0/doc/Makefile
+++ /dev/null
@@ -1,66 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-
-
-##
-##	settings
-##
-
-MAKEPDF = pdflatex
-LATEX = latex
-
-
-##
-##	targets
-##
-
-all: doc
-
-
-.PHONY: doc
-doc:
-	@ echo "Creating doxygen documentation "
-	@ doxygen doxygen.config
-	
-
-.PHONY: clean
-clean:
-	@ ${RM} -rf ./html
-
-
-.PHONY: clobber
-clobber: clean
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/doc/doxygen.config b/extlibs/qpOASES-3.2.0/doc/doxygen.config
deleted file mode 100644
index 4a50e22..0000000
--- a/extlibs/qpOASES-3.2.0/doc/doxygen.config
+++ /dev/null
@@ -1,310 +0,0 @@
-#---------------------------------------------------------------------------
-# Project related configuration options
-#---------------------------------------------------------------------------
-DOXYFILE_ENCODING      = UTF-8
-PROJECT_NAME           = qpOASES
-PROJECT_NUMBER         = 3.2.0
-PROJECT_BRIEF          = "An Implementation of the Online Active Set Strategy"
-PROJECT_LOGO           =
-OUTPUT_DIRECTORY       =
-CREATE_SUBDIRS         = NO
-OUTPUT_LANGUAGE        = English
-BRIEF_MEMBER_DESC      = YES
-REPEAT_BRIEF           = NO
-ABBREVIATE_BRIEF       =
-ALWAYS_DETAILED_SEC    = NO
-INLINE_INHERITED_MEMB  = YES
-FULL_PATH_NAMES        = YES
-STRIP_FROM_PATH        = ..
-STRIP_FROM_INC_PATH    =
-SHORT_NAMES            = NO
-JAVADOC_AUTOBRIEF      = NO
-QT_AUTOBRIEF           = NO
-MULTILINE_CPP_IS_BRIEF = NO
-INHERIT_DOCS           = YES
-SEPARATE_MEMBER_PAGES  = NO
-TAB_SIZE               = 4
-ALIASES                =
-TCL_SUBST              =
-OPTIMIZE_OUTPUT_FOR_C  = NO
-OPTIMIZE_OUTPUT_JAVA   = NO
-OPTIMIZE_FOR_FORTRAN   = NO
-OPTIMIZE_OUTPUT_VHDL   = NO
-EXTENSION_MAPPING      =
-MARKDOWN_SUPPORT       = YES
-AUTOLINK_SUPPORT       = YES
-BUILTIN_STL_SUPPORT    = NO
-CPP_CLI_SUPPORT        = NO
-SIP_SUPPORT            = NO
-IDL_PROPERTY_SUPPORT   = YES
-DISTRIBUTE_GROUP_DOC   = NO
-SUBGROUPING            = YES
-INLINE_GROUPED_CLASSES = NO
-INLINE_SIMPLE_STRUCTS  = NO
-TYPEDEF_HIDES_STRUCT   = NO
-SYMBOL_CACHE_SIZE      = 0
-LOOKUP_CACHE_SIZE      = 0
-
-#---------------------------------------------------------------------------
-# Build related configuration options
-#---------------------------------------------------------------------------
-EXTRACT_ALL            = NO
-EXTRACT_PRIVATE        = YES
-EXTRACT_PACKAGE        = NO
-EXTRACT_STATIC         = NO
-EXTRACT_LOCAL_CLASSES  = YES
-EXTRACT_LOCAL_METHODS  = NO
-EXTRACT_ANON_NSPACES   = NO
-HIDE_UNDOC_MEMBERS     = NO
-HIDE_UNDOC_CLASSES     = NO
-HIDE_FRIEND_COMPOUNDS  = NO
-HIDE_IN_BODY_DOCS      = NO
-INTERNAL_DOCS          = NO
-CASE_SENSE_NAMES       = YES
-HIDE_SCOPE_NAMES       = NO
-SHOW_INCLUDE_FILES     = YES
-FORCE_LOCAL_INCLUDES   = NO
-INLINE_INFO            = YES
-SORT_MEMBER_DOCS       = YES
-SORT_BRIEF_DOCS        = NO
-SORT_MEMBERS_CTORS_1ST = NO
-SORT_GROUP_NAMES       = NO
-SORT_BY_SCOPE_NAME     = NO
-STRICT_PROTO_MATCHING  = NO
-GENERATE_TODOLIST      = NO
-GENERATE_TESTLIST      = NO
-GENERATE_BUGLIST       = NO
-GENERATE_DEPRECATEDLIST= YES
-ENABLED_SECTIONS       =
-MAX_INITIALIZER_LINES  = 30
-SHOW_USED_FILES        = YES
-SHOW_FILES             = YES
-SHOW_NAMESPACES        = YES
-FILE_VERSION_FILTER    =
-LAYOUT_FILE            = DoxygenLayout.xml
-CITE_BIB_FILES         =
-
-#---------------------------------------------------------------------------
-# configuration options related to warning and progress messages
-#---------------------------------------------------------------------------
-QUIET                  = NO
-WARNINGS               = YES
-WARN_IF_UNDOCUMENTED   = YES
-WARN_IF_DOC_ERROR      = YES
-WARN_NO_PARAMDOC       = NO
-WARN_FORMAT            = "$file:$line: $text"
-WARN_LOGFILE           =
-
-#---------------------------------------------------------------------------
-# configuration options related to the input files
-#---------------------------------------------------------------------------
-INPUT                  = ./mainpage.dox \
-../src \
-../include/qpOASES \
-../include/qpOASES/extras \
-../examples
-INPUT_ENCODING         = UTF-8
-FILE_PATTERNS          = *.cpp \
-*.ipp \
-*.hpp \
-*.c
-RECURSIVE              = YES
-EXCLUDE                =
-EXCLUDE_SYMLINKS       = NO
-EXCLUDE_PATTERNS       =
-EXCLUDE_SYMBOLS        =
-EXAMPLE_PATH           = ../examples
-EXAMPLE_PATTERNS       =
-EXAMPLE_RECURSIVE      = NO
-IMAGE_PATH             =
-INPUT_FILTER           =
-FILTER_PATTERNS        =
-FILTER_SOURCE_FILES    = NO
-FILTER_SOURCE_PATTERNS =
-
-#---------------------------------------------------------------------------
-# configuration options related to source browsing
-#---------------------------------------------------------------------------
-SOURCE_BROWSER         = NO
-INLINE_SOURCES         = NO
-STRIP_CODE_COMMENTS    = YES
-REFERENCED_BY_RELATION = YES
-REFERENCES_RELATION    = YES
-REFERENCES_LINK_SOURCE = YES
-USE_HTAGS              = NO
-VERBATIM_HEADERS       = YES
-
-#---------------------------------------------------------------------------
-# configuration options related to the alphabetical class index
-#---------------------------------------------------------------------------
-ALPHABETICAL_INDEX     = NO
-COLS_IN_ALPHA_INDEX    = 5
-IGNORE_PREFIX          =
-
-#---------------------------------------------------------------------------
-# configuration options related to the HTML output
-#---------------------------------------------------------------------------
-GENERATE_HTML          = YES
-HTML_OUTPUT            = html
-HTML_FILE_EXTENSION    = .html
-HTML_HEADER            =
-HTML_FOOTER            =
-HTML_STYLESHEET        =
-HTML_EXTRA_STYLESHEET  =
-HTML_EXTRA_FILES       =
-HTML_COLORSTYLE_HUE    = 220
-HTML_COLORSTYLE_SAT    = 100
-HTML_COLORSTYLE_GAMMA  = 80
-HTML_TIMESTAMP         = YES
-HTML_DYNAMIC_SECTIONS  = NO
-HTML_INDEX_NUM_ENTRIES = 100
-GENERATE_DOCSET        = NO
-DOCSET_FEEDNAME        = "Doxygen generated docs"
-DOCSET_BUNDLE_ID       = org.doxygen.Project
-DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
-DOCSET_PUBLISHER_NAME  = Publisher
-GENERATE_HTMLHELP      = NO
-CHM_FILE               =
-HHC_LOCATION           =
-GENERATE_CHI           = NO
-CHM_INDEX_ENCODING     =
-BINARY_TOC             = NO
-TOC_EXPAND             = NO
-GENERATE_QHP           = NO
-QCH_FILE               =
-QHP_NAMESPACE          = org.doxygen.Project
-QHP_VIRTUAL_FOLDER     = doc
-QHP_CUST_FILTER_NAME   =
-QHP_CUST_FILTER_ATTRS  =
-QHP_SECT_FILTER_ATTRS  =
-QHG_LOCATION           =
-GENERATE_ECLIPSEHELP   = NO
-ECLIPSE_DOC_ID         = org.doxygen.Project
-DISABLE_INDEX          = NO
-GENERATE_TREEVIEW      = NO
-ENUM_VALUES_PER_LINE   = 4
-TREEVIEW_WIDTH         = 250
-EXT_LINKS_IN_WINDOW    = NO
-FORMULA_FONTSIZE       = 10
-FORMULA_TRANSPARENT    = YES
-USE_MATHJAX            = NO
-MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
-MATHJAX_EXTENSIONS     =
-SEARCHENGINE           = NO
-SERVER_BASED_SEARCH    = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the LaTeX output
-#---------------------------------------------------------------------------
-GENERATE_LATEX         = NO
-LATEX_OUTPUT           = latex
-LATEX_CMD_NAME         = latex
-MAKEINDEX_CMD_NAME     = makeindex
-COMPACT_LATEX          = NO
-PAPER_TYPE             = a4wide
-EXTRA_PACKAGES         =
-LATEX_HEADER           =
-LATEX_FOOTER           =
-PDF_HYPERLINKS         = YES
-USE_PDFLATEX           = NO
-LATEX_BATCHMODE        = NO
-LATEX_HIDE_INDICES     = NO
-LATEX_SOURCE_CODE      = NO
-LATEX_BIB_STYLE        = plain
-
-#---------------------------------------------------------------------------
-# configuration options related to the RTF output
-#---------------------------------------------------------------------------
-GENERATE_RTF           = NO
-RTF_OUTPUT             = RTF
-COMPACT_RTF            = NO
-RTF_HYPERLINKS         = NO
-RTF_STYLESHEET_FILE    =
-RTF_EXTENSIONS_FILE    =
-
-#---------------------------------------------------------------------------
-# configuration options related to the man page output
-#---------------------------------------------------------------------------
-GENERATE_MAN           = NO
-MAN_OUTPUT             = MAN
-MAN_EXTENSION          = .3
-MAN_LINKS              = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the XML output
-#---------------------------------------------------------------------------
-GENERATE_XML           = NO
-XML_OUTPUT             = XML
-XML_SCHEMA             =
-XML_DTD                =
-XML_PROGRAMLISTING     = YES
-
-#---------------------------------------------------------------------------
-# configuration options for the AutoGen Definitions output
-#---------------------------------------------------------------------------
-GENERATE_AUTOGEN_DEF   = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the Perl module output
-#---------------------------------------------------------------------------
-GENERATE_PERLMOD       = NO
-PERLMOD_LATEX          = NO
-PERLMOD_PRETTY         = YES
-PERLMOD_MAKEVAR_PREFIX =
-
-#---------------------------------------------------------------------------
-# Configuration options related to the preprocessor
-#---------------------------------------------------------------------------
-ENABLE_PREPROCESSING   = YES
-MACRO_EXPANSION        = NO
-EXPAND_ONLY_PREDEF     = NO
-SEARCH_INCLUDES        = YES
-INCLUDE_PATH           =
-INCLUDE_FILE_PATTERNS  =
-PREDEFINED             =
-EXPAND_AS_DEFINED      =
-SKIP_FUNCTION_MACROS   = YES
-
-#---------------------------------------------------------------------------
-# Configuration::additions related to external references
-#---------------------------------------------------------------------------
-TAGFILES               =
-GENERATE_TAGFILE       =
-ALLEXTERNALS           = NO
-EXTERNAL_GROUPS        = YES
-PERL_PATH              = /usr/bin/perl
-
-#---------------------------------------------------------------------------
-# Configuration options related to the dot tool
-#---------------------------------------------------------------------------
-CLASS_DIAGRAMS         = YES
-MSCGEN_PATH            =
-HIDE_UNDOC_RELATIONS   = YES
-HAVE_DOT               = NO
-DOT_NUM_THREADS        = 0
-DOT_FONTNAME           = Helvetica
-DOT_FONTSIZE           = 10
-DOT_FONTPATH           =
-CLASS_GRAPH            = YES
-COLLABORATION_GRAPH    = NO
-GROUP_GRAPHS           = YES
-UML_LOOK               = NO
-UML_LIMIT_NUM_FIELDS   = 10
-TEMPLATE_RELATIONS     = NO
-INCLUDE_GRAPH          = YES
-INCLUDED_BY_GRAPH      = YES
-CALL_GRAPH             = NO
-CALLER_GRAPH           = NO
-GRAPHICAL_HIERARCHY    = YES
-DIRECTORY_GRAPH        = YES
-DOT_IMAGE_FORMAT       = png
-INTERACTIVE_SVG        = NO
-DOT_PATH               =
-DOTFILE_DIRS           =
-MSCFILE_DIRS           =
-DOT_GRAPH_MAX_NODES    = 50
-MAX_DOT_GRAPH_DEPTH    = 0
-DOT_TRANSPARENT        = NO
-DOT_MULTI_TARGETS      = NO
-GENERATE_LEGEND        = YES
-DOT_CLEANUP            = YES
diff --git a/extlibs/qpOASES-3.2.0/doc/mainpage.dox b/extlibs/qpOASES-3.2.0/doc/mainpage.dox
deleted file mode 100644
index 8a93b00..0000000
--- a/extlibs/qpOASES-3.2.0/doc/mainpage.dox
+++ /dev/null
@@ -1,134 +0,0 @@
-/**
- *	\mainpage Main Page
- *
- *	<p>&nbsp;</p>
- *
- *	\section sec_copyright Copyright
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy. \n
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *	<p>&nbsp;</p>
- *
- *
- *	\section sec_developers Authors and Contributors
- *
- *	qpOASES's core functionality and software design have been developed by 
- *	the following main developers (in alphabetical order):
- *	<ul>
- *	<li>Hans Joachim Ferreau
- *	<li>Christian Kirches
- *	<li>Andreas Potschka
- *	</ul>
- *
- *	Moreover, the following developers have contributed code to qpOASES's 
- *	third-party interfaces or provided additional functionality 
- *	(in alphabetical order):
- *	<ul>
- *	<li>Alexander Buchner
- *	<li>Holger Diedam
- *	<li>Dennis Janka
- *	<li>Manuel Kudruss
- *	<li>Andreas Waechter
- *	<li>Sebastian F. Walter
- *	</ul>
- *
- *	Finally, the following people have not contributed to the source code, 
- *	but have helped making qpOASES even more useful by testing, reporting 
- *	bugs or proposing algorithmic improvements (in alphabetical order): 
- *	<ul>
- *	<li>Eckhard Arnold
- *	<li>Boris Houska
- *	<li>D. Kwame Minde Kufoalor
- *	<li>Aude Perrin
- *	<li>Milan Vukov
- *	<li>Thomas Wiese
- *	<li>Leonard Wirsching
- *	</ul>
- *
- *	We also would like to thank two persons who had a major share in making 
- *	qpOASES a success. Not by writing even a single line of code, but by 
- *	establishing the idea of using a homotopy-based approach for high-speed 
- *	QP solutions and by excellent scientific guidance during the development 
- *	process:
- *	<ul>
- *	<li>Hans Georg Bock
- *	<li>Moritz Diehl 
- *	</ul>
- *
- *	All users are invited to further improve qpOASES by providing comments, code enhancements, 
- *	bug reports, additional documentation or whatever you feel is missing. The preferred way
- *	of doing so is to <b>create a <a href="https://projects.coin-or.org/qpOASES/newticket">new ticket</a>
- *	at the qpOASES webpage</b>. In case you do not want to disclose your feedback to the public, 
- *	you may send an e-mail to <a href="mailto:support@qpOASES.org">support@qpOASES.org</a> 
- *	or contact one of the main developers directly.
- *	<p>&nbsp;</p>
- *
- *
- *	\section sec_citing Citing qpOASES
- *
- *	If you use qpOASES within your scientific work, we strongly encourage you to cite at least 
- *	one of the following publications:
- *
- *	<ul>
- *	<li>Reference to the <b>software</b>:
- *	\code
- *	 @ARTICLE{Ferreau2014,
- *	  author = {H.J. Ferreau and C. Kirches and A. Potschka and H.G. Bock and M. Diehl},
- *	  title = {{qpOASES}: A parametric active-set algorithm for quadratic programming},
- *	  journal = {Mathematical Programming Computation},
- *	  year = {2014},
- *	  volume = {6},
- *	  number = {4},
- *	  pages = {327--363},
- *	  keywords = {qpOASES, parametric quadratic programming, active set method, model predictive control}
- *	}
- *	\endcode
- *
- *	<li>Reference to the <b>online active set strategy</b>:
- *	\code
- *	 @ARTICLE{Ferreau2008,
- *	  author = {H.J. Ferreau and H.G. Bock and M. Diehl},
- *	  title = {An online active set strategy to overcome the limitations of explicit MPC},
- *	  journal = {International Journal of Robust and Nonlinear Control},
- *	  year = {2008},
- *	  volume = {18},
- *	  number = {8},
- *	  pages = {816--830},
- *	  keywords = {model predictive control, parametric quadratic programming, online active set strategy}
- *	}
- *	\endcode
- *
- *	<li>Reference to the <b>webpage</b>:
- *	\code
- *	 @MISC{qpOASES2014,
- *	  author = {H.J. Ferreau and A. Potschka and C. Kirches},
- *	  title = {{qpOASES} webpage},
- *	  howpublished = {http://www.qpOASES.org/},
- *	  year = {2007--2015},
- *	  keywords = {qpOASES, model predictive control, parametric quadratic programming, online active set strategy}
- *	}
- *	\endcode
- *	</ul>
- *	<p>&nbsp;</p>
- *
- *	\section sec_moreinfo More Information
- *
- *	More information can be found on <a href="http://www.qpOASES.org/">http://www.qpOASES.org/</a> 
- *	and in the <a href="../manual.pdf">qpOASES User's Manual</a>.
- *	<p>&nbsp;</p>
- */
diff --git a/extlibs/qpOASES-3.2.0/doc/manual.pdf b/extlibs/qpOASES-3.2.0/doc/manual.pdf
deleted file mode 100644
index d542c2d0e1dccfd643b041f1b0a012462d589b72..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 820879
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

diff --git a/extlibs/qpOASES-3.2.0/examples/Makefile b/extlibs/qpOASES-3.2.0/examples/Makefile
deleted file mode 100644
index 03cfe00..0000000
--- a/extlibs/qpOASES-3.2.0/examples/Makefile
+++ /dev/null
@@ -1,107 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  examples/Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-include ../make.mk
-
-##
-##	flags
-##
-
-IFLAGS      =  -I. \
-               -I${IDIR}
-
-QPOASES_EXES = \
-	${BINDIR}/example1${EXE} \
-	${BINDIR}/example1a${EXE} \
-	${BINDIR}/example1b${EXE} \
-	${BINDIR}/example2${EXE} \
-	${BINDIR}/example3${EXE} \
-	${BINDIR}/example3b${EXE} \
-	${BINDIR}/example4${EXE} \
-	${BINDIR}/example5${EXE} \
-	${BINDIR}/exampleLP${EXE} \
-	${BINDIR}/qrecipe${EXE} \
-	${BINDIR}/qrecipeSchur${EXE}
-
-
-##
-##	targets
-##
-
-all: ${QPOASES_EXES}
-
-${BINDIR}/%${EXE}: %.${OBJEXT} ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/example4${EXE}: example4.${OBJEXT} example4CP.cpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/qrecipe${EXE}: qrecipe.${OBJEXT} qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/qrecipeSchur${EXE}: qrecipeSchur.${OBJEXT} qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-
-clean:
-	@${ECHO} "Cleaning up (examples)"
-	@${RM} -f *.${OBJEXT} ${QPOASES_EXES}
-
-clobber: clean
-
-
-${LINK_DEPENDS}:
-	@cd ..; ${MAKE} -s src
-
-example4.${OBJEXT}: example4.cpp example4CP.cpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-qrecipe.${OBJEXT}: qrecipe.cpp qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-qrecipeSchur.${OBJEXT}: qrecipeSchur.cpp qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-%.${OBJEXT}: %.cpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/examples/example1.cpp b/extlibs/qpOASES-3.2.0/examples/example1.cpp
deleted file mode 100644
index 1489537..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example1.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES using the QProblem class.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up QProblem object. */
-	QProblem example( 2,1 );
-
-	Options options;
-	example.setOptions( options );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR );
-
-	/* Get and print solution of first QP. */
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-	
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-
-	example.printOptions();
-	/*example.printProperties();*/
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example1a.cpp b/extlibs/qpOASES-3.2.0/examples/example1a.cpp
deleted file mode 100644
index 848c4d6..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example1a.cpp
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example1a.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES using the SQProblem class.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the SQProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up SQProblem object. */
-	SQProblem example( 2,1 );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[2];
-	example.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example1b.cpp b/extlibs/qpOASES-3.2.0/examples/example1b.cpp
deleted file mode 100644
index 6960d0f..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example1b.cpp
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example1b.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES using the QProblemB class.
- */
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the QProblemB class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-
-
-	/* Setting up QProblemB object. */
-	QProblemB example( 2 );
-
-	Options options;
-	//options.enableFlippingBounds = BT_FALSE;
-	options.initialStatusBounds = ST_INACTIVE;
-	options.numRefinementSteps = 1;
-	options.enableCholeskyRefactorisation = 1;
-	example.setOptions( options );
-
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,lb,ub, nWSR,0 );
-
-	/* Get and print solution of first QP. */
-	real_t xOpt[2];
-	example.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-	
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new, nWSR,0 );
-// 	printf( "\nnWSR = %d\n\n", nWSR );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example2.cpp b/extlibs/qpOASES-3.2.0/examples/example2.cpp
deleted file mode 100644
index 5017a54..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example2.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example2.cpp
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Very simple example for testing qpOASES in combination
- *  with the SolutionAnalysis class.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the SolutionAnalysis class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up SQProblem object and solution analyser. */
-	SQProblem example( 2,1 );
-	SolutionAnalysis analyser;
-
-	/* Solve first QP ... */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	/* ... and analyse it. */
-	real_t maxKktViolation = analyser.getKktViolation( &example );
-    printf( "maxKktViolation: %e\n", maxKktViolation );
-
-	/* Solve second QP ... */
-	nWSR = 10;
-	example.hotstart( H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-	/* ... and analyse it. */
-	maxKktViolation = analyser.getKktViolation( &example );
-    printf( "maxKktViolation: %e\n", maxKktViolation );
-
-
-//  ------------ VARIANCE-COVARIANCE EVALUATION --------------------
-
-        real_t *Var              = new real_t[5*5];
-        real_t *Primal_Dual_Var  = new real_t[5*5];
-
-        int_t run1, run2;
-        for( run1 = 0; run1 < 5*5; run1++ )
-            Var[run1] = 0.0;
-
-        Var[0] = 1.0;
-        Var[6] = 1.0;
-
-//                  (  1   0   0   0   0   )
-//                  (  0   1   0   0   0   )
-//     Var     =    (  0   0   0   0   0   )
-//                  (  0   0   0   0   0   )
-//                  (  0   0   0   0   0   )
-
-
-        analyser.getVarianceCovariance( &example, Var,Primal_Dual_Var );
-
-        printf("\nPrimal_Dual_VAR = \n");
-        for( run1 = 0; run1 < 5; run1++ ){
-          for( run2 = 0; run2 < 5; run2++ ){
-            printf(" %10f", Primal_Dual_Var[run1*5+run2]);
-          }
-          printf("\n");
-        }
-
-        delete[] Primal_Dual_Var;
-        delete[] Var;
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example3.cpp b/extlibs/qpOASES-3.2.0/examples/example3.cpp
deleted file mode 100644
index 5257579..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example3.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example3.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Example demonstrating usage of qpOASES for solving a QP sequence of the
- *	Online QP Benchmark Collection. In order to run it, you have to download
- *	"Example 02" from from http://www.qpOASES.org/onlineQP/ and store it into 
- *	the directory bin/chain80w/.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the OQP interface. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* 1) Define benchmark arguments. */
-	BooleanType isSparse = BT_FALSE;
-	Options options;
-	options.setToMPC();
-	options.printLevel = PL_NONE;
-
-	int_t nWSR = 600;
-	real_t maxCPUtime = 10.0; /* seconds */
-	real_t maxStationarity, maxFeasibility, maxComplementarity;
-
-	/* 2) Run benchmark. */
-	if ( runOqpBenchmark(	"./chain80w/",
-							isSparse,
-							options,
-							nWSR,
-							maxCPUtime,
-							maxStationarity,
-							maxFeasibility,
-							maxComplementarity
-							) != SUCCESSFUL_RETURN )
-	{
-		myPrintf( "In order to run this example, you need to download example no. 02\nfrom the Online QP Benchmark Collection website first!\n" );
-		return -1;
-	}
-
-	/* 3) Print results. */
-	printf( "\n\n" );
-	printf( "OQP Benchmark Results:\n" );
-	printf( "======================\n\n" );
-	printf( "maximum violation stationarity:     %.3e\n",maxStationarity );
-	printf( "maximum violation feasibility:      %.3e\n",maxFeasibility );
-	printf( "maximum violation complementarity:  %.3e\n",maxComplementarity );
-	printf( "\n" );
-	printf( "maximum CPU time:             %.3f milliseconds\n\n",1000.0*maxCPUtime );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example3b.cpp b/extlibs/qpOASES-3.2.0/examples/example3b.cpp
deleted file mode 100644
index 7e023a7..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example3b.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example3b.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Example demonstrating usage of qpOASES for solving a QP sequence of the
- *	Online QP Benchmark Collection. In order to run it, you have to download
- *	"Example 02" from http://www.qpOASES.org/onlineQP/ and store it into 
- *	the directory bin/chain80/.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the OQP interface. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* 1) Define benchmark arguments. */
-	BooleanType isSparse = BT_FALSE;
-	Options options;
-	options.setToMPC();
-	options.printLevel = PL_NONE;
-	
-	int_t nWSR = 300;
-	real_t maxCPUtime = 10.0; /* seconds */
-	real_t maxStationarity, maxFeasibility, maxComplementarity;
-
-	/* 2) Run benchmark. */
-	if ( runOqpBenchmark(	"./chain80/",
-							isSparse,
-							options,
-							nWSR,
-							maxCPUtime,
-							maxStationarity,
-							maxFeasibility,
-							maxComplementarity
-							) != SUCCESSFUL_RETURN )
-	{
-		myPrintf( "In order to run this example, you need to download example no. 02\nfrom the Online QP Benchmark Collection website first!\n" );
-		return -1;
-	}
-
-	/* 3) Print results. */
-	printf( "\n\n" );
-	printf( "OQP Benchmark Results:\n" );
-	printf( "======================\n\n" );
-	printf( "maximum violation stationarity:     %.3e\n",maxStationarity );
-	printf( "maximum violation feasibility:      %.3e\n",maxFeasibility );
-	printf( "maximum violation complementarity:  %.3e\n",maxComplementarity );
-	printf( "\n" );
-	printf( "maximum CPU time:             %.3f milliseconds\n\n",1000.0*maxCPUtime );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example4.cpp b/extlibs/qpOASES-3.2.0/examples/example4.cpp
deleted file mode 100644
index 59205ab..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example4.cpp
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example4.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2009-2015
- *
- *	Very simple example for testing qpOASES (using the possibility to specify 
- *	user-defined constraint product function).
- */
-
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "example4CP.cpp"
-
-
-/**	Example for qpOASES main function using the possibility to specify 
- *	user-defined constraint product function. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t i,j;
-
-	/* Setup data of first QP... */
-	real_t H[7*7];
-	real_t A[50*7];
-	real_t g[7];
-	real_t lbA[50];
-
-	/*	    ( 1.0 0.5 |                    )
-	 *	    ( 0.5 2.0 |                    )
-	 *	    ( --------+------------------- )
-	 *	H = (         | 1e-6               )
-	 *	    (         |      1e-6          )
-	 *	    (         |           ...      )
-	 *	    (         |               1e-6 ) */
-	for( i=0; i<7*7; ++i )
-		H[i] = 0.0;
-	for( i=2; i<7; ++i )
-		H[i*7+i] = 1.0e-6;
-	H[0] = 1.0;
-	H[1] = 0.5;
-	H[7] = 0.5;
-	H[8] = 2.0;
-
-	/*	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x | ...             )
-	 *	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x |     1.0         )
-	 *	A = ( x.x x.x |     ...         )
-	 *	    ( x.x x.x |     1.0         )
-	 *	    ( x.x x.x |         ...     )
-	 *	    ( x.x x.x |             1.0 )
-	 *	    ( x.x x.x |             ... )
-	 *	    ( x.x x.x |             1.0 ) */
-	for( i=0; i<50*7; ++i )
-		A[i] = 0.0;
-	for( i=0; i<50; ++i )
-	{
-		for( j=0; j<2; ++j )
-			A[i*7+j] = (real_t)rand() / (real_t)RAND_MAX;
-
-		A[i*7 + (i/10)+2] = 1.0;
-	}
-
-	/*	    ( -1.0 )
-	 *	    ( -0.5 )
-	 *	    ( ---- )
-	 *	g = (      )
-	 *	    (      )
-	 *	    (      )
-	 *	    (      ) */
-	for( i=0; i<7; ++i )
-		g[i] = 0.0;
-	g[0] = -1.0;
-	g[1] = -0.5;
-
-	for( i=0; i<50; ++i )
-		lbA[i] = 1.0;
-
-	/* ... and setting up user-defined constraint product function. */
-	MyConstraintProduct myCP( 7,50,A );
-
-
-	/* Setting up QProblem object and set construct product function. */
-	QProblem exampleCP( 7,50 );
-	exampleCP.setPrintLevel( PL_NONE );
-	
-	exampleCP.setConstraintProduct( &myCP );
-
-
-	/* Solve first QP. */
-	real_t cputime = 1.0;
-	int_t nWSR = 100;
-	exampleCP.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-
-
-	/* Solve second QP using a modified gradient. */
-	g[0] = -2.0;
-	g[1] =  0.5;
-
-	cputime = 1.0;
-	nWSR = 100;
-	exampleCP.hotstart( g,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[7];
-	exampleCP.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e, %e ... ];  objVal = %e\n", xOpt[0],xOpt[1],xOpt[2],exampleCP.getObjVal() );
-	printf( "CPU time:  %.3f microseconds\n\n", cputime*1.0e6 ); 
-
-	
-	
-	/* Do the same without specifying constraint product. */
-	QProblem example( 7,50 );
-	example.setPrintLevel( PL_NONE );
-	
-	/* Solve first QP. */
-	g[0] = -1.0;
-	g[1] = -0.5;
-	
-	cputime = 1.0;
-	nWSR = 100;
-	example.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-	
-	/* Solve second QP using a modified gradient. */
-	g[0] = -2.0;
-	g[1] =  0.5;
-
-	cputime = 1.0;
-	nWSR = 100;
-	example.hotstart( g,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e, %e ... ];  objVal = %e\n", xOpt[0],xOpt[1],xOpt[2],example.getObjVal() );
-	printf( "CPU time:  %.3f microseconds\n\n", cputime*1.0e6 ); 
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example4CP.cpp b/extlibs/qpOASES-3.2.0/examples/example4CP.cpp
deleted file mode 100644
index 3eeada7..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example4CP.cpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example4CP.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2009-2015
- *
- *	Sample implementation of the ConstraintProduct class tailored for Example4.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Example illustrating the use of the \a ConstraintProduct class.
- *
- *	Example illustrating the use of the \a ConstraintProduct class.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- */
-class MyConstraintProduct : public ConstraintProduct
-{
-	public:
-		/** Default constructor. */
-		MyConstraintProduct( ) {};
-
-		/** Constructor. */
-		MyConstraintProduct(	int_t _nV,
-								int_t _nC,
-								real_t* _A
-								)
-		{
-			nV = _nV;
-			nC = _nC;
-			A  = _A;
-		};
-
-		/** Copy constructor (flat copy). */
-		MyConstraintProduct(	const MyConstraintProduct& rhs
-								)
-		{
-			nV = rhs.nV;
-			nC = rhs.nC;
-			A  = rhs.A;
-		};
-
-		/** Destructor. */
-		virtual ~MyConstraintProduct( ) {};
-		
-		/** Assignment operator (flat copy). */
-		MyConstraintProduct& operator=(	const MyConstraintProduct& rhs
-										)
-		{
-			if ( this != &rhs )
-			{
-				nV = rhs.nV;
-				nC = rhs.nC;
-				A  = rhs.A;
-			}
-			return *this;
-		};
-
-		virtual int_t operator() (	int_t constrIndex,
-									const real_t* const x,
-									real_t* const constrValue
-									) const
-		{
-			int_t i;
-
-			constrValue[0] = 1.0 * x[(constrIndex/10)+2];
-
-			for( i=0; i<2; ++i )
-				constrValue[0] += A[constrIndex*nV + i] * x[i];
-
-			return 0;
-		};
-
-	protected:
-		int_t nV;		/**< Number of variables. */
-		int_t nC;		/**< Number of constraints. */
-		real_t* A;		/**< Pointer to full constraint matrix (typically not needed!). */
-};
-
-
-END_NAMESPACE_QPOASES
-
diff --git a/extlibs/qpOASES-3.2.0/examples/example5.cpp b/extlibs/qpOASES-3.2.0/examples/example5.cpp
deleted file mode 100644
index 1798f9c..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example5.cpp
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example5.cpp
- *	\author Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2011-2015
- *
- *	Very simple example for testing qpOASES (using the possibility to
- *  compute the local linear feedback law)
- */
-
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "example4CP.cpp"
-
-
-/**	Example for qpOASES main function using the possibility to specify
- *	user-defined constraint product function. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t i,j,jj;
-	real_t d = 0.0;
-
-	/* Setup data of first QP... */
-	real_t H[7*7];
-	real_t A[50*7];
-	real_t g[7];
-	real_t lbA[50];
-
-	/*	    ( 1.0 0.5 |                    )
-	 *	    ( 0.5 2.0 |                    )
-	 *	    ( --------+------------------- )
-	 *	H = (         | 1e-6               )
-	 *	    (         |      1e-6          )
-	 *	    (         |           ...      )
-	 *	    (         |               1e-6 ) */
-	for( i=0; i<7*7; ++i )
-		H[i] = 0.0;
-	for( i=2; i<7; ++i )
-		H[i*7+i] = 1.0e-6;
-	H[0] = 1.0;
-	H[1] = 0.5;
-	H[7] = 0.5;
-	H[8] = 2.0;
-
-	/*	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x | ...             )
-	 *	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x |     1.0         )
-	 *	A = ( x.x x.x |     ...         )
-	 *	    ( x.x x.x |     1.0         )
-	 *	    ( x.x x.x |         ...     )
-	 *	    ( x.x x.x |             1.0 )
-	 *	    ( x.x x.x |             ... )
-	 *	    ( x.x x.x |             1.0 ) */
-	for( i=0; i<50*7; ++i )
-		A[i] = 0.0;
-	for( i=0; i<50; ++i )
-	{
-		for( j=0; j<2; ++j )
-			A[i*7+j] = (real_t)rand() / (real_t)RAND_MAX;
-
-		A[i*7 + (i/10)+2] = 1.0;
-	}
-
-	/*	    ( -1.0 )
-	 *	    ( -0.5 )
-	 *	    ( ---- )
-	 *	g = (      )
-	 *	    (      )
-	 *	    (      )
-	 *	    (      ) */
-	for( i=0; i<7; ++i )
-		g[i] = 0.0;
-	g[0] = -1.0;
-	g[1] = -0.5;
-
-	for( i=0; i<50; ++i )
-		lbA[i] = 1.0;
-
-	/* ... and setting up user-defined constraint product function. */
-	MyConstraintProduct myCP( 7,50,A );
-
-
-	/* Setting up QProblem object and set construct product function. */
-	QProblem example( 7,50 );
-	example.setConstraintProduct( &myCP );
-
-
-	/* Solve first QP. */
-	real_t cputime = 1.0;
-	int_t nWSR = 100;
-	example.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of QP. */
-	real_t xOpt[7], yOpt[7+50];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-
-
-	/* Compute local linear feedback law */
-	const int_t n_rhs = 7+7+50;
-	real_t g_in[7*n_rhs];
-	real_t b_in[7*n_rhs];
-	real_t bA_in[50*n_rhs];
-	real_t x_out[7*n_rhs];
-	real_t y_out[(7+50)*n_rhs];
-
-	int_t ii;
-	memset (g_in, 0, sizeof (g_in));
-	memset (b_in, 0, sizeof (b_in));
-	memset (bA_in, 0, sizeof (bA_in));
-
-	for ( ii = 0; ii < 7; ++ii )
-		g_in[ii*7 + ii] = 1.0;
-	for ( ii = 0; ii < 7; ++ii )
-		b_in[(ii+7)*7 + ii] = 1.0;
-	for ( ii = 0; ii < 50; ++ii )
-		bA_in[(ii+14)*50 + ii] = 1.0;
-
-	example.solveCurrentEQP ( n_rhs, g_in, b_in, b_in, bA_in, bA_in, x_out, y_out );
-
-	/* Verify validity of local feedback law by perturbation and hot starts */
-	real_t perturb = 1.0e-6;
-	real_t nrm = 0.0;
-	for ( ii = 0; ii < n_rhs; ++ii )
-	{
-		for ( jj = 0; jj < 7; ++jj )
-			g_in[ii*7 + jj] = g[jj] + g_in[ii*7+jj]*perturb;
-		for ( jj = 0; jj < 50; ++jj )
-			bA_in[ii*50 + jj] = lbA[jj] + bA_in[ii*50+jj]*perturb;
-
-		nWSR = 100;
-		example.hotstart( &g_in[ii*7],0,0,&bA_in[ii*50],0, nWSR, 0 );
-
-		real_t xPer[7], yPer[7+50];
-		example.getPrimalSolution( xPer );
-		example.getDualSolution( yPer );
-
-		for ( jj = 0; jj < 7; ++jj )
-		{
-			d = getAbs (x_out[ii*7+jj]*perturb - (xPer[jj]-xOpt[jj]) );
-			if (nrm < d) nrm=d;
-		}
-		for ( jj = 0; jj < 7+50; ++jj )
-		{
-			d = getAbs (y_out[ii*(7+50)+jj]*perturb - (yPer[jj]-yOpt[jj]) );
-			if (nrm < d) nrm=d;
-		}
-	}
-	printf ("Maximum perturbation over all directions: %e\n", nrm);
-
-	/* // print feedback matrix
-	for (ii = 0; ii < n_rhs; ++ii)
-	{
-		printf ("x: ");
-		for (jj = 0; jj < 7; ++jj )
-			printf ("%8.2e ", x_out[ii*7+jj]);
-		printf (" y: ");
-		for (jj = 0; jj < 7+50; ++jj )
-			printf ("%8.2e ", y_out[ii*(7+50)+jj]);
-		printf("\n");
-	}
-*/
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/exampleLP.cpp b/extlibs/qpOASES-3.2.0/examples/exampleLP.cpp
deleted file mode 100644
index 5492e34..0000000
--- a/extlibs/qpOASES-3.2.0/examples/exampleLP.cpp
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/exampleLP.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Very simple example for solving a LP sequence using qpOASES.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function solving LPs. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first LP. */
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second LP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up QProblem object with zero Hessian matrix. */
-	QProblem example( 2,1,HST_ZERO );
-
-	Options options;
- 	//options.setToMPC();
-	example.setOptions( options );
-
-	/* Solve first LP. */
-	int_t nWSR = 10;
-	example.init( 0,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	/* Solve second LP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-
-	/* Get and print solution of second LP. */
-	real_t xOpt[2];
-	example.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/qrecipe.cpp b/extlibs/qpOASES-3.2.0/examples/qrecipe.cpp
deleted file mode 100644
index 25aa2c7..0000000
--- a/extlibs/qpOASES-3.2.0/examples/qrecipe.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/qrecipe.cpp
- *	\author Andreas Potschka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- */
-
-
-
-#include <qpOASES.hpp>
-
-#include "qrecipe_data.hpp"
-
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	long i;
-	int_t nWSR;
-	real_t err, tic, toc;
-	real_t *x1 = new real_t[180];
-	real_t *y1 = new real_t[271];
-	real_t *x2 = new real_t[180];
-	real_t *y2 = new real_t[271];
-
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	SparseMatrix *A = new SparseMatrix(91, 180, A_ir, A_jc, A_val);
-
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	real_t* A_full = A->full();
-
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-	DenseMatrix *Ad = new DenseMatrix(91,180,180,A_full);
-
-	/* solve with dense matrices */
-	nWSR = 1000;
-	QProblem qrecipeD(180, 91);
-	tic = getCPUtime();
-	qrecipeD.init(Hd, g, Ad, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeD.getPrimalSolution(x1);
-	qrecipeD.getDualSolution(y1);
-
-	fprintf(stdFile, "Solved dense problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* solve with sparse matrices */
-	nWSR = 1000;
-	QProblem qrecipeS(180, 91);
-	tic = getCPUtime();
-	qrecipeS.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeS.getPrimalSolution(x2);
-	qrecipeS.getDualSolution(y2);
-
-	fprintf(stdFile, "Solved sparse problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* check distance of solutions */
-	err = 0.0;
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x2[i]) > err)
-			err = getAbs(x1[i] - x2[i]);
-	fprintf(stdFile, "Primal error: %9.2e\n", err);
-	err = 0.0;
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y2[i]) > err)
-			err = getAbs(y1[i] - y2[i]);
-	fprintf(stdFile, "Dual error: %9.2e  (might not be unique)\n", err);
-
-	delete H;
-	delete A;
-	delete[] H_full;
-	delete[] A_full;
-	delete Hd;
-	delete Ad;
-
-	delete[] y2;
-	delete[] x2;
-	delete[] y1;
-	delete[] x1;
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/qrecipeSchur.cpp b/extlibs/qpOASES-3.2.0/examples/qrecipeSchur.cpp
deleted file mode 100644
index 9e6c885..0000000
--- a/extlibs/qpOASES-3.2.0/examples/qrecipeSchur.cpp
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/qrecipeSchur.cpp
- *	\author Dennis Janka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- *	Comparison between nullspace factorization (dense and sparse) and
- *	Schur complement approach.
- */
-
-
-
-#include <qpOASES.hpp>
-
-#include "qrecipe_data.hpp"
-
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	long i;
-	int_t nWSR;
-	real_t errP1, errP2, errP3, errD1, errD2, errD3, tic, toc;
-	real_t *x1 = new real_t[180];
-	real_t *y1 = new real_t[271];
-	real_t *x2 = new real_t[180];
-	real_t *y2 = new real_t[271];
-	real_t *x3 = new real_t[180];
-	real_t *y3 = new real_t[271];
-
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	SparseMatrix *A = new SparseMatrix(91, 180, A_ir, A_jc, A_val);
-
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	real_t* A_full = A->full();
-
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-	DenseMatrix *Ad = new DenseMatrix(91,180,180,A_full);
-
-	/* solve with dense matrices */
-	nWSR = 1000;
-	QProblem qrecipeD(180, 91);
-	tic = getCPUtime();
-	qrecipeD.init(Hd, g, Ad, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeD.getPrimalSolution(x1);
-	qrecipeD.getDualSolution(y1);
-
-	fprintf(stdFile, "Solved dense problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* solve with sparse matrices (nullspace factorization) */
-	nWSR = 1000;
-	QProblem qrecipeS(180, 91);
-	tic = getCPUtime();
-	qrecipeS.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeS.getPrimalSolution(x2);
-	qrecipeS.getDualSolution(y2);
-
-	fprintf(stdFile, "Solved sparse problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* solve with sparse matrices (Schur complement) */
-	nWSR = 1000;
-	SQProblemSchur qrecipeSchur(180, 91);
-	tic = getCPUtime();
-	qrecipeSchur.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeSchur.getPrimalSolution(x3);
-	qrecipeSchur.getDualSolution(y3);
-
-	fprintf(stdFile, "Solved sparse problem (Schur complement approach) in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* check distance of solutions */
-	errP1 = 0.0;
-	errP2 = 0.0;
-	errP3 = 0.0;
-	#ifndef SOLVER_NONE
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x2[i]) > errP1)
-			errP1 = getAbs(x1[i] - x2[i]);
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x3[i]) > errP2)
-			errP2 = getAbs(x1[i] - x3[i]);
-	for (i = 0; i < 180; i++)
-		if (getAbs(x2[i] - x3[i]) > errP3)
-			errP3 = getAbs(x2[i] - x3[i]);
-	#endif /* SOLVER_NONE */
-	fprintf(stdFile, "Primal error (dense and sparse): %9.2e\n", errP1);
-	fprintf(stdFile, "Primal error (dense and Schur):  %9.2e\n", errP2);
-	fprintf(stdFile, "Primal error (sparse and Schur): %9.2e\n", errP3);
-
-	errD1 = 0.0;
-	errD2 = 0.0;
-	errD3 = 0.0;
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y2[i]) > errD1)
-			errD1 = getAbs(y1[i] - y2[i]);
-	#ifndef SOLVER_NONE
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y3[i]) > errD2)
-			errD2 = getAbs(y1[i] - y3[i]);
-	for (i = 0; i < 271; i++)
-		if (getAbs(y2[i] - y3[i]) > errD3)
-			errD3 = getAbs(y2[i] - y3[i]);
-	#endif /* SOLVER_NONE */
-	fprintf(stdFile, "Dual error (dense and sparse): %9.2e  (might not be unique)\n", errD1);
-	fprintf(stdFile, "Dual error (dense and Schur):  %9.2e  (might not be unique)\n", errD2);
-	fprintf(stdFile, "Dual error (sparse and Schur): %9.2e  (might not be unique)\n", errD3);
-
-	delete H;
-	delete A;
-	delete[] H_full;
-	delete[] A_full;
-	delete Hd;
-	delete Ad;
-
-	delete[] y3;
-	delete[] x3;
-	delete[] y2;
-	delete[] x2;
-	delete[] y1;
-	delete[] x1;
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/qrecipe_data.hpp b/extlibs/qpOASES-3.2.0/examples/qrecipe_data.hpp
deleted file mode 100644
index 3357b96..0000000
--- a/extlibs/qpOASES-3.2.0/examples/qrecipe_data.hpp
+++ /dev/null
@@ -1,401 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_qrecipe.cpp
- *	\author Andreas Potschka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- */
-
-
-USING_NAMESPACE_QPOASES
-
-
-
-const real_t Inf = INFTY;
-
-sparse_int_t H_jc[] = { 0,  4,  8, 12, 16, 20, 20, 20, 20, 20, 20,
-	                   24, 28, 32, 36, 40, 40, 40, 40, 40, 40,
-					   44, 48, 52, 56, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
-					   64, 68, 72, 76, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80 };
-
-sparse_int_t H_ir[] = {
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38,
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38,
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38,
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38};
-
-real_t H_val[] = {10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1,
-	1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 1,
-	10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 1, 10, 1,
-	1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10};
-
-sparse_int_t A_jc[] = {
-	  0,  10,  20,  30,  40,  50,  60,  70,  80,  90, 100, 110, 120,
-	130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270,
-	280, 290, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312,
-	313, 314, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 331,
-	333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361,
-	363, 365, 367, 369, 371, 373, 383, 393, 403, 405, 408, 410, 413, 415, 418,
-	420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448,
-	450, 452, 454, 456, 458, 460, 462, 472, 482, 492, 494, 497, 499, 502, 504,
-	507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535,
-	537, 539, 541, 543, 545, 547, 549, 551, 561, 571, 581, 583, 586, 588, 591,
-	593, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609,
-	610, 611, 612, 613, 614, 615, 616, 617, 618, 628, 638, 648, 650, 653, 655,
-	658, 660, 663};
-
-sparse_int_t A_ir[] = {0, 14, 35, 36, 71, 72, 85, 86, 87, 88, 1, 14, 35, 36, 71, 72, 85,
-	86, 87, 88, 2, 14, 35, 36, 71, 72, 85, 86, 87, 88, 3, 14, 35, 36, 71, 72,
-	85, 86, 87, 88, 4, 14, 35, 36, 71, 72, 85, 86, 87, 88, 5, 14, 35, 36, 71,
-	72, 85, 86, 87, 88, 6, 14, 35, 36, 71, 72, 85, 86, 87, 88, 7, 14, 35, 36,
-	71, 72, 85, 86, 87, 88, 8, 14, 35, 36, 71, 72, 85, 86, 87, 88, 9, 14, 35,
-	36, 71, 72, 85, 86, 87, 88, 0, 15, 37, 38, 69, 70, 79, 80, 81, 82, 1, 15,
-	37, 38, 69, 70, 79, 80, 81, 82, 2, 15, 37, 38, 69, 70, 79, 80, 81, 82, 3,
-	15, 37, 38, 69, 70, 79, 80, 81, 82, 4, 15, 37, 38, 69, 70, 79, 80, 81, 82,
-	5, 15, 37, 38, 69, 70, 79, 80, 81, 82, 6, 15, 37, 38, 69, 70, 79, 80, 81,
-	82, 7, 15, 37, 38, 69, 70, 79, 80, 81, 82, 8, 15, 37, 38, 69, 70, 79, 80,
-	81, 82, 9, 15, 37, 38, 69, 70, 79, 80, 81, 82, 0, 16, 39, 40, 67, 68, 73,
-	74, 75, 76, 1, 16, 39, 40, 67, 68, 73, 74, 75, 76, 2, 16, 39, 40, 67, 68,
-	73, 74, 75, 76, 3, 16, 39, 40, 67, 68, 73, 74, 75, 76, 4, 16, 39, 40, 67,
-	68, 73, 74, 75, 76, 5, 16, 39, 40, 67, 68, 73, 74, 75, 76, 6, 16, 39, 40,
-	67, 68, 73, 74, 75, 76, 7, 16, 39, 40, 67, 68, 73, 74, 75, 76, 8, 16, 39,
-	40, 67, 68, 73, 74, 75, 76, 9, 16, 39, 40, 67, 68, 73, 74, 75, 76, 10, 11,
-	12, 13, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 47, 48, 49, 50, 51,
-	52, 53, 54, 55, 56, 57, 47, 58, 48, 59, 49, 60, 50, 61, 51, 62, 52, 63, 53,
-	64, 54, 65, 55, 66, 46, 56, 45, 57, 47, 58, 48, 59, 49, 60, 50, 61, 51, 62,
-	52, 63, 53, 64, 54, 65, 55, 66, 46, 56, 45, 57, 10, 14, 71, 72, 85, 86, 87,
-	88, 89, 90, 11, 15, 69, 70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74,
-	75, 76, 77, 78, 35, 90, 36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78,
-	44, 58, 43, 59, 42, 60, 41, 61, 34, 62, 33, 63, 32, 64, 31, 65, 30, 66, 29,
-	46, 28, 45, 44, 58, 43, 59, 42, 60, 41, 61, 34, 62, 33, 63, 32, 64, 31, 65,
-	30, 66, 29, 46, 28, 45, 10, 14, 71, 72, 85, 86, 87, 88, 89, 90, 11, 15, 69,
-	70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74, 75, 76, 77, 78, 35, 90,
-	36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78, 27, 44, 26, 43, 25, 42,
-	24, 41, 23, 34, 22, 33, 21, 32, 20, 31, 19, 30, 18, 29, 17, 28, 27, 44, 26,
-	43, 25, 42, 24, 41, 23, 34, 22, 33, 21, 32, 20, 31, 19, 30, 18, 29, 17, 28,
-	10, 14, 71, 72, 85, 86, 87, 88, 89, 90, 11, 15, 69, 70, 79, 80, 81, 82, 83,
-	84, 12, 16, 67, 68, 73, 74, 75, 76, 77, 78, 35, 90, 36, 89, 90, 37, 84, 38,
-	83, 84, 39, 78, 40, 77, 78, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 27,
-	26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 10, 14, 71, 72, 85, 86, 87, 88, 89,
-	90, 11, 15, 69, 70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74, 75, 76,
-	77, 78, 35, 90, 36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78};
-
-real_t A_val[] = {
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.8678200000000004e+01,
- 9.3617050000000006e+01,  1.6000000000000000e+01,  8.1999999999999993e+00,
- 9.9000000000000000e+01,  8.0000000000000000e+01,  1.2000000000000000e+01,
- 9.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.0062830000000005e+01,  9.9224010000000007e+01,  1.0000000000000000e+02,
- 2.1100000000000001e+01,  1.0000000000000000e+02,  1.0000000000000000e+02,
- 1.1400000000000000e+02,  1.1680000000000000e+02, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.4697360000000003e+01,  8.3801220000000001e+01,
--8.1999999999999993e+00,  2.0000000000000000e+00,  9.0000000000000000e+01,
- 2.3999999999999999e+00, -1.2000000000000000e+01, -1.4800000000000001e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.9194209999999998e+01,
- 9.0175110000000004e+01,  4.3000000000000000e+01,  8.0000000000000000e+00,
- 1.0000000000000000e+02,  9.5000000000000000e+01,  9.0000000000000000e+00,
- 2.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.8568219999999997e+01,  8.5996200000000002e+01, -1.2500000000000000e+01,
- 1.0000000000000000e+00,  9.6500000000000000e+01,  4.0000000000000000e+00,
--1.8000000000000000e+01, -2.1899999999999999e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.2922240000000002e+01,  8.6963380000000001e+01,
- 6.5000000000000000e+01,  1.2500000000000000e+01,  1.0000000000000000e+02,
- 9.8000000000000000e+01,  4.9000000000000000e+01,  3.7000000000000000e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.2592740000000006e+01,
- 9.3147599999999997e+01, -1.2000000000000000e+01,  1.0000000000000000e+00,
- 9.6500000000000000e+01,  4.0000000000000000e+00, -1.8000000000000000e+01,
--2.1899999999999999e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.6506460000000004e+01,  7.8210250000000002e+01,  7.9000000000000000e+01,
- 1.2000000000000000e+01,  1.0000000000000000e+02,  9.5000000000000000e+01,
- 6.8000000000000000e+01,  6.1000000000000000e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.8357460000000003e+01,  9.4257840000000002e+01,
- 1.2500000000000000e+02,  6.1299999999999997e+01,  1.0000000000000000e+02,
- 1.0000000000000000e+02,  1.4500000000000000e+02,  1.4500000000000000e+02,
--1.0000000000000000e+00,  1.0000000000000000e+00,  9.0590469999999996e+01,
- 1.0582863000000000e+02,  6.2000000000000002e+00,  6.0000000000000000e+00,
- 9.7000000000000000e+01,  2.8500000000000000e+01,  4.0000000000000000e+00,
- 3.6000000000000001e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.8678200000000004e+01,  9.3617050000000006e+01,  1.6000000000000000e+01,
- 8.1999999999999993e+00,  9.9000000000000000e+01,  8.0000000000000000e+01,
- 1.2000000000000000e+01,  9.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.0062830000000005e+01,  9.9224010000000007e+01,
- 1.0000000000000000e+02,  2.1100000000000001e+01,  1.0000000000000000e+02,
- 1.0000000000000000e+02,  1.1400000000000000e+02,  1.1680000000000000e+02,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.4697360000000003e+01,
- 8.3801220000000001e+01, -8.1999999999999993e+00,  2.0000000000000000e+00,
- 9.0000000000000000e+01,  2.3999999999999999e+00, -1.2000000000000000e+01,
--1.4800000000000001e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.9194209999999998e+01,  9.0175110000000004e+01,  4.3000000000000000e+01,
- 8.0000000000000000e+00,  1.0000000000000000e+02,  9.5000000000000000e+01,
- 9.0000000000000000e+00,  2.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.8568219999999997e+01,  8.5996200000000002e+01,
--1.2500000000000000e+01,  1.0000000000000000e+00,  9.6500000000000000e+01,
- 4.0000000000000000e+00, -1.8000000000000000e+01, -2.1899999999999999e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.2922240000000002e+01,
- 8.6963380000000001e+01,  6.5000000000000000e+01,  1.2500000000000000e+01,
- 1.0000000000000000e+02,  9.8000000000000000e+01,  4.9000000000000000e+01,
- 3.7000000000000000e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.2592740000000006e+01,  9.3147599999999997e+01, -1.2000000000000000e+01,
- 1.0000000000000000e+00,  9.6500000000000000e+01,  4.0000000000000000e+00,
--1.8000000000000000e+01, -2.1899999999999999e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.6506460000000004e+01,  7.8210250000000002e+01,
- 7.9000000000000000e+01,  1.2000000000000000e+01,  1.0000000000000000e+02,
- 9.5000000000000000e+01,  6.8000000000000000e+01,  6.1000000000000000e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.8357460000000003e+01,
- 9.4257840000000002e+01,  1.2500000000000000e+02,  6.1299999999999997e+01,
- 1.0000000000000000e+02,  1.0000000000000000e+02,  1.4500000000000000e+02,
- 1.4500000000000000e+02, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 9.0590469999999996e+01,  1.0582863000000000e+02,  6.2000000000000002e+00,
- 6.0000000000000000e+00,  9.7000000000000000e+01,  2.8500000000000000e+01,
- 4.0000000000000000e+00,  3.6000000000000001e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.8678200000000004e+01,  9.3617050000000006e+01,
- 1.6000000000000000e+01,  8.1999999999999993e+00,  9.9000000000000000e+01,
- 8.0000000000000000e+01,  1.2000000000000000e+01,  9.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.0062830000000005e+01,
- 9.9224010000000007e+01,  1.0000000000000000e+02,  2.1100000000000001e+01,
- 1.0000000000000000e+02,  1.0000000000000000e+02,  1.1400000000000000e+02,
- 1.1680000000000000e+02, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.4697360000000003e+01,  8.3801220000000001e+01, -8.1999999999999993e+00,
- 2.0000000000000000e+00,  9.0000000000000000e+01,  2.3999999999999999e+00,
--1.2000000000000000e+01, -1.4800000000000001e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.9194209999999998e+01,  9.0175110000000004e+01,
- 4.3000000000000000e+01,  8.0000000000000000e+00,  1.0000000000000000e+02,
- 9.5000000000000000e+01,  9.0000000000000000e+00,  2.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.8568219999999997e+01,
- 8.5996200000000002e+01, -1.2500000000000000e+01,  1.0000000000000000e+00,
- 9.6500000000000000e+01,  4.0000000000000000e+00, -1.8000000000000000e+01,
--2.1899999999999999e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.2922240000000002e+01,  8.6963380000000001e+01,  6.5000000000000000e+01,
- 1.2500000000000000e+01,  1.0000000000000000e+02,  9.8000000000000000e+01,
- 4.9000000000000000e+01,  3.7000000000000000e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.2592740000000006e+01,  9.3147599999999997e+01,
--1.2000000000000000e+01,  1.0000000000000000e+00,  9.6500000000000000e+01,
- 4.0000000000000000e+00, -1.8000000000000000e+01, -2.1899999999999999e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.6506460000000004e+01,
- 7.8210250000000002e+01,  7.9000000000000000e+01,  1.2000000000000000e+01,
- 1.0000000000000000e+02,  9.5000000000000000e+01,  6.8000000000000000e+01,
- 6.1000000000000000e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.8357460000000003e+01,  9.4257840000000002e+01,  1.2500000000000000e+02,
- 6.1299999999999997e+01,  1.0000000000000000e+02,  1.0000000000000000e+02,
- 1.4500000000000000e+02,  1.4500000000000000e+02, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  9.0590469999999996e+01,  1.0582863000000000e+02,
- 6.2000000000000002e+00,  6.0000000000000000e+00,  9.7000000000000000e+01,
- 2.8500000000000000e+01,  4.0000000000000000e+00,  3.6000000000000001e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00, -1.2000000000000000e-01,
--3.8000000000000000e-01, -5.0000000000000000e-01,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--9.3000000000000000e+01, -8.9000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -8.9000000000000000e+01, -8.5000000000000000e+01,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.1000000000000000e+01,
--8.8000000000000000e+01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.3000000000000000e+01,
--8.9000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--8.9000000000000000e+01, -8.5000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.1000000000000000e+01, -8.8000000000000000e+01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.3000000000000000e+01, -8.9000000000000000e+01,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -8.9000000000000000e+01,
--8.5000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--9.1000000000000000e+01, -8.8000000000000000e+01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.3000000000000000e+01,
--8.9000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--8.9000000000000000e+01, -8.5000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.1000000000000000e+01, -8.8000000000000000e+01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01};
-
-real_t g[] = {+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00,
-	-2e+00, +0e+00, -2e+00, +0e+00, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03,
-	+2e-03, +1e-03, +2e-03, +2e-03, +2e-03, +0e+00, -2e-03, -2e-03, -2e-03,
-	-2e-03, -2e-03, -2e-03, -1e-03, -2e-03, -2e-03, -2e-03, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +2e-03,
-	+2e-03, +2e-03, +2e-03, +2e-03, +2e-03, +1e-03, +2e-03, +2e-03, +2e-03,
-	+0e+00, -2e-03, -2e-03, -2e-03, -2e-03, -2e-03, -2e-03, -1e-03, -2e-03,
-	-2e-03, -2e-03, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03,
-	+1e-03, +2e-03, +2e-03, +2e-03, +0e+00, -2e-03, -2e-03, -2e-03, -2e-03,
-	-2e-03, -2e-03, -1e-03, -2e-03, -2e-03, -2e-03, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +1e-01, +1e-01,
-	+1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +0e+00,
-	-1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01,
-	-1e-01, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00};
-
-real_t lb[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, -Inf, 0, -Inf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 5,
-	10, 5, 0, 10, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 10, 5, 10, 5, 0, 10, 0, 5, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 5, 10, 5, 0, 10, 0, 5, 0, 10, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-real_t ub[] = {Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, 0, 92, 39, 87, 29, 0, 20, 0, 28, 20, 71, Inf, 130, 45, 53, 55, 75,
-	112, 0, 73, 480, 154, 121, 50, 30, 77, 20, 0, 18, 0, 5, 20, 71, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, 130, 55, 93, 60, 75, 115, 0, 67,
-	480, 154, 121, 50, 20, 37, 15, 0, 15, 0, 8, 20, 71, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, 130, 55, 93, 60, 75, 105, 0, 67, 4980, 154, 110,
-	50, 20, 37, 15, 0, 25, 0, 8, 20, 71, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, 20, 20, 20, 20, 0, 20, 0, 20, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf};
-
-real_t lbA[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -Inf, -Inf,
-	-Inf, -Inf, -Inf, -Inf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0};
-
-real_t ubA[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf};
-
-long H_nnz = (long) sizeof(H_val) / (long) sizeof(real_t);
-long A_nnz = (long) sizeof(A_val) / (long) sizeof(real_t);
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES.hpp
deleted file mode 100644
index 9d51cf9..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-
-
-#if defined(__SINGLE_OBJECT__) || defined(__C_WRAPPER__)
-
-#include <MessageHandling.cpp>
-#include <Utils.cpp>
-#include <Indexlist.cpp>
-#include <SubjectTo.cpp>
-#include <Bounds.cpp>
-#include <Constraints.cpp>
-#include <BLASReplacement.cpp>
-#include <LAPACKReplacement.cpp>
-#include <Matrices.cpp>
-#include <Options.cpp>
-#include <QProblemB.cpp>
-#include <Flipper.cpp>
-#include <QProblem.cpp>
-#include <SQProblem.cpp>
-#include <SparseSolver.cpp>
-#include <SQProblemSchur.cpp>
-
-#ifndef __C_WRAPPER__
-#include <OQPinterface.cpp>
-#include <SolutionAnalysis.cpp>
-#endif
-
-#else /* default compilation mode */
-
-#include <qpOASES/QProblemB.hpp>
-#include <qpOASES/QProblem.hpp>
-#include <qpOASES/SQProblem.hpp>
-#include <qpOASES/SQProblemSchur.hpp>
-#include <qpOASES/extras/OQPinterface.hpp>
-#include <qpOASES/extras/SolutionAnalysis.hpp>
-
-#endif
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.hpp
deleted file mode 100644
index 312bc1a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.hpp
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Bounds.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the Bounds class designed to manage working sets of
- *	bounds within a QProblem.
- */
-
-
-#ifndef QPOASES_BOUNDS_HPP
-#define QPOASES_BOUNDS_HPP
-
-
-#include <qpOASES/SubjectTo.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Manages working sets of bounds (i.e. box constraints).
- *
- *	This class manages working sets of bounds (= box constraints) 
- *	by storing index sets and other status information.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- */
-class Bounds : public SubjectTo
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Bounds( );
-
-		/** Constructor which takes the number of bounds. */
-		Bounds(	int_t _n								/**< Number of bounds. */
-				);
-
-		/** Copy constructor (deep copy). */
-		Bounds(	const Bounds& rhs						/**< Rhs object. */
-				);
-
-		/** Destructor. */
-		virtual ~Bounds( );
-
-		/** Assignment operator (deep copy). */
-		Bounds& operator=(	const Bounds& rhs			/**< Rhs object. */
-							);
-
-
-		/** Initialises object with given number of bounds.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INVALID_ARGUMENTS */
-		returnValue init(	int_t _n = 0				/**< Number of bounds. */
-							);
-
-
-		/** Initially adds number of a new (i.e. not yet in the list) bound to
-		 *  given index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_BOUND_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS \n
-					RET_INVALID_ARGUMENTS */
-		returnValue setupBound(	int_t number,			/**< Number of new bound. */
-								SubjectToStatus _status	/**< Status of new bound. */
-								);
-
-		/** Initially adds all numbers of new (i.e. not yet in the list) bounds to
-		 *  to the index set of free bounds; the order depends on the SujectToType
-		 *  of each index.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_BOUND_FAILED */
-		returnValue setupAllFree( );
-
-		/** Initially adds all numbers of new (i.e. not yet in the list) bounds to
-		 *  to the index set of fixed bounds (on their lower bounds);
-		 *  the order depends on the SujectToType of each index.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_BOUND_FAILED */
-		returnValue setupAllLower( );
-
-		/** Initially adds all numbers of new (i.e. not yet in the list) bounds to
-		 *  to the index set of fixed bounds (on their upper bounds);
-		 *  the order depends on the SujectToType of each index.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_BOUND_FAILED */
-		returnValue setupAllUpper( );
-
-
-		/** Moves index of a bound from index list of fixed to that of free bounds.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_BOUND_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS */
-		returnValue moveFixedToFree(	int_t number			/**< Number of bound to be freed. */
-										);
-
-		/** Moves index of a bound from index list of free to that of fixed bounds.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_BOUND_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS */
-		returnValue moveFreeToFixed(	int_t number,			/**< Number of bound to be fixed. */
-										SubjectToStatus _status	/**< Status of bound to be fixed. */
-										);
-
-		/** Flip fixed bound.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_BOUND_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS */
-		returnValue flipFixed( int_t number );
-
-		/** Swaps the indices of two free bounds within the index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SWAPINDEX_FAILED */
-		returnValue swapFree(	int_t number1,					/**< Number of first constraint or bound. */
-								int_t number2					/**< Number of second constraint or bound. */
-								);
-
-
-		/** Returns number of variables.
-		 *	\return Number of variables. */
-		inline int_t getNV( ) const;
-
-		/** Returns number of implicitly fixed variables.
-		 *	\return Number of implicitly fixed variables. */
-		inline int_t getNFV( ) const;
-
-		/** Returns number of bounded (but possibly free) variables.
-		 *	\return Number of bounded (but possibly free) variables. */
-		inline int_t getNBV( ) const;
-
-		/** Returns number of unbounded variables.
-		 *	\return Number of unbounded variables. */
-		inline int_t getNUV( ) const;
-
-		/** Returns number of free variables.
-		 *	\return Number of free variables. */
-		inline int_t getNFR( ) const;
-
-		/** Returns number of fixed variables.
-		 *	\return Number of fixed variables. */
-		inline int_t getNFX( ) const;
-
-
-		/** Returns a pointer to free variables index list.
-		 *	\return Pointer to free variables index list. */
-		inline Indexlist* getFree( );
-
-		/** Returns a pointer to fixed variables index list.
-		 *	\return Pointer to fixed variables index list. */
-		inline Indexlist* getFixed( );
-
-
-		/** Shifts forward type and status of all bounds by a given
-		 *  offset. This offset has to lie within the range [0,n/2] and has to
-		 *  be an integer divisor of the total number of bounds n.
-		 *  Type and status of the first \<offset\> bounds is thrown away,
-		 *  type and status of the last \<offset\> bounds is doubled,
-		 *  e.g. for offset = 2: \n
-		 *  shift( {b1,b2,b3,b4,b5,b6} ) = {b3,b4,b5,b6,b5,b6}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_INVALID_ARGUMENTS \n
-		 			RET_SHIFTING_FAILED */
-		virtual returnValue shift(	int_t offset	/**< Shift offset within the range [0,n/2] and integer divisor of n. */
-									);
-
-		/** Rotates forward type and status of all bounds by a given
-		 *  offset. This offset has to lie within the range [0,n].
-		 *  Example for offset = 2: \n
-		 *  rotate( {b1,b2,b3,b4,b5,b6} ) = {b3,b4,b5,b6,b1,b2}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_ROTATING_FAILED */
-		virtual returnValue rotate(	int_t offset	/**< Rotation offset within the range [0,n]. */
-									);
-
-
-		/** Prints information on bounds object
-		 *  (in particular, lists of free and fixed bounds.
-		 * \return SUCCESSFUL_RETURN \n
-				   RET_INDEXLIST_CORRUPTED */
-		returnValue print( );
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-		
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Bounds& rhs	/**< Rhs object. */
-							);
-
-
-		/** Initially adds all numbers of new (i.e. not yet in the list) bounds to
-		 *  to the index set corresponding to the desired status;
-		 *  the order depends on the SujectToType of each index.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_BOUND_FAILED */
-		returnValue setupAll(	SubjectToStatus _status	/**< Desired initial status for all bounds. */
-								);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		Indexlist freee;		/**< Index list of free variables. */
-		Indexlist fixed;		/**< Index list of fixed variables. */
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/Bounds.ipp>
-
-#endif	/* QPOASES_BOUNDS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.ipp
deleted file mode 100644
index ebd0eeb..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.ipp
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Bounds.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the Bounds class designed
- *	to manage working sets of bounds within a QProblem.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-/*
- *	g e t N V
- */
-inline int_t Bounds::getNV( ) const
-{
- 	return n;
-}
-
-
-/*
- *	g e t N F V
- */
-inline int_t Bounds::getNFV( ) const
-{
- 	return getNumberOfType( ST_EQUALITY );
-}
-
-
-/*
- *	g e t N B V
- */
-inline int_t Bounds::getNBV( ) const
-{
- 	return getNumberOfType( ST_BOUNDED );
-}
-
-
-/*
- *	g e t N U V
- */
-inline int_t Bounds::getNUV( ) const
-{
-	return getNumberOfType( ST_UNBOUNDED );
-}
-
-
-/*
- *	g e t N F R
- */
-inline int_t Bounds::getNFR( ) const
-{
- 	return freee.getLength( );
-}
-
-
-/*
- *	g e t N F X
- */
-inline int_t Bounds::getNFX( ) const
-{
-	return fixed.getLength( );
-}
-
-
-/*
- *	g e t F r e e
- */
-inline Indexlist* Bounds::getFree( )
-{
-	return &freee;
-}
-
-
-/*
- *	g e t F i x e d
- */
-inline Indexlist* Bounds::getFixed( )
-{
-	return &fixed;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Constants.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Constants.hpp
deleted file mode 100644
index 214167c..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Constants.hpp
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Constants.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Definition of all global constants.
- */
-
-
-#ifndef QPOASES_CONSTANTS_HPP
-#define QPOASES_CONSTANTS_HPP
-
-
-#include <qpOASES/Types.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** Numerical value of machine precision (min eps, s.t. 1+eps > 1).
- *	Note: this value has to be positive! */
-#ifdef __USE_SINGLE_PRECISION__
-const real_t EPS = 1.193e-07f;
-#else
-const real_t EPS = 2.221e-16;
-#endif /* __USE_SINGLE_PRECISION__ */
-
-
-/** Numerical value of zero (for situations in which it would be
- *	unreasonable to compare with 0.0).
- *	Note: this value has to be positive! */
-const real_t ZERO = 1.0e-25;
-
-/** Numerical value of infinity (e.g. for non-existing bounds).
-	Note: this value has to be positive! */
-const real_t INFTY = 1.0e20;
-
-
-/** Maximum number of characters within a string.
- *	Note: this value should be at least 41! */
-const uint_t MAX_STRING_LENGTH = 160;
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_CONSTANTS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/ConstraintProduct.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/ConstraintProduct.hpp
deleted file mode 100644
index 4d70831..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/ConstraintProduct.hpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/ConstraintProduct.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2009-2015
- *
- *	Declaration of the ConstraintProduct class which allows to specify a
- *	user-defined function for evaluating the constraint product at the 
- *	current iterate to speed-up QP solution in case of a specially structured
- *	constraint matrix.
- */
-
-
-
-#ifndef QPOASES_CONSTRAINT_PRODUCT_HPP
-#define QPOASES_CONSTRAINT_PRODUCT_HPP
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Interface for specifying user-defined evaluations of constraint products.
- *
- *	A class which allows to specify a user-defined function for evaluating the 
- *	constraint product at the current iterate to speed-up QP solution in case 
- *	of a specially structured constraint matrix.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2009-2015
- */
-class ConstraintProduct
-{
-	public:
-		/** Default constructor. */
-		ConstraintProduct( ) {};
-
-		/** Copy constructor. */
-        ConstraintProduct(	const ConstraintProduct &/*toCopy*/	/**< Rhs object. */
-							) {};
-
-		/** Destructor. */
-		virtual ~ConstraintProduct( ) {};
-		
-		/** Assignment operator. */
-        ConstraintProduct &operator=(	const ConstraintProduct &/*toCopy*/	/**< Rhs object. */
-										)
-		{
-			return *this;
-		}
-
-		/** Evaluates the product of a given constraint with the current iterate.
-		 *	This function needs to be implemented in a derived class for the 
-		 *	user-defined constraint product function.
-		 *	\return 0:         successful \n
-					otherwise: not successful */
-		virtual int_t operator() (	int_t constrIndex,			/**< Number of constraint to be evaluated. */
-									const real_t* const x,		/**< Array containing current primal iterate. */
-									real_t* const constrValue	/**< Output: Scalar value of the evaluated constraint. */
-									) const = 0;
-};
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_CONSTRAINT_PRODUCT_HPP */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.hpp
deleted file mode 100644
index 3b43635..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.hpp
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Constraints.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the Constraints class designed to manage working sets of
- *	constraints within a QProblem.
- */
-
-
-#ifndef QPOASES_CONSTRAINTS_HPP
-#define QPOASES_CONSTRAINTS_HPP
-
-
-#include <qpOASES/SubjectTo.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Manages working sets of constraints.
- *
- *	This class manages working sets of constraints by storing
- *	index sets and other status information.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- */
-class Constraints : public SubjectTo
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Constraints( );
-
-		/** Constructor which takes the number of constraints. */
-		Constraints(	int_t _n						/**< Number of constraints. */
-						);
-
-		/** Copy constructor (deep copy). */
-		Constraints(	const Constraints& rhs			/**< Rhs object. */
-						);
-
-		/** Destructor. */
-		virtual ~Constraints( );
-
-		/** Assignment operator (deep copy). */
-		Constraints& operator=(	const Constraints& rhs	/**< Rhs object. */
-								);
-
-
-		/** Initialises object with given number of constraints.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INVALID_ARGUMENTS */
-		returnValue init(	int_t _n = 0				/**< Number of constraints. */
-							);
-
-
-		/** Initially adds number of a new (i.e. not yet in the list) constraint to
-		 *  a given index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_CONSTRAINT_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS \n
-					RET_INVALID_ARGUMENTS */
-		returnValue setupConstraint(	int_t number,			/**< Number of new constraint. */
-										SubjectToStatus _status	/**< Status of new constraint. */
-										);
-
-		/** Initially adds all enabled numbers of new (i.e. not yet in the list) constraints to
-		 *  to the index set of inactive constraints; the order depends on the SujectToType
-		 *  of each index. Only disabled constraints are added to index set of disabled constraints!
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_CONSTRAINT_FAILED */
-		returnValue setupAllInactive( );
-
-		/** Initially adds all enabled numbers of new (i.e. not yet in the list) constraints to
-		 *  to the index set of active constraints (on their lower bounds); the order depends on the SujectToType
-		 *  of each index. Only disabled constraints are added to index set of disabled constraints!
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_CONSTRAINT_FAILED */
-		returnValue setupAllLower( );
-
-		/** Initially adds all enabled numbers of new (i.e. not yet in the list) constraints to
-		 *  to the index set of active constraints (on their upper bounds); the order depends on the SujectToType
-		 *  of each index. Only disabled constraints are added to index set of disabled constraints!
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_CONSTRAINT_FAILED */
-		returnValue setupAllUpper( );
-
-
-		/** Moves index of a constraint from index list of active to that of inactive constraints.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_CONSTRAINT_FAILED */
-		returnValue moveActiveToInactive(	int_t number			/**< Number of constraint to become inactive. */
-											);
-
-		/** Moves index of a constraint from index list of inactive to that of active constraints.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_CONSTRAINT_FAILED */
-		returnValue moveInactiveToActive(	int_t number,			/**< Number of constraint to become active. */
-											SubjectToStatus _status	/**< Status of constraint to become active. */
-											);
-
-		/** Flip fixed constraint.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_CONSTRAINT_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS */
-		returnValue flipFixed( int_t number );
-
-
-		/** Returns the number of constraints.
-		 *	\return Number of constraints. */
-		inline int_t getNC( ) const;
-
-		/** Returns the number of implicit equality constraints.
-		 *	\return Number of implicit equality constraints. */
-		inline int_t getNEC( ) const;
-
-		/** Returns the number of "real" inequality constraints.
-		 *	\return Number of "real" inequality constraints. */
-		inline int_t getNIC( ) const;
-
-		/** Returns the number of unbounded constraints (i.e. without any bounds).
-		 *	\return Number of unbounded constraints (i.e. without any bounds). */
-		inline int_t getNUC( ) const;
-
-		/** Returns the number of active constraints.
-		 *	\return Number of active constraints. */
-		inline int_t getNAC( ) const;
-
-		/** Returns the number of inactive constraints.
-		 *	\return Number of inactive constraints. */
-		inline int_t getNIAC( ) const;
-
-
-		/** Returns a pointer to active constraints index list.
-		 *	\return Pointer to active constraints index list. */
-		inline Indexlist* getActive( );
-
-		/** Returns a pointer to inactive constraints index list.
-		 *	\return Pointer to inactive constraints index list. */
-		inline Indexlist* getInactive( );
-
-
-		/** Shifts forward type and status of all constraints by a given
-		 *  offset. This offset has to lie within the range [0,n/2] and has to
-		 *  be an integer divisor of the total number of constraints n.
-		 *  Type and status of the first \<offset\> constraints  is thrown away,
-		 *  type and status of the last \<offset\> constraints is doubled,
-		 *  e.g. for offset = 2: \n
-		 *  shift( {c1,c2,c3,c4,c5,c6} ) = {c3,c4,c5,c6,c5,c6}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_INVALID_ARGUMENTS \n
-		 			RET_SHIFTING_FAILED */
-		virtual returnValue shift(	int_t offset	/**< Shift offset within the range [0,n/2] and integer divisor of n. */
-									);
-
-		/** Rotates forward type and status of all constraints by a given
-		 *  offset. This offset has to lie within the range [0,n].
-		 *  Example for offset = 2: \n
-		 *  rotate( {c1,c2,c3,c4,c5,c6} ) = {c3,c4,c5,c6,c1,c2}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_ROTATING_FAILED */
-		virtual returnValue rotate(	int_t offset	/**< Rotation offset within the range [0,n]. */
-									);
-
-
-		/** Prints information on constraints object
-		 *  (in particular, lists of inactive and active constraints.
-		 * \return SUCCESSFUL_RETURN \n
-				   RET_INDEXLIST_CORRUPTED */
-		returnValue print( );
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-		
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Constraints& rhs	/**< Rhs object. */
-							);
-
-
-		/** Initially adds all numbers of new (i.e. not yet in the list) bounds to
-		 *  to the index set corresponding to the desired status;
-		 *  the order depends on the SujectToType of each index.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_CONSTRAINT_FAILED */
-		returnValue setupAll(	SubjectToStatus _status	/**< Desired initial status for all bounds. */
-								);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		Indexlist active;		/**< Index list of active constraints. */
-		Indexlist inactive;		/**< Index list of inactive constraints. */
-};
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/Constraints.ipp>
-
-#endif	/* QPOASES_CONSTRAINTS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.ipp
deleted file mode 100644
index ca7035a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.ipp
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Constraints.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of inlined member functions of the Constraints class designed
- *	to manage working sets of constraints within a QProblem.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	g e t N C
- */
-inline int_t Constraints::getNC( ) const
-{
- 	return n;
-}
-
-
-/*
- *	g e t N E C
- */
-inline int_t Constraints::getNEC( ) const
-{
-	return getNumberOfType( ST_EQUALITY );
-}
-
-
-/*
- *	g e t N I C
- */
-inline int_t Constraints::getNIC( ) const
-{
- 	return getNumberOfType( ST_BOUNDED );
-}
-
-
-/*
- *	g e t N U C
- */
-inline int_t Constraints::getNUC( ) const
-{
- 	return getNumberOfType( ST_UNBOUNDED );
-}
-
-
-/*
- *	g e t N A C
- */
-inline int_t Constraints::getNAC( ) const
-{
- 	return active.getLength( );
-}
-
-
-/*
- *	g e t N I A C
- */
-inline int_t Constraints::getNIAC( ) const
-{
-	return inactive.getLength( );
-}
-
-
-
-/*
- *	g e t A c t i v e
- */
-inline Indexlist* Constraints::getActive( )
-{
-	return &active;
-}
-
-
-/*
- *	g e t I n a c t i v e
- */
-inline Indexlist* Constraints::getInactive( )
-{
-	return &inactive;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Flipper.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Flipper.hpp
deleted file mode 100644
index a97c4d1..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Flipper.hpp
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Flipper.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the Options class designed to manage user-specified
- *	options for solving a QProblem.
- */
-
-
-#ifndef QPOASES_FLIPPER_HPP
-#define QPOASES_FLIPPER_HPP
-
-
-#include <qpOASES/Bounds.hpp>
-#include <qpOASES/Constraints.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Auxiliary class for storing a copy of the current matrix factorisations.
- *
- *	This auxiliary class stores a copy of the current matrix factorisations. It
- *	is used by the classe QProblemB and QProblem in case flipping bounds are enabled.
- *
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-class Flipper
-{
-	friend class QProblemB;
-	friend class QProblem;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Flipper( );
-
-		/** Constructor which takes the number of bounds and constraints. */
-		Flipper(	uint_t _nV,			/**< Number of bounds. */
-					uint_t _nC = 0		/**< Number of constraints. */
-					);
-
-		/** Copy constructor (deep copy). */
-		Flipper(	const Flipper& rhs			/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		~Flipper( );
-
-		/** Assignment operator (deep copy). */
-		Flipper& operator=(	const Flipper& rhs	/**< Rhs object. */
-							);
-
-
-		/** Initialises object with given number of bounds and constraints.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INVALID_ARGUMENTS */
-		returnValue init(	uint_t _nV = 0,		/**< Number of bounds. */
-							uint_t _nC = 0		/**< Number of constraints. */
-							);
-
-
-		/** Copies current values to non-null arguments (assumed to be allocated with consistent size).
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue get(	Bounds* const _bounds,					/**< Pointer to new bounds. */
-							real_t* const R,						/**< New matrix R. */
-							Constraints* const _constraints = 0,	/**< Pointer to new constraints. */
-							real_t* const _Q = 0,					/**< New matrix Q. */
-							real_t* const _T = 0					/**< New matrix T. */
-							) const;
-
-		/** Assigns new values to non-null arguments.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue set(	const Bounds* const _bounds,				/**< Pointer to new bounds. */
-							const real_t* const _R,						/**< New matrix R. */
-							const Constraints* const _constraints = 0,	/**< Pointer to new constraints. */
-							const real_t* const _Q = 0,					/**< New matrix Q. */
-							const real_t* const _T = 0					/**< New matrix T. */
-							);
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-		
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Flipper& rhs	/**< Rhs object. */
-							);
-
-		/** Returns dimension of matrix T.
-		 *  \return Dimension of matrix T. */
-		uint_t getDimT( ) const;
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		uint_t nV;						/**< Number of variables. */
-		uint_t nC;						/**< Number of constraints. */
-
-		Bounds      bounds;				/**< Data structure for problem's bounds. */
-		Constraints constraints;		/**< Data structure for problem's constraints. */
-
-		real_t* R;						/**< Cholesky factor of H (i.e. H = R^T*R). */
-		real_t* Q;						/**< Orthonormal quadratic matrix, A = [0 T]*Q'. */
-		real_t* T;						/**< Reverse triangular matrix, A = [0 T]*Q'. */
-};
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_FLIPPER_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.hpp
deleted file mode 100644
index 62ff915..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.hpp
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Indexlist.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the Indexlist class designed to manage index lists of
- *	constraints and bounds within a SubjectTo object.
- */
-
-
-#ifndef QPOASES_INDEXLIST_HPP
-#define QPOASES_INDEXLIST_HPP
-
-
-#include <qpOASES/Utils.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Stores and manages index lists.
- *
- *	This class manages index lists of active/inactive bounds/constraints.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- */
-class Indexlist
-{
-	/*
-	 *  FRIENDS
-	 */
-	friend class DenseMatrix;
-	friend class SymDenseMat;
-	friend class SparseMatrix;
-	friend class SparseMatrixRow;
-	friend class SymSparseMat;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Indexlist( );
-
-		/** Constructor which takes the desired physical length of the index list. */
-		Indexlist(	int_t n	/**< Physical length of index list. */
-					);
-
-		/** Copy constructor (deep copy). */
-		Indexlist(	const Indexlist& rhs	/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		~Indexlist( );
-
-		/** Assingment operator (deep copy). */
-		Indexlist& operator=(	const Indexlist& rhs	/**< Rhs object. */
-								);
-
-
-		/** Initialises index list of desired physical length.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INVALID_ARGUMENTS */
-		returnValue init(	int_t n = 0	/**< Physical length of index list. */
-							);
-
-
-		/** Creates an array of all numbers within the index set in correct order.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEXLIST_CORRUPTED */
-		returnValue	getNumberArray(	int_t** const numberarray	/**< Output: Array of numbers (NULL on error). */
-									) const;
-
-		/** Creates an array of all numbers within the index set in correct order.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INDEXLIST_CORRUPTED */
-		returnValue	getISortArray(	int_t** const iSortArray	/**< Output: iSort Array. */
-									) const;
-
-
-		/** Determines the index within the index list at which a given number is stored.
-		 *	\return >= 0: Index of given number. \n
-		 			-1: Number not found. */
-		int_t getIndex(	int_t givennumber	/**< Number whose index shall be determined. */
-						) const;
-
-		/** Returns the number stored at a given physical index.
-		 *	\return >= 0: Number stored at given physical index. \n
-		 			-RET_INDEXLIST_OUTOFBOUNDS */
-		int_t getNumber(	int_t physicalindex	/**< Physical index of the number to be returned. */
-							) const;
-
-
-		/** Returns the current length of the index list.
-		 *	\return Current length of the index list. */
-		inline int_t getLength( ) const;
-
-		/** Returns last number within the index list.
-		 *	\return Last number within the index list. */
-		inline int_t getLastNumber( ) const;
-
-
-		/** Adds number to index list.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEXLIST_MUST_BE_REORDERD \n
-		 			RET_INDEXLIST_EXCEEDS_MAX_LENGTH */
-		returnValue addNumber(	int_t addnumber			/**< Number to be added. */
-								);
-
-		/** Removes number from index list.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue removeNumber(	int_t removenumber	/**< Number to be removed. */
-									);
-
-		/** Swaps two numbers within index list.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue swapNumbers(	int_t number1,		/**< First number for swapping. */
-									int_t number2			/**< Second number for swapping. */
-									);
-
-		/** Determines if a given number is contained in the index set.
-		 *	\return BT_TRUE iff number is contain in the index set */
-		inline BooleanType isMember(	int_t _number		/**< Number to be tested for membership. */
-										) const;
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Indexlist& rhs	/**< Rhs object. */
-							);
-
-		/** Find first index j between -1 and length in sorted list of indices
-		 *  iSort such that numbers[iSort[j]] <= i < numbers[iSort[j+1]]. Uses
-		 *  bisection.
-		 *  \return j. */
-		int_t findInsert(	int_t i
-							) const;
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		int_t* number;			/**< Array to store numbers of constraints or bounds. */
-		int_t* iSort;			/**< Index list to sort vector \a number */
-
-		int_t	length;			/**< Length of index list. */
-		int_t	first;			/**< Physical index of first element. */
-		int_t	last;			/**< Physical index of last element. */
-		int_t	lastusedindex;	/**< Physical index of last entry in index list. */
-		int_t	physicallength;	/**< Physical length of index list. */
-};
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/Indexlist.ipp>
-
-#endif	/* QPOASES_INDEXLIST_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.ipp
deleted file mode 100644
index f1bd9cf..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.ipp
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Indexlist.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the Indexlist class designed
- *	to manage index lists of constraints and bounds within a QProblem_SubjectTo.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	g e t N u m b e r
- */
-inline int_t Indexlist::getNumber( int_t physicalindex ) const
-{
-	/* consistency check */
-	if ( ( physicalindex < 0 ) || ( physicalindex > length ) )
-		return -RET_INDEXLIST_OUTOFBOUNDS;
-
-	return number[physicalindex];
-}
-
-
-/*
- *	g e t L e n g t h
- */
-inline int_t Indexlist::getLength( ) const
-{
-	return length;
-}
-
-
-/*
- *	g e t L a s t N u m b e r
- */
-inline int_t Indexlist::getLastNumber( ) const
-{
-	return number[length-1];
-}
-
-
-/*
- *	g e t L a s t N u m b e r
- */
-inline BooleanType Indexlist::isMember( int_t _number ) const
-{
-	if ( getIndex( _number ) >= 0 )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Matrices.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Matrices.hpp
deleted file mode 100644
index ae06407..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Matrices.hpp
+++ /dev/null
@@ -1,1009 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Matrices.hpp
- *	\author Andreas Potschka, Hans Joachim Ferreau, Christian Kirches
- *	\version 3.2
- *	\date 2009-2015
- *
- *  Various matrix classes: Abstract base matrix class, dense and sparse matrices,
- *  including symmetry exploiting specializations.
- */
-
-
-
-#ifndef QPOASES_MATRICES_HPP
-#define QPOASES_MATRICES_HPP
-
-
-#include <qpOASES/Utils.hpp>
-#include <qpOASES/Indexlist.hpp>
-
-
-#ifdef __USE_SINGLE_PRECISION__
-
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define GEMM sgemm_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define SYR ssyr_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define SYR2 ssyr2_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define POTRF spotrf_
-
-#else
-
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define GEMM dgemm_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define SYR  dsyr_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define SYR2 dsyr2_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define POTRF dpotrf_
-
-#endif /* __USE_SINGLE_PRECISION__ */
-
-
-extern "C"
-{
-	/** Performs one of the matrix-matrix operation in double precision. */
-	void dgemm_ ( const char*, const char*, const unsigned long*, const unsigned long*, const unsigned long*,
-			const double*, const double*, const unsigned long*, const double*, const unsigned long*,
-			const double*, double*, const unsigned long* );
-	/** Performs one of the matrix-matrix operation in single precision. */
-	void sgemm_ ( const char*, const char*, const unsigned long*, const unsigned long*, const unsigned long*,
-			const float*, const float*, const unsigned long*, const float*, const unsigned long*,
-			const float*, float*, const unsigned long* );
-
-	/** Performs a symmetric rank 1 operation in double precision. */
-	void dsyr_ ( const char *, const unsigned long *, const double *, const double *,
-				 const unsigned long *, double *, const unsigned long *);
-	/** Performs a symmetric rank 1 operation in single precision. */
-	void ssyr_ ( const char *, const unsigned long *, const float *, const float *,
-				 const unsigned long *, float *, const unsigned long *);
-
-	/** Performs a symmetric rank 2 operation in double precision. */
-	void dsyr2_ ( const char *, const unsigned long *, const double *, const double *,
-				  const unsigned long *, const double *, const unsigned long *, double *, const unsigned long *);
-	/** Performs a symmetric rank 2 operation in single precision. */
-	void ssyr2_ ( const char *, const unsigned long *, const float *, const float *,
-				  const unsigned long *, const float *, const unsigned long *, float *, const unsigned long *);
-
-	/** Calculates the Cholesky factorization of a real symmetric positive definite matrix in double precision. */
-	void dpotrf_ ( const char *, const unsigned long *, double *, const unsigned long *, long * );
-	/** Calculates the Cholesky factorization of a real symmetric positive definite matrix in single precision. */
-	void spotrf_ ( const char *, const unsigned long *, float *, const unsigned long *, long * );
-}
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-	/**
- *	\brief Abstract base class for interfacing tailored matrix-vector operations.
- *
- *	Abstract base matrix class. Supplies interface to matrix vector
- *  products, including products with submatrices given by (ordered) working set
- *  index lists (see \a SubjectTo).
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class Matrix
-{
-	public:
-		/** Default constructor. */
-		Matrix( ) { doNotFreeMemory(); };
-
-		/** Destructor. */
-		virtual ~Matrix( ) { };
-
-		/** Frees all internal memory. */
-		virtual void free( ) = 0;
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix* duplicate( ) const = 0;
-
-		/** Returns i-th diagonal entry.
-		 *	\return i-th diagonal entry */
-		virtual real_t diag(	int_t i			/**< Index. */
-								) const = 0;
-
-		/** Checks whether matrix is square and diagonal.
-		 *	\return BT_TRUE  iff matrix is square and diagonal; \n
-		 *	        BT_FALSE otherwise. */
-		virtual BooleanType isDiag( ) const = 0;
-
-        /** Get the N-norm of the matrix
-         *  \return N-norm of the matrix
-         */
-        virtual real_t getNorm(	int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-								) const = 0;
-
-        /** Get the N-norm of a row
-         *  \return N-norm of row \a rNum
-         */
-        virtual real_t getRowNorm(	int_t rNum,		/**< Row number. */
-									int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-									) const = 0;
-
-		/** Retrieve indexed entries of matrix row multiplied by alpha.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue getRow(	int_t rNum,						/**< Row number. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									real_t alpha,					/**< Scalar factor. */
-									real_t *row						/**< Output row vector. */
-									) const = 0;
-
-		/** Retrieve indexed entries of matrix column multiplied by alpha.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue getCol(	int_t cNum,						/**< Column number. */
-									const Indexlist* const irows,	/**< Index list specifying rows. */
-									real_t alpha,					/**< Scalar factor. */
-									real_t *col						/**< Output column vector. */
-									) const = 0;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				const Indexlist* const irows,	/**< Index list specifying rows. */
-				const Indexlist* const icols,	/**< Index list specifying columns. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.  This version retrieves one
-		 *  column.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				const Indexlist* const irows,	/**< Index list specifying rows. */
-				int_t idx_icol,					/**< Index list specifying columns. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.  This version retrieves one row.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				int_t idx_row,					/**< Row number. */
-				const Indexlist* const icols,	/**< Index list specifying columns. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				int_t irowsLength,				/**< Number of rows. */
-				const int_t* const irowsNumber, /**< Array with row numbers. */
-				int_t icolsLength,				/**< Number of columns. */
-				const int_t* const icolsNumber, /**< Array with column numbers. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const = 0;
-
-		/** Evaluate Y=alpha*A*X + beta*Y.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue times (	int_t xN,				/**< Number of vectors to multiply. */
-									real_t alpha,			/**< Scalar factor for matrix vector product. */
-									const real_t *x,		/**< Input vector to be multiplied. */
-									int_t xLD,				/**< Leading dimension of input x. */
-									real_t beta,			/**< Scalar factor for y. */
-									real_t *y,				/**< Output vector of results. */
-									int_t yLD				/**< Leading dimension of output y. */
-									) const = 0;
-
-		/** Evaluate Y=alpha*A'*X + beta*Y.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue transTimes (	int_t xN,			/**< Number of vectors to multiply. */
-											real_t alpha,		/**< Scalar factor for matrix vector product. */
-											const real_t *x,	/**< Input vector to be multiplied. */
-											int_t xLD,			/**< Leading dimension of input x. */
-											real_t beta,		/**< Scalar factor for y. */
-											real_t *y,			/**< Output vector of results. */
-											int_t yLD			/**< Leading dimension of output y. */
-											) const = 0;
-
-		/** Evaluate matrix vector product with submatrix given by Indexlist.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue times (	const Indexlist* const irows,	/**< Index list specifying rows. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									int_t xN,						/**< Number of vectors to multiply. */
-									real_t alpha,					/**< Scalar factor for matrix vector product. */
-									const real_t *x,				/**< Input vector to be multiplied. */
-									int_t xLD,						/**< Leading dimension of input x. */
-									real_t beta,					/**< Scalar factor for y. */
-									real_t *y,						/**< Output vector of results. */
-									int_t yLD,						/**< Leading dimension of output y. */
-									BooleanType yCompr = BT_TRUE	/**< Compressed storage for y. */
-									) const = 0;
-
-		/** Evaluate matrix transpose vector product.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue transTimes (	const Indexlist* const irows,	/**< Index list specifying rows. */
-											const Indexlist* const icols,	/**< Index list specifying columns. */
-											int_t xN,						/**< Number of vectors to multiply. */
-											real_t alpha,					/**< Scalar factor for matrix vector product. */
-											const real_t *x,				/**< Input vector to be multiplied. */
-											int_t xLD,						/**< Leading dimension of input x. */
-											real_t beta,					/**< Scalar factor for y. */
-											real_t *y,						/**< Output vector of results. */
-											int_t yLD						/**< Leading dimension of output y. */
-											) const = 0;
-
-		/** Adds given offset to diagonal of matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_NO_DIAGONAL_AVAILABLE */
-		virtual returnValue addToDiag(	real_t alpha		/**< Diagonal offset. */
-										) = 0;
-
-		/** Allocates and creates dense matrix array in row major format.
-		 *
-		 *  Note: Calling function has to free allocated memory!
-		 *
-		 *  \return Pointer to matrix array. 
-		 */
-		virtual real_t* full() const = 0;
-
-
-		/** Prints matrix to screen.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue print(	const char* name = 0	/** Name of matrix. */
-									) const = 0;
-
-		/** Write matrix to file.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue writeToFile( FILE* output_file, const char* prefix ) const = 0;
-
-		/** Returns whether internal memory needs to be de-allocated.
-		 *	\return BT_TRUE  iff internal memory needs to be de-allocated, \n
-		 			BT_FALSE otherwise */
-		BooleanType needToFreeMemory( ) const { return freeMemory; };
-
-		/** Enables de-allocation of internal memory. */
-		void doFreeMemory( ) { freeMemory = BT_TRUE; };
-
-		/** Disables de-allocation of internal memory. */
-		void doNotFreeMemory( ) { freeMemory = BT_FALSE; };
-
-
-	protected:
-			BooleanType freeMemory;				/**< Indicating whether internal memory needs to be de-allocated. */
-
-};
-
-
-/**
- *	\brief Abstract base class for interfacing matrix-vector operations tailored to symmetric matrices.
- *
- *	Abstract base class for symmetric matrices. Extends Matrix interface with
- *  bilinear form evaluation.
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class SymmetricMatrix : public virtual Matrix
-{
-	public:
-		/** Default constructor. */
-		SymmetricMatrix( ) { };
-
-		/** Destructor. */
-		virtual ~SymmetricMatrix( ) { };
-
-		/** Returns a deep-copy of the SymmetricMatrix object.
-		 *	\return Deep-copy of SymmetricMatrix object */
-		virtual SymmetricMatrix* duplicateSym( ) const = 0;
-
-
-		/** Compute bilinear form y = x'*H*x using submatrix given by index list.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue bilinear(	const Indexlist* const icols,	/**< Index list specifying columns of x. */
-										int_t xN,						/**< Number of vectors to multiply. */
-										const real_t *x,				/**< Input vector to be multiplied (uncompressed). */
-										int_t xLD,						/**< Leading dimension of input x. */
-										real_t *y,						/**< Output vector of results (compressed). */
-										int_t yLD						/**< Leading dimension of output y. */
-										) const = 0;
-
-};
-
-
-/**
- *	\brief Interfaces matrix-vector operations tailored to general dense matrices.
- *
- *	Dense matrix class (row major format).
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class DenseMatrix : public virtual Matrix
-{
-	public:
-		/** Default constructor. */
-		DenseMatrix( ) : nRows(0), nCols(0), leaDim(0), val(0) { };
-
-		/** Constructor from vector of values.
-		 *  Caution: Data pointer must be valid throughout lifetime
-		 */
-		DenseMatrix(	int_t m,		/**< Number of rows. */
-						int_t n,		/**< Number of columns. */
-						int_t lD,		/**< Leading dimension. */
-						real_t *v		/**< Values. */
-						) : nRows(m), nCols(n), leaDim(lD), val(v) {}
-
-
-		/** Destructor. */
-		virtual ~DenseMatrix( );
-
-		/** Frees all internal memory. */
-		virtual void free( );
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix *duplicate( ) const;
-
-		/** Returns i-th diagonal entry.
-		 *	\return i-th diagonal entry */
-		virtual real_t diag(	int_t i			/**< Index. */
-								) const;
-
-		/** Checks whether matrix is square and diagonal.
-		 *	\return BT_TRUE  iff matrix is square and diagonal; \n
-		 *	        BT_FALSE otherwise. */
-		virtual BooleanType isDiag( ) const;
-
-        /** Get the N-norm of the matrix
-         *  \return N-norm of the matrix
-         */
-        virtual real_t getNorm(	int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-								) const;
-		
-        /** Get the N-norm of a row
-         *  \return N-norm of row \a rNum
-         */
-        virtual real_t getRowNorm(	int_t rNum,		/**< Row number. */
-									int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-									) const;
-
-        /** Retrieve indexed entries of matrix row multiplied by alpha.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getRow(	int_t rNum,						/**< Row number. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									real_t alpha,					/**< Scalar factor. */
-									real_t *row						/**< Output row vector. */
-									) const;
-
-		/** Retrieve indexed entries of matrix column multiplied by alpha.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getCol(
-				int_t cNum,						/**< Column number. */
-				const Indexlist* const irows,	/**< Index list specifying rows. */
-				real_t alpha,					/**< Scalar factor. */
-				real_t *col						/**< Output column vector. */
-				) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				int_t irowsLength,				/**< Number of rows. */
-				const int_t* const irowsNumber, /**< Array with row numbers. */
-				int_t icolsLength,				/**< Number of columns. */
-				const int_t* const icolsNumber, /**< Array with column numbers. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-
-		/** Evaluate Y=alpha*A*X + beta*Y.
-		 *  \return SUCCESSFUL_RETURN. */
-		virtual returnValue times(	int_t xN,				/**< Number of vectors to multiply. */
-									real_t alpha,			/**< Scalar factor for matrix vector product. */
-									const real_t *x,		/**< Input vector to be multiplied. */
-									int_t xLD,				/**< Leading dimension of input x. */
-									real_t beta,			/**< Scalar factor for y. */
-									real_t *y,				/**< Output vector of results. */
-									int_t yLD				/**< Leading dimension of output y. */
-									) const;
-
-		/** Evaluate Y=alpha*A'*X + beta*Y.
-		 *  \return SUCCESSFUL_RETURN. */
-		virtual returnValue transTimes(	int_t xN,			/**< Number of vectors to multiply. */
-										real_t alpha,		/**< Scalar factor for matrix vector product. */
-										const real_t *x,	/**< Input vector to be multiplied. */
-										int_t xLD,			/**< Leading dimension of input x. */
-										real_t beta,		/**< Scalar factor for y. */
-										real_t *y,			/**< Output vector of results. */
-										int_t yLD			/**< Leading dimension of output y. */
-										) const;
-
-		/** Evaluate matrix vector product with submatrix given by Indexlist.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue times(	const Indexlist* const irows,	/**< Index list specifying rows. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									int_t xN,						/**< Number of vectors to multiply. */
-									real_t alpha,					/**< Scalar factor for matrix vector product. */
-									const real_t *x,				/**< Input vector to be multiplied. */
-									int_t xLD,						/**< Leading dimension of input x. */
-									real_t beta,					/**< Scalar factor for y. */
-									real_t *y,						/**< Output vector of results. */
-									int_t yLD,						/**< Leading dimension of output y. */
-									BooleanType yCompr = BT_TRUE	/**< Compressed storage for y. */
-									) const;
-
-		/** Evaluate matrix transpose vector product.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue transTimes(	const Indexlist* const irows,	/**< Index list specifying rows. */
-										const Indexlist* const icols,	/**< Index list specifying columns. */
-										int_t xN,						/**< Number of vectors to multiply. */
-										real_t alpha,					/**< Scalar factor for matrix vector product. */
-										const real_t *x,				/**< Input vector to be multiplied. */
-										int_t xLD,						/**< Leading dimension of input x. */
-										real_t beta,					/**< Scalar factor for y. */
-										real_t *y,						/**< Output vector of results. */
-										int_t yLD						/**< Leading dimension of output y. */
-										) const;
-
-		/** Adds given offset to diagonal of matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_NO_DIAGONAL_AVAILABLE */
-		virtual returnValue addToDiag(	real_t alpha		/**< Diagonal offset. */
-										);
-
-
-		/** Allocates and creates dense matrix array in row major format.
-		 *
-		 *  Note: Calling function has to free allocated memory!
-		 *
-		 *  \return Pointer to matrix array. 
-		 */
-		virtual real_t* full() const;
-
-
-		/** Prints matrix to screen.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue print( 	const char* name = 0	/** Name of matrix. */
-									) const;
-
-		/** Write matrix to file.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue writeToFile( FILE* output_file, const char* prefix ) const;
-
-	protected:
-		int_t nRows;		/**< Number of rows. */
-		int_t nCols;		/**< Number of columns. */
-		int_t leaDim;		/**< Leading dimension. */
-		real_t *val;		/**< Vector of entries. */
-};
-
-
-/**
- *	\brief Interfaces matrix-vector operations tailored to symmetric dense matrices.
- *
- *	Symmetric dense matrix class.
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class SymDenseMat : public DenseMatrix, public SymmetricMatrix
-{
-	public:
-		/** Default constructor. */
-		SymDenseMat() : DenseMatrix() { };
-
-		/** Constructor from vector of values. */
-		SymDenseMat(	int_t m,		/**< Number of rows. */
-						int_t n,		/**< Number of columns. */
-						int_t lD,		/**< Leading dimension. */
-						real_t *v		/**< Values. */
-						) : DenseMatrix(m, n, lD, v) { };
-
-		/** Destructor. */
-		virtual ~SymDenseMat() { };
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix *duplicate( ) const;
-
-		/** Returns a deep-copy of the SymmetricMatrix object.
-		 *	\return Deep-copy of SymmetricMatrix object */
-		virtual SymmetricMatrix* duplicateSym( ) const;
-
-
-		/** Compute bilinear form y = x'*H*x using submatrix given by index list.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue bilinear(	const Indexlist* const icols,	/**< Index list specifying columns of x. */
-										int_t xN,						/**< Number of vectors to multiply. */
-										const real_t *x,				/**< Input vector to be multiplied (uncompressed). */
-										int_t xLD,						/**< Leading dimension of input x. */
-										real_t *y,						/**< Output vector of results (compressed). */
-										int_t yLD						/**< Leading dimension of output y. */
-										) const;
-};
-
-
-/**
- *	\brief Interfaces matrix-vector operations tailored to general sparse matrices.
- *
- *	Sparse matrix class (col compressed format).
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class SparseMatrix : public virtual Matrix
-{
-	public:
-		/** Default constructor. */
-		SparseMatrix( );
-
-		/** Constructor with arguments. */
-		SparseMatrix(	int_t nr, 			/**< Number of rows. */
-						int_t nc, 			/**< Number of columns. */
-						sparse_int_t *r, 	/**< Row indices (length). */
-						sparse_int_t *c, 	/**< Indices to first entry of columns (nCols+1). */
-						real_t *v			/**< Vector of entries (length). */
-						);
-
-		/** Constructor from dense matrix. */
-		SparseMatrix(	int_t nr, 				/**< Number of rows. */
-						int_t nc,		 		/**< Number of columns. */
-						int_t ld,				/**< Leading dimension. */
-						const real_t * const v	/**< Row major stored matrix elements. */
-						);
-
-		/** Destructor. */
-		virtual ~SparseMatrix( );
-
-		/** Frees all internal memory. */
-		virtual void free( );
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix *duplicate( ) const;
-
-		/** Returns i-th diagonal entry.
-		 *	\return i-th diagonal entry (or INFTY if diagonal does not exist)*/
-		virtual real_t diag(	int_t i			/**< Index. */
-								) const;
-
-		/** Checks whether matrix is square and diagonal.
-		 *	\return BT_TRUE  iff matrix is square and diagonal; \n
-		 *	        BT_FALSE otherwise. */
-		virtual BooleanType isDiag( ) const;
-
-
-        /** Get the N-norm of the matrix
-         *  \return N-norm of the matrix
-         */
-        virtual real_t getNorm(	int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-								) const;
-
-        /** Get the N-norm of a row
-         *  \return N-norm of row \a rNum
-         */
-        virtual real_t getRowNorm(	int_t rNum,		/**< Row number. */
-									int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-									) const;
-
-		/** Retrieve indexed entries of matrix row multiplied by alpha. */
-		virtual returnValue getRow(	int_t rNum,						/**< Row number. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									real_t alpha,					/**< Scalar factor. */
-									real_t *row						/**< Output row vector. */
-									) const;
-
-		/** Retrieve indexed entries of matrix column multiplied by alpha. */
-		virtual returnValue getCol(	int_t cNum,						/**< Column number. */
-									const Indexlist* const irows,	/**< Index list specifying rows. */
-									real_t alpha,					/**< Scalar factor. */
-									real_t *col						/**< Output column vector. */
-									) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				int_t irowsLength,				/**< Number of rows. */
-				const int_t* const irowsNumber, /**< Array with row numbers. */
-				int_t icolsLength,				/**< Number of columns. */
-				const int_t* const icolsNumber, /**< Array with column numbers. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-		/** Evaluate Y=alpha*A*X + beta*Y. */
-		virtual returnValue times (	int_t xN,				/**< Number of vectors to multiply. */
-									real_t alpha,			/**< Scalar factor for matrix vector product. */
-									const real_t *x,		/**< Input vector to be multiplied. */
-									int_t xLD,				/**< Leading dimension of input x. */
-									real_t beta,			/**< Scalar factor for y. */
-									real_t *y,				/**< Output vector of results. */
-									int_t yLD				/**< Leading dimension of output y. */
-									) const;
-
-		/** Evaluate Y=alpha*A'*X + beta*Y. */
-		virtual returnValue transTimes (	int_t xN,			/**< Number of vectors to multiply. */
-											real_t alpha,		/**< Scalar factor for matrix vector product. */
-											const real_t *x,	/**< Input vector to be multiplied. */
-											int_t xLD,			/**< Leading dimension of input x. */
-											real_t beta,		/**< Scalar factor for y. */
-											real_t *y,			/**< Output vector of results. */
-											int_t yLD			/**< Leading dimension of output y. */
-											) const;
-
-		/** Evaluate matrix vector product with submatrix given by Indexlist. */
-		virtual returnValue times (	const Indexlist* const irows,	/**< Index list specifying rows. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									int_t xN,						/**< Number of vectors to multiply. */
-									real_t alpha,					/**< Scalar factor for matrix vector product. */
-									const real_t *x,				/**< Input vector to be multiplied. */
-									int_t xLD,						/**< Leading dimension of input x. */
-									real_t beta,					/**< Scalar factor for y. */
-									real_t *y,						/**< Output vector of results. */
-									int_t yLD,						/**< Leading dimension of output y. */
-									BooleanType yCompr = BT_TRUE	/**< Compressed storage for y. */
-									) const;
-
-		/** Evaluate matrix transpose vector product. */
-		virtual returnValue transTimes (	const Indexlist* const irows,	/**< Index list specifying rows. */
-											const Indexlist* const icols,	/**< Index list specifying columns. */
-											int_t xN,						/**< Number of vectors to multiply. */
-											real_t alpha,					/**< Scalar factor for matrix vector product. */
-											const real_t *x,				/**< Input vector to be multiplied. */
-											int_t xLD,						/**< Leading dimension of input x. */
-											real_t beta,					/**< Scalar factor for y. */
-											real_t *y,						/**< Output vector of results. */
-											int_t yLD						/**< Leading dimension of output y. */
-											) const;
-
-		/** Adds given offset to diagonal of matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_NO_DIAGONAL_AVAILABLE */
-		virtual returnValue addToDiag(	real_t alpha		/**< Diagonal offset. */
-										);
-
-		/** Create jd field from ir and jc.
-		 *  \return Pointer to jd. */
-		sparse_int_t *createDiagInfo();
-
-		/** Allocates and creates dense matrix array in row major format.
-		 *
-		 *  Note: Calling function has to free allocated memory!
-		 *
-		 *  \return Pointer to matrix array. 
-		 */
-		virtual real_t* full() const;
-
-		/** Prints matrix to screen.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue print( 	const char* name = 0	/** Name of matrix. */
-									) const;
-
-		/** Write matrix to file.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue writeToFile( FILE* output_file, const char* prefix ) const;
-
-
-	protected:
-		int_t nRows;		/**< Number of rows. */
-		int_t nCols;		/**< Number of columns. */
-		sparse_int_t *ir;	/**< Row indices (length). */
-		sparse_int_t *jc;	/**< Indices to first entry of columns (nCols+1). */
-		sparse_int_t *jd;	/**< Indices to first entry of lower triangle (including diagonal) (nCols). */
-		real_t *val;		/**< Vector of entries (length). */
-};
-
-
-/**
- *	\brief Interfaces matrix-vector operations tailored to general sparse matrices.
- *
- *	Sparse matrix class (row compressed format).
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class SparseMatrixRow : public virtual Matrix
-{
-	public:
-		/** Default constructor. */
-		SparseMatrixRow( );
-
-		/** Constructor with arguments. */
-		SparseMatrixRow(	int_t nr, 			/**< Number of rows. */
-							int_t nc, 			/**< Number of columns. */
-							sparse_int_t *r, 	/**< Indices to first entry of rows (nRows+1). */
-							sparse_int_t *c, 	/**< Column indices (length). */
-							real_t *v			/**< Vector of entries (length). */
-							);
-
-		/** Constructor from dense matrix. */
-		SparseMatrixRow(	int_t nr, 				/**< Number of rows. */
-							int_t nc,			 	/**< Number of columns. */
-							int_t ld,				/**< Leading dimension. */
-							const real_t * const v	/**< Row major stored matrix elements. */
-							);
-
-		/** Destructor. */
-		virtual ~SparseMatrixRow( );
-
-		/** Frees all internal memory. */
-		virtual void free( );
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix *duplicate( ) const;
-
-		/** Returns i-th diagonal entry.
-		 *	\return i-th diagonal entry (or INFTY if diagonal does not exist)*/
-		virtual real_t diag(	int_t i			/**< Index. */
-								) const;
-
-		/** Checks whether matrix is square and diagonal.
-		 *	\return BT_TRUE  iff matrix is square and diagonal; \n
-		 *	        BT_FALSE otherwise. */
-		virtual BooleanType isDiag( ) const;
-
-		
-        /** Get the N-norm of the matrix
-         *  \return N-norm of the matrix
-         */
-        virtual real_t getNorm(	int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-								) const;
-
-        /** Get the N-norm of a row
-         *  \return N-norm of row \a rNum
-         */
-        virtual real_t getRowNorm(	int_t rNum,		/**< Row number. */
-									int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-									) const;
-
-		/** Retrieve indexed entries of matrix row multiplied by alpha. */
-		virtual returnValue getRow (	int_t rNum,						/**< Row number. */
-										const Indexlist* const icols,	/**< Index list specifying columns. */
-										real_t alpha,					/**< Scalar factor. */
-										real_t *row						/**< Output row vector. */
-										) const;
-
-		/** Retrieve indexed entries of matrix column multiplied by alpha. */
-		virtual returnValue getCol (	int_t cNum,						/**< Column number. */
-										const Indexlist* const irows,	/**< Index list specifying rows. */
-										real_t alpha,					/**< Scalar factor. */
-										real_t *col						/**< Output column vector. */
-										) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				int_t irowsLength,				/**< Number of rows. */
-				const int_t* const irowsNumber, /**< Array with row numbers. */
-				int_t icolsLength,				/**< Number of columns. */
-				const int_t* const icolsNumber, /**< Array with column numbers. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-		/** Evaluate Y=alpha*A*X + beta*Y. */
-		virtual returnValue times(	int_t xN,				/**< Number of vectors to multiply. */
-									real_t alpha,			/**< Scalar factor for matrix vector product. */
-									const real_t *x,		/**< Input vector to be multiplied. */
-									int_t xLD,				/**< Leading dimension of input x. */
-									real_t beta,			/**< Scalar factor for y. */
-									real_t *y,				/**< Output vector of results. */
-									int_t yLD				/**< Leading dimension of output y. */
-									) const;
-
-		/** Evaluate Y=alpha*A'*X + beta*Y. */
-		virtual returnValue transTimes(	int_t xN,			/**< Number of vectors to multiply. */
-										real_t alpha,		/**< Scalar factor for matrix vector product. */
-										const real_t *x,	/**< Input vector to be multiplied. */
-										int_t xLD,			/**< Leading dimension of input x. */
-										real_t beta,		/**< Scalar factor for y. */
-										real_t *y,			/**< Output vector of results. */
-										int_t yLD			/**< Leading dimension of output y. */
-										) const;
-
-		/** Evaluate matrix vector product with submatrix given by Indexlist. */
-		virtual returnValue times(	const Indexlist* const irows,	/**< Index list specifying rows. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									int_t xN,						/**< Number of vectors to multiply. */
-									real_t alpha,					/**< Scalar factor for matrix vector product. */
-									const real_t *x,				/**< Input vector to be multiplied. */
-									int_t xLD,						/**< Leading dimension of input x. */
-									real_t beta,					/**< Scalar factor for y. */
-									real_t *y,						/**< Output vector of results. */
-									int_t yLD,						/**< Leading dimension of output y. */
-									BooleanType yCompr = BT_TRUE	/**< Compressed storage for y. */
-									) const;
-
-		/** Evaluate matrix transpose vector product. */
-		virtual returnValue transTimes(	const Indexlist* const irows,	/**< Index list specifying rows. */
-										const Indexlist* const icols,	/**< Index list specifying columns. */
-										int_t xN,						/**< Number of vectors to multiply. */
-										real_t alpha,					/**< Scalar factor for matrix vector product. */
-										const real_t *x,				/**< Input vector to be multiplied. */
-										int_t xLD,						/**< Leading dimension of input x. */
-										real_t beta,					/**< Scalar factor for y. */
-										real_t *y,						/**< Output vector of results. */
-										int_t yLD						/**< Leading dimension of output y. */
-										) const;
-
-		/** Adds given offset to diagonal of matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_NO_DIAGONAL_AVAILABLE */
-		virtual returnValue addToDiag(	real_t alpha		/**< Diagonal offset. */
-										);
-
-		/** Create jd field from ir and jc.
-		 *  \return Pointer to jd. */
-		sparse_int_t *createDiagInfo();
-
-		/** Allocates and creates dense matrix array in row major format.
-		 *
-		 *  Note: Calling function has to free allocated memory!
-		 *
-		 *  \return Pointer to matrix array. 
-		 */
-		virtual real_t* full() const;
-
-		/** Prints matrix to screen.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue print( 	const char* name = 0	/** Name of matrix. */
-									) const;
-
-		/** Write matrix to file.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue writeToFile( FILE* output_file, const char* prefix ) const;
-
-	protected:
-		int_t nRows;		/**< Number of rows. */
-		int_t nCols;		/**< Number of columns. */
-		sparse_int_t *jr;	/**< Indices to first entry of row (nRows+1). */
-		sparse_int_t *ic;	/**< Column indices (length). */
-		sparse_int_t *jd;	/**< Indices to first entry of upper triangle (including diagonal) (nRows). */
-		real_t *val;		/**< Vector of entries (length). */
-};
-
-
-/**
- *	\brief Interfaces matrix-vector operations tailored to symmetric sparse matrices.
- *
- *	Symmetric sparse matrix class (column compressed format).
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class SymSparseMat : public SymmetricMatrix, public SparseMatrix
-{
-	public:
-		/** Default constructor. */
-		SymSparseMat( ) : SparseMatrix( ) { };
-
-		/** Constructor with arguments. */
-		SymSparseMat(	int_t nr, 			/**< Number of rows. */
-						int_t nc, 			/**< Number of columns. */
-						sparse_int_t *r, 	/**< Row indices (length). */
-						sparse_int_t *c, 	/**< Indices to first entry of columns (nCols+1). */
-						real_t *v			/**< Vector of entries (length). */
-						) : SparseMatrix(nr, nc, r, c, v) { };
-
-		/** Constructor from dense matrix. */
-		SymSparseMat(	int_t nr, 				/**< Number of rows. */
-						int_t nc,		 		/**< Number of columns. */
-						int_t ld,				/**< Leading dimension. */
-						const real_t * const v	/**< Row major stored matrix elements. */
-						) : SparseMatrix(nr, nc, ld, v) { };
-
-		/** Destructor. */
-		virtual ~SymSparseMat( ) { };
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix *duplicate( ) const;
-
-		/** Returns a deep-copy of the SymmetricMatrix object.
-		 *	\return Deep-copy of SymmetricMatrix object */
-		virtual SymmetricMatrix* duplicateSym( ) const;
-
-
-		/** Compute bilinear form y = x'*H*x using submatrix given by index list.
-		*	\return SUCCESSFUL_RETURN */
-		virtual returnValue bilinear(	const Indexlist* const icols,	/**< Index list specifying columns of x. */
-										int_t xN,						/**< Number of vectors to multiply. */
-										const real_t *x,				/**< Input vector to be multiplied (uncompressed). */
-										int_t xLD,						/**< Leading dimension of input x. */
-										real_t *y,						/**< Output vector of results (compressed). */
-										int_t yLD						/**< Leading dimension of output y. */
-										) const;
-};
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_MATRICES_HPP */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.hpp
deleted file mode 100644
index 8520686..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.hpp
+++ /dev/null
@@ -1,480 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/MessageHandling.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches (thanks to Leonard Wirsching)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the MessageHandling class including global return values.
- */
-
-
-#ifndef QPOASES_MESSAGEHANDLING_HPP
-#define QPOASES_MESSAGEHANDLING_HPP
-
-
-#include <stdio.h>
-#include <string.h>
-
-#ifdef __DEBUG__
-#include <assert.h>
-#endif
-
-#include <qpOASES/Constants.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** Default file to display messages. */
-extern FILE* stdFile;
-
-
-/**
- *	\brief Defines all symbols for global return values.
- *
- *  The enumeration returnValueType defines all symbols for global return values.
- *	Important: All return values are assumed to be nonnegative!
- *
- *	\author Hans Joachim Ferreau
- */
-enum returnValue
-{
-TERMINAL_LIST_ELEMENT = -1,						/**< Terminal list element, internal usage only! */
-/* miscellaneous */
-SUCCESSFUL_RETURN = 0,							/**< Successful return. */
-RET_DIV_BY_ZERO,		   						/**< Division by zero. */
-RET_INDEX_OUT_OF_BOUNDS,						/**< Index out of bounds. */
-RET_INVALID_ARGUMENTS,							/**< At least one of the arguments is invalid. */
-RET_ERROR_UNDEFINED,							/**< Error number undefined. */
-RET_WARNING_UNDEFINED,							/**< Warning number undefined. */
-RET_INFO_UNDEFINED,								/**< Info number undefined. */
-RET_EWI_UNDEFINED,								/**< Error/warning/info number undefined. */
-RET_AVAILABLE_WITH_LINUX_ONLY,					/**< This function is available under Linux only. */
-RET_UNKNOWN_BUG,								/**< The error occurred is not yet known. */
-RET_PRINTLEVEL_CHANGED,							/**< Print level changed. (10) */
-RET_NOT_YET_IMPLEMENTED,						/**< Requested function is not yet implemented in this version of qpOASES. */
-/* Indexlist */
-RET_INDEXLIST_MUST_BE_REORDERD,					/**< Index list has to be reordered. */
-RET_INDEXLIST_EXCEEDS_MAX_LENGTH,				/**< Index list exceeds its maximal physical length. */
-RET_INDEXLIST_CORRUPTED,						/**< Index list corrupted. */
-RET_INDEXLIST_OUTOFBOUNDS,						/**< Physical index is out of bounds. */
-RET_INDEXLIST_ADD_FAILED,						/**< Adding indices from another index set failed. */
-RET_INDEXLIST_INTERSECT_FAILED,					/**< Intersection with another index set failed. */
-/* SubjectTo / Bounds / Constraints */
-RET_INDEX_ALREADY_OF_DESIRED_STATUS,			/**< Index is already of desired status. (18) */
-RET_ADDINDEX_FAILED,							/**< Adding index to index set failed. */
-RET_REMOVEINDEX_FAILED,							/**< Removing index from index set failed. (20) */
-RET_SWAPINDEX_FAILED,							/**< Cannot swap between different indexsets. */
-RET_NOTHING_TO_DO,								/**< Nothing to do. */
-RET_SETUP_BOUND_FAILED,							/**< Setting up bound index failed. */
-RET_SETUP_CONSTRAINT_FAILED,					/**< Setting up constraint index failed. */
-RET_MOVING_BOUND_FAILED,						/**< Moving bound between index sets failed. */
-RET_MOVING_CONSTRAINT_FAILED,					/**< Moving constraint between index sets failed. */
-RET_SHIFTING_FAILED,							/**< Shifting of bounds/constraints failed. */
-RET_ROTATING_FAILED,							/**< Rotating of bounds/constraints failed. */
-/* QProblem */
-RET_QPOBJECT_NOT_SETUP,							/**< The QP object has not been setup correctly, use another constructor. */
-RET_QP_ALREADY_INITIALISED,						/**< QProblem has already been initialised. (30) */
-RET_NO_INIT_WITH_STANDARD_SOLVER,				/**< Initialisation via extern QP solver is not yet implemented. */
-RET_RESET_FAILED,								/**< Reset failed. */
-RET_INIT_FAILED,								/**< Initialisation failed. */
-RET_INIT_FAILED_TQ,								/**< Initialisation failed due to TQ factorisation. */
-RET_INIT_FAILED_CHOLESKY,						/**< Initialisation failed due to Cholesky decomposition. */
-RET_INIT_FAILED_HOTSTART,						/**< Initialisation failed! QP could not be solved! */
-RET_INIT_FAILED_INFEASIBILITY,					/**< Initial QP could not be solved due to infeasibility! */
-RET_INIT_FAILED_UNBOUNDEDNESS,					/**< Initial QP could not be solved due to unboundedness! */
-RET_INIT_FAILED_REGULARISATION,					/**< Initialisation failed as Hessian matrix could not be regularised. */
-RET_INIT_SUCCESSFUL,							/**< Initialisation done. (40) */
-RET_OBTAINING_WORKINGSET_FAILED,				/**< Failed to obtain working set for auxiliary QP. */
-RET_SETUP_WORKINGSET_FAILED,					/**< Failed to setup working set for auxiliary QP. */
-RET_SETUP_AUXILIARYQP_FAILED,					/**< Failed to setup auxiliary QP for initialised homotopy. */
-RET_NO_CHOLESKY_WITH_INITIAL_GUESS,				/**< Externally computed Cholesky factor cannot be combined with an initial guess. */
-RET_NO_EXTERN_SOLVER,							/**< No extern QP solver available. */
-RET_QP_UNBOUNDED,								/**< QP is unbounded. */
-RET_QP_INFEASIBLE,								/**< QP is infeasible. */
-RET_QP_NOT_SOLVED,								/**< Problems occurred while solving QP with standard solver. */
-RET_QP_SOLVED,									/**< QP successfully solved. */
-RET_UNABLE_TO_SOLVE_QP,							/**< Problems occurred while solving QP. (50) */
-RET_INITIALISATION_STARTED,						/**< Starting problem initialisation... */
-RET_HOTSTART_FAILED,							/**< Unable to perform homotopy due to internal error. */
-RET_HOTSTART_FAILED_TO_INIT,					/**< Unable to initialise problem. */
-RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED,		/**< Unable to perform homotopy as previous QP is not solved. */
-RET_ITERATION_STARTED,							/**< Iteration... */
-RET_SHIFT_DETERMINATION_FAILED,					/**< Determination of shift of the QP data failed. */
-RET_STEPDIRECTION_DETERMINATION_FAILED,			/**< Determination of step direction failed. */
-RET_STEPLENGTH_DETERMINATION_FAILED,			/**< Determination of step direction failed. */
-RET_OPTIMAL_SOLUTION_FOUND,						/**< Optimal solution of neighbouring QP found. */
-RET_HOMOTOPY_STEP_FAILED,						/**< Unable to perform homotopy step. (60) */
-RET_HOTSTART_STOPPED_INFEASIBILITY,				/**< Premature homotopy termination because QP is infeasible. */
-RET_HOTSTART_STOPPED_UNBOUNDEDNESS,				/**< Premature homotopy termination because QP is unbounded. */
-RET_WORKINGSET_UPDATE_FAILED,					/**< Unable to update working sets according to initial guesses. */
-RET_MAX_NWSR_REACHED,							/**< Maximum number of working set recalculations performed. */
-RET_CONSTRAINTS_NOT_SPECIFIED,					/**< Problem does comprise constraints! You also have to specify new constraints' bounds. */
-RET_INVALID_FACTORISATION_FLAG,					/**< Invalid factorisation flag. */
-RET_UNABLE_TO_SAVE_QPDATA,						/**< Unable to save QP data. */
-RET_STEPDIRECTION_FAILED_TQ,					/**< Abnormal termination due to TQ factorisation. */
-RET_STEPDIRECTION_FAILED_CHOLESKY,				/**< Abnormal termination due to Cholesky factorisation. */
-RET_CYCLING_DETECTED,							/**< Cycling detected. (70) */
-RET_CYCLING_NOT_RESOLVED,						/**< Cycling cannot be resolved, QP probably infeasible. */
-RET_CYCLING_RESOLVED,							/**< Cycling probably resolved. */
-RET_STEPSIZE,									/**< For displaying performed stepsize. */
-RET_STEPSIZE_NONPOSITIVE,						/**< For displaying non-positive stepsize. */
-RET_SETUPSUBJECTTOTYPE_FAILED,					/**< Setup of SubjectToTypes failed. */
-RET_ADDCONSTRAINT_FAILED,						/**< Addition of constraint to working set failed. */
-RET_ADDCONSTRAINT_FAILED_INFEASIBILITY,			/**< Addition of constraint to working set failed (due to QP infeasibility). */
-RET_ADDBOUND_FAILED,							/**< Addition of bound to working set failed. */
-RET_ADDBOUND_FAILED_INFEASIBILITY,				/**< Addition of bound to working set failed (due to QP infeasibility). */
-RET_REMOVECONSTRAINT_FAILED,					/**< Removal of constraint from working set failed. (80) */
-RET_REMOVEBOUND_FAILED,							/**< Removal of bound from working set failed. */
-RET_REMOVE_FROM_ACTIVESET,						/**< Removing from active set... */
-RET_ADD_TO_ACTIVESET,							/**< Adding to active set... */
-RET_REMOVE_FROM_ACTIVESET_FAILED,				/**< Removing from active set failed. */
-RET_ADD_TO_ACTIVESET_FAILED,					/**< Adding to active set failed. */
-RET_CONSTRAINT_ALREADY_ACTIVE,					/**< Constraint is already active. */
-RET_ALL_CONSTRAINTS_ACTIVE,						/**< All constraints are active, no further constraint can be added. */
-RET_LINEARLY_DEPENDENT,							/**< New bound/constraint is linearly dependent. */
-RET_LINEARLY_INDEPENDENT,						/**< New bound/constraint is linearly independent. */
-RET_LI_RESOLVED,								/**< Linear independence of active constraint matrix successfully resolved. (90) */
-RET_ENSURELI_FAILED,							/**< Failed to ensure linear independence of active constraint matrix. */
-RET_ENSURELI_FAILED_TQ,							/**< Abnormal termination due to TQ factorisation. */
-RET_ENSURELI_FAILED_NOINDEX,					/**< QP is infeasible. */
-RET_ENSURELI_FAILED_CYCLING,					/**< QP is infeasible. */
-RET_BOUND_ALREADY_ACTIVE,						/**< Bound is already active. */
-RET_ALL_BOUNDS_ACTIVE,							/**< All bounds are active, no further bound can be added. */
-RET_CONSTRAINT_NOT_ACTIVE,						/**< Constraint is not active. */
-RET_BOUND_NOT_ACTIVE,							/**< Bound is not active. */
-RET_HESSIAN_NOT_SPD,							/**< Projected Hessian matrix not positive definite. */
-RET_HESSIAN_INDEFINITE,							/**< Hessian matrix is indefinite. (100) */
-RET_MATRIX_SHIFT_FAILED,						/**< Unable to update matrices or to transform vectors. */
-RET_MATRIX_FACTORISATION_FAILED,				/**< Unable to calculate new matrix factorisations. */
-RET_PRINT_ITERATION_FAILED,						/**< Unable to print information on current iteration. */
-RET_NO_GLOBAL_MESSAGE_OUTPUTFILE,				/**< No global message output file initialised. */
-RET_DISABLECONSTRAINTS_FAILED,					/**< Unable to disbable constraints. */
-RET_ENABLECONSTRAINTS_FAILED,					/**< Unable to enbable constraints. */
-RET_ALREADY_ENABLED,							/**< Bound or constraint is already enabled. */
-RET_ALREADY_DISABLED,							/**< Bound or constraint is already disabled. */
-RET_NO_HESSIAN_SPECIFIED, 						/**< No Hessian matrix has been specified. */
-RET_USING_REGULARISATION,						/**< Using regularisation as Hessian matrix is not positive definite. (110) */
-RET_EPS_MUST_BE_POSITVE,						/**< Eps for regularisation must be sufficiently positive. */
-RET_REGSTEPS_MUST_BE_POSITVE, 					/**< Maximum number of regularisation steps must be non-negative. */
-RET_HESSIAN_ALREADY_REGULARISED,				/**< Hessian has been already regularised. */
-RET_CANNOT_REGULARISE_IDENTITY,					/**< Identity Hessian matrix cannot be regularised. */
-RET_CANNOT_REGULARISE_SPARSE,					/**< Sparse matrix cannot be regularised as diagonal entry is missing. */
-RET_NO_REGSTEP_NWSR,							/**< No additional regularisation step could be performed due to limits. */
-RET_FEWER_REGSTEPS_NWSR,						/**< Fewer additional regularisation steps have been performed due to limits. */
-RET_CHOLESKY_OF_ZERO_HESSIAN, 					/**< Cholesky decomposition of (unregularised) zero Hessian matrix. */
-RET_ZERO_HESSIAN_ASSUMED,						/**< Zero Hessian matrix assumed as null pointer passed without specifying hessianType. */
-RET_CONSTRAINTS_ARE_NOT_SCALED, 				/**< (no longer in use) (120) */
-RET_INITIAL_BOUNDS_STATUS_NYI, 					/**< (no longer in use) */
-RET_ERROR_IN_CONSTRAINTPRODUCT,					/**< Error in user-defined constraint product function. */
-RET_FIX_BOUNDS_FOR_LP,							/**< All initial bounds must be fixed when solving an (unregularised) LP. */
-RET_USE_REGULARISATION_FOR_LP,					/**< Set options.enableRegularisation=BT_TRUE for solving LPs. */
-/* SQProblem */
-RET_UPDATEMATRICES_FAILED,						/**< Unable to update QP matrices. */
-RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED,		/**< Unable to update matrices as previous QP is not solved. */
-/* Utils */
-RET_UNABLE_TO_OPEN_FILE,						/**< Unable to open file. */
-RET_UNABLE_TO_WRITE_FILE,						/**< Unable to write into file. */
-RET_UNABLE_TO_READ_FILE,						/**< Unable to read from file. */
-RET_FILEDATA_INCONSISTENT,						/**< File contains inconsistent data. (130) */
-/* Options */
-RET_OPTIONS_ADJUSTED,							/**< Options needed to be adjusted for consistency reasons. */
-/* SolutionAnalysis */
-RET_UNABLE_TO_ANALYSE_QPROBLEM, 				/**< Unable to analyse (S)QProblem(B) object. */
-/* Benchmark */
-RET_NWSR_SET_TO_ONE,							/**< Maximum number of working set changes was set to 1. */
-RET_UNABLE_TO_READ_BENCHMARK,					/**< Unable to read benchmark data. */
-RET_BENCHMARK_ABORTED,							/**< Benchmark aborted. */
-RET_INITIAL_QP_SOLVED,							/**< Initial QP solved. */
-RET_QP_SOLUTION_STARTED,						/**< Solving QP... */
-RET_BENCHMARK_SUCCESSFUL,						/**< Benchmark terminated successfully. */
-/* Sparse matrices */
-RET_NO_DIAGONAL_AVAILABLE,						/**< Sparse matrix does not have entries on full diagonal. */
-RET_DIAGONAL_NOT_INITIALISED,					/**< Diagonal data of sparse matrix has not been initialised. (140) */
-/* Dropping of infeasible constraints */
-RET_ENSURELI_DROPPED,							/**< Linear independence resolved by dropping blocking constraint. */
-/* Schur complement computations */
-RET_KKT_MATRIX_SINGULAR,						/**< KKT matrix is singular. */
-RET_QR_FACTORISATION_FAILED,					/**< QR factorization of Schur complement failed. */
-RET_INERTIA_CORRECTION_FAILED,					/**< Inertia correction failed after KKT matrix had too many negative eigenvalues. */
-RET_NO_SPARSE_SOLVER,							/**< No factorization routine for the KKT matrix installed. */
-/* Simple exitflags */
-RET_SIMPLE_STATUS_P1,							/**< QP problem could not be solved within given number of iterations. */
-RET_SIMPLE_STATUS_P0,							/**< QP problem solved. */
-RET_SIMPLE_STATUS_M1,							/**< QP problem could not be solved due to an internal error. */
-RET_SIMPLE_STATUS_M2,							/**< QP problem is infeasible (and thus could not be solved). */
-RET_SIMPLE_STATUS_M3							/**< QP problem is unbounded (and thus could not be solved). (150) */
-};
-
-
-/**
- *	\brief Handles all kind of error messages, warnings and other information.
- *
- *	This class handles all kinds of messages (errors, warnings, infos) initiated
- *  by qpOASES modules and stores the corresponding global preferences.
- *
- *	\author Hans Joachim Ferreau (thanks to Leonard Wirsching)
- *	\version 3.2
- *	\date 2007-2015
- */
-class MessageHandling
-{
-	/*
-	 *	INTERNAL DATA STRUCTURES
-	 */
-	public:
-		/**
-		*	\brief Data structure for entries in global message list.
-		*
-		*	Data structure for entries in global message list.
-		*
-		*	\author Hans Joachim Ferreau
-		*/
-		typedef struct {
-			returnValue key;							/**< Global return value. */
-			const char* data;							/**< Corresponding message. */
-			VisibilityStatus globalVisibilityStatus; 	/**< Determines if message can be printed.
-														* 	 If this value is set to VS_HIDDEN, no message is printed! */
-		} ReturnValueList;
-
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		MessageHandling( );
-
-		/** Constructor which takes the desired output file. */
-		MessageHandling(  FILE* _outputFile						/**< Output file. */
-						  );
-
-		/** Constructor which takes the desired visibility states. */
-		MessageHandling(	VisibilityStatus _errorVisibility,	/**< Visibility status for error messages. */
-							VisibilityStatus _warningVisibility,/**< Visibility status for warning messages. */
-							VisibilityStatus _infoVisibility	/**< Visibility status for info messages. */
-							);
-
-		/** Constructor which takes the desired output file and desired visibility states. */
-		MessageHandling(	FILE* _outputFile,					/**< Output file. */
-							VisibilityStatus _errorVisibility,	/**< Visibility status for error messages. */
-							VisibilityStatus _warningVisibility,/**< Visibility status for warning messages. */
-							VisibilityStatus _infoVisibility	/**< Visibility status for info messages. */
-							);
-
-		/** Copy constructor (deep copy). */
-		MessageHandling(	const MessageHandling& rhs	/**< Rhs object. */
-							);
-
-		/** Destructor. */
-		~MessageHandling( );
-
-		/** Assignment operator (deep copy). */
-		MessageHandling& operator=(	const MessageHandling& rhs	/**< Rhs object. */
-									);
-
-
-		/** Prints an error message(a simplified macro THROWERROR is also provided). \n
-		 *  Errors are defined as abnormal events which cause an immediate termination of the current (sub) function.
-		 *  Errors of a sub function should be commented by the calling function by means of a warning message
-		 *  (if this error does not cause an error of the calling function, either)!
-		 *  \return Error number returned by sub function call
-		 */
-		returnValue throwError(	returnValue Enumber,					/**< Error number returned by sub function call. */
-								const char* additionaltext,				/**< Additional error text (0, if none). */
-								const char* functionname,				/**< Name of function which caused the error. */
-								const char* filename,					/**< Name of file which caused the error. */
-								const unsigned long linenumber,			/**< Number of line which caused the error.incompatible binary file */
-								VisibilityStatus localVisibilityStatus	/**< Determines (locally) if error message can be printed to stdFile.
-																	*   If GLOBAL visibility status of the message is set to VS_HIDDEN,
-																	*   no message is printed, anyway! */
-								);
-
-		/** Prints a warning message (a simplified macro THROWWARNING is also provided).
-		 *  Warnings are definied as abnormal events which does NOT cause an immediate termination of the current (sub) function.
-		 *  \return Warning number returned by sub function call
-		 */
-		returnValue throwWarning(	returnValue Wnumber,	 				/**< Warning number returned by sub function call. */
-									const char* additionaltext,				/**< Additional warning text (0, if none). */
-									const char* functionname,				/**< Name of function which caused the warning. */
-									const char* filename,   				/**< Name of file which caused the warning. */
-									const unsigned long linenumber,	 		/**< Number of line which caused the warning. */
-									VisibilityStatus localVisibilityStatus	/**< Determines (locally) if warning message can be printed to stdFile.
-																			*   If GLOBAL visibility status of the message is set to VS_HIDDEN,
-																			*   no message is printed, anyway! */
-									);
-
-	   /** Prints a info message (a simplified macro THROWINFO is also provided).
-		 *  \return Info number returned by sub function call
-		 */
-		returnValue throwInfo(	returnValue Inumber,	 				/**< Info number returned by sub function call. */
-								const char* additionaltext,	 			/**< Additional warning text (0, if none). */
-								const char* functionname,				/**< Name of function which submitted the info. */
-								const char* filename,   				/**< Name of file which submitted the info. */
-								const unsigned long linenumber,			/**< Number of line which submitted the info. */
-								VisibilityStatus localVisibilityStatus	/**< Determines (locally) if info message can be printed to stdFile.
-																		*   If GLOBAL visibility status of the message is set to VS_HIDDEN,
-																		*   no message is printed, anyway! */
-								);
-
-
-		/** Resets all preferences to default values.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue reset( );
-
-
-		/** Prints a complete list of all messages to output file.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue listAllMessages( );
-
-
-		/** Returns visibility status for error messages.
-		 *	\return Visibility status for error messages. */
-		inline VisibilityStatus getErrorVisibilityStatus( ) const;
-
-		/** Returns visibility status for warning messages.
-		 *	\return Visibility status for warning messages. */
-		inline VisibilityStatus getWarningVisibilityStatus( ) const;
-
-		/** Returns visibility status for info messages.
-		 *	\return Visibility status for info messages. */
-		inline VisibilityStatus getInfoVisibilityStatus( ) const;
-
-		/** Returns pointer to output file.
-		 *	\return Pointer to output file. */
-		inline FILE* getOutputFile( ) const;
-
-		/** Returns error count value.
-		 *	\return Error count value. */
-		inline int_t getErrorCount( ) const;
-
-
-		/** Changes visibility status for error messages. */
-		inline void setErrorVisibilityStatus(	VisibilityStatus _errorVisibility	/**< New visibility status for error messages. */
-												);
-
-		/** Changes visibility status for warning messages. */
-		inline void setWarningVisibilityStatus(	VisibilityStatus _warningVisibility	/**< New visibility status for warning messages. */
-												);
-
-		/** Changes visibility status for info messages. */
-		inline void setInfoVisibilityStatus(	VisibilityStatus _infoVisibility	/**< New visibility status for info messages. */
-												);
-
-		/** Changes output file for messages. */
-		inline void setOutputFile(	FILE* _outputFile	/**< New output file for messages. */
-									);
-
-		/** Changes error count.
-		 * \return SUCCESSFUL_RETURN \n
-		 *		   RET_INVALID_ARGUMENT */
-		inline returnValue setErrorCount(	int_t _errorCount	/**< New error count value. */
-											);
-
-		/** Provides message text corresponding to given \a returnValue.
-		 * \return String containing message text. */
-		static const char* getErrorCodeMessage(	const returnValue _returnValue
-												);
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Prints a info message to stdFile (auxiliary function).
-		 *  \return Error/warning/info number returned by sub function call
-		 */
-		returnValue throwMessage(
-			returnValue RETnumber,	 				/**< Error/warning/info number returned by sub function call. */
-			const char* additionaltext,				/**< Additional warning text (0, if none). */
-			const char* functionname,				/**< Name of function which caused the error/warning/info. */
-			const char* filename,   				/**< Name of file which caused the error/warning/info. */
-			const unsigned long linenumber,			/**< Number of line which caused the error/warning/info. */
-			VisibilityStatus localVisibilityStatus,	/**< Determines (locally) if info message can be printed to stdFile.
-					  								 *   If GLOBAL visibility status of the message is set to VS_HIDDEN,
-				   									 *   no message is printed, anyway! */
-			const char* RETstring					/**< Leading string of error/warning/info message. */
-			);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		VisibilityStatus errorVisibility;		/**< Error messages visible? */
-		VisibilityStatus warningVisibility;		/**< Warning messages visible? */
-		VisibilityStatus infoVisibility;		/**< Info messages visible? */
-
-		FILE* outputFile;						/**< Output file for messages. */
-
-		int_t errorCount; 						/**< Counts number of errors (for nicer output only). */
-};
-
-
-#ifndef __FILE__
-  /** Ensures that __FILE__ macro is defined. */
-  #define __FILE__ 0
-#endif
-
-#ifndef __LINE__
-  /** Ensures that __LINE__ macro is defined. */
-  #define __LINE__ 0
-#endif
-
-/** Define __FUNC__ macro providing current function for debugging. */
-/*#define __FUNC__ 0*/
-#define __FUNC__ ("(no function name provided)")
-/*#define __FUNC__ __func__*/
-/*#define __FUNC__ __FUNCTION__*/
-
-
-/** Short version of throwError with default values, only returnValue is needed */
-#define THROWERROR(retval) ( getGlobalMessageHandler( )->throwError((retval),0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE) )
-
-/** Short version of throwWarning with default values, only returnValue is needed */
-#define THROWWARNING(retval) ( getGlobalMessageHandler( )->throwWarning((retval),0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE) )
-
-/** Short version of throwInfo with default values, only returnValue is needed */
-#define THROWINFO(retval) ( getGlobalMessageHandler( )->throwInfo((retval),0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE) )
-
-
-/** Returns a pointer to global message handler.
- *  \return Pointer to global message handler.
- */
-MessageHandling* getGlobalMessageHandler( );
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/MessageHandling.ipp>
-
-#endif /* QPOASES_MESSAGEHANDLING_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.ipp
deleted file mode 100644
index 4ae9629..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.ipp
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/MessageHandling.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the MessageHandling class.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	g e t E r r o r V i s i b i l i t y S t a t u s
- */
-inline VisibilityStatus MessageHandling::getErrorVisibilityStatus( ) const
-{
- 	return errorVisibility;
-}
-
-
-/*
- *	g e t W a r n i n g V i s i b i l i t y S t a t u s
- */
-inline VisibilityStatus MessageHandling::getWarningVisibilityStatus( ) const
-{
- 	return warningVisibility;
-}
-
-
-/*
- *	g e t I n f o V i s i b i l i t y S t a t u s
- */
-inline VisibilityStatus MessageHandling::getInfoVisibilityStatus( ) const
-{
- 	return infoVisibility;
-}
-
-
-/*
- *	g e t O u t p u t F i l e
- */
-inline FILE* MessageHandling::getOutputFile( ) const
-{
- 	return outputFile;
-}
-
-
-/*
- *	g e t E r r o r C o u n t
- */
-inline int_t MessageHandling::getErrorCount( ) const
-{
- 	return errorCount;
-}
-
-
-/*
- *	s e t E r r o r V i s i b i l i t y S t a t u s
- */
-inline void MessageHandling::setErrorVisibilityStatus( VisibilityStatus _errorVisibility )
-{
- 	errorVisibility = _errorVisibility;
-}
-
-
-/*
- *	s e t W a r n i n g V i s i b i l i t y S t a t u s
- */
-inline void MessageHandling::setWarningVisibilityStatus( VisibilityStatus _warningVisibility )
-{
- 	warningVisibility = _warningVisibility;
-}
-
-
-/*
- *	s e t I n f o V i s i b i l i t y S t a t u s
- */
-inline void MessageHandling::setInfoVisibilityStatus( VisibilityStatus _infoVisibility )
-{
- 	infoVisibility = _infoVisibility;
-}
-
-
-/*
- *	s e t O u t p u t F i l e
- */
-inline void MessageHandling::setOutputFile( FILE* _outputFile )
-{
- 	outputFile = _outputFile;
-}
-
-
-/*
- *	s e t E r r o r C o u n t
- */
-inline returnValue MessageHandling::setErrorCount( int_t _errorCount )
-{
-	if ( _errorCount >= -1 )
-	{
-		errorCount = _errorCount;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-		return RET_INVALID_ARGUMENTS;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Options.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Options.hpp
deleted file mode 100644
index 6a1ec01..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Options.hpp
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Options.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the Options class designed to manage user-specified
- *	options for solving a QProblem.
- */
-
-
-#ifndef QPOASES_OPTIONS_HPP
-#define QPOASES_OPTIONS_HPP
-
-
-#include <qpOASES/Utils.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Manages all user-specified options for solving QPs.
- *
- *	This class manages all user-specified options used for solving
- *	quadratic programs.
- *
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-class Options
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Options( );
-
-		/** Copy constructor (deep copy). */
-		Options(	const Options& rhs			/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		~Options( );
-
-		/** Assignment operator (deep copy). */
-		Options& operator=(	const Options& rhs	/**< Rhs object. */
-							);
-
-
-		/** Sets all options to default values.
- 		 *	\return SUCCESSFUL_RETURN */
-		returnValue setToDefault( );
-
-		/** Sets all options to values resulting in maximum reliabilty.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue setToReliable( );
-
-		/** Sets all options to values resulting in minimum solution time.
- 		 *	\return SUCCESSFUL_RETURN */
-		returnValue setToMPC( );
-
-		/** Same as setToMPC( ), for ensuring backwards compatibility.
- 		 *	\return SUCCESSFUL_RETURN */
-		returnValue setToFast( );
-
-
-		/** Ensures that all options have consistent values by automatically
-		 *	adjusting inconsistent ones.
-		 *	Note: This routine cannot (and does not try to) ensure that values
-		 *	      are set to reasonable values that make the QP solution work!
-		 *	\return SUCCESSFUL_RETURN \n
-		 *          RET_OPTIONS_ADJUSTED */
-		returnValue ensureConsistency( );
-
-
-		/** Prints values of all options.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue print( ) const;
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Options& rhs	/**< Rhs object. */
-							);
-
-	/*
-	 *	PUBLIC MEMBER VARIABLES
-	 */
-	public:
-		PrintLevel printLevel;					/**< Print level. */
-
-		BooleanType enableRamping;				/**< Specifies whether ramping shall be enabled or not. */
-		BooleanType enableFarBounds;			/**< Specifies whether far bounds shall be used or not. */
-		BooleanType enableFlippingBounds;		/**< Specifies whether flipping bounds shall be used or not. */
-		BooleanType enableRegularisation;		/**< Specifies whether Hessian matrix shall be regularised in case semi-definiteness is detected. */
-		BooleanType enableFullLITests;			/**< Specifies whether condition-hardened LI test shall be used or not. */
-		BooleanType enableNZCTests;				/**< Specifies whether nonzero curvature tests shall be used. */
-		int_t enableDriftCorrection;			/**< Specifies the frequency of drift corrections (0 = off). */
-		int_t enableCholeskyRefactorisation;	/**< Specifies the frequency of full refactorisation of proj. Hessian (otherwise updates). */
-		BooleanType enableEqualities;			/**< Specifies whether equalities shall be always treated as active constraints. */
-
-		real_t terminationTolerance;			/**< Termination tolerance. */
-		real_t boundTolerance;					/**< Lower/upper (constraints') bound tolerance (an inequality constraint whose lower and
-													 upper bounds differ by less is regarded to be an equality constraint). */
-		real_t boundRelaxation;					/**< Offset for relaxing (constraints') bounds at beginning of an initial homotopy. It is also as initial value for far bounds. */
-		real_t epsNum;							/**< Numerator tolerance for ratio tests. */
-		real_t epsDen;							/**< Denominator tolerance for ratio tests. */
-		real_t maxPrimalJump;					/**< Maximum allowed jump in primal variables in nonzero curvature tests. */
-		real_t maxDualJump;						/**< Maximum allowed jump in dual variables in linear independence tests. */
-
-		real_t initialRamping;					/**< Start value for Ramping Strategy. */
-		real_t finalRamping;					/**< Final value for Ramping Strategy. */
-		real_t initialFarBounds;				/**< Initial size of Far Bounds. */
-		real_t growFarBounds;					/**< Factor to grow Far Bounds. */
-		SubjectToStatus initialStatusBounds;	/**< Initial status of bounds at first iteration. */
-		real_t epsFlipping;						/**< Tolerance of squared Cholesky diagonal factor which triggers flipping bound. */
-		int_t numRegularisationSteps;			/**< Maximum number of successive regularisation steps. */
-		real_t epsRegularisation;				/**< Scaling factor of identity matrix used for Hessian regularisation. */
-		int_t numRefinementSteps;				/**< Maximum number of iterative refinement steps. */
-		real_t epsIterRef;						/**< Early termination tolerance for iterative refinement. */
-		real_t epsLITests;						/**< Tolerance for linear independence tests. */
-		real_t epsNZCTests;						/**< Tolerance for nonzero curvature tests. */
-
-		real_t rcondSMin;						/**< Minimum reciprocal condition number of S before refactorization is triggered */
-		BooleanType enableInertiaCorrection;	/**< Specifies whether the working set should be repaired when negative curvature is discovered during hotstart. */
-
-		BooleanType enableDropInfeasibles;		/**< ... */
-		int_t dropBoundPriority;				/**< ... */
-        int_t dropEqConPriority;				/**< ... */
-        int_t dropIneqConPriority;				/**< ... */
-};
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_OPTIONS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.hpp
deleted file mode 100644
index a142151..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.hpp
+++ /dev/null
@@ -1,1079 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/QProblem.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the QProblem class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming.
- */
-
-
-
-#ifndef QPOASES_QPROBLEM_HPP
-#define QPOASES_QPROBLEM_HPP
-
-
-#include <qpOASES/QProblemB.hpp>
-#include <qpOASES/Constraints.hpp>
-#include <qpOASES/ConstraintProduct.hpp>
-#include <qpOASES/Matrices.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Implements the online active set strategy for QPs with general constraints.
- *
- *	A class for setting up and solving quadratic programs. The main feature is
- *	the possibily to use the newly developed online active set strategy for
- * 	parametric quadratic programming.
- *
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-class QProblem : public QProblemB
-{
-	/* allow SolutionAnalysis class to access private members */
-	friend class SolutionAnalysis;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		QProblem( );
-
-		/** Constructor which takes the QP dimension and Hessian type
-		 *  information. If the Hessian is the zero (i.e. HST_ZERO) or the
-		 *  identity matrix (i.e. HST_IDENTITY), respectively, no memory
-		 *  is allocated for it and a NULL pointer can be passed for it
-		 *  to the init() functions. */
-		QProblem(	int_t _nV,	  							/**< Number of variables. */
-					int_t _nC,		  						/**< Number of constraints. */
-					HessianType _hessianType = HST_UNKNOWN	/**< Type of Hessian matrix. */
-					);
-
-		/** Copy constructor (deep copy). */
-		QProblem(	const QProblem& rhs		/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~QProblem( );
-
-		/** Assignment operator (deep copy). */
-		virtual QProblem& operator=(	const QProblem& rhs	/**< Rhs object. */
-								);
-
-
-		/** Clears all data structures of QProblemB except for QP data.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_RESET_FAILED */
-		virtual returnValue reset( );
-
-
-		/** Initialises a QP problem with given QP data and tries to solve it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0    : starts with xOpt = 0, yOpt = 0 and gB/gC empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0    : starts with xOpt, yOpt = 0 and obtain gB/gC by "clipping", \n
-		 *	3. 0,    yOpt, 0    : starts with xOpt = 0, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	4. 0,    0,    gB/gC: starts with xOpt = 0, yOpt = 0 and gB/gC, \n
-		 *	5. xOpt, yOpt, 0    : starts with xOpt, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB/gC: starts with xOpt, yOpt = 0 and gB/gC, \n
-		 *	7. xOpt, yOpt, gB/gC: starts with xOpt, yOpt and gB/gC (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		  *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_TQ \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue init(	SymmetricMatrix *_H,							/**< Hessian matrix (a shallow copy is made). */
-							const real_t* const _g, 						/**< Gradient vector. */
-							Matrix *_A,  									/**< Constraint matrix (a shallow copy is made). */
-							const real_t* const _lb,						/**< Lower bound vector (on variables). \n
-																				 If no lower bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ub,						/**< Upper bound vector (on variables). \n
-																				 If no upper bounds exist, a NULL pointer can be passed. */
-							const real_t* const _lbA,						/**< Lower constraints' bound vector. \n
-																				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ubA,						/**< Upper constraints' bound vector. \n
-																				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR,									/**< Input: Maximum number of working set recalculations when using initial homotopy.
-																				 Output: Number of performed working set recalculations. */
-							real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																				 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,					/**< Optimal primal solution vector. \n
-																				 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,					/**< Optimal dual solution vector. \n
-																				 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const Constraints* const guessedConstraints = 0,/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all constraints are assumed inactive!) */
-							const real_t* const _R = 0						/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix.
-																			 	 The Cholesky factor must be stored in a real_t array of size nV*nV
-																				 in row-major format. Note: Only used if xOpt/yOpt and gB are NULL! \n
-																				 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-
-		/** Initialises a QP problem with given QP data and tries to solve it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0    : starts with xOpt = 0, yOpt = 0 and gB/gC empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0    : starts with xOpt, yOpt = 0 and obtain gB/gC by "clipping", \n
-		 *	3. 0,    yOpt, 0    : starts with xOpt = 0, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	4. 0,    0,    gB/gC: starts with xOpt = 0, yOpt = 0 and gB/gC, \n
-		 *	5. xOpt, yOpt, 0    : starts with xOpt, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB/gC: starts with xOpt, yOpt = 0 and gB/gC, \n
-		 *	7. xOpt, yOpt, gB/gC: starts with xOpt, yOpt and gB/gC (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_TQ \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue init(	const real_t* const _H,							/**< Hessian matrix (a shallow copy is made). \n
-																				 If Hessian matrix is trivial, a NULL pointer can be passed. */
-							const real_t* const _g,							/**< Gradient vector. */
-							const real_t* const _A,							/**< Constraint matrix (a shallow copy is made). */
-							const real_t* const _lb,						/**< Lower bound vector (on variables). \n
-																				 If no lower bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ub,						/**< Upper bound vector (on variables). \n
-																				 If no upper bounds exist, a NULL pointer can be passed. */
-							const real_t* const _lbA,						/**< Lower constraints' bound vector. \n
-																				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ubA,						/**< Upper constraints' bound vector. \n
-																				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR,									/**< Input: Maximum number of working set recalculations when using initial homotopy.
-																				 Output: Number of performed working set recalculations. */
-							real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																				 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,					/**< Optimal primal solution vector. \n
-																				 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,					/**< Optimal dual solution vector. \n
-																				 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const Constraints* const guessedConstraints = 0,/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all constraints are assumed inactive!) */
-							const real_t* const _R = 0						/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix.
-																			 	 The Cholesky factor must be stored in a real_t array of size nV*nV
-																				 in row-major format. Note: Only used if xOpt/yOpt and gB are NULL! \n
-																				 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-		/** Initialises a QP problem with given data to be read from files and solves it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0    : starts with xOpt = 0, yOpt = 0 and gB/gC empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0    : starts with xOpt, yOpt = 0 and obtain gB/gC by "clipping", \n
-		 *	3. 0,    yOpt, 0    : starts with xOpt = 0, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	4. 0,    0,    gB/gC: starts with xOpt = 0, yOpt = 0 and gB/gC, \n
-		 *	5. xOpt, yOpt, 0    : starts with xOpt, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB/gC: starts with xOpt, yOpt = 0 and gB/gC, \n
-		 *	7. xOpt, yOpt, gB/gC: starts with xOpt, yOpt and gB/gC (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_TQ \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue init(	const char* const H_file,						/**< Name of file where Hessian matrix is stored. \n
-																				 If Hessian matrix is trivial, a NULL pointer can be passed. */
-							const char* const g_file,						/**< Name of file where gradient vector is stored. */
-							const char* const A_file,						/**< Name of file where constraint matrix is stored. */
-							const char* const lb_file,						/**< Name of file where lower bound vector. \n
-																				 If no lower bounds exist, a NULL pointer can be passed. */
-							const char* const ub_file,						/**< Name of file where upper bound vector. \n
-																				 If no upper bounds exist, a NULL pointer can be passed. */
-							const char* const lbA_file,						/**< Name of file where lower constraints' bound vector. \n
-																				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-							const char* const ubA_file,						/**< Name of file where upper constraints' bound vector. \n
-																				 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR,									/**< Input: Maximum number of working set recalculations when using initial homotopy.
-																				 Output: Number of performed working set recalculations. */
-							real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																				 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,					/**< Optimal primal solution vector. \n
-																				 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,					/**< Optimal dual solution vector. \n
-																				 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const Constraints* const guessedConstraints = 0,/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all constraints are assumed inactive!) */
-							const char* const R_file = 0					/**< Name of the file where a pre-computed (upper triangular) Cholesky factor
-																			 	 of the Hessian matrix is stored. \n
-																				 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-
-		/** Solves an initialised QP sequence using the online active set strategy.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This function internally calls solveQP/solveRegularisedQP
-		 *        for solving an initialised QP!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue hotstart(	const real_t* const g_new,						/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const lb_new,						/**< Lower bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,						/**< Upper bounds of neighbouring QP to be solved. \n
-													 							 	 If no upper bounds exist, a NULL pointer can be passed. */
-								const real_t* const lbA_new,					/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const real_t* const ubA_new,					/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-													 							 	 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,									/**< Input: Maximum number of working set recalculations; \n
-																			 		 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																				 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-		/** Solves an initialised QP sequence using the online active set strategy,
-		 *  where QP data is read from files.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This function internally calls solveQP/solveRegularisedQP
-		 *        for solving an initialised QP!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue hotstart(	const char* const g_file,						/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-								const char* const lb_file,					 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower bounds exist, a NULL pointer can be passed. */
-								const char* const ub_file,						/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper bounds exist, a NULL pointer can be passed. */
-								const char* const lbA_file,						/**< Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const char* const ubA_file,						/**< Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR, 									/**< Input: Maximum number of working set recalculations; \n
-																					 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																				 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-
-        /** Solves an equality-constrained QP problem resulting from the current working set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_STEPDIRECTION_FAILED_TQ \n
-		 *			RET_STEPDIRECTION_FAILED_CHOLESKY \n
-		 *			RET_INVALID_ARGUMENTS */
-        returnValue solveCurrentEQP (	const int_t n_rhs,			/**< Number of consecutive right hand sides */
-										const real_t* g_in,			/**< Gradient of neighbouring QP to be solved. */
-										const real_t* lb_in,		/**< Lower bounds of neighbouring QP to be solved. \n
-																		 If no lower bounds exist, a NULL pointer can be passed. */
-										const real_t* ub_in,		/**< Upper bounds of neighbouring QP to be solved. \n
-																		 If no upper bounds exist, a NULL pointer can be passed. */
-										const real_t* lbA_in,		/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-																		 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-										const real_t* ubA_in,		/**< Upper constraints' bounds of neighbouring QP to be solved. \n */
-										real_t* x_out,				/**< Output: Primal solution */
-										real_t* y_out				/**< Output: Dual solution */
-										);
-
-		/** Writes a vector with the state of the working set
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSet(	real_t* workingSet		/** Output: array containing state of the working set. */
-											);
-
-		/** Writes a vector with the state of the working set of bounds
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSetBounds(	real_t* workingSetB		/** Output: array containing state of the working set of bounds. */
-													);
-
-		/** Writes a vector with the state of the working set of constraints
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSetConstraints(	real_t* workingSetC	/** Output: array containing state of the working set of constraints. */
-														);
-
-
-		/** Returns current constraints object of the QP (deep copy).
-		  *	\return SUCCESSFUL_RETURN \n
-		  			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue getConstraints(	Constraints& _constraints	/** Output: Constraints object. */
-											) const;
-
-
-		/** Returns the number of constraints.
-		 *	\return Number of constraints. */
-		inline int_t getNC( ) const;
-
-		/** Returns the number of (implicitly defined) equality constraints.
-		 *	\return Number of (implicitly defined) equality constraints. */
-		inline int_t getNEC( ) const;
-
-		/** Returns the number of active constraints.
-		 *	\return Number of active constraints. */
-		inline int_t getNAC( ) const;
-
-		/** Returns the number of inactive constraints.
-		 *	\return Number of inactive constraints. */
-		inline int_t getNIAC( ) const;
-
-		/** Returns the dimension of null space.
-		 *	\return Dimension of null space. */
-		virtual int_t getNZ( ) const;
-
-
-		/** Returns the dual solution vector (deep copy).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_QP_NOT_SOLVED */
-		virtual returnValue getDualSolution(	real_t* const yOpt	/**< Output: Dual solution vector (if QP has been solved). */
-												) const;
-
-
-		/** Defines user-defined routine for calculating the constraint product A*x
-		 *	\return  SUCCESSFUL_RETURN \n */
-		returnValue setConstraintProduct(	ConstraintProduct* const _constraintProduct
-											);
-
-
-		/** Prints concise list of properties of the current QP.
-		 *	\return  SUCCESSFUL_RETURN \n */
-		virtual returnValue printProperties( );
-
-		/** Set the incoming array to true for each variable entry that is
-			in the set of free variables */
-		returnValue getFreeVariablesFlags( BooleanType* varIsFree );
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const QProblem& rhs	/**< Rhs object. */
-							);
-
-		/** Solves a QProblem whose QP data is assumed to be stored in the member variables.
-		 *  A guess for its primal/dual optimal solution vectors and the corresponding
-		 *  working sets of bounds and constraints can be provided.
-		 *  Note: This function is internally called by all init functions!
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_TQ \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED */
-		returnValue solveInitialQP(	const real_t* const xOpt,						/**< Optimal primal solution vector.*/
-									const real_t* const yOpt,						/**< Optimal dual solution vector. */
-									const Bounds* const guessedBounds,				/**< Optimal working set of bounds for solution (xOpt,yOpt). */
-									const Constraints* const guessedConstraints,	/**< Optimal working set of constraints for solution (xOpt,yOpt). */
-									const real_t* const _R,							/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix. */
-									int_t& nWSR, 									/**< Input: Maximum number of working set recalculations; \n
-																 						 Output: Number of performed working set recalculations. */
-									real_t* const cputime							/**< Input: Maximum CPU time allowed for QP solution. \n
-																			 			 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-									);
-
-		/** Solves QProblem using online active set strategy.
-		 *  Note: This function is internally called by all hotstart functions!
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue solveQP(	const real_t* const g_new,			/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const lb_new,			/**< Lower bounds of neighbouring QP to be solved. \n
-													 			 		 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,			/**< Upper bounds of neighbouring QP to be solved. \n
-													 				 	 If no upper bounds exist, a NULL pointer can be passed. */
-								const real_t* const lbA_new,		/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-													 			 		 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const real_t* const ubA_new,		/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-													 					 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,						/**< Input: Maximum number of working set recalculations; \n
-																 		 Output: Number of performed working set recalculations. */
-								real_t* const cputime,				/**< Input: Maximum CPU time allowed for QP solution. \n
-																	 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								int_t nWSRperformed = 0,			/**< Number of working set recalculations already performed to solve
-																		 this QP within previous solveQP() calls. This number is
-																		 always zero, except for successive calls from solveRegularisedQP()
-																		 or when using the far bound strategy. */
-								BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-								);
-
-
-		/** Solves QProblem using online active set strategy.
-		 *  Note: This function is internally called by all hotstart functions!
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue solveRegularisedQP(	const real_t* const g_new,			/**< Gradient of neighbouring QP to be solved. */
-										const real_t* const lb_new,			/**< Lower bounds of neighbouring QP to be solved. \n
-															 				 	 If no lower bounds exist, a NULL pointer can be passed. */
-										const real_t* const ub_new,			/**< Upper bounds of neighbouring QP to be solved. \n
-															 				 	 If no upper bounds exist, a NULL pointer can be passed. */
-										const real_t* const lbA_new,		/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-															 				 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-										const real_t* const ubA_new,		/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-															 				 	 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-										int_t& nWSR,						/**< Input: Maximum number of working set recalculations; \n
-																		 		 Output: Number of performed working set recalculations. */
-										real_t* const cputime,				/**< Input: Maximum CPU time allowed for QP solution. \n
-																			 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-										int_t nWSRperformed = 0,			/**< Number of working set recalculations already performed to solve
-																				 this QP within previous solveRegularisedQP() calls. This number is
-																				 always zero, except for successive calls when using the far bound strategy. */
-										BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-										);
-
-
-		/** Update activities in a hot start if some of the bounds have
-			become infinity or if variables have become fixed.  */
-		/*	\return SUCCESSFUL_RETURN \n
-					RET_HOTSTART_FAILED */
-		virtual returnValue updateActivitiesForHotstart( const real_t* const lb_new,	/**< New lower bounds. */
-														 const real_t* const ub_new,	/**< New upper bounds. */
-														 const real_t* const lbA_new,	/**< New lower constraints' bounds. */
-														 const real_t* const ubA_new	/**< New upper constraints' bounds. */
-														 );
-
-
-		/** Determines type of existing constraints and bounds (i.e. implicitly fixed, unbounded etc.).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUPSUBJECTTOTYPE_FAILED */
-		virtual returnValue setupSubjectToType( );
-
-		/** Determines type of new constraints and bounds (i.e. implicitly fixed, unbounded etc.).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUPSUBJECTTOTYPE_FAILED */
-		using QProblemB::setupSubjectToType;
-		virtual returnValue setupSubjectToType(	const real_t* const lb_new,		/**< New lower bounds. */
-												const real_t* const ub_new,		/**< New upper bounds. */
-												const real_t* const lbA_new,	/**< New lower constraints' bounds. */
-												const real_t* const ubA_new		/**< New upper constraints' bounds. */
-												);
-
-		/** Computes the Cholesky decomposition of the projected Hessian (i.e. R^T*R = Z^T*H*Z).
-		 *  Note: If Hessian turns out not to be positive definite, the Hessian type
-		 *		  is set to HST_SEMIDEF accordingly.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_HESSIAN_NOT_SPD \n
-		 *			RET_INDEXLIST_CORRUPTED */
-		virtual returnValue computeProjectedCholesky( );
-
-		/** Computes initial Cholesky decomposition of the projected Hessian making
-		 *  use of the function computeCholesky() or computeProjectedCholesky().
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_HESSIAN_NOT_SPD \n
-		 *			RET_INDEXLIST_CORRUPTED */
-		virtual returnValue setupInitialCholesky( );
-
-		/** Initialises TQ factorisation of A (i.e. A*Q = [0 T]) if NO constraint is active.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEXLIST_CORRUPTED */
-		virtual returnValue setupTQfactorisation( );
-
-
-		/** Obtains the desired working set for the auxiliary initial QP in
-		 *  accordance with the user specifications
-		 *  (assumes that member AX has already been initialised!)
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_OBTAINING_WORKINGSET_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue obtainAuxiliaryWorkingSet(	const real_t* const xOpt,						/**< Optimal primal solution vector.
-																								 *	 If a NULL pointer is passed, all entries are assumed to be zero. */
-												const real_t* const yOpt,						/**< Optimal dual solution vector.
-																								 *	 If a NULL pointer is passed, all entries are assumed to be zero. */
-												const Bounds* const guessedBounds,				/**< Guessed working set of bounds for solution (xOpt,yOpt). */
-												const Constraints* const guessedConstraints,	/**< Guessed working set for solution (xOpt,yOpt). */
-												Bounds* auxiliaryBounds,						/**< Input: Allocated bound object. \n
-																								 *	 Ouput: Working set of constraints for auxiliary QP. */
-												Constraints* auxiliaryConstraints				/**< Input: Allocated bound object. \n
-																								 *	 Ouput: Working set for auxiliary QP. */
-												) const;
-
-		/** Sets up bound and constraints data structures according to auxiliaryBounds/Constraints.
-		 *  (If the working set shall be setup afresh, make sure that
-		 *  bounds and constraints data structure have been resetted
-		 *  and the TQ factorisation has been initialised!)
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUP_WORKINGSET_FAILED \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNOWN_BUG */
-		virtual returnValue setupAuxiliaryWorkingSet(	const Bounds* const auxiliaryBounds,			/**< Working set of bounds for auxiliary QP. */
-												const Constraints* const auxiliaryConstraints,	/**< Working set of constraints for auxiliary QP. */
-												BooleanType setupAfresh							/**< Flag indicating if given working set shall be
-																								 *    setup afresh or by updating the current one. */
-												);
-
-		/** Sets up the optimal primal/dual solution of the auxiliary initial QP.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue setupAuxiliaryQPsolution(	const real_t* const xOpt,			/**< Optimal primal solution vector.
-																				 	*	 If a NULL pointer is passed, all entries are set to zero. */
-												const real_t* const yOpt			/**< Optimal dual solution vector.
-																					 *	 If a NULL pointer is passed, all entries are set to zero. */
-												);
-
-		/** Sets up gradient of the auxiliary initial QP for given
-		 *  optimal primal/dual solution and given initial working set
-		 *  (assumes that members X, Y and BOUNDS, CONSTRAINTS have already been initialised!).
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue setupAuxiliaryQPgradient( );
-
-		/** Sets up (constraints') bounds of the auxiliary initial QP for given
-		 *  optimal primal/dual solution and given initial working set
-		 *  (assumes that members X, Y and BOUNDS, CONSTRAINTS have already been initialised!).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNKNOWN_BUG */
-		returnValue setupAuxiliaryQPbounds(	const Bounds* const auxiliaryBounds,			/**< Working set of bounds for auxiliary QP. */
-											const Constraints* const auxiliaryConstraints,	/**< Working set of constraints for auxiliary QP. */
-											BooleanType useRelaxation						/**< Flag indicating if inactive (constraints') bounds shall be relaxed. */
-											);
-
-
-		/** Adds a constraint to active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDCONSTRAINT_FAILED \n
-					RET_ADDCONSTRAINT_FAILED_INFEASIBILITY \n
-					RET_ENSURELI_FAILED */
-		virtual returnValue addConstraint(	int_t number,					/**< Number of constraint to be added to active set. */
-											SubjectToStatus C_status,		/**< Status of new active constraint. */
-											BooleanType updateCholesky,		/**< Flag indicating if Cholesky decomposition shall be updated. */
-											BooleanType ensureLI = BT_TRUE	/**< Ensure linear independence by exchange rules by default. */
-											);
-
-		/** Checks if new active constraint to be added is linearly dependent from
-		 *	from row of the active constraints matrix.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT \n
-					 RET_INDEXLIST_CORRUPTED */
-		virtual returnValue addConstraint_checkLI(	int_t number	/**< Number of constraint to be added to active set. */
-													);
-
-		/** Ensures linear independence of constraint matrix when a new constraint is added.
-		 * 	To this end a bound or constraint is removed simultaneously if necessary.
-		 *	\return	 SUCCESSFUL_RETURN \n
-		 			 RET_LI_RESOLVED \n
-					 RET_ENSURELI_FAILED \n
-					 RET_ENSURELI_FAILED_TQ \n
-					 RET_ENSURELI_FAILED_NOINDEX \n
-					 RET_REMOVE_FROM_ACTIVESET */
-		virtual returnValue addConstraint_ensureLI(	int_t number,				/**< Number of constraint to be added to active set. */
-													SubjectToStatus C_status	/**< Status of new active bound. */
-													);
-
-		/** Adds a bound to active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDBOUND_FAILED \n
-					RET_ADDBOUND_FAILED_INFEASIBILITY \n
-					RET_ENSURELI_FAILED */
-		virtual returnValue addBound(	int_t number,					/**< Number of bound to be added to active set. */
-										SubjectToStatus B_status,		/**< Status of new active bound. */
-										BooleanType updateCholesky,		/**< Flag indicating if Cholesky decomposition shall be updated. */
-										BooleanType ensureLI = BT_TRUE	/**< Ensure linear independence by exchange rules by default. */
-										);
-
-		/** Checks if new active bound to be added is linearly dependent from
-		 *	from row of the active constraints matrix.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT */
-		virtual returnValue addBound_checkLI(	int_t number	/**< Number of bound to be added to active set. */
-												);
-
-		/** Ensures linear independence of constraint matrix when a new bound is added.
-		 *	To this end a bound or constraint is removed simultaneously if necessary.
-		 *	\return	 SUCCESSFUL_RETURN \n
-		 			 RET_LI_RESOLVED \n
-					 RET_ENSURELI_FAILED \n
-					 RET_ENSURELI_FAILED_TQ \n
-					 RET_ENSURELI_FAILED_NOINDEX \n
-					 RET_REMOVE_FROM_ACTIVESET */
-		virtual returnValue addBound_ensureLI(	int_t number,				/**< Number of bound to be added to active set. */
-												SubjectToStatus B_status	/**< Status of new active bound. */
-												);
-
-		/** Removes a constraint from active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_CONSTRAINT_NOT_ACTIVE \n
-					RET_REMOVECONSTRAINT_FAILED \n
-					RET_HESSIAN_NOT_SPD */
-		virtual returnValue removeConstraint(	int_t number,							/**< Number of constraint to be removed from active set. */
-												BooleanType updateCholesky,				/**< Flag indicating if Cholesky decomposition shall be updated. */
-												BooleanType allowFlipping = BT_FALSE,	/**< Flag indicating if flipping bounds are allowed. */
-												BooleanType ensureNZC = BT_FALSE		/**< Flag indicating if non-zero curvature is ensured by exchange rules. */
-												);
-
-		/** Removes a bounds from active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_BOUND_NOT_ACTIVE \n
-					RET_HESSIAN_NOT_SPD \n
-					RET_REMOVEBOUND_FAILED */
-		virtual returnValue removeBound(	int_t number,							/**< Number of bound to be removed from active set. */
-											BooleanType updateCholesky,				/**< Flag indicating if Cholesky decomposition shall be updated. */
-											BooleanType allowFlipping = BT_FALSE,	/**< Flag indicating if flipping bounds are allowed. */
-											BooleanType ensureNZC = BT_FALSE		/**< Flag indicating if non-zero curvature is ensured by exchange rules. */
-											);
-
-
-		/** Performs robustified ratio test yield the maximum possible step length
-		 *  along the homotopy path.
-		 *	\return  SUCCESSFUL_RETURN */
-		returnValue performPlainRatioTest(	int_t nIdx, 						/**< Number of ratios to be checked. */
-											const int_t* const idxList, 		/**< Array containing the indices of all ratios to be checked. */
-											const real_t* const num,	 		/**< Array containing all numerators for performing the ratio test. */
-											const real_t* const den,		 	/**< Array containing all denominators for performing the ratio test. */
-											real_t epsNum,						/**< Numerator tolerance. */
-											real_t epsDen,						/**< Denominator tolerance. */
-											real_t& t,							/**< Output: Maximum possible step length along the homotopy path. */
-											int_t& BC_idx 						/**< Output: Index of blocking constraint. */
-											) const;
-
-
-		/** Ensure non-zero curvature by primal jump.
-		 *  \return SUCCESSFUL_RETURN \n
-		 *          RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue ensureNonzeroCurvature(
-				BooleanType removeBoundNotConstraint,	/**< SubjectTo to be removed is a bound. */
-				int_t remIdx,							/**< Index of bound/constraint to be removed. */
-				BooleanType &exchangeHappened,			/**< Output: Exchange was necessary to ensure. */
-				BooleanType &addBoundNotConstraint,		/**< SubjectTo to be added is a bound. */
-				int_t &addIdx,							/**< Index of bound/constraint to be added. */
-				SubjectToStatus &addStatus				/**< Status of bound/constraint to be added. */
-				);
-
-
-		/** Solves the system Ta = b or T^Ta = b where T is a reverse upper triangular matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_DIV_BY_ZERO */
-		virtual returnValue backsolveT(	const real_t* const b,	/**< Right hand side vector. */
-								BooleanType transposed,	/**< Indicates if the transposed system shall be solved. */
-								real_t* const a 		/**< Output: Solution vector */
-								) const;
-
-
-		/** Determines step direction of the shift of the QP data.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue determineDataShift(	const real_t* const g_new,	/**< New gradient vector. */
-										const real_t* const lbA_new,/**< New lower constraints' bounds. */
-										const real_t* const ubA_new,/**< New upper constraints' bounds. */
-										const real_t* const lb_new,	/**< New lower bounds. */
-										const real_t* const ub_new,	/**< New upper bounds. */
-										real_t* const delta_g,	 	/**< Output: Step direction of gradient vector. */
-										real_t* const delta_lbA,	/**< Output: Step direction of lower constraints' bounds. */
-										real_t* const delta_ubA,	/**< Output: Step direction of upper constraints' bounds. */
-										real_t* const delta_lb,	 	/**< Output: Step direction of lower bounds. */
-										real_t* const delta_ub,	 	/**< Output: Step direction of upper bounds. */
-										BooleanType& Delta_bC_isZero,/**< Output: Indicates if active constraints' bounds are to be shifted. */
-										BooleanType& Delta_bB_isZero/**< Output: Indicates if active bounds are to be shifted. */
-										);
-
-		/** Determines step direction of the homotopy path.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_STEPDIRECTION_FAILED_TQ \n
-					RET_STEPDIRECTION_FAILED_CHOLESKY */
-		virtual returnValue determineStepDirection(	const real_t* const delta_g,	/**< Step direction of gradient vector. */
-											const real_t* const delta_lbA,	/**< Step direction of lower constraints' bounds. */
-											const real_t* const delta_ubA,	/**< Step direction of upper constraints' bounds. */
-											const real_t* const delta_lb,	/**< Step direction of lower bounds. */
-											const real_t* const delta_ub,	/**< Step direction of upper bounds. */
-											BooleanType Delta_bC_isZero, 	/**< Indicates if active constraints' bounds are to be shifted. */
-											BooleanType Delta_bB_isZero,	/**< Indicates if active bounds are to be shifted. */
-											real_t* const delta_xFX, 		/**< Output: Primal homotopy step direction of fixed variables. */
-											real_t* const delta_xFR,	 	/**< Output: Primal homotopy step direction of free variables. */
-											real_t* const delta_yAC, 		/**< Output: Dual homotopy step direction of active constraints' multiplier. */
-											real_t* const delta_yFX 		/**< Output: Dual homotopy step direction of fixed variables' multiplier. */
-											);
-
-		/** Determines the maximum possible step length along the homotopy path
-		 *  and performs this step (without changing working set).
-		 *	\return SUCCESSFUL_RETURN \n
-		 * 			RET_ERROR_IN_CONSTRAINTPRODUCT \n
-		 * 			RET_QP_INFEASIBLE */
-		returnValue performStep(	const real_t* const delta_g,		/**< Step direction of gradient. */
-									const real_t* const delta_lbA,		/**< Step direction of lower constraints' bounds. */
-									const real_t* const delta_ubA,		/**< Step direction of upper constraints' bounds. */
-									const real_t* const delta_lb,	 	/**< Step direction of lower bounds. */
-									const real_t* const delta_ub,	 	/**< Step direction of upper bounds. */
-									const real_t* const delta_xFX, 		/**< Primal homotopy step direction of fixed variables. */
-									const real_t* const delta_xFR,		/**< Primal homotopy step direction of free variables. */
-									const real_t* const delta_yAC,		/**< Dual homotopy step direction of active constraints' multiplier. */
-									const real_t* const delta_yFX,		/**< Dual homotopy step direction of fixed variables' multiplier. */
-									int_t& BC_idx, 						/**< Output: Index of blocking constraint. */
-									SubjectToStatus& BC_status,			/**< Output: Status of blocking constraint. */
-									BooleanType& BC_isBound 			/**< Output: Indicates if blocking constraint is a bound. */
-									);
-
-		/** Updates the active set.
-		 *	\return  SUCCESSFUL_RETURN \n
-		 			 RET_REMOVE_FROM_ACTIVESET_FAILED \n
-					 RET_ADD_TO_ACTIVESET_FAILED */
-		returnValue changeActiveSet(	int_t BC_idx, 						/**< Index of blocking constraint. */
-										SubjectToStatus BC_status,			/**< Status of blocking constraint. */
-										BooleanType BC_isBound 				/**< Indicates if blocking constraint is a bound. */
-										);
-
-
-		/** Compute relative length of homotopy in data space for termination
-		 *  criterion.
-		 *  \return Relative length in data space. */
-		real_t getRelativeHomotopyLength(	const real_t* const g_new,		/**< Final gradient. */
-											const real_t* const lb_new,		/**< Final lower variable bounds. */
-											const real_t* const ub_new,		/**< Final upper variable bounds. */
-											const real_t* const lbA_new,	/**< Final lower constraint bounds. */
-											const real_t* const ubA_new		/**< Final upper constraint bounds. */
-											);
-
-
-		/** Ramping Strategy to avoid ties. Modifies homotopy start without
-		 *  changing current active set.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue performRamping( );
-
-
-		/** ... */
-		returnValue updateFarBounds(	real_t curFarBound,					/**< ... */
-                                        int_t nRamp,						/**< ... */
-                                        const real_t* const lb_new,			/**< ... */
-                                        real_t* const lb_new_far,			/**< ... */
-                                        const real_t* const ub_new,			/**< ... */
-                                        real_t* const ub_new_far,			/**< ... */
-                                        const real_t* const lbA_new,		/**< ... */
-                                        real_t* const lbA_new_far,			/**< ... */
-                                        const real_t* const ubA_new,		/**< ... */
-                                        real_t* const ubA_new_far			/**< ... */
-                                        ) const;
-
-
-		/** Drift correction at end of each active set iteration
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue performDriftCorrection( );
-
-
-		/** Updates QP vectors, working sets and internal data structures in order to
-			start from an optimal solution corresponding to initial guesses of the working
-			set for bounds and constraints.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_SETUP_AUXILIARYQP_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		using QProblemB::setupAuxiliaryQP;
-		virtual returnValue setupAuxiliaryQP(	const Bounds* const guessedBounds,			/**< Initial guess for working set of bounds. */
-												const Constraints* const guessedConstraints	/**< Initial guess for working set of constraints. */
-												);
-
-		/** Determines if it is more efficient to refactorise the matrices when
-		 *  hotstarting or not (i.e. better to update the existing factorisations).
-		 *	\return BT_TRUE iff matrices shall be refactorised afresh
-		 */
-		BooleanType shallRefactorise(	const Bounds* const guessedBounds,			/**< Guessed new working set of bounds. */
-										const Constraints* const guessedConstraints	/**< Guessed new working set of constraints. */
-										) const;
-
-		/** Sets up internal QP data.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNONW_BUG */
-		returnValue setupQPdata(	SymmetricMatrix *_H, 		/**< Hessian matrix. \n
-																     If Hessian matrix is trivial,a NULL pointer can be passed. */
-									const real_t* const _g, 	/**< Gradient vector. */
-									Matrix *_A, 			 	/**< Constraint matrix. */
-									const real_t* const _lb,	/**< Lower bound vector (on variables). \n
-																	 If no lower bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ub,	/**< Upper bound vector (on variables). \n
-																	 If no upper bounds exist, a NULL pointer can be passed. */
-									const real_t* const _lbA,	/**< Lower constraints' bound vector. \n
-																	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ubA	/**< Upper constraints' bound vector. \n
-																	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-									);
-
-
-		/** Sets up dense internal QP data. If the current Hessian is trivial
-		 *  (i.e. HST_ZERO or HST_IDENTITY) but a non-trivial one is given,
-		 *  memory for Hessian is allocated and it is set to the given one.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNONW_BUG */
-		returnValue setupQPdata(	const real_t* const _H, 	/**< Hessian matrix. \n
-																     If Hessian matrix is trivial,a NULL pointer can be passed. */
-									const real_t* const _g, 	/**< Gradient vector. */
-									const real_t* const _A,  	/**< Constraint matrix. */
-									const real_t* const _lb,	/**< Lower bound vector (on variables). \n
-																	 If no lower bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ub,	/**< Upper bound vector (on variables). \n
-																	 If no upper bounds exist, a NULL pointer can be passed. */
-									const real_t* const _lbA,	/**< Lower constraints' bound vector. \n
-																	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ubA	/**< Upper constraints' bound vector. \n
-																	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-									);
-
-		/** Sets up internal QP data by loading it from files. If the current Hessian
-		 *  is trivial (i.e. HST_ZERO or HST_IDENTITY) but a non-trivial one is given,
-		 *  memory for Hessian is allocated and it is set to the given one.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNABLE_TO_OPEN_FILE \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNONW_BUG */
-		returnValue setupQPdataFromFile(	const char* const H_file, 	/**< Name of file where Hessian matrix, of neighbouring QP to be solved, is stored. \n
-																     		 If Hessian matrix is trivial,a NULL pointer can be passed. */
-											const char* const g_file, 	/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-											const char* const A_file,	/**< Name of file where constraint matrix, of neighbouring QP to be solved, is stored. */
-											const char* const lb_file, 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower bounds exist, a NULL pointer can be passed. */
-											const char* const ub_file, 	/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper bounds exist, a NULL pointer can be passed. */
-											const char* const lbA_file, /**< Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-											const char* const ubA_file	/**< Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-											);
-
-		/** Loads new QP vectors from files (internal members are not affected!).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNABLE_TO_OPEN_FILE \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue loadQPvectorsFromFile(	const char* const g_file, 	/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-											const char* const lb_file, 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower bounds exist, a NULL pointer can be passed. */
-											const char* const ub_file, 	/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper bounds exist, a NULL pointer can be passed. */
-											const char* const lbA_file, /**< Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-											const char* const ubA_file, /**< Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-											real_t* const g_new,		/**< Output: Gradient of neighbouring QP to be solved. */
-											real_t* const lb_new,		/**< Output: Lower bounds of neighbouring QP to be solved */
-											real_t* const ub_new,		/**< Output: Upper bounds of neighbouring QP to be solved */
-											real_t* const lbA_new,		/**< Output: Lower constraints' bounds of neighbouring QP to be solved */
-											real_t* const ubA_new		/**< Output: Upper constraints' bounds of neighbouring QP to be solved */
-											) const;
-
-
-		/** Prints concise information on the current iteration.
-		 *	\return  SUCCESSFUL_RETURN \n */
-		returnValue printIteration(	int_t iter,							/**< Number of current iteration. */
-									int_t BC_idx, 						/**< Index of blocking constraint. */
-									SubjectToStatus BC_status,			/**< Status of blocking constraint. */
-									BooleanType BC_isBound,				/**< Indicates if blocking constraint is a bound. */
-									real_t homotopyLength,				/**< Current homotopy distance. */
-									BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-		 							);
-
-
-		/** Sets constraint matrix of the QP. \n
-			Note: Also internal vector Ax is recomputed!
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_INVALID_ARGUMENTS */
-		inline returnValue setA(	Matrix *A_new	/**< New constraint matrix (a shallow copy is made). */
-									);
-
-		/** Sets dense constraint matrix of the QP. \n
-			Note: Also internal vector Ax is recomputed!
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_INVALID_ARGUMENTS */
-		inline returnValue setA(	const real_t* const A_new	/**< New dense constraint matrix (with correct dimension!), a shallow copy is made. */
-									);
-
-
-		/** Sets constraints' lower bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue setLBA(	const real_t* const lbA_new	/**< New constraints' lower bound vector (with correct dimension!). */
-									);
-
-		/** Changes single entry of lower constraints' bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP \n
-		 *			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setLBA(	int_t number,	/**< Number of entry to be changed. */
-									real_t value	/**< New value for entry of lower constraints' bound vector (with correct dimension!). */
-									);
-
-		/** Sets constraints' upper bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue setUBA(	const real_t* const ubA_new	/**< New constraints' upper bound vector (with correct dimension!). */
-									);
-
-		/** Changes single entry of upper constraints' bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP \n
-		 *			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setUBA(	int_t number,	/**< Number of entry to be changed. */
-									real_t value	/**< New value for entry of upper constraints' bound vector (with correct dimension!). */
-									);
-
-
-		/** Drops the blocking bound/constraint that led to infeasibility, or finds another
-		 *  bound/constraint to drop according to drop priorities.
-		 *  \return SUCCESSFUL_RETURN \n
-		 */
-		returnValue dropInfeasibles ( 	int_t BC_number,			/**< Number of the bound or constraint to be added. */
-										SubjectToStatus BC_status, 	/**< New status of the bound or constraint to be added. */
-										BooleanType BC_isBound,		/**< Whether a bound or a constraint is to be added. */
-										real_t *xiB,				/**< (not yet documented) */
-										real_t *xiC					/**< (not yet documented) */
-										);
-
-		/** Decides if lower bounds are smaller than upper bounds
-		 *
-		 * \return SUCCESSFUL_RETURN \n
-		 * 		   RET_QP_INFEASIBLE */
-
-				returnValue areBoundsConsistent(const real_t* const lb,  /**< Vector of lower bounds*/
-												const real_t* const ub,  /**< Vector of upper bounds*/
-												const real_t* const lbA, /**< Vector of lower constraints*/
-												const real_t* const ubA  /**< Vector of upper constraints*/
-												) const;
-
-
-	public:
-		/** ...
-		 *	\return SUCCESSFUL_RETURN  \n
-					RET_UNABLE_TO_OPEN_FILE */
-		returnValue writeQpDataIntoMatFile(	const char* const filename	/**< Mat file name. */
-											) const;
-
-		/** ...
-		 *	\return SUCCESSFUL_RETURN  \n
-					RET_UNABLE_TO_OPEN_FILE */
-		returnValue writeQpWorkspaceIntoMatFile(	const char* const filename	/**< Mat file name. */
-													);
-
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		BooleanType freeConstraintMatrix; 		/**< Flag indicating whether the constraint matrix needs to be de-allocated. */
-		Matrix* A;								/**< Constraint matrix. */
-
-		real_t* lbA;							/**< Lower constraints' bound vector. */
-		real_t* ubA;							/**< Upper constraints' bound vector. */
-
-		Constraints constraints;				/**< Data structure for problem's constraints. */
-
-		real_t* T;								/**< Reverse triangular matrix, A = [0 T]*Q'. */
-		real_t* Q;								/**< Orthonormal quadratic matrix, A = [0 T]*Q'. */
-		int_t sizeT;							/**< Matrix T is stored in a (sizeT x sizeT) array. */
-
-		real_t* Ax;								/**< Stores the current A*x \n
-												 *	 (for increased efficiency only). */
-		real_t* Ax_l;							/**< Stores the current distance to lower constraints' bounds A*x-lbA \n
-												 *	 (for increased efficiency only). */
-		real_t* Ax_u;							/**< Stores the current distance to lower constraints' bounds ubA-A*x \n
-												 *	 (for increased efficiency only). */
-
-		ConstraintProduct* constraintProduct;	/**< Pointer to user-defined constraint product function. */
-
-		real_t* tempA;							/**< Temporary for determineStepDirection. */
-		real_t* tempB;							/**< Temporary for determineStepDirection. */
-		real_t* ZFR_delta_xFRz;					/**< Temporary for determineStepDirection. */
-		real_t* delta_xFRy;						/**< Temporary for determineStepDirection. */
-		real_t* delta_xFRz;						/**< Temporary for determineStepDirection. */
-		real_t* delta_yAC_TMP;					/**< Temporary for determineStepDirection. */
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/QProblem.ipp>
-
-#endif	/* QPOASES_QPROBLEM_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.ipp
deleted file mode 100644
index c7d2a14..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.ipp
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/QProblem.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the QProblem class which
- *	is able to use the newly developed online active set strategy for
- *	parametric quadratic programming.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	g e t C o n s t r a i n t s
- */
-inline returnValue QProblem::getConstraints( Constraints& _constraints ) const
-{
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	_constraints = constraints;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	g e t N C
- */
-inline int_t QProblem::getNC( ) const
-{
-	return constraints.getNC( );
-}
-
-
-/*
- *	g e t N E C
- */
-inline int_t QProblem::getNEC( ) const
-{
-	return constraints.getNEC( );
-}
-
-
-/*
- *	g e t N A C
- */
-inline int_t QProblem::getNAC( ) const
-{
-	return constraints.getNAC( );
-}
-
-
-/*
- *	g e t N I A C
- */
-inline int_t QProblem::getNIAC( ) const
-{
-	return constraints.getNIAC( );
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-
-/*
- *	s e t A
- */
-inline returnValue QProblem::setA( Matrix *A_new )
-{
-	int_t j;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( A_new == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* Set constraint matrix AND update member AX. */
-	if ( ( freeConstraintMatrix == BT_TRUE ) && ( A != 0 ) )
-	{
-		delete A;
-		A = 0;
-	}
-	A = A_new;
-	freeConstraintMatrix = BT_FALSE;
-
-	A->times(1, 1.0, x, nV, 0.0, Ax, nC);
-
-	for( j=0; j<nC; ++j )
-	{
-		Ax_u[j] = ubA[j] - Ax[j];
-		Ax_l[j] = Ax[j] - lbA[j];
-		/* AW: TODO: Takes too much time - could be implemented differently
-		// (ckirches) disable constraints with empty rows	
-		*/
-		if ( isZero( A->getRowNorm (j) ) == BT_TRUE )
-			constraints.setType ( j, ST_DISABLED );
-	}
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t A
- */
-inline returnValue QProblem::setA( const real_t* const A_new )
-{
-	int_t j;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-	DenseMatrix* dA;
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( A_new == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* Set constraint matrix AND update member AX. */
-	if ( ( freeConstraintMatrix == BT_TRUE ) && ( A != 0 ) )
-	{
-		delete A;
-		A = 0;
-	}
-	A = dA = new DenseMatrix(nC, nV, nV, (real_t*) A_new);
-	freeConstraintMatrix = BT_TRUE;
-
-	A->times(1, 1.0, x, nV, 0.0, Ax, nC);
-
-	for( j=0; j<nC; ++j )
-	{
-		Ax_u[j] = ubA[j] - Ax[j];
-		Ax_l[j] = Ax[j] - lbA[j];
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t L B A
- */
-inline returnValue QProblem::setLBA( const real_t* const lbA_new )
-{
-	uint_t i;
-	uint_t nV = (uint_t)getNV( );
-	uint_t nC = (uint_t)getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( lbA_new != 0 )
-	{	
-		memcpy( lbA,lbA_new,nC*sizeof(real_t) );
-	}
-	else
-	{
-		/* if no lower constraints' bounds are specified, set them to -infinity */
-		for( i=0; i<nC; ++i )
-			lbA[i] = -INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t L B A
- */
-inline returnValue QProblem::setLBA( int_t number, real_t value )
-{
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ( number >= 0 ) && ( number < nC ) )
-	{
-		lbA[number] = value;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-}
-
-
-/*
- *	s e t U B A
- */
-inline returnValue QProblem::setUBA( const real_t* const ubA_new )
-{
-	uint_t i;
-	uint_t nV = (uint_t)getNV( );
-	uint_t nC = (uint_t)getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ubA_new != 0 )
-	{
-		memcpy( ubA,ubA_new,nC*sizeof(real_t) );
-	}
-	else
-	{
-		/* if no upper constraints' bounds are specified, set them to infinity */
-		for( i=0; i<nC; ++i )
-			ubA[i] = INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t U B A
- */
-inline returnValue QProblem::setUBA( int_t number, real_t value )
-{
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ( number >= 0 ) && ( number < nC ) )
-	{
-		ubA[number] = value;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.hpp
deleted file mode 100644
index 4801d06..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.hpp
+++ /dev/null
@@ -1,1020 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/QProblemB.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the QProblemB class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming
- *	for problems with (simple) bounds only.
- */
-
-
-
-#ifndef QPOASES_QPROBLEMB_HPP
-#define QPOASES_QPROBLEMB_HPP
-
-
-#include <qpOASES/Flipper.hpp>
-#include <qpOASES/Options.hpp>
-#include <qpOASES/Matrices.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-class SolutionAnalysis;
-
-/**
- *	\brief Implements the online active set strategy for box-constrained QPs.
- *
- *	Class for setting up and solving quadratic programs with bounds (= box constraints) only.
- *	The main feature is the possibily to use the newly developed online active set strategy
- *	for parametric quadratic programming.
- *
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-class QProblemB
-{
-	/* allow SolutionAnalysis class to access private members */
-	friend class SolutionAnalysis;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		QProblemB( );
-
-		/** Constructor which takes the QP dimension and Hessian type
-		 *  information. If the Hessian is the zero (i.e. HST_ZERO) or the
-		 *  identity matrix (i.e. HST_IDENTITY), respectively, no memory
-		 *  is allocated for it and a NULL pointer can be passed for it
-		 *  to the init() functions. */
-		QProblemB(	int_t _nV,								/**< Number of variables. */
-					HessianType _hessianType = HST_UNKNOWN	/**< Type of Hessian matrix. */
-					);
-
-		/** Copy constructor (deep copy). */
-		QProblemB(	const QProblemB& rhs	/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~QProblemB( );
-
-		/** Assignment operator (deep copy). */
-		virtual QProblemB& operator=(	const QProblemB& rhs	/**< Rhs object. */
-								);
-
-
-		/** Clears all data structures of QProblemB except for QP data.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_RESET_FAILED */
-		virtual returnValue reset( );
-
-
-		/** Initialises a simply bounded QP problem with given QP data and tries to solve it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0 : starts with xOpt = 0, yOpt = 0 and gB empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0 : starts with xOpt, yOpt = 0 and obtain gB by "clipping", \n
-		 *	3. 0,    yOpt, 0 : starts with xOpt = 0, yOpt and obtain gB from yOpt != 0, \n
-		 *	4. 0,    0,    gB: starts with xOpt = 0, yOpt = 0 and gB, \n
-		 *	5. xOpt, yOpt, 0 : starts with xOpt, yOpt and obtain gB from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB: starts with xOpt, yOpt = 0 and gB, \n
-		 *	7. xOpt, yOpt, gB: starts with xOpt, yOpt and gB (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue init(	SymmetricMatrix *_H,					/**< Hessian matrix (a shallow copy is made). */
-							const real_t* const _g,					/**< Gradient vector. */
-							const real_t* const _lb,				/**< Lower bounds (on variables). \n
-																		 If no lower bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ub,				/**< Upper bounds (on variables). \n
-																		 If no upper bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR, 							/**< Input: Maximum number of working set recalculations when using initial homotopy. \n
-																		 Output: Number of performed working set recalculations. */
-				 			real_t* const cputime = 0,				/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																		 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,			/**< Optimal primal solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,			/**< Optimal dual solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,	/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																		 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const real_t* const _R = 0				/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix.
-																	 	 The Cholesky factor must be stored in a real_t array of size nV*nV
-																		 in row-major format. Note: Only used if xOpt/yOpt and gB are NULL! \n
-																		 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-		/** Initialises a simply bounded QP problem with given QP data and tries to solve it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0 : starts with xOpt = 0, yOpt = 0 and gB empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0 : starts with xOpt, yOpt = 0 and obtain gB by "clipping", \n
-		 *	3. 0,    yOpt, 0 : starts with xOpt = 0, yOpt and obtain gB from yOpt != 0, \n
-		 *	4. 0,    0,    gB: starts with xOpt = 0, yOpt = 0 and gB, \n
-		 *	5. xOpt, yOpt, 0 : starts with xOpt, yOpt and obtain gB from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB: starts with xOpt, yOpt = 0 and gB, \n
-		 *	7. xOpt, yOpt, gB: starts with xOpt, yOpt and gB (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue init(	const real_t* const _H, 				/**< Hessian matrix (a shallow copy is made). \n
-																		 If Hessian matrix is trivial, a NULL pointer can be passed. */
-							const real_t* const _g,					/**< Gradient vector. */
-							const real_t* const _lb,				/**< Lower bounds (on variables). \n
-																		 If no lower bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ub,				/**< Upper bounds (on variables). \n
-																		 If no upper bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR, 							/**< Input: Maximum number of working set recalculations when using initial homotopy. \n
-																		 Output: Number of performed working set recalculations. */
-				 			real_t* const cputime = 0,				/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																		 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,			/**< Optimal primal solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,			/**< Optimal dual solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,	/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																		 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const real_t* const _R = 0				/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix.
-																	 	 The Cholesky factor must be stored in a real_t array of size nV*nV
-																		 in row-major format. Note: Only used if xOpt/yOpt and gB are NULL! \n
-																		 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-		/** Initialises a simply bounded QP problem with given QP data to be read from files and solves it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0 : starts with xOpt = 0, yOpt = 0 and gB empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0 : starts with xOpt, yOpt = 0 and obtain gB by "clipping", \n
-		 *	3. 0,    yOpt, 0 : starts with xOpt = 0, yOpt and obtain gB from yOpt != 0, \n
-		 *	4. 0,    0,    gB: starts with xOpt = 0, yOpt = 0 and gB, \n
-		 *	5. xOpt, yOpt, 0 : starts with xOpt, yOpt and obtain gB from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB: starts with xOpt, yOpt = 0 and gB, \n
-		 *	7. xOpt, yOpt, gB: starts with xOpt, yOpt and gB (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_UNABLE_TO_READ_FILE */
-		returnValue init(	const char* const H_file,				/**< Name of file where Hessian matrix is stored. \n
-																		 If Hessian matrix is trivial, a NULL pointer can be passed. */
-							const char* const g_file,				/**< Name of file where gradient vector is stored. */
-							const char* const lb_file,				/**< Name of file where lower bound vector. \n
-																		 If no lower bounds exist, a NULL pointer can be passed. */
-							const char* const ub_file,				/**< Name of file where upper bound vector. \n
-																		 If no upper bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR, 							/**< Input: Maximum number of working set recalculations when using initial homotopy. \n
-																		 Output: Number of performed working set recalculations. */
-				 			real_t* const cputime = 0,				/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																		 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,			/**< Optimal primal solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,			/**< Optimal dual solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,	/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																		 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const char* const R_file = 0			/**< Name of the file where a pre-computed (upper triangular) Cholesky factor
-																		 of the Hessian matrix is stored. \n
-																		 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-
-		/** Solves an initialised QP sequence using the online active set strategy.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This function internally calls solveQP/solveRegularisedQP
-		 *        for solving an initialised QP!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_MAX_NWSR_REACHED \n
-					RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_SETUP_AUXILIARYQP_FAILED */
-		returnValue hotstart(	const real_t* const g_new,				/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const lb_new,				/**< Lower bounds of neighbouring QP to be solved. \n
-													 						 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,				/**< Upper bounds of neighbouring QP to be solved. \n
-													 						 If no upper bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,							/**< Input: Maximum number of working set recalculations; \n
-																			 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,				/**< Input: Maximum CPU time allowed for QP solution. \n
-																			 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0	/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																			 (If a null pointer is passed, the previous working set is kept!) */
-								);
-
-		/** Solves an initialised QP sequence using the online active set strategy,
-		 *  where QP data is read from files.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This function internally calls solveQP/solveRegularisedQP
-		 *        for solving an initialised QP!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_SETUP_AUXILIARYQP_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue hotstart(	const char* const g_file, 				/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-								const char* const lb_file,				/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-													 						 If no lower bounds exist, a NULL pointer can be passed. */
-								const char* const ub_file,				/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-													 						 If no upper bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR, 							/**< Input: Maximum number of working set recalculations; \n
-																			 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,			 	/**< Input: Maximum CPU time allowed for QP solution. \n
-																			 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0	/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																			 (If a null pointer is passed, the previous working set is kept!) */
-								);
-
-
-		/** Writes a vector with the state of the working set
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSet(	real_t* workingSet				/** Output: array containing state of the working set. */
-											);
-
-		/** Writes a vector with the state of the working set of bounds
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSetBounds(	real_t* workingSetB		/** Output: array containing state of the working set of bounds. */
-													);
-
-		/** Writes a vector with the state of the working set of constraints
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSetConstraints(	real_t* workingSetC	/** Output: array containing state of the working set of constraints. */
-														);
-
-
-		/** Returns current bounds object of the QP (deep copy).
-		  *	\return SUCCESSFUL_RETURN \n
-		  			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue getBounds(	Bounds& _bounds	/** Output: Bounds object. */
-										) const;
-
-
-		/** Returns the number of variables.
-		 *	\return Number of variables. */
-		inline int_t getNV( ) const;
-
-		/** Returns the number of free variables.
-		 *	\return Number of free variables. */
-		inline int_t getNFR( ) const;
-
-		/** Returns the number of fixed variables.
-		 *	\return Number of fixed variables. */
-		inline int_t getNFX( ) const;
-
-		/** Returns the number of implicitly fixed variables.
-		 *	\return Number of implicitly fixed variables. */
-		inline int_t getNFV( ) const;
-
-		/** Returns the dimension of null space.
-		 *	\return Dimension of null space. */
-		virtual int_t getNZ( ) const;
-
-
-		/** Returns the optimal objective function value.
-		 *	\return finite value: Optimal objective function value (QP was solved) \n
-		 			+infinity:	  QP was not yet solved */
-		real_t getObjVal( ) const;
-
-		/** Returns the objective function value at an arbitrary point x.
-		 *	\return Objective function value at point x */
-		real_t getObjVal(	const real_t* const _x	/**< Point at which the objective function shall be evaluated. */
-							) const;
-
-		/** Returns the primal solution vector.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_QP_NOT_SOLVED */
-		returnValue getPrimalSolution(	real_t* const xOpt			/**< Output: Primal solution vector (if QP has been solved). */
-										) const;
-
-		/** Returns the dual solution vector.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_QP_NOT_SOLVED */
-		virtual returnValue getDualSolution(	real_t* const yOpt	/**< Output: Dual solution vector (if QP has been solved). */
-												) const;
-
-
-		/** Returns status of the solution process.
-		 *	\return Status of solution process. */
-		inline QProblemStatus getStatus( ) const;
-
-
-		/** Returns if the QProblem object is initialised.
-		 *	\return BT_TRUE:  QProblemB initialised \n
-		 			BT_FALSE: QProblemB not initialised */
-		inline BooleanType isInitialised( ) const;
-
-		/** Returns if the QP has been solved.
-		 *	\return BT_TRUE:  QProblemB solved \n
-		 			BT_FALSE: QProblemB not solved */
-		inline BooleanType isSolved( ) const;
-
-		/** Returns if the QP is infeasible.
-		 *	\return BT_TRUE:  QP infeasible \n
-		 			BT_FALSE: QP feasible (or not known to be infeasible!) */
-		inline BooleanType isInfeasible( ) const;
-
-		/** Returns if the QP is unbounded.
-		 *	\return BT_TRUE:  QP unbounded \n
-		 			BT_FALSE: QP unbounded (or not known to be unbounded!) */
-		inline BooleanType isUnbounded( ) const;
-
-
-		/** Returns Hessian type flag (type is not determined due to this call!).
-		 *	\return Hessian type. */
-		inline HessianType getHessianType( ) const;
-
-		/** Changes the print level.
- 		 *	\return SUCCESSFUL_RETURN */
-		inline returnValue setHessianType(	HessianType _hessianType /**< New Hessian type. */
-											);
-
-		/** Returns if the QP has been internally regularised.
-		 *	\return BT_TRUE:  Hessian is internally regularised for QP solution \n
-		 			BT_FALSE: No internal Hessian regularisation is used for QP solution */
-		inline BooleanType usingRegularisation( ) const;
-
-		/** Returns current options struct.
-		 *	\return Current options struct. */
-		inline Options getOptions( ) const;
-
-		/** Overrides current options with given ones.
- 		 *	\return SUCCESSFUL_RETURN */
-		inline returnValue setOptions(	const Options& _options	/**< New options. */
-										);
-
-		/** Returns the print level.
-		 *	\return Print level. */
-		inline PrintLevel getPrintLevel( ) const;
-
-		/** Changes the print level.
- 		 *	\return SUCCESSFUL_RETURN */
-		returnValue setPrintLevel(	PrintLevel _printlevel	/**< New print level. */
-									);
-
-
-		/** Returns the current number of QP problems solved.
-		 *	\return Number of QP problems solved. */
-		inline uint_t getCount( ) const;
-
-		/** Resets QP problem counter (to zero).
-		 *	\return SUCCESSFUL_RETURN. */
-		inline returnValue resetCounter( );
-
-
-		/** Prints concise list of properties of the current QP.
-		 *	\return  SUCCESSFUL_RETURN \n */
-		virtual returnValue printProperties( );
-
-		/** Prints a list of all options and their current values.
-		 *	\return  SUCCESSFUL_RETURN \n */
-		returnValue printOptions( ) const;
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const QProblemB& rhs	/**< Rhs object. */
-							);
-
-		/** If Hessian type has been set by the user, nothing is done.
-		 *  Otherwise the Hessian type is set to HST_IDENTITY, HST_ZERO, or
-		 *  HST_POSDEF (default), respectively.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HESSIAN_INDEFINITE */
-		returnValue determineHessianType( );
-
-		/** Determines type of existing constraints and bounds (i.e. implicitly fixed, unbounded etc.).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUPSUBJECTTOTYPE_FAILED */
-		virtual returnValue setupSubjectToType( );
-
-		/** Determines type of new constraints and bounds (i.e. implicitly fixed, unbounded etc.).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUPSUBJECTTOTYPE_FAILED */
-		virtual returnValue setupSubjectToType(	const real_t* const lb_new,	/**< New lower bounds. */
-												const real_t* const ub_new	/**< New upper bounds. */
-												);
-
-		/** Computes the Cholesky decomposition of the (simply projected) Hessian
-		 *  (i.e. R^T*R = Z^T*H*Z). It only works in the case where Z is a simple
-		 *  projection matrix!
-		 *  Note: If Hessian turns out not to be positive definite, the Hessian type
-		 *		  is set to HST_SEMIDEF accordingly.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_HESSIAN_NOT_SPD \n
-		 *			RET_INDEXLIST_CORRUPTED */
-		virtual returnValue computeCholesky( );
-
-
-		/** Computes initial Cholesky decomposition of the (simply projected) Hessian
-		 *  making use of the function computeCholesky().
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_HESSIAN_NOT_SPD \n
-		 *			RET_INDEXLIST_CORRUPTED */
-		virtual returnValue setupInitialCholesky( );
-
-		/** Obtains the desired working set for the auxiliary initial QP in
-		 *  accordance with the user specifications
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_OBTAINING_WORKINGSET_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue obtainAuxiliaryWorkingSet(	const real_t* const xOpt,			/**< Optimal primal solution vector.
-																					 *	 If a NULL pointer is passed, all entries are assumed to be zero. */
-												const real_t* const yOpt,			/**< Optimal dual solution vector.
-																					 *	 If a NULL pointer is passed, all entries are assumed to be zero. */
-												const Bounds* const guessedBounds,	/**< Guessed working set for solution (xOpt,yOpt). */
-												Bounds* auxiliaryBounds				/**< Input: Allocated bound object. \n
-																					 *	 Output: Working set for auxiliary QP. */
-												) const;
-
-		/** Decides if lower bounds are smaller than upper bounds
-		 *
-		 * \return SUCCESSFUL_RETURN \n
-		 * 		   RET_QP_INFEASIBLE */
-
-		returnValue areBoundsConsistent(const real_t* const lb, /**< Vector of lower bounds*/
-										const real_t* const ub  /**< Vector of upper bounds*/
-										) const;
-
-		/** Solves the system Ra = b or R^Ta = b where R is an upper triangular matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_DIV_BY_ZERO */
-		virtual returnValue backsolveR(	const real_t* const b,	/**< Right hand side vector. */
-								BooleanType transposed,	/**< Indicates if the transposed system shall be solved. */
-								real_t* const a 		/**< Output: Solution vector */
-								) const;
-
-		/** Solves the system Ra = b or R^Ta = b where R is an upper triangular matrix. \n
-		 *  Special variant for the case that this function is called from within "removeBound()".
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_DIV_BY_ZERO */
-		virtual returnValue backsolveR(	const real_t* const b,		/**< Right hand side vector. */
-								BooleanType transposed,		/**< Indicates if the transposed system shall be solved. */
-								BooleanType removingBound,	/**< Indicates if function is called from "removeBound()". */
-								real_t* const a 			/**< Output: Solution vector */
-								) const;
-
-
-		/** Determines step direction of the shift of the QP data.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue determineDataShift(	const real_t* const g_new,	/**< New gradient vector. */
-										const real_t* const lb_new,	/**< New lower bounds. */
-										const real_t* const ub_new,	/**< New upper bounds. */
-										real_t* const delta_g,	 	/**< Output: Step direction of gradient vector. */
-										real_t* const delta_lb,	 	/**< Output: Step direction of lower bounds. */
-										real_t* const delta_ub,	 	/**< Output: Step direction of upper bounds. */
-										BooleanType& Delta_bB_isZero/**< Output: Indicates if active bounds are to be shifted. */
-										);
-
-
-		/** Sets up internal QP data.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INVALID_ARGUMENTS */
-		returnValue setupQPdata(	SymmetricMatrix *_H,	 	/**< Hessian matrix.*/
-									const real_t* const _g,		/**< Gradient vector. */
-									const real_t* const _lb,	/**< Lower bounds (on variables). \n
-																	 If no lower bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ub		/**< Upper bounds (on variables). \n
-																	 If no upper bounds exist, a NULL pointer can be passed. */
-									);
-
-		/** Sets up internal QP data. If the current Hessian is trivial
-		 *  (i.e. HST_ZERO or HST_IDENTITY) but a non-trivial one is given,
-		 *  memory for Hessian is allocated and it is set to the given one.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INVALID_ARGUMENTS \n
-					RET_NO_HESSIAN_SPECIFIED */
-		returnValue setupQPdata(	const real_t* const _H, 	/**< Hessian matrix. \n
-																     If Hessian matrix is trivial,a NULL pointer can be passed. */
-									const real_t* const _g,		/**< Gradient vector. */
-									const real_t* const _lb,	/**< Lower bounds (on variables). \n
-																	 If no lower bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ub		/**< Upper bounds (on variables). \n
-																	 If no upper bounds exist, a NULL pointer can be passed. */
-									);
-
-		/** Sets up internal QP data by loading it from files. If the current Hessian
-		 *  is trivial (i.e. HST_ZERO or HST_IDENTITY) but a non-trivial one is given,
-		 *  memory for Hessian is allocated and it is set to the given one.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNABLE_TO_OPEN_FILE \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS \n
-					RET_NO_HESSIAN_SPECIFIED */
-		returnValue setupQPdataFromFile(	const char* const H_file, 	/**< Name of file where Hessian matrix, of neighbouring QP to be solved, is stored. \n
-																     		 If Hessian matrix is trivial,a NULL pointer can be passed. */
-											const char* const g_file, 	/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-											const char* const lb_file, 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower bounds exist, a NULL pointer can be passed. */
-											const char* const ub_file 	/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper bounds exist, a NULL pointer can be passed. */
-											);
-
-		/** Loads new QP vectors from files (internal members are not affected!).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNABLE_TO_OPEN_FILE \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue loadQPvectorsFromFile(	const char* const g_file, 	/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-											const char* const lb_file, 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower bounds exist, a NULL pointer can be passed. */
-											const char* const ub_file, 	/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper bounds exist, a NULL pointer can be passed. */
-											real_t* const g_new,		/**< Output: Gradient of neighbouring QP to be solved. */
-											real_t* const lb_new,		/**< Output: Lower bounds of neighbouring QP to be solved */
-											real_t* const ub_new		/**< Output: Upper bounds of neighbouring QP to be solved */
-											) const;
-
-
-		/** Sets internal infeasibility flag and throws given error in case the far bound
-		 *	strategy is not enabled (as QP might actually not be infeasible in this case).
-		 *	\return RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_ENSURELI_FAILED_CYCLING \n
-					RET_ENSURELI_FAILED_NOINDEX */
-		returnValue setInfeasibilityFlag(	returnValue returnvalue,			/**< Returnvalue to be tunneled. */
-											BooleanType doThrowError = BT_FALSE	/**< Flag forcing to throw an error. */
-											);
-
-
-		/** Determines if next QP iteration can be performed within given CPU time limit.
-		 *	\return BT_TRUE: CPU time limit is exceeded, stop QP solution. \n
-					BT_FALSE: Sufficient CPU time for next QP iteration. */
-		BooleanType isCPUtimeLimitExceeded(	const real_t* const cputime,	/**< Maximum CPU time allowed for QP solution. */
-											real_t starttime,				/**< Start time of current QP solution. */
-											int_t nWSR						/**< Number of working set recalculations performed so far. */
-											) const;
-
-
-		/** Regularise Hessian matrix by adding a scaled identity matrix to it.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HESSIAN_ALREADY_REGULARISED */
-		returnValue regulariseHessian( );
-
-
-		/** Sets Hessian matrix of the QP.
-		 *	\return SUCCESSFUL_RETURN */
-		inline returnValue setH(	SymmetricMatrix* H_new	/**< New Hessian matrix (a shallow copy is made). */
-									);
-
-		/** Sets dense Hessian matrix of the QP.
-		 *  If a null pointer is passed and
-		 *  a) hessianType is HST_IDENTITY, nothing is done,
-		 *  b) hessianType is not HST_IDENTITY, Hessian matrix is set to zero.
-		 *	\return SUCCESSFUL_RETURN */
-		inline returnValue setH(	const real_t* const H_new	/**< New dense Hessian matrix (with correct dimension!), a shallow copy is made. */
-									);
-
-		/** Changes gradient vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_INVALID_ARGUMENTS */
-		inline returnValue setG(	const real_t* const g_new	/**< New gradient vector (with correct dimension!). */
-									);
-
-		/** Changes lower bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue setLB(	const real_t* const lb_new	/**< New lower bound vector (with correct dimension!). */
-									);
-
-		/** Changes single entry of lower bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP \n
-		 *			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setLB(	int_t number,	/**< Number of entry to be changed. */
-									real_t value	/**< New value for entry of lower bound vector. */
-									);
-
-		/** Changes upper bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue setUB(	const real_t* const ub_new	/**< New upper bound vector (with correct dimension!). */
-									);
-
-		/** Changes single entry of upper bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP \n
-		 *			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setUB(	int_t number,	/**< Number of entry to be changed. */
-									real_t value	/**< New value for entry of upper bound vector. */
-									);
-
-
-		/** Computes parameters for the Givens matrix G for which [x,y]*G = [z,0]
-		 *	\return SUCCESSFUL_RETURN */
-		inline void computeGivens(	real_t xold,	/**< Matrix entry to be normalised. */
-									real_t yold,	/**< Matrix entry to be annihilated. */
-									real_t& xnew,	/**< Output: Normalised matrix entry. */
-									real_t& ynew,	/**< Output: Annihilated matrix entry. */
-									real_t& c,		/**< Output: Cosine entry of Givens matrix. */
-									real_t& s 		/**< Output: Sine entry of Givens matrix. */
-									) const;
-
-		/** Applies Givens matrix determined by c and s (cf. computeGivens).
-		 *	\return SUCCESSFUL_RETURN */
-		inline void applyGivens(	real_t c,		/**< Cosine entry of Givens matrix. */
-									real_t s,		/**< Sine entry of Givens matrix. */
-									real_t nu, 		/**< Further factor: s/(1+c). */
-									real_t xold,	/**< Matrix entry to be transformed corresponding to
-													 *	 the normalised entry of the original matrix. */
-									real_t yold, 	/**< Matrix entry to be transformed corresponding to
-													 *	 the annihilated entry of the original matrix. */
-									real_t& xnew,	/**< Output: Transformed matrix entry corresponding to
-													 *	 the normalised entry of the original matrix. */
-									real_t& ynew	/**< Output: Transformed matrix entry corresponding to
-													 *	 the annihilated entry of the original matrix. */
-									) const;
-
-
-
-		/** Compute relative length of homotopy in data space for termination
-		 *  criterion.
-		 *  \return Relative length in data space. */
-		real_t getRelativeHomotopyLength(	const real_t* const g_new,		/**< Final gradient. */
-											const real_t* const lb_new,		/**< Final lower variable bounds. */
-											const real_t* const ub_new		/**< Final upper variable bounds. */
-											);
-
-		/** Ramping Strategy to avoid ties. Modifies homotopy start without
-		 *  changing current active set.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue performRamping( );
-
-
-		/** ... */
-		returnValue updateFarBounds(	real_t curFarBound,					/**< ... */
-                                        int_t nRamp,						/**< ... */
-                                        const real_t* const lb_new,			/**< ... */
-                                        real_t* const lb_new_far,			/**< ... */
-                                        const real_t* const ub_new,			/**< ... */
-                                        real_t* const ub_new_far			/**< ... */
-                                        ) const;
-
-
-		/** Performs robustified ratio test yield the maximum possible step length
-		 *  along the homotopy path.
-		 *	\return  SUCCESSFUL_RETURN */
-		returnValue performRatioTest(	int_t nIdx, 						/**< Number of ratios to be checked. */
-										const int_t* const idxList, 		/**< Array containing the indices of all ratios to be checked. */
-										const SubjectTo* const subjectTo,	/**< Bound/Constraint object corresponding to ratios to be checked. */
-										const real_t* const num,	 		/**< Array containing all numerators for performing the ratio test. */
-										const real_t* const den,		 	/**< Array containing all denominators for performing the ratio test. */
-										real_t epsNum,						/**< Numerator tolerance. */
-										real_t epsDen,						/**< Denominator tolerance. */
-										real_t& t,							/**< Output: Maximum possible step length along the homotopy path. */
-										int_t& BC_idx 						/**< Output: Index of blocking constraint. */
-										) const;
-
-		/** Checks whether given ratio is blocking, i.e. limits the maximum step length
-		 *  along the homotopy path to a value lower than given one.
-		 *	\return  SUCCESSFUL_RETURN */
-		inline BooleanType isBlocking(	real_t num,					 		/**< Numerator for performing the ratio test. */
-										real_t den,		 					/**< Denominator for performing the ratio test. */
-										real_t epsNum,						/**< Numerator tolerance. */
-										real_t epsDen,						/**< Denominator tolerance. */
-										real_t& t							/**< Input: Current maximum step length along the homotopy path,
-																			 *   Output: Updated maximum possible step length along the homotopy path. */
-										) const;
-
-
-		/** Creates a sparse diagonal (square-)matrix which is a given
-		 *  multiple of the identity matrix.
-		 *  \return Diagonal matrix \n
-		 */
-		SymSparseMat* createDiagSparseMat(	int_t n,				/**< Row/column dimension of matrix to be created. */
-											real_t diagVal = 1.0	/**< Value of all diagonal entries. */
-											);
-
-
-	/*
-	 *	PRIVATE MEMBER FUNCTIONS
-	 */
-	private:
-		/** Solves a QProblemB whose QP data is assumed to be stored in the member variables.
-		 *  A guess for its primal/dual optimal solution vectors and the corresponding
-		 *  optimal working set can be provided.
-		 *  Note: This function is internally called by all init functions!
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED */
-		returnValue solveInitialQP(	const real_t* const xOpt,			/**< Optimal primal solution vector.*/
-									const real_t* const yOpt,			/**< Optimal dual solution vector. */
-									const Bounds* const guessedBounds,	/**< Optimal working set of bounds for solution (xOpt,yOpt). */
-									const real_t* const _R,				/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix. */
-									int_t& nWSR, 						/**< Input: Maximum number of working set recalculations; \n
-																 		 *	 Output: Number of performed working set recalculations. */
-									real_t* const cputime				/**< Input: Maximum CPU time allowed for QP solution. \n
-																 			 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-									);
-
-		/** Solves an initialised QProblemB using online active set strategy.
-		 *  Note: This function is internally called by all hotstart functions!
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_MAX_NWSR_REACHED \n
-					RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue solveQP(	const real_t* const g_new,			/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const lb_new,			/**< Lower bounds of neighbouring QP to be solved. \n
-													 					 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,			/**< Upper bounds of neighbouring QP to be solved. \n
-													 					 If no upper bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,						/**< Input: Maximum number of working set recalculations; \n
-																		 Output: Number of performed working set recalculations. */
-								real_t* const cputime,				/**< Input: Maximum CPU time allowed for QP solution. \n
-																		 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								int_t  nWSRperformed = 0,			/**< Number of working set recalculations already performed to solve
-																		 this QP within previous solveQP() calls. This number is
-																		 always zero, except for successive calls from solveRegularisedQP()
-																		 or when using the far bound strategy. */
-								BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-								);
-
-
-		/** Solves an initialised QProblemB using online active set strategy.
-		 *  Note: This function is internally called by all hotstart functions!
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_MAX_NWSR_REACHED \n
-					RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue solveRegularisedQP(	const real_t* const g_new,			/**< Gradient of neighbouring QP to be solved. */
-										const real_t* const lb_new,			/**< Lower bounds of neighbouring QP to be solved. \n
-															 					 If no lower bounds exist, a NULL pointer can be passed. */
-										const real_t* const ub_new,			/**< Upper bounds of neighbouring QP to be solved. \n
-															 					 If no upper bounds exist, a NULL pointer can be passed. */
-										int_t& nWSR,						/**< Input: Maximum number of working set recalculations; \n
-																				 Output: Number of performed working set recalculations. */
-										real_t* const cputime,				/**< Input: Maximum CPU time allowed for QP solution. \n
-																				 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-										int_t nWSRperformed = 0,			/**< Number of working set recalculations already performed to solve
-																				 this QP within previous solveRegularisedQP() calls. This number is
-																				 always zero, except for successive calls when using the far bound strategy. */
-										BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-										);
-
-
-		/** Sets up bound data structure according to auxiliaryBounds.
-		 *  (If the working set shall be setup afresh, make sure that
-		 *  bounds data structure has been resetted!)
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUP_WORKINGSET_FAILED \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNOWN_BUG */
-		returnValue setupAuxiliaryWorkingSet(	const Bounds* const auxiliaryBounds,	/**< Working set for auxiliary QP. */
-												BooleanType setupAfresh					/**< Flag indicating if given working set shall be
-																						 *    setup afresh or by updating the current one. */
-												);
-
-		/** Sets up the optimal primal/dual solution of the auxiliary initial QP.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue setupAuxiliaryQPsolution(	const real_t* const xOpt,			/**< Optimal primal solution vector.
-																				 	*	 If a NULL pointer is passed, all entries are set to zero. */
-												const real_t* const yOpt			/**< Optimal dual solution vector.
-																					 *	 If a NULL pointer is passed, all entries are set to zero. */
-												);
-
-		/** Sets up gradient of the auxiliary initial QP for given
-		 *  optimal primal/dual solution and given initial working set
-		 *  (assumes that members X, Y and BOUNDS have already been initialised!).
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue setupAuxiliaryQPgradient( );
-
-		/** Sets up bounds of the auxiliary initial QP for given
-		 *  optimal primal/dual solution and given initial working set
-		 *  (assumes that members X, Y and BOUNDS have already been initialised!).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNKNOWN_BUG */
-		returnValue setupAuxiliaryQPbounds( BooleanType useRelaxation	/**< Flag indicating if inactive bounds shall be relaxed. */
-											);
-
-
-	protected:
-		/** Updates QP vectors, working sets and internal data structures in order to
-			start from an optimal solution corresponding to initial guesses of the working
-			set for bounds
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_SETUP_AUXILIARYQP_FAILED */
-		virtual returnValue setupAuxiliaryQP(	const Bounds* const guessedBounds	/**< Initial guess for working set of bounds. */
-												);
-
-	private:
-		/** Determines step direction of the homotopy path.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_STEPDIRECTION_FAILED_CHOLESKY */
-		returnValue determineStepDirection(	const real_t* const delta_g,	/**< Step direction of gradient vector. */
-											const real_t* const delta_lb,	/**< Step direction of lower bounds. */
-											const real_t* const delta_ub,	/**< Step direction of upper bounds. */
-											BooleanType Delta_bB_isZero,	/**< Indicates if active bounds are to be shifted. */
-											real_t* const delta_xFX, 		/**< Output: Primal homotopy step direction of fixed variables. */
-											real_t* const delta_xFR,	 	/**< Output: Primal homotopy step direction of free variables. */
-											real_t* const delta_yFX 		/**< Output: Dual homotopy step direction of fixed variables' multiplier. */
-											);
-
-		/** Determines the maximum possible step length along the homotopy path
-		 *  and performs this step (without changing working set).
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QP_INFEASIBLE \n
-		 */
-		returnValue performStep(	const real_t* const delta_g,	/**< Step direction of gradient. */
-									const real_t* const delta_lb,	/**< Step direction of lower bounds. */
-									const real_t* const delta_ub,	/**< Step direction of upper bounds. */
-									const real_t* const delta_xFX, 	/**< Primal homotopy step direction of fixed variables. */
-									const real_t* const delta_xFR,	/**< Primal homotopy step direction of free variables. */
-									const real_t* const delta_yFX,	/**< Dual homotopy step direction of fixed variables' multiplier. */
-									int_t& BC_idx, 					/**< Output: Index of blocking constraint. */
-									SubjectToStatus& BC_status		/**< Output: Status of blocking constraint. */
-									);
-
-		/** Updates active set.
-		 *	\return  SUCCESSFUL_RETURN \n
-		 			 RET_REMOVE_FROM_ACTIVESET_FAILED \n
-					 RET_ADD_TO_ACTIVESET_FAILED */
-		returnValue changeActiveSet(	int_t BC_idx, 						/**< Index of blocking constraint. */
-										SubjectToStatus BC_status 			/**< Status of blocking constraint. */
-										);
-
-		/** Drift correction at end of each active set iteration
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue performDriftCorrection( );
-
-		/** Determines if it is more efficient to refactorise the matrices when
-		 *  hotstarting or not (i.e. better to update the existing factorisations).
-		 *	\return BT_TRUE iff matrices shall be refactorised afresh
-		 */
-		BooleanType shallRefactorise(	const Bounds* const guessedBounds	/**< Guessed new working set. */
-										) const;
-
-
-		/** Adds a bound to active set (specialised version for the case where no constraints exist).
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDBOUND_FAILED */
-		returnValue addBound(	int_t number,				/**< Number of bound to be added to active set. */
-								SubjectToStatus B_status,	/**< Status of new active bound. */
-								BooleanType updateCholesky	/**< Flag indicating if Cholesky decomposition shall be updated. */
-								);
-
-		/** Removes a bounds from active set (specialised version for the case where no constraints exist).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HESSIAN_NOT_SPD \n
-					RET_REMOVEBOUND_FAILED */
-		returnValue removeBound(	int_t number,				/**< Number of bound to be removed from active set. */
-									BooleanType updateCholesky	/**< Flag indicating if Cholesky decomposition shall be updated. */
-									);
-
-
-		/** Prints concise information on the current iteration.
-		 *	\return  SUCCESSFUL_RETURN \n */
-		returnValue printIteration(	int_t iter,							/**< Number of current iteration. */
-									int_t BC_idx, 						/**< Index of blocking bound. */
-									SubjectToStatus BC_status,			/**< Status of blocking bound. */
-									real_t homotopyLength,				/**< Current homotopy distance. */
-									BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-									);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		BooleanType freeHessian;	/**< Flag indicating whether the Hessian matrix needs to be de-allocated. */
-		SymmetricMatrix* H;			/**< Hessian matrix. */
-
-		real_t* g;					/**< Gradient. */
-		real_t* lb;					/**< Lower bound vector (on variables). */
-		real_t* ub;					/**< Upper bound vector (on variables). */
-
-		Bounds bounds;				/**< Data structure for problem's bounds. */
-
-		real_t* R;					/**< Cholesky factor of H (i.e. H = R^T*R). */
-		BooleanType haveCholesky;	/**< Flag indicating whether Cholesky decomposition has already been setup. */
-
-		real_t* x;					/**< Primal solution vector. */
-		real_t* y;					/**< Dual solution vector. */
-
-		real_t tau;					/**< Last homotopy step length. */
-
-		QProblemStatus status;		/**< Current status of the solution process. */
-
-		BooleanType infeasible;		/**< QP infeasible? */
-		BooleanType unbounded;		/**< QP unbounded? */
-
-		HessianType hessianType;	/**< Type of Hessian matrix. */
-		real_t regVal;				/**< Holds the offset used to regularise Hessian matrix (zero by default). */
-
-		uint_t count;				/**< Counts the number of hotstart function calls. */
-
-		real_t *delta_xFR_TMP;		/**< Temporary for determineStepDirection */
-
-		real_t ramp0;				/**< Start value for Ramping Strategy. */
-		real_t ramp1;				/**< Final value for Ramping Strategy. */
-		int_t rampOffset;			/**< Offset index for Ramping. */
-
-		Options options;			/**< Struct containing all user-defined options for solving QPs. */
-
-		Flipper flipper;			/**< Struct for making a temporary copy of the matrix factorisations. */
-
-		TabularOutput tabularOutput;	/**< Struct storing information for tabular output (printLevel == PL_TABULAR). */
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/QProblemB.ipp>
-
-#endif	/* QPOASES_QPROBLEMB_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.ipp
deleted file mode 100644
index 464f1ae..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.ipp
+++ /dev/null
@@ -1,496 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/QProblemB.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the QProblemB class which
- *	is able to use the newly developed online active set strategy for
- *	parametric quadratic programming.
- */
-
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-/*
- *	g e t B o u n d s
- */
-inline returnValue QProblemB::getBounds( Bounds& _bounds ) const
-{
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	_bounds = bounds;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t N V
- */
-inline int_t QProblemB::getNV( ) const
-{
-	return bounds.getNV( );
-}
-
-
-/*
- *	g e t N F R
- */
-inline int_t QProblemB::getNFR( ) const
-{
-	return bounds.getNFR( );
-}
-
-
-/*
- *	g e t N F X
- */
-inline int_t QProblemB::getNFX( ) const
-{
-	return bounds.getNFX( );
-}
-
-
-/*
- *	g e t N F V
- */
-inline int_t QProblemB::getNFV( ) const
-{
-	return bounds.getNFV( );
-}
-
-
-/*
- *	g e t S t a t u s
- */
-inline QProblemStatus QProblemB::getStatus( ) const
-{
-	return status;
-}
-
-
-/*
- *	i s I n i t i a l i s e d
- */
-inline BooleanType QProblemB::isInitialised( ) const
-{
-	if ( status == QPS_NOTINITIALISED )
-		return BT_FALSE;
-	else
-		return BT_TRUE;
-}
-
-
-/*
- *	i s S o l v e d
- */
-inline BooleanType QProblemB::isSolved( ) const
-{
-	if ( status == QPS_SOLVED )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *	i s I n f e a s i b l e
- */
-inline BooleanType QProblemB::isInfeasible( ) const
-{
-	return infeasible;
-}
-
-
-/*
- *	i s U n b o u n d e d
- */
-inline BooleanType QProblemB::isUnbounded( ) const
-{
-	return unbounded;
-}
-
-
-/*
- *	g e t H e s s i a n T y p e
- */
-inline HessianType QProblemB::getHessianType( ) const
-{
-	return hessianType;
-}
-
-
-/*
- *	s e t H e s s i a n T y p e
- */
-inline returnValue QProblemB::setHessianType( HessianType _hessianType )
-{
-	hessianType = _hessianType;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	u s i n g R e g u l a r i s a t i o n
- */
-inline BooleanType QProblemB::usingRegularisation( ) const
-{
-	if ( regVal > ZERO )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *	g e t O p t i o n s
- */
-inline Options QProblemB::getOptions( ) const
-{
-	return options;
-}
-
-
-/*
- *	s e t O p t i o n s
- */
-inline returnValue QProblemB::setOptions(	const Options& _options
-											)
-{
-	options = _options;
-	options.ensureConsistency( );
-
-	setPrintLevel( options.printLevel );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t P r i n t L e v e l
- */
-inline PrintLevel QProblemB::getPrintLevel( ) const
-{
-	return options.printLevel;
-}
-
-
-
-/*
- *	g e t C o u n t
- */
-inline uint_t QProblemB::getCount( ) const
-{
-	return count;
-}
-
-
-/*
- *	r e s e t C o u n t e r
- */
-inline returnValue QProblemB::resetCounter( )
-{
-	count = 0;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	s e t H
- */
-inline returnValue QProblemB::setH( SymmetricMatrix* H_new )
-{
-	if ( ( freeHessian == BT_TRUE ) && ( H != 0 ) )
-	{
-		delete H;
-		H = 0;
-	}
-
-	H = H_new;
-	freeHessian = BT_FALSE;
-	
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t H
- */
-inline returnValue QProblemB::setH( const real_t* const H_new )
-{
-	int_t nV = getNV();
-	SymDenseMat* dH;
-
-	/* if null pointer is passed, Hessian is set to zero matrix
-	 *                            (or stays identity matrix) */
-	if ( H_new == 0 )
-	{
-		if ( hessianType == HST_IDENTITY )
-			return SUCCESSFUL_RETURN;
-
-		hessianType = HST_ZERO;
-
-		if ( ( freeHessian == BT_TRUE ) && ( H != 0 ) )
-			delete H;
-
-		H = 0;
-		freeHessian = BT_FALSE;
-	}
-	else
-	{
-		if ( ( freeHessian == BT_TRUE ) && ( H != 0 ) )
-			delete H;
-
-		H = dH = new SymDenseMat( nV, nV, nV, (real_t*) H_new );
-		freeHessian = BT_TRUE;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t G
- */
-inline returnValue QProblemB::setG( const real_t* const g_new )
-{
-	uint_t nV = (uint_t)getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( g_new == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	memcpy( g,g_new,nV*sizeof(real_t) );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t L B
- */
-inline returnValue QProblemB::setLB( const real_t* const lb_new )
-{
-	uint_t i;
-	uint_t nV = (uint_t)getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( lb_new != 0 )
-	{
-		memcpy( lb,lb_new,nV*sizeof(real_t) );
-	}
-	else
-	{
-		/* if no lower bounds are specified, set them to -infinity */
-		for( i=0; i<nV; ++i )
-			lb[i] = -INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t L B
- */
-inline returnValue QProblemB::setLB( int_t number, real_t value )
-{
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ( number >= 0 ) && ( number < nV ) )
-	{
-		lb[number] = value;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-	{
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-	}
-}
-
-
-/*
- *	s e t U B
- */
-inline returnValue QProblemB::setUB( const real_t* const ub_new )
-{
-	uint_t i;
-	uint_t nV = (uint_t)getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ub_new != 0 )
-	{
-		memcpy( ub,ub_new,nV*sizeof(real_t) );
-	}
-	else
-	{
-		/* if no upper bounds are specified, set them to infinity */
-		for( i=0; i<nV; ++i )
-			ub[i] = INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t U B
- */
-inline returnValue QProblemB::setUB( int_t number, real_t value )
-{
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ( number >= 0 ) && ( number < nV ) )
-	{
-		ub[number] = value;
-
-		return SUCCESSFUL_RETURN;
-	}
-	else
-	{
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-	}
-}
-
-
-/*
- *	c o m p u t e G i v e n s
- */
-inline void QProblemB::computeGivens(	real_t xold, real_t yold, real_t& xnew, real_t& ynew,
-										real_t& c, real_t& s
-										) const
-{
-	real_t t, mu;
-
-	if ( isZero( yold ) == BT_TRUE )
-	{
-		c = 1.0;
-		s = 0.0;
-
-		xnew = xold;
-		ynew = yold;
-	}
-	else
-	{
-		mu = getAbs( xold );
-		if ( getAbs( yold ) > mu )
-			mu = getAbs( yold );
-
-		t = mu * getSqrt( (xold/mu)*(xold/mu) + (yold/mu)*(yold/mu) );
-
-		if ( xold < 0.0 )
-		t = -t;
-
-		c = xold/t;
-		s = yold/t;
-		xnew = t;
-		ynew = 0.0;
-	}
-
-	return;
-}
-
-
-/*
- *	a p p l y G i v e n s
- */
-inline void QProblemB::applyGivens(	real_t c, real_t s, real_t /*nu*/, real_t xold, real_t yold,
-									real_t& xnew, real_t& ynew
-									) const
-{
-	#ifdef __USE_THREE_MULTS_GIVENS__
-
-	/* Givens plane rotation requiring only three multiplications,
-	 * cf. Hammarling, S.: A note on modifications to the givens plane rotation.
-	 * J. Inst. Maths Applics, 13:215-218, 1974. */
-	xnew = xold*c + yold*s;
-	ynew = (xnew+xold)*nu - yold;
-
-	#else
-
-	/* Usual Givens plane rotation requiring four multiplications. */
-	xnew =  c*xold + s*yold;
-	ynew = -s*xold + c*yold;
-
-	#endif
-
-	return;
-}
-
-
-/*
- * i s B l o c k i n g
- */
-inline BooleanType QProblemB::isBlocking(	real_t num,
-											real_t den,
-											real_t epsNum,
-											real_t epsDen,
-											real_t& t
-											) const
-{
-	if ( ( den >= epsDen ) && ( num >= epsNum ) )
-	{
-		if ( num < t*den )
-			return BT_TRUE;
-	}
-
-	return BT_FALSE;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.hpp
deleted file mode 100644
index f1e3552..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.hpp
+++ /dev/null
@@ -1,358 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SQProblem.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the SQProblem class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming
- *	with varying matrices.
- */
-
-
-
-#ifndef QPOASES_SQPROBLEM_HPP
-#define QPOASES_SQPROBLEM_HPP
-
-
-#include <qpOASES/QProblem.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Implements the online active set strategy for QPs with varying matrices.
- *
- *	A class for setting up and solving quadratic programs with varying QP matrices.
- *	The main feature is the possibily to use the newly developed online active set strategy
- *	for parametric quadratic programming.
- *
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-class SQProblem : public QProblem
-{
-	/* allow SolutionAnalysis class to access private members */
-	friend class SolutionAnalysis;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		SQProblem( );
-
-		/** Constructor which takes the QP dimension and Hessian type
-		 *  information. If the Hessian is the zero (i.e. HST_ZERO) or the
-		 *  identity matrix (i.e. HST_IDENTITY), respectively, no memory
-		 *  is allocated for it and a NULL pointer can be passed for it
-		 *  to the init() functions. */
-		SQProblem(	int_t _nV,	  							/**< Number of variables. */
-					int_t _nC,  							/**< Number of constraints. */
-					HessianType _hessianType = HST_UNKNOWN	/**< Type of Hessian matrix. */
-					);
-
-		/** Copy constructor (deep copy). */
-		SQProblem(	const SQProblem& rhs	/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~SQProblem( );
-
-		/** Assignment operator (deep copy). */
-		virtual SQProblem& operator=(	const SQProblem& rhs	/**< Rhs object. */
-								);
-
-
-		/** Solves an initialised QP sequence with matrix shift using
-		 *	the online active set strategy.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_MATRIX_SHIFT_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_SETUP_AUXILIARYQP_FAILED */
-		returnValue hotstart(	SymmetricMatrix *H_new,							/**< Hessian matrix of neighbouring QP to be solved (a shallow copy is made). \n
-																					 If Hessian matrix is trivial, a NULL pointer can be passed. */
-								const real_t* const g_new,						/**< Gradient of neighbouring QP to be solved. */
-								Matrix *A_new,									/**< Constraint matrix of neighbouring QP to be solved (a shallow copy is made). \n
-																					 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-								const real_t* const lb_new,						/**< Lower bounds of neighbouring QP to be solved. \n
-													 								 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,						/**< Upper bounds of neighbouring QP to be solved. \n
-													 		 						 If no upper bounds exist, a NULL pointer can be passed. */
-								const real_t* const lbA_new,					/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-													 		 						 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const real_t* const ubA_new,					/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-												 			 						 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,									/**< Input: Maximum number of working set recalculations; \n
-																					 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																					 Output: CPU time spen for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-		/** Solves an initialised QP sequence with matrix shift using
-		 *	the online active set strategy.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_MATRIX_SHIFT_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_SETUP_AUXILIARYQP_FAILED */
-		returnValue hotstart(	const real_t* const H_new,						/**< Hessian matrix of neighbouring QP to be solved (a shallow copy is made). \n
-																					 If Hessian matrix is trivial, a NULL pointer can be passed. */
-								const real_t* const g_new,						/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const A_new,						/**< Constraint matrix of neighbouring QP to be solved (a shallow copy is made). \n
-																					 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-								const real_t* const lb_new,						/**< Lower bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,						/**< Upper bounds of neighbouring QP to be solved. \n
-													 							 	 If no upper bounds exist, a NULL pointer can be passed. */
-								const real_t* const lbA_new,					/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const real_t* const ubA_new,					/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-												 								 	 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,									/**< Input: Maximum number of working set recalculations; \n
-																					 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																					 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-		/** Solves an initialised QP sequence with matrix shift using
-		 *	the online active set strategy, where QP data is read from files.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_MATRIX_SHIFT_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_SETUP_AUXILIARYQP_FAILED \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue hotstart(	const char* const H_file,						/**< Name of file where Hessian matrix is stored. \n
-																					 If Hessian matrix is trivial, a NULL pointer can be passed. */
-								const char* const g_file,						/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-								const char* const A_file,						/**< Name of file where constraint matrix is stored. \n
-																					 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-								const char* const lb_file,						/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower bounds exist, a NULL pointer can be passed. */
-								const char* const ub_file, 						/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper bounds exist, a NULL pointer can be passed. */
-								const char* const lbA_file,						/**< Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const char* const ubA_file,						/**< Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,									/**< Input: Maximum number of working set recalculations; \n
-																					 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																					 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-		/** Solves an initialised QP sequence (without matrix shift) using
-		 *	the online active set strategy.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This functions just forwards to the corresponding
-		 *  	  QProblem::hotstart member function.
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue hotstart(	const real_t* const g_new,						/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const lb_new,						/**< Lower bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,						/**< Upper bounds of neighbouring QP to be solved. \n
-													 							 	 If no upper bounds exist, a NULL pointer can be passed. */
-								const real_t* const lbA_new,					/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const real_t* const ubA_new,					/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-													 							 	 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,									/**< Input: Maximum number of working set recalculations; \n
-																			 		 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																				 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-		/** Solves an initialised QP sequence (without matrix shift) using
-		 *  the online active set strategy, where QP data is read from files.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This functions just forwards to the corresponding
-		 *  	  QProblem::hotstart member function.
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue hotstart(	const char* const g_file,						/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-								const char* const lb_file,					 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower bounds exist, a NULL pointer can be passed. */
-								const char* const ub_file,						/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper bounds exist, a NULL pointer can be passed. */
-								const char* const lbA_file,						/**< Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const char* const ubA_file,						/**< Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR, 									/**< Input: Maximum number of working set recalculations; \n
-																					 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																				 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-
-		#ifdef __MATLAB__
-		/** Sets pointer of Hessian and constraint matrix to zero.
-		 *  QUICK HACK FOR MAKING THE MATLAB INTERFACE RUN! TO BE REMOVED!
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue resetMatrixPointers( );
-		#endif
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-
-		/** Sets new matrices and calculates their factorisations. If the
-		 *  current Hessian is trivial (i.e. HST_ZERO or HST_IDENTITY) but a
-		 *  non-trivial one is given, memory for Hessian is allocated and
-		 *  it is set to the given one. Afterwards, all QP vectors are
-		 *  transformed in order to start from an optimal solution.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_MATRIX_FACTORISATION_FAILED \n
-		 * 			RET_NO_HESSIAN_SPECIFIED */
-		virtual returnValue setupNewAuxiliaryQP(	SymmetricMatrix *H_new,		/**< New Hessian matrix. \n
-																					 If Hessian matrix is trivial, a NULL pointer can be passed. */
-													Matrix *A_new,				/**< New constraint matrix. \n
-																					 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-													const real_t *lb_new,		/**< New lower bounds. \n
-														 						 	 If no lower bounds exist, a NULL pointer can be passed. */
-													const real_t *ub_new,		/**< New upper bounds. \n
-														 						 	 If no lower bounds exist, a NULL pointer can be passed. */
-													const real_t *lbA_new,		/**< New lower constraints' bounds. \n
-														 						 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-													const real_t *ubA_new		/**< New lower constraints' bounds. \n
-														 						 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-													);
-
-		/** Sets new matrices and calculates their factorisations. If the
-		 *  current Hessian is trivial (i.e. HST_ZERO or HST_IDENTITY) but a
-		 *  non-trivial one is given, memory for Hessian is allocated and
-		 *  it is set to the given one. Afterwards, all QP vectors are
-		 *  transformed in order to start from an optimal solution.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_MATRIX_FACTORISATION_FAILED \n
-		 * 			RET_NO_HESSIAN_SPECIFIED */
-		virtual returnValue setupNewAuxiliaryQP(	const real_t* const H_new,	/**< New Hessian matrix. \n
-																	     		 	 If Hessian matrix is trivial, a NULL pointer can be passed. */
-													const real_t* const A_new,	/**< New constraint matrix. \n
-																	     		 	 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-													const real_t *lb_new,		/**< New lower bounds. \n
-														 						 	 If no lower bounds exist, a NULL pointer can be passed. */
-													const real_t *ub_new,		/**< New upper bounds. \n
-														 						 	 If no lower bounds exist, a NULL pointer can be passed. */
-													const real_t *lbA_new,		/**< New lower constraints' bounds. \n
-														 						 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-													const real_t *ubA_new		/**< New lower constraints' bounds. \n
-														 						 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-													);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/SQProblem.ipp>
-
-#endif	/* QPOASES_SQPROBLEM_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.ipp
deleted file mode 100644
index d56c42a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.ipp
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SQProblem.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the SQProblem class which
- *	is able to use the newly developed online active set strategy for
- *	parametric quadratic programming with varying matrices.
- */
-
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.hpp
deleted file mode 100644
index 7f09695..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.hpp
+++ /dev/null
@@ -1,475 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2014 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SQProblemSchur.hpp
- *	\author Andreas Waechter and Dennis Janka, based on QProblem.hpp by Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2012-2015
- *
- *	Declaration of the SQProblemSchur class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming
- *	with varying matrices and uses a Schur Complement approach to solve
- *	the linear systems.
- */
-
-
-#ifndef QPOASES_SQPROBLEMSCHUR_HPP
-#define QPOASES_SQPROBLEMSCHUR_HPP
-
-
-#include <qpOASES/SQProblem.hpp>
-#include <qpOASES/SparseSolver.hpp>
-
-#ifdef __USE_SINGLE_PRECISION__
-
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	//#define GEQRF sgeqrf_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	//#define ORMQR sormqr_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define TRTRS strtrs_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define TRCON strcon_
-
-#else
-
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	//#define GEQRF dgeqrf_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	//#define ORMQR dormqr_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define TRTRS dtrtrs_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define TRCON dtrcon_
-
-#endif /* __USE_SINGLE_PRECISION__ */
-
-extern "C" {
-	/** Compute a QR factorization of a real M-by-N matrix A in double precision */
-	//void dgeqrf_(	const unsigned long *M, const unsigned long *N, double *A, const unsigned long *LDA,
-					//double *TAU, double *WORK, const unsigned long *LWORK, int *INFO );
-	/** Compute a QR factorization of a real M-by-N matrix A in single precision */
-	//void sgeqrf_(	const unsigned long *M, const unsigned long *N, float *A, const unsigned long *LDA,
-					//float *TAU, float *WORK, const unsigned long *LWORK, int *INFO );
-
-	/** Multiply C with orthogonal matrix Q**T as returned by geqrf (double precision) */
-	//void dormqr_(	const char *SIDE, const char *TRANS, const unsigned long *M, const unsigned long *N, const unsigned long *K,
-					//double *A, const unsigned long *LDA, double *TAU, double *C, const unsigned long *LDC,
-					//double *WORK, const unsigned long *LWORK, int *INFO );
-	/** Multiply C with orthogonal matrix Q**T as returned by geqrf (single precision) */
-	//void sormqr_(	const char *SIDE, const char *TRANS, const unsigned long *M, const unsigned long *N, const unsigned long *K,
-					//float *A, const unsigned long *LDA, float *TAU, float *C, const unsigned long *LDC,
-					//float *WORK, const unsigned long *LWORK, int *INFO );
-
-	/** Solve a triangular system (double precision) */
-	void dtrtrs_(	const char *UPLO, const char *TRANS, const char *DIAG, const unsigned long *N, const unsigned long *NRHS,
-					double *A, const unsigned long *LDA, double *B, const unsigned long *LDB, long *INFO );
-	/** Solve a triangular system (single precision) */
-	void strtrs_(	const char *UPLO, const char *TRANS, const char *DIAG, const unsigned long *N, const unsigned long *NRHS,
-					float *A, const unsigned long *LDA, float *B, const unsigned long *LDB, long *INFO );
-
-	/** Estimate the reciprocal of the condition number of a triangular matrix in double precision */
-	void dtrcon_(	const char *NORM, const char *UPLO, const char *DIAG, const unsigned long *N, double *A, const unsigned long *LDA,
-					double *RCOND, double *WORK, const unsigned long *IWORK, long *INFO );
-	/** Estimate the reciprocal of the condition number of a triangular matrix in single precision */
-	void strcon_(	const char *NORM, const char *UPLO, const char *DIAG, const unsigned long *N, float *A, const unsigned long *LDA,
-					float *RCOND, float *WORK, const unsigned long *IWORK, long *INFO );
-}
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Implements the online active set strategy for QPs with varying, sparse matrices.
- *
- *	A class for setting up and solving quadratic programs with varying,
- *	sparse QP matrices. Here, sparsity is exploited by means of a
- *	Schur complement approach to solve the linear systems.
- *
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- */
-class SQProblemSchur : public SQProblem
-{
-	/* allow SolutionAnalysis class to access private members */
-	friend class SolutionAnalysis;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		SQProblemSchur( );
-
-		/** Constructor which takes the QP dimension and Hessian type
-		 *  information. If the Hessian is the zero (i.e. HST_ZERO) or the
-		 *  identity matrix (i.e. HST_IDENTITY), respectively, no memory
-		 *  is allocated for it and a NULL pointer can be passed for it
-		 *  to the init() functions. */
-		SQProblemSchur(	int_t _nV,	  								/**< Number of variables. */
-						int_t _nC,		  							/**< Number of constraints. */
-						HessianType _hessianType = HST_UNKNOWN,	/**< Type of Hessian matrix. */
-						int_t maxSchurUpdates = 75					/**< Maximal number of Schur updates */
-						);
-
-		/** Copy constructor (deep copy). */
-		SQProblemSchur(	const SQProblemSchur& rhs		/**< Rhs object. */
-						);
-
-		/** Destructor. */
-		virtual ~SQProblemSchur( );
-
-		/** Assignment operator (deep copy). */
-		virtual SQProblemSchur& operator=(	const SQProblemSchur& rhs	/**< Rhs object. */
-											);
-
-		/** Clears all data structures of QProblem except for QP data.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_RESET_FAILED */
-		virtual returnValue reset( );
-
-		/** Resets Schur complement.  This sets up the KKT matrix for the
-			current activities, copies the activities, etc. TODO: Return values */
-		returnValue resetSchurComplement( BooleanType allowInertiaCorrection );
-
-		/** Return the total number of sparse matrix factorizations performed so far. */
-		inline int_t getNumFactorizations( ) const;
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const SQProblemSchur& rhs	/**< Rhs object. */
-							);
-
-		/** Computes the Cholesky decomposition of the projected Hessian (i.e. R^T*R = Z^T*H*Z).
-		 *  For the Schur complement version, this function only returns SUCCESSFUL_RETURN. */
-		virtual returnValue computeProjectedCholesky( );
-
-		/** Computes initial Cholesky decomposition of the projected Hessian making
-		 *  use of the function setupCholeskyDecomposition() or setupCholeskyDecompositionProjected().
-		 *  For the Schur complement version, this function only returns SUCCESSFUL_RETURN. */
-		virtual returnValue computeInitialCholesky( );
-
-		/** Initialises TQ factorisation of A (i.e. A*Q = [0 T]) if NO constraint is active.
-		 *  For the Schur complement version, this function only returns SUCCESSFUL_RETURN. */
-		virtual returnValue setupTQfactorisation( );
-
-		/** This method is overloaded from SQProblem.
-		 *  Sets new matrices and calculates their factorisations. If the
-		 *  current Hessian is trivial (i.e. HST_ZERO or HST_IDENTITY) but a
-		 *  non-trivial one is given, memory for Hessian is allocated and
-		 *  it is set to the given one. Afterwards, all QP vectors are
-		 *  transformed in order to start from an optimal solution.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_MATRIX_FACTORISATION_FAILED \n
-		 * 			RET_NO_HESSIAN_SPECIFIED */
-		virtual returnValue setupAuxiliaryQP(	SymmetricMatrix *H_new,		/**< New Hessian matrix. \n
-																				 If Hessian matrix is trivial, a NULL pointer can be passed. */
-												Matrix *A_new,				/**< New constraint matrix. \n
-																				 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-												const real_t *lb_new,
-												const real_t *ub_new,
-												const real_t *lbA_new,
-												const real_t *ubA_new
-												);
-
-		/** Setup bounds and constraints data structures according to auxiliaryBounds/Constraints.
-		 *  Calls the sparse solver to obtain the factorization for the initial active set.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUP_WORKINGSET_FAILED \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNOWN_BUG */
-		virtual returnValue setupAuxiliaryWorkingSet(	const Bounds* const auxiliaryBounds,
-														const Constraints* const auxiliaryConstraints,
-														BooleanType setupAfresh
-														);
-
-
-		/** Adds a constraint to active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDCONSTRAINT_FAILED \n
-					RET_ADDCONSTRAINT_FAILED_INFEASIBILITY \n
-					RET_ENSURELI_FAILED */
-		virtual returnValue addConstraint(	int_t number,					/**< Number of constraint to be added to active set. */
-											SubjectToStatus C_status,		/**< Status of new active constraint. */
-											BooleanType updateCholesky,		/**< Flag indicating if Cholesky decomposition shall be updated. */
-											BooleanType ensureLI = BT_TRUE	/**< Ensure linear independence by exchange rules by default. */
-											);
-
-		/** Checks if new active constraint to be added is linearly dependent from
-		 *	from row of the active constraints matrix.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT \n
-					 RET_INDEXLIST_CORRUPTED */
-		virtual returnValue addConstraint_checkLI(	int_t number	/**< Number of constraint to be added to active set. */
-											);
-
-		/** Ensures linear independence of constraint matrix when a new constraint is added.
-		 * 	To this end a bound or constraint is removed simultaneously if necessary.
-		 *	\return	 SUCCESSFUL_RETURN \n
-		 			 RET_LI_RESOLVED \n
-					 RET_ENSURELI_FAILED \n
-					 RET_ENSURELI_FAILED_TQ \n
-					 RET_ENSURELI_FAILED_NOINDEX \n
-					 RET_REMOVE_FROM_ACTIVESET */
-		virtual returnValue addConstraint_ensureLI(	int_t number,				/**< Number of constraint to be added to active set. */
-														SubjectToStatus C_status	/**< Status of new active bound. */
-														);
-
-		/** Adds a bound to active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDBOUND_FAILED \n
-					RET_ADDBOUND_FAILED_INFEASIBILITY \n
-					RET_ENSURELI_FAILED */
-		virtual returnValue addBound(	int_t number,					/**< Number of bound to be added to active set. */
-										SubjectToStatus B_status,		/**< Status of new active bound. */
-										BooleanType updateCholesky,		/**< Flag indicating if Cholesky decomposition shall be updated. */
-										BooleanType ensureLI = BT_TRUE	/**< Ensure linear independence by exchange rules by default. */
-										);
-
-		/** Checks if new active bound to be added is linearly dependent from
-		 *	from row of the active constraints matrix.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT */
-		virtual returnValue addBound_checkLI(	int_t number	/**< Number of bound to be added to active set. */
-												);
-
-		/** Ensures linear independence of constraint matrix when a new bound is added.
-		 *	To this end a bound or constraint is removed simultaneously if necessary.
-		 *	\return	 SUCCESSFUL_RETURN \n
-		 			 RET_LI_RESOLVED \n
-					 RET_ENSURELI_FAILED \n
-					 RET_ENSURELI_FAILED_TQ \n
-					 RET_ENSURELI_FAILED_NOINDEX \n
-					 RET_REMOVE_FROM_ACTIVESET */
-		virtual returnValue addBound_ensureLI(	int_t number,				/**< Number of bound to be added to active set. */
-												SubjectToStatus B_status	/**< Status of new active bound. */
-												);
-
-		/** Removes a constraint from active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_CONSTRAINT_NOT_ACTIVE \n
-					RET_REMOVECONSTRAINT_FAILED \n
-					RET_HESSIAN_NOT_SPD */
-		virtual returnValue removeConstraint(	int_t number,							/**< Number of constraint to be removed from active set. */
-												BooleanType updateCholesky,				/**< Flag indicating if Cholesky decomposition shall be updated. */
-												BooleanType allowFlipping = BT_FALSE,	/**< Flag indicating if flipping bounds are allowed. */
-												BooleanType ensureNZC = BT_FALSE		/**< Flag indicating if non-zero curvature is ensured by exchange rules. */
-												);
-
-		/** Removes a bounds from active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_BOUND_NOT_ACTIVE \n
-					RET_HESSIAN_NOT_SPD \n
-					RET_REMOVEBOUND_FAILED */
-		virtual returnValue removeBound(	int_t number,							/**< Number of bound to be removed from active set. */
-											BooleanType updateCholesky,				/**< Flag indicating if Cholesky decomposition shall be updated. */
-											BooleanType allowFlipping = BT_FALSE,	/**< Flag indicating if flipping bounds are allowed. */
-											BooleanType ensureNZC = BT_FALSE		/**< Flag indicating if non-zero curvature is ensured by exchange rules. */
-											);
-
-		/** Solves the system Ta = b or T^Ta = b where T is a reverse upper triangular matrix.
-		 *	 This must not be called for the Schur complement version. */
-		virtual returnValue backsolveT( 	const real_t* const b,	/**< Right hand side vector. */
-											BooleanType transposed,	/**< Indicates if the transposed system shall be solved. */
-											real_t* const a 		/**< Output: Solution vector */
-											) const;
-
-		/** Solves the system Ra = b or R^Ta = b where R is an upper triangular matrix.
-		 *	This must not be called for the Schur complement version. */
-		virtual returnValue backsolveR( 	const real_t* const b,	/**< Right hand side vector. */
-											BooleanType transposed,	/**< Indicates if the transposed system shall be solved. */
-											real_t* const a 		/**< Output: Solution vector */
-											) const;
-
-		/** Solves the system Ra = b or R^Ta = b where R is an upper triangular matrix. \n
-		 *	This must not be called for the Schur complement version. */
-		virtual returnValue backsolveR( 	const real_t* const b,		/**< Right hand side vector. */
-											BooleanType transposed,		/**< Indicates if the transposed system shall be solved. */
-											BooleanType removingBound,	/**< Indicates if function is called from "removeBound()". */
-											real_t* const a 			/**< Output: Solution vector */
-											) const;
-
-
-		/** Determines step direction of the homotopy path.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_STEPDIRECTION_FAILED_TQ \n
-					RET_STEPDIRECTION_FAILED_CHOLESKY */
-		virtual returnValue determineStepDirection(	const real_t* const delta_g,	/**< Step direction of gradient vector. */
-														const real_t* const delta_lbA,	/**< Step direction of lower constraints' bounds. */
-														const real_t* const delta_ubA,	/**< Step direction of upper constraints' bounds. */
-														const real_t* const delta_lb,	/**< Step direction of lower bounds. */
-														const real_t* const delta_ub,	/**< Step direction of upper bounds. */
-														BooleanType Delta_bC_isZero, 	/**< Indicates if active constraints' bounds are to be shifted. */
-														BooleanType Delta_bB_isZero,	/**< Indicates if active bounds are to be shifted. */
-														real_t* const delta_xFX, 		/**< Output: Primal homotopy step direction of fixed variables. */
-														real_t* const delta_xFR,	 	/**< Output: Primal homotopy step direction of free variables. */
-														real_t* const delta_yAC, 		/**< Output: Dual homotopy step direction of active constraints' multiplier. */
-														real_t* const delta_yFX 		/**< Output: Dual homotopy step direction of fixed variables' multiplier. */
-														);
-
-		virtual returnValue determineStepDirection2(	const real_t* const delta_g,	/**< Step direction of gradient vector. */
-														const real_t* const delta_lbA,	/**< Step direction of lower constraints' bounds. */
-														const real_t* const delta_ubA,	/**< Step direction of upper constraints' bounds. */
-														const real_t* const delta_lb,	/**< Step direction of lower bounds. */
-														const real_t* const delta_ub,	/**< Step direction of upper bounds. */
-														BooleanType Delta_bC_isZero, 	/**< Indicates if active constraints' bounds are to be shifted. */
-														BooleanType Delta_bB_isZero,	/**< Indicates if active bounds are to be shifted. */
-														real_t* const delta_xFX, 		/**< Output: Primal homotopy step direction of fixed variables. */
-														real_t* const delta_xFR,	 	/**< Output: Primal homotopy step direction of free variables. */
-														real_t* const delta_yAC, 		/**< Output: Dual homotopy step direction of active constraints' multiplier. */
-														real_t* const delta_yFX 		/**< Output: Dual homotopy step direction of fixed variables' multiplier. */
-														);
-
-	/*
-	 *	PRIVATE MEMBER FUNCTION
-	 */
-	private:
-		/** Checks if new active bound to be added is linearly dependent from
-		 *	from row of the active constraints matrix.  This version computes
-		 *	the multipliers in the (full) test.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT */
-		returnValue addBound_checkLISchur(	int_t number,			/**< Number of bound to be added to active set. */
-											real_t* const xiC, 		/**< Output: Multipliers in linear independence test for active constraints. */
-											real_t* const xiX 		/**< Output: Multipliers in linear independence test for fixed variables. */
-											);
-
-		/** Checks if new active bound to be added is linearly dependent from
-		 *	from row of the active constraints matrix.  This version computes
-		 *	the multipliers in the (full) test.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT */
-		returnValue addConstraint_checkLISchur(	int_t number,		/**< Number of bound to be added to active set. */
-													real_t* const xiC, 	/**< Output: Multipliers in linear independence test for active constraints. */
-													real_t* const xiX 	/**< Output: Multipliers in linear independence test for fixed variables. */
-													);
-
-		/** Compute product of "M" matrix (additional columns in KKT
-			matrix) with vector.  y = alpha * M * x + beta * y */
-		returnValue computeMTimes( real_t alpha, const real_t* const x, real_t beta, real_t* const y );
-
-		/** Compute product of transpose of "M" matrix (additional columns in KKT
-			matrix) with vector.  y = alpha * M^T * x + beta * y */
-		returnValue computeMTransTimes( real_t alpha, const real_t* const x, real_t beta, real_t* const y );
-
-		/** Add a row/column to the Schur complement. */
-		returnValue addToSchurComplement( int_t number, SchurUpdateType update, int_t numNonzerosM, const sparse_int_t* M_pos, const real_t* const M_vals, int_t numNonzerosN, const sparse_int_t* Npos, const real_t* const Nvals, real_t N_diag );
-
-		/** Remove a row/column from the Schur complement. */
-		returnValue deleteFromSchurComplement( int_t idx, BooleanType allowUndo = BT_FALSE );
-
-		/** Undo the last deletion from the Schur complement by moving the nS+1th row/column to position idx. */
-		returnValue undoDeleteFromSchurComplement( int_t idx );
-
-		/** Compute determinant of new nS*nS Schur complement from old factorization */
-		real_t calcDetSchur( int_t idxDel );
-
-		/** Update QR factorization and determinant of Schur complement after a row and column have been added or removed */
-		returnValue updateSchurQR( int_t idxDel );
-
-		/** Compute the solution to QRx = rhs and store it in sol */
-		returnValue backsolveSchurQR( int_t dimS, const real_t* const rhs, int_t dimRhs, real_t* const sol );
-
-		/** If negative curvature is discovered in the reduced Hessian, add bounds until all eigenvalues are positive */
-		returnValue correctInertia();
-
-		/** If the KKT matrix is declared singular during refactorization, remove linearly dependent constraints or add bounds */
-		returnValue repairSingularWorkingSet( );
-
-		returnValue stepCalcRhs( int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx, real_t& rhs_max, const real_t* const delta_g,
-								const real_t* const delta_lbA, const real_t* const delta_ubA,
-								const real_t* const delta_lb, const real_t* const delta_ub,
-								BooleanType Delta_bC_isZero, BooleanType Delta_bB_isZero,
-								real_t* const delta_xFX, real_t* const delta_xFR,
-								real_t* const delta_yAC, real_t* const delta_yFX
-								 );
-
-		returnValue stepCalcReorder(int_t nFR, int_t nAC, int_t* FR_idx, int_t* AC_idx, int_t nFRStart, int_t nACStart,
-									int_t* FR_idxStart, int_t* AC_idxStart, int_t* FR_iSort, int_t* FR_iSortStart,
-									int_t* AC_iSort, int_t* AC_iSortStart, real_t* rhs);
-
-		returnValue stepCalcBacksolveSchur( int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx,
-											int_t dim, real_t* rhs, real_t* sol );
-
-		returnValue stepCalcReorder2(	int_t nFR, int_t nAC, int_t* FR_idx, int_t* AC_idx, int_t nFRStart, int_t nACStart,
-										int_t* FR_idxStart, int_t* AC_idxStart, int_t* FR_iSort, int_t* FR_iSortStart,
-										int_t* AC_iSort, int_t* AC_iSortStart, real_t* sol, real_t* const delta_xFR, real_t* const delta_yAC);
-
-		returnValue stepCalcResid(	int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx,
-									BooleanType Delta_bC_isZero, real_t* const delta_xFX, real_t* const delta_xFR,
-									real_t* const delta_yAC, const real_t* const delta_g,
-									const real_t* const delta_lbA, const real_t* const delta_ubA, real_t& rnrm);
-
-		returnValue stepCalcDeltayFx(	int_t nFR, int_t nFX, int_t nAC, int_t* FX_idx, const real_t* const delta_g,
-										real_t* const delta_xFX, real_t* const delta_xFR, real_t* const delta_yAC, real_t* const delta_yFX);
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		SparseSolver* sparseSolver;			/**< Interface to the sparse linear solver. */
-
-		real_t* S;							/**< Schur complement matrix. (This is actually the negative of the Schur complement!) */
-		int_t nS;							/**< Current size of Schur complement matrix. -1 means that the Schur complement has not yet been initialized. */
-		int_t nSmax;						/**< Maximum size of Schur complement matrix. */
-
-		real_t* Q_;							/**< QR factorization of S: orthogonal matrix Q */
-		real_t* R_;							/**< QR factorization of S: upper triangular matrix R */
-		real_t detS;						/**< Determinant of Schur complement */
-		real_t rcondS;						/**< Reciprocal of condition number of S (estimate) */
-		int_t numFactorizations;			/**< Total number of factorizations performed */
-
-		int_t* schurUpdateIndex;			/**< Indices of variables or constraints for each update in Schur complement. */
-		SchurUpdateType* schurUpdate;		/**< Type of update for each update in Schur complement. */
-
-		int_t M_physicallength;				/**< Allocated size of the M_vals and M_ir arrays. */
-		real_t* M_vals;						/**< Values of the sparse M matrix containing the vectors with the additional rows defining the Schur complement (length). */
-		sparse_int_t* M_ir;					/**< Row indices (length). */
-		sparse_int_t* M_jc;					/**< Indices in M to first entry of columns (nS+1). */
-
-		Indexlist boundsFreeStart;			/**< Index list for free bounds when major iteration started. */
-		Indexlist constraintsActiveStart;	/**< Index list for active constraints when major iteration started. */
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/SQProblemSchur.ipp>
-
-#endif	/* QPOASES_QPROBLEMSCHUR_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.ipp
deleted file mode 100644
index b08ef59..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.ipp
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2013 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SQProblemSchur.ipp
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- *
- *	Implementation of inlined member functions of the SQProblemSchur class which
- *	is able to use the newly developed online active set strategy for
- *	parametric quadratic programming.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-/*
- *	g e t N u m F a c t o r i z a t i o n s
- */
-inline int_t SQProblemSchur::getNumFactorizations( ) const
-{
-	return numFactorizations;
-}
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SparseSolver.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/SparseSolver.hpp
deleted file mode 100644
index 9a2d68b..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SparseSolver.hpp
+++ /dev/null
@@ -1,395 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *
- *	Copyright (C) 2012 by Andreas Waechter. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SparseSolver.hpp
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- *
- *	Interfaces to sparse linear solvers that are used in a Schur-complement
- *	implementation in qpOASES.
- */
-
-#ifndef QPOASES_SPARSESOLVER_HPP
-#define QPOASES_SPARSESOLVER_HPP
-
-#include <qpOASES/Utils.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Base class for linear solvers that are used in a Schur-complement
- *	implementation in qpOASES.
- *
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- */
-class SparseSolver
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		SparseSolver( );
-
-		/** Copy constructor (deep copy). */
-		SparseSolver(	const SparseSolver& rhs		/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~SparseSolver( );
-
-		/** Assignment operator (deep copy). */
-		virtual SparseSolver& operator=(	const SparseSolver& rhs	/**< Rhs object. */
-								);
-
-		/** Set new matrix data.  The matrix is to be provided
-		    in the Harwell-Boeing format.  Only the lower
-		    triangular part should be set. */
-		virtual returnValue setMatrixData( int_t dim,					/**< Dimension of the linear system. */
-										   int_t numNonzeros,			/**< Number of nonzeros in the matrix. */
-										   const int_t* const airn,		/**< Row indices for each matrix entry. */
-										   const int_t* const acjn,		/**< Column indices for each matrix entry. */
-										   const real_t* const avals	/**< Values for each matrix entry. */
-										   ) = 0;
-
-		/** Compute factorization of current matrix.  This method must be called before solve.*/
-		virtual returnValue factorize( ) = 0;
-
-		/** Solve linear system with most recently set matrix data. */
-		virtual returnValue solve( int_t dim, /**< Dimension of the linear system. */
-					   const real_t* const rhs, /**< Values for the right hand side. */
-					   real_t* const sol /**< Solution of the linear system. */
-					   ) = 0;
-
-		/** Clears all data structures. */
-		virtual returnValue reset( );
-
-		/** Return the number of negative eigenvalues. */
-		virtual int_t getNegativeEigenvalues( );
-
-		/** Return the rank after a factorization */
-		virtual int_t getRank( );
-
-		/** Returns the zero pivots in case the matrix is rank deficient */
-		virtual returnValue getZeroPivots( int_t *&zeroPivots );
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const SparseSolver& rhs	/**< Rhs object. */
-							);
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-};
-
-
-#ifdef SOLVER_MA27
-
-/**
- *	\brief Implementation of the linear solver interface using Harwell's MA27.
- *
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- */
-class Ma27SparseSolver: public SparseSolver
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Ma27SparseSolver( );
-
-		/** Copy constructor (deep copy). */
-		Ma27SparseSolver(	const Ma27SparseSolver& rhs		/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~Ma27SparseSolver( );
-
-		/** Assignment operator (deep copy). */
-		virtual Ma27SparseSolver& operator=(	const SparseSolver& rhs	/**< Rhs object. */
-								);
-
-		/** Set new matrix data.  The matrix is to be provided
-		    in the Harwell-Boeing format.  Only the lower
-		    triangular part should be set. */
-		virtual returnValue setMatrixData( int_t dim,					/**< Dimension of the linear system. */
-										   int_t numNonzeros,			/**< Number of nonzeros in the matrix. */
-										   const int_t* const airn,		/**< Row indices for each matrix entry. */
-										   const int_t* const acjn,		/**< Column indices for each matrix entry. */
-										   const real_t* const avals	/**< Values for each matrix entry. */
-										   );
-
-		/** Compute factorization of current matrix.  This method must be called before solve.*/
-		virtual returnValue factorize( );
-
-		/** Solve linear system with most recently set matrix data. */
-		virtual returnValue solve( int_t dim,				/**< Dimension of the linear system. */
-								   const real_t* const rhs, /**< Values for the right hand side. */
-								   real_t* const sol		/**< Solution of the linear system. */
-								   );
-
-		/** Clears all data structures. */
-		virtual returnValue reset( );
-
-		/** Return the number of negative eigenvalues. */
-		virtual int_t getNegativeEigenvalues( );
-
-		/** Return the rank after a factorization */
-		virtual int getRank( );
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Ma27SparseSolver& rhs	/**< Rhs object. */
-							);
-
-	/*
-	 *	PRIVATE MEMBER FUNCTIONS
-	 */
-	private:
-	/*
-	 *	PRIVATE MEMBER VARIABLES
-	 */
-	private:
-		fint dim; /**< Dimension of the current linear system. */
-
-		fint numNonzeros; /**< Number of nonzeros in the current linear system. */
-
-		fint la_ma27; /**< size of a_ma27 (LA in MA27) */
-
-		double* a_ma27; /**< matrix/factor for MA27 (A in MA27).  If have_factorization is false, it contains the matrix entries (and has length numNonzeros), otherwise the factor (and has length la_ma27). */
-
-		fint* irn_ma27; /**< Row entries of matrix (IRN in MA27) */
-
-		fint* jcn_ma27; /**< Column entries of matrix (JCN in MA27) */
-
-		fint icntl_ma27[30];  /**< integer control values (ICNRL in MA27) */
-
-		double cntl_ma27[5];  /**< real control values (CNRL in MA27) */
-
-		fint liw_ma27;  /**< length of integer work space (LIW in MA27) */
-
-		fint* iw_ma27; /**< integer work space (IW in MA27) */
-
-		fint* ikeep_ma27;  /**< IKEEP in MA27 */
-
-		fint nsteps_ma27;  /**< NSTEPS in MA27 */
-
-		fint maxfrt_ma27;  /**< MAXFRT in MA27 */
-
-		bool have_factorization; /**< flag indicating whether factorization for current matrix has already been computed */
-
-		fint neig;	/**< number of negative eigenvalues */
-
-		fint rank;	/**< rank of matrix */
-};
-
-#endif // SOLVER_MA27
-
-
-#ifdef SOLVER_MA57
-
-/**
- *	\brief Implementation of the linear solver interface using Harwell's MA57.
- *
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2013-2015
- */
-class Ma57SparseSolver: public SparseSolver
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Ma57SparseSolver( );
-
-		/** Copy constructor (deep copy). */
-		Ma57SparseSolver(	const Ma57SparseSolver& rhs		/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~Ma57SparseSolver( );
-
-		/** Assignment operator (deep copy). */
-		virtual Ma57SparseSolver& operator=(	const SparseSolver& rhs	/**< Rhs object. */
-								);
-
-		/** Set new matrix data.  The matrix is to be provided
-		    in the Harwell-Boeing format.  Only the lower
-		    triangular part should be set. */
-		virtual returnValue setMatrixData( int_t dim,					/**< Dimension of the linear system. */
-										   int_t numNonzeros,			/**< Number of nonzeros in the matrix. */
-										   const int_t* const airn,		/**< Row indices for each matrix entry. */
-										   const int_t* const acjn,		/**< Column indices for each matrix entry. */
-										   const real_t* const avals	/**< Values for each matrix entry. */
-										   );
-
-		/** Compute factorization of current matrix.  This method must be called before solve.*/
-		virtual returnValue factorize( );
-
-		/** Solve linear system with most recently set matrix data. */
-		virtual returnValue solve(	int_t dim,					/**< Dimension of the linear system. */
-									const real_t* const rhs,	/**< Values for the right hand side. */
-									real_t* const sol			/**< Solution of the linear system. */
-									);
-
-		/** Clears all data structures. */
-		virtual returnValue reset( );
-
-		/** Return the number of negative eigenvalues. */
-		virtual int_t getNegativeEigenvalues( );
-
-		/** Return the rank after a factorization */
-		virtual int_t getRank( );
-
-		/** Returns the zero pivots in case the matrix is rank deficient */
-		virtual returnValue getZeroPivots( int_t *&zeroPivots );
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Ma57SparseSolver& rhs	/**< Rhs object. */
-							);
-
-	/*
-	 *	PRIVATE MEMBER FUNCTIONS
-	 */
-	private:
-	/*
-	 *	PRIVATE MEMBER VARIABLES
-	 */
-	private:
-		fint dim;				/**< Dimension of the current linear system. */
-
-		fint numNonzeros;		/**< Number of nonzeros in the current linear system. */
-
-		double* a_ma57;			/**< matrix for MA57 (A in MA57) */
-
-		fint* irn_ma57;			/**< Row entries of matrix (IRN in MA57) */
-
-		fint* jcn_ma57;			/**< Column entries of matrix (JCN in MA57) */
-
-		fint icntl_ma57[30];	/**< integer control values (ICNRL in MA57) */
-
-		double cntl_ma57[5];	/**< real control values (CNRL in MA57) */
-
-		double* fact_ma57;		/**< array for storing the factors */
-
-		fint lfact_ma57;		/**< length of fact_ma57 */
-
-		fint* ifact_ma57;		/**< indexing information about the factors */
-
-		fint lifact_ma57;		/**< length of ifact_ma57 */
-
-		bool have_factorization;/**< flag indicating whether factorization for current matrix has already been computed */
-
-		fint neig;				/**< number of negative eigenvalues */
-
-		fint rank;				/**< rank of matrix */
-
-		fint* pivots;			/**< sequence of pivots used in factorization */
-};
-
-#endif // SOLVER_MA57
-
-
-#ifdef SOLVER_NONE
-
-/**
- *	\brief Implementation of a dummy sparse solver. An error is thrown if a factorization is attempted.
- *
- *	\author Dennis Janka
- *	\version 3.2
- *	\date 2015
- */
-class DummySparseSolver: public SparseSolver
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Set new matrix data.  The matrix is to be provided
-		    in the Harwell-Boeing format.  Only the lower
-		    triangular part should be set. */
-		virtual returnValue setMatrixData(	int_t dim,					/**< Dimension of the linear system. */
-											int_t numNonzeros,			/**< Number of nonzeros in the matrix. */
-											const int_t* const airn,	/**< Row indices for each matrix entry. */
-											const int_t* const acjn,	/**< Column indices for each matrix entry. */
-											const real_t* const avals	/**< Values for each matrix entry. */
-											);
-
-		/** Compute factorization of current matrix.  This method must be called before solve.*/
-		virtual returnValue factorize( );
-
-		/** Solve linear system with most recently set matrix data. */
-		virtual returnValue solve(	int_t dim,					/**< Dimension of the linear system. */
-									const real_t* const rhs,	/**< Values for the right hand side. */
-									real_t* const sol			/**< Solution of the linear system. */
-									);
-};
-
-#endif // SOLVER_NONE
-
-
-END_NAMESPACE_QPOASES
-
-#endif	/* QPOASES_SPARSESOLVER_HPP */
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.hpp
deleted file mode 100644
index 441ed2a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.hpp
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SubjectTo.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the SubjectTo class designed to manage working sets of
- *	constraints and bounds within a QProblem.
- */
-
-
-#ifndef QPOASES_SUBJECTTO_HPP
-#define QPOASES_SUBJECTTO_HPP
-
-
-#include <qpOASES/Indexlist.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Base class for managing working sets of bounds and constraints.
- *
- *	This class manages working sets of bounds and constraints by storing
- *	index sets and other status information.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- */
-class SubjectTo
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		SubjectTo( );
-
-		/** Constructor which takes the number of constraints or bounds. */
-		SubjectTo(	int_t _n 							/**< Number of constraints or bounds. */
-					);
-
-		/** Copy constructor (deep copy). */
-		SubjectTo(	const SubjectTo& rhs				/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~SubjectTo( );
-
-		/** Assignment operator (deep copy). */
-		SubjectTo& operator=(	const SubjectTo& rhs	/**< Rhs object. */
-								);
-
-
-		/** Initialises object with given number of constraints or bounds.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INVALID_ARGUMENTS */
-		returnValue init(	int_t _n = 0				/**< Number of constraints or bounds. */
-							);
-
-
-		/** Returns number of constraints/bounds with given SubjectTo type.
-		 *	\return Number of constraints/bounds with given type. */
-		inline int_t getNumberOfType(	SubjectToType _type	/**< Type of (constraints') bound. */
-										) const;
-
-
-		/** Returns type of (constraints') bound.
-		 *	\return Type of (constraints') bound \n
-		 			RET_INDEX_OUT_OF_BOUNDS */
-		inline SubjectToType getType(	int_t i			/**< Number of (constraints') bound. */
-										) const;
-
-		/** Returns status of (constraints') bound.
-		 *	\return Status of (constraints') bound \n
-		 			ST_UNDEFINED */
-		inline SubjectToStatus getStatus(	int_t i		/**< Number of (constraints') bound. */
-											) const;
-
-
-		/** Sets type of (constraints') bound.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setType(	int_t i,			/**< Number of (constraints') bound. */
-									SubjectToType value	/**< Type of (constraints') bound. */
-									);
-
-		/** Sets status of (constraints') bound.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setStatus(	int_t i,				/**< Number of (constraints') bound. */
-										SubjectToStatus value	/**< Status of (constraints') bound. */
-										);
-
-
-		/** Sets status of lower (constraints') bounds. */
-		inline void setNoLower(	BooleanType _status		/**< Status of lower (constraints') bounds. */
-								);
-
-		/** Sets status of upper (constraints') bounds. */
-		inline void setNoUpper(	BooleanType _status		/**< Status of upper (constraints') bounds. */
-								);
-
-
-		/** Returns status of lower (constraints') bounds.
-		 *	\return BT_TRUE if there is no lower (constraints') bound on any variable. */
-		inline BooleanType hasNoLower( ) const;
-
-		/** Returns status of upper bounds.
-		 *	\return BT_TRUE if there is no upper (constraints') bound on any variable. */
-		inline BooleanType hasNoUpper( ) const;
-
-
-		/** Shifts forward type and status of all constraints/bounds by a given
-		 *  offset. This offset has to lie within the range [0,n/2] and has to
-		 *  be an integer divisor of the total number of constraints/bounds n.
-		 *  Type and status of the first \<offset\> constraints/bounds is thrown away,
-		 *  type and status of the last \<offset\> constraints/bounds is doubled,
-		 *  e.g. for offset = 2: \n
-		 *  shift( {c/b1,c/b2,c/b3,c/b4,c/b5,c/b6} ) = {c/b3,c/b4,c/b5,c/b6,c/b5,c/b6}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_INVALID_ARGUMENTS \n
-		 			RET_SHIFTING_FAILED */
-		virtual returnValue shift(	int_t offset	/**< Shift offset within the range [0,n/2] and integer divisor of n. */
-									) = 0;
-
-		/** Rotates forward type and status of all constraints/bounds by a given
-		 *  offset. This offset has to lie within the range [0,n].
-		 *  Example for offset = 2: \n
-		 *  rotate( {c/b1,c/b2,c/b3,c/b4,c/b5,c/b6} ) = {c/b3,c/b4,c/b5,c/b6,c/b1,c/b2}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_ROTATING_FAILED */
-		virtual returnValue rotate(	int_t offset	/**< Rotation offset within the range [0,n]. */
-									) = 0;
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-		
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const SubjectTo& rhs	/**< Rhs object. */
-							);
-
-
-		/** Adds the index of a new constraint or bound to index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDINDEX_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue addIndex(	Indexlist* const indexlist,	/**< Index list to which the new index shall be added. */
-								int_t newnumber,			/**< Number of new constraint or bound. */
-								SubjectToStatus newstatus	/**< Status of new constraint or bound. */
-								);
-
-		/** Removes the index of a constraint or bound from index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_REMOVEINDEX_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue removeIndex(	Indexlist* const indexlist,	/**< Index list from which the new index shall be removed. */
-									int_t removenumber			/**< Number of constraint or bound to be removed. */
-									);
-
-		/** Swaps the indices of two constraints or bounds within the index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SWAPINDEX_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue swapIndex(	Indexlist* const indexlist,	/**< Index list in which the indices shold be swapped. */
-								int_t number1,				/**< Number of first constraint or bound. */
-								int_t number2				/**< Number of second constraint or bound. */
-								);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		int_t n;					/**< Total number of constraints/bounds. */
-
-		SubjectToType* type; 		/**< Type of constraints/bounds. */
-		SubjectToStatus* status;	/**< Status of constraints/bounds. */
-
-		BooleanType noLower;	 	/**< This flag indicates if there is no lower bound on any variable. */
-		BooleanType noUpper;	 	/**< This flag indicates if there is no upper bound on any variable. */
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/SubjectTo.ipp>
-
-#endif	/* QPOASES_SUBJECTTO_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.ipp
deleted file mode 100644
index 0cc8286..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.ipp
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SubjectTo.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the inlined member functions of the SubjectTo class
- *	designed to manage working sets of constraints and bounds within a QProblem.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	g e t N u m b e r O f T y p e
- */
-inline int_t SubjectTo::getNumberOfType( SubjectToType _type ) const
-{
-	int_t i;
-	int_t numberOfType = 0;
-
-	if ( type != 0 )
-	{
-		for( i=0; i<n; ++i )
-			if ( type[i] == _type )
-				++numberOfType;
-	}
-
-	return numberOfType;
-}
-
-
-/*
- *	g e t T y p e
- */
-inline SubjectToType SubjectTo::getType( int_t i ) const
-{
-	if ( ( i >= 0 ) && ( i < n ) )
-		return type[i];
-
-	return ST_UNKNOWN;
-}
-
-
-/*
- *	g e t S t a t u s
- */
-inline SubjectToStatus SubjectTo::getStatus( int_t i ) const
-{
-	if ( ( i >= 0 ) && ( i < n ) )
-		return status[i];
-
-	return ST_UNDEFINED;
-}
-
-
-/*
- *	s e t T y p e
- */
-inline returnValue SubjectTo::setType( int_t i, SubjectToType value )
-{
-	if ( ( i >= 0 ) && ( i < n ) )
-	{
-		type[i] = value;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-}
-
-
-/*
- *	s e t S t a t u s
- */
-inline returnValue SubjectTo::setStatus( int_t i, SubjectToStatus value )
-{
-	if ( ( i >= 0 ) && ( i < n ) )
-	{
-		status[i] = value;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-}
-
-
-/*
- *	s e t N o L o w e r
- */
-inline void SubjectTo::setNoLower( BooleanType _status )
-{
-	noLower = _status;
-}
-
-
-/*
- *	s e t N o U p p e r
- */
-inline void SubjectTo::setNoUpper( BooleanType _status )
-{
-	noUpper = _status;
-}
-
-
-/*
- *	h a s N o L o w e r
- */
-inline BooleanType SubjectTo::hasNoLower( ) const
-{
-	return noLower;
-}
-
-
-/*
- *	h a s N o U p p p e r
- */
-inline BooleanType SubjectTo::hasNoUpper( ) const
-{
-	return noUpper;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Types.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Types.hpp
deleted file mode 100644
index 9654e3a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Types.hpp
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Types.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of all non-built-in types (except for classes).
- */
-
-
-#ifndef QPOASES_TYPES_HPP
-#define QPOASES_TYPES_HPP
-
-
-/* If your compiler does not support the snprintf() function,
- * uncomment the following line and try to compile again. */
-/* #define __NO_SNPRINTF__ */
-
-
-/* Uncomment the following line for setting the __DSPACE__ flag. */
-/* #define __DSPACE__ */
-
-/* Uncomment the following line for setting the __XPCTARGET__ flag. */
-/* #define __XPCTARGET__ */
-
-
-/* Uncomment the following line for setting the __NO_FMATH__ flag. */
-/* #define __NO_FMATH__ */
-
-/* Uncomment the following line to enable debug information. */
-/* #define __DEBUG__ */
-
-/* Uncomment the following line to enable suppress any kind of console output. */
-/* #define __SUPPRESSANYOUTPUT__ */
-
-
-/** Forces to always include all implicitly fixed bounds and all equality constraints
- *  into the initial working set when setting up an auxiliary QP. */
-#define __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-
-
-/* Uncomment the following line to activate the use of an alternative Givens
- * plane rotation requiring only three multiplications. */
-/* #define __USE_THREE_MULTS_GIVENS__ */
-
-/* Uncomment the following line to activate the use of single precision arithmetic. */
-/* #define __USE_SINGLE_PRECISION__ */
-
-
-
-/* Work-around for Borland BCC 5.5 compiler. */
-#ifdef __BORLANDC__
-#if __BORLANDC__ < 0x0561
-  #define __STDC__ 1
-#endif
-#endif
-
-
-/* Work-around for Microsoft compilers. */
-#ifdef _MSC_VER
-  #define __NO_SNPRINTF__
-  #pragma warning( disable : 4061 4100 4250 4514 4996 )
-#endif
-
-
-#ifdef __DSPACE__
-
-	/** Macro for switching on/off the beginning of the qpOASES namespace definition. */
-	#define BEGIN_NAMESPACE_QPOASES
-
-	/** Macro for switching on/off the end of the qpOASES namespace definition. */
-	#define END_NAMESPACE_QPOASES
-
-	/** Macro for switching on/off the use of the qpOASES namespace. */
-	#define USING_NAMESPACE_QPOASES
-
-	/** Macro for switching on/off references to the qpOASES namespace. */
-	#define REFER_NAMESPACE_QPOASES ::
-
-#else
-
-	/** Macro for switching on/off the beginning of the qpOASES namespace definition. */
-	#define BEGIN_NAMESPACE_QPOASES  namespace qpOASES {
-
-	/** Macro for switching on/off the end of the qpOASES namespace definition. */
-	#define END_NAMESPACE_QPOASES    }
-
-	/** Macro for switching on/off the use of the qpOASES namespace. */
-	#define USING_NAMESPACE_QPOASES  using namespace qpOASES;
-
-	/** Macro for switching on/off references to the qpOASES namespace. */
-	#define REFER_NAMESPACE_QPOASES  qpOASES::
-
-#endif
-
-
-/* Avoid any printing on embedded platforms. */
-#if defined(__DSPACE__) || defined(__XPCTARGET__)
-  #define __SUPPRESSANYOUTPUT__
-  #define __NO_SNPRINTF__
-#endif
-
-
-#ifdef __NO_SNPRINTF__
-  #if (!defined(_MSC_VER)) || defined(__DSPACE__) || defined(__XPCTARGET__)
-    /* If snprintf is not available, provide an empty implementation... */
-    int snprintf( char* s, size_t n, const char* format, ... );
-  #else
-	/* ... or substitute snprintf by _snprintf for Microsoft compilers. */
-    #define snprintf _snprintf
-  #endif
-#endif /* __NO_SNPRINTF__ */
-
-
-
-/** Macro for accessing the Cholesky factor R. */
-#define RR( I,J )  R[(I)+nV*(J)]
-
-/** Macro for accessing the orthonormal matrix Q of the QT factorisation. */
-#define QQ( I,J )  Q[(I)+nV*(J)]
-
-/** Macro for accessing the triangular matrix T of the QT factorisation. */
-#define TT( I,J )  T[(I)*sizeT+(J)]
-
-
-/* If neither MA57 nor MA27 are selected, activate the dummy solver */
-#if !defined(SOLVER_MA27) && !defined(SOLVER_MA57) && !defined(SOLVER_NONE)
-#define SOLVER_NONE
-#endif
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** Defines real_t for facilitating switching between double and float. */
-#ifdef __USE_SINGLE_PRECISION__
-typedef float real_t;
-#else
-typedef double real_t;
-#endif /* __USE_SINGLE_PRECISION__ */
-
-
-/** Defines int_t for facilitating switching between int and long int. */
-#ifdef __USE_LONG_INTEGERS__
-typedef long int_t;
-typedef unsigned long uint_t;
-#else
-typedef int int_t;
-typedef unsigned int uint_t;
-#endif /* __USE_LONG_INTEGERS__ */
-
-
-/** typedef for Fortran INTEGER type. Might be platform dependent! */
-typedef int fint;
-
-
-/**
- * Integer type for sparse matrix row/column entries. Make this "int"
- * for 32 bit entries, and "long" for 64-bit entries on x86_64 platform.
- *
- * Most sparse codes still assume 32-bit entries here (HSL, BQPD, ...)
- */
-typedef int_t sparse_int_t;
-
-
-/** Summarises all possible logical values. */
-enum BooleanType
-{
-	BT_FALSE,					/**< Logical value for "false". */
-	BT_TRUE						/**< Logical value for "true". */
-};
-
-
-/** Summarises all possible print levels. Print levels are used to describe
- *	the desired amount of output during runtime of qpOASES. */
-enum PrintLevel
-{
-	PL_DEBUG_ITER = -2,			/**< Full tabular debugging output. */
-	PL_TABULAR,					/**< Normal tabular output. */
-	PL_NONE,					/**< No output. */
-	PL_LOW,						/**< Print error messages only. */
-	PL_MEDIUM,					/**< Print error and warning messages as well as concise info messages. */
-	PL_HIGH						/**< Print all messages with full details. */
-};
-
-
-/** Defines visibility status of a message. */
-enum VisibilityStatus
-{
-	VS_HIDDEN,					/**< Message not visible. */
-	VS_VISIBLE					/**< Message visible. */
-};
-
-
-/** Summarises all possible states of the (S)QProblem(B) object during the
-solution process of a QP sequence. */
-enum QProblemStatus
-{
-	QPS_NOTINITIALISED,			/**< QProblem object is freshly instantiated or reset. */
-	QPS_PREPARINGAUXILIARYQP,	/**< An auxiliary problem is currently setup, either at the very beginning
-								 *   via an initial homotopy or after changing the QP matrices. */
-	QPS_AUXILIARYQPSOLVED,		/**< An auxilary problem was solved, either at the very beginning
-								 *   via an initial homotopy or after changing the QP matrices. */
-	QPS_PERFORMINGHOMOTOPY,		/**< A homotopy according to the main idea of the online active
-								 *   set strategy is performed. */
-	QPS_HOMOTOPYQPSOLVED,		/**< An intermediate QP along the homotopy path was solved. */
-	QPS_SOLVED					/**< The solution of the actual QP was found. */
-};
-
-
-/** Summarises all possible types of the QP's Hessian matrix. */
-enum HessianType
-{
-	HST_ZERO,				/**< Hessian is zero matrix (i.e. LP formulation). */
-	HST_IDENTITY,			/**< Hessian is identity matrix. */
-	HST_POSDEF,				/**< Hessian is (strictly) positive definite. */
-	HST_POSDEF_NULLSPACE,	/**< Hessian is positive definite on null space of active bounds/constraints. */
-	HST_SEMIDEF,			/**< Hessian is positive semi-definite. */
-	HST_INDEF,				/**< Hessian is indefinite. */
-	HST_UNKNOWN				/**< Hessian type is unknown. */
-};
-
-
-/** Summarises all possible types of bounds and constraints. */
-enum SubjectToType
-{
-	ST_UNBOUNDED,		/**< Bound/constraint is unbounded. */
-	ST_BOUNDED,			/**< Bound/constraint is bounded but not fixed. */
-	ST_EQUALITY,		/**< Bound/constraint is fixed (implicit equality bound/constraint). */
-	ST_DISABLED,		/**< Bound/constraint is disabled (i.e. ignored when solving QP). */
-	ST_UNKNOWN			/**< Type of bound/constraint unknown. */
-};
-
-
-/** Summarises all possible states of bounds and constraints. */
-enum SubjectToStatus
-{
-	ST_LOWER = -1,			/**< Bound/constraint is at its lower bound. */
-	ST_INACTIVE,			/**< Bound/constraint is inactive. */
-	ST_UPPER,				/**< Bound/constraint is at its upper bound. */
-	ST_INFEASIBLE_LOWER,	/**< (to be documented) */
-	ST_INFEASIBLE_UPPER,	/**< (to be documented) */
-	ST_UNDEFINED			/**< Status of bound/constraint undefined. */
-};
-
-/** Flag indicating which type of update generated column in Schur complement. */
-enum SchurUpdateType
-{
-	SUT_VarFixed,			/**< Free variable gets fixed. */
-	SUT_VarFreed,			/**< Fixed variable gets freed. */
-	SUT_ConAdded,			/**< Constraint becomes active. */
-	SUT_ConRemoved,			/**< Constraint becomes inactive. */
-	SUT_UNDEFINED			/**< Type of Schur update is undefined. */
-};
-
-/**
- *	\brief Stores internal information for tabular (debugging) output.
- *
- *	Struct storing internal information for tabular (debugging) output
- *	when using the (S)QProblem(B) objects.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2013-2015
- */
-struct TabularOutput {
-	int_t idxAddB;		/**< Index of bound that has been added to working set. */
-	int_t idxRemB;		/**< Index of bound that has been removed from working set. */
-	int_t idxAddC;		/**< Index of constraint that has been added to working set. */
-	int_t idxRemC;		/**< Index of constraint that has been removed from working set. */
-	int_t excAddB;		/**< Flag indicating whether a bound has been added to working set to keep a regular projected Hessian. */
-	int_t excRemB;		/**< Flag indicating whether a bound has been removed from working set to keep a regular projected Hessian. */
-	int_t excAddC;		/**< Flag indicating whether a constraint has been added to working set to keep a regular projected Hessian. */
-	int_t excRemC;		/**< Flag indicating whether a constraint has been removed from working set to keep a regular projected Hessian. */
-};
-
-
-
-/**
- *	\brief Struct containing the variable header for mat file.
- *
- *	Struct storing the header of a variable to be stored in
- *	Matlab's binary format (using the outdated Level 4 variant
- *  for simplictiy).
- *
- *  Note, this code snippet has been inspired from the document
- *  "Matlab(R) MAT-file Format, R2013b" by MathWorks
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2013-2015
- */
-typedef struct {
-	long numericFormat;		/**< Flag indicating numerical format. */
-	long nRows;				/**< Number of rows. */
-	long nCols;				/**< Number of rows. */
-	long imaginaryPart;		/**< (to be documented) */
-	long nCharName;			/**< Number of character in name. */
-} MatMatrixHeader;
-
-
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_TYPES_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/UnitTesting.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/UnitTesting.hpp
deleted file mode 100644
index c08e0ae..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/UnitTesting.hpp
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/UnitTesting.hpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Definition of auxiliary functions/macros for unit testing.
- */
-
-
-#ifndef QPOASES_UNIT_TESTING_HPP
-#define QPOASES_UNIT_TESTING_HPP
-
-
-#ifndef TEST_TOL_FACTOR
-#define TEST_TOL_FACTOR 1
-#endif
-
-
-/** Return value for tests that passed. */
-#define TEST_PASSED 0
-
-/** Return value for tests that failed. */
-#define TEST_FAILED 1
-
-/** Return value for tests that could not run due to missing external data. */
-#define TEST_DATA_NOT_FOUND 99
-
-
-/** Macro verifying that two numerical values are equal in order to pass unit test. */
-#define QPOASES_TEST_FOR_EQUAL( x,y ) if ( REFER_NAMESPACE_QPOASES isEqual( (x),(y) ) == BT_FALSE ) { return TEST_FAILED; }
-
-/** Macro verifying that two numerical values are close to each other in order to pass unit test. */
-#define QPOASES_TEST_FOR_NEAR( x,y )  if ( REFER_NAMESPACE_QPOASES getAbs((x)-(y)) / REFER_NAMESPACE_QPOASES getMax( 1.0,REFER_NAMESPACE_QPOASES getAbs(x) ) >= 1e-10 ) { return TEST_FAILED; }
-
-/** Macro verifying that first quantity is lower or equal than second one in order to pass unit test. */
-#define QPOASES_TEST_FOR_TOL( x,tol )  if ( (x) > (tol)*(TEST_TOL_FACTOR) ) { return TEST_FAILED; }
-
-/** Macro verifying that a logical expression holds in order to pass unit test. */
-#define QPOASES_TEST_FOR_TRUE( x )  if ( (x) == false ) { return TEST_FAILED; }
-
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_UNIT_TESTING_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.hpp
deleted file mode 100644
index 81e5736..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.hpp
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Utils.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of some utility functions for working with qpOASES.
- */
-
-
-#ifndef QPOASES_UTILS_HPP
-#define QPOASES_UTILS_HPP
-
-
-#include <qpOASES/MessageHandling.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** Prints a (possibly named) vector.
- * \return SUCCESSFUL_RETURN */
-returnValue print(	const real_t* const v,	/**< Vector to be printed. */
-					int_t n,				/**< Length of vector. */
-					const char* name = 0	/**< Name of vector. */
-					);
-
-/** Prints a (possibly named) permuted vector.
- * \return SUCCESSFUL_RETURN */
-returnValue print(	const real_t* const v,		/**< Vector to be printed. */
-					int_t n,					/**< Length of vector. */
-					const int_t* const V_idx,	/**< Pemutation vector. */
-					const char* name = 0		/**< Name of vector. */
-					);
-
-/** Prints a (possibly named) matrix.
- * \return SUCCESSFUL_RETURN */
-returnValue print(	const real_t* const M,	/**< Matrix to be printed. */
-					int_t nrow,				/**< Row number of matrix. */
-					int_t ncol,				/**< Column number of matrix. */
-					const char* name = 0	/**< Name of matrix. */
-					);
-
-/** Prints a (possibly named) permuted matrix.
- * \return SUCCESSFUL_RETURN */
-returnValue print(	const real_t* const M,		/**< Matrix to be printed. */
-					int_t nrow,					/**< Row number of matrix. */
-					int_t ncol	,				/**< Column number of matrix. */
-					const int_t* const ROW_idx,	/**< Row pemutation vector. */
-					const int_t* const COL_idx,	/**< Column pemutation vector. */
-					const char* name = 0		/**< Name of matrix. */
-					);
-
-/** Prints a (possibly named) index array.
- * \return SUCCESSFUL_RETURN */
-returnValue print(	const int_t* const index,	/**< Index array to be printed. */
-					int_t n,					/**< Length of index array. */
-					const char* name = 0		/**< Name of index array. */
-					);
-
-
-/** Prints a string to desired output target (useful also for MATLAB output!).
- * \return SUCCESSFUL_RETURN */
-returnValue myPrintf(	const char* s	/**< String to be written. */
-						);
-
-
-/** Prints qpOASES copyright notice.
- * \return SUCCESSFUL_RETURN */
-returnValue printCopyrightNotice( );
-
-
-/** Reads a real_t matrix from file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE \n
-		   RET_UNABLE_TO_READ_FILE */
-returnValue readFromFile(	real_t* data,				/**< Matrix to be read from file. */
-							int_t nrow,					/**< Row number of matrix. */
-							int_t ncol,					/**< Column number of matrix. */
-							const char* datafilename	/**< Data file name. */
-							);
-
-/** Reads a real_t vector from file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE \n
-		   RET_UNABLE_TO_READ_FILE */
-returnValue readFromFile(	real_t* data,				/**< Vector to be read from file. */
-							int_t n,					/**< Length of vector. */
-							const char* datafilename	/**< Data file name. */
-							);
-
-/** Reads an integer (column) vector from file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE \n
-		   RET_UNABLE_TO_READ_FILE */
-returnValue readFromFile(	int_t* data,				/**< Vector to be read from file. */
-							int_t n,					/**< Length of vector. */
-							const char* datafilename	/**< Data file name. */
-							);
-
-
-/** Writes a real_t matrix into a file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE  */
-returnValue writeIntoFile(	const real_t* const data,		/**< Matrix to be written into file. */
-							int_t nrow,						/**< Row number of matrix. */
-							int_t ncol,						/**< Column number of matrix. */
-							const char* datafilename,		/**< Data file name. */
-							BooleanType append = BT_FALSE	/**< Indicates if data shall be appended if the file already exists (otherwise it is overwritten). */
-							);
-
-/** Writes a real_t vector into a file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE  */
-returnValue writeIntoFile(	const real_t* const data,		/**< Vector to be written into file. */
-							int_t n,						/**< Length of vector. */
-							const char* datafilename,		/**< Data file name. */
-							BooleanType append = BT_FALSE	/**< Indicates if data shall be appended if the file already exists (otherwise it is overwritten). */
-							);
-
-/** Writes an integer (column) vector into a file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE */
-returnValue writeIntoFile(	const int_t* const integer,		/**< Integer vector to be written into file. */
-							int_t n,						/**< Length of vector. */
-							const char* datafilename,		/**< Data file name. */
-							BooleanType append = BT_FALSE	/**< Indicates if integer shall be appended if the file already exists (otherwise it is overwritten). */
-							);
-
-/** Writes a real_t matrix/vector into a Matlab binary file.
- * \return SUCCESSFUL_RETURN \n
-		   RET_INVALID_ARGUMENTS
- 		   RET_UNABLE_TO_WRITE_FILE */
-returnValue writeIntoMatFile(	FILE* const matFile,		/**< Pointer to Matlab binary file. */
-								const real_t* const data,	/**< Data to be written into file. */
-								int_t nRows,				/**< Row number of matrix. */
-								int_t nCols, 				/**< Column number of matrix. */
-								const char* name			/**< Matlab name of matrix/vector to be stored. */
-								);
-
-/** Writes in integer matrix/vector into a Matlab binary file.
- * \return SUCCESSFUL_RETURN \n
-		   RET_INVALID_ARGUMENTS
- 		   RET_UNABLE_TO_WRITE_FILE */
-returnValue writeIntoMatFile(	FILE* const matFile,		/**< Pointer to Matlab binary file. */
-								const int_t* const data,	/**< Data to be written into file. */
-								int_t nRows,				/**< Row number of matrix. */
-								int_t nCols,				/**< Column number of matrix. */
-								const char* name			/**< Matlab name of matrix/vector to be stored. */
-								);
-
-
-/** Returns the current system time.
- * \return current system time */
-real_t getCPUtime( );
-
-
-/** Returns the N-norm of a vector.
- * \return >= 0.0: successful */
-real_t getNorm(	const real_t* const v,	/**< Vector. */
-				int_t n,				/**< Vector's dimension. */
-				int_t type = 2			/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-				);
-
-
-/** Tests whether two real_t-valued arguments are (numerically) equal.
- * \return	BT_TRUE:  arguments differ not more than TOL \n
-		 	BT_FALSE: arguments differ more than TOL */
-inline BooleanType isEqual(	real_t x,			/**< First real number. */
-							real_t y,			/**< Second real number. */
-							real_t TOL = ZERO	/**< Tolerance for comparison. */
-							);
-
-
-/** Tests whether a real-valued argument is (numerically) zero.
- * \return	BT_TRUE:  argument differs from 0.0 not more than TOL \n
-		 	BT_FALSE: argument differs from 0.0 more than TOL */
-inline BooleanType isZero(	real_t x,			/**< Real number. */
-							real_t TOL = ZERO	/**< Tolerance for comparison. */
-							);
-
-
-/** Returns sign of a real-valued argument.
- * \return	 1.0: argument is non-negative \n
-		 	-1.0: argument is negative */
-inline real_t getSign(	real_t arg	/**< real-valued argument whose sign is to be determined. */
-						);
-
-
-/** Returns maximum of two integers.
- * \return	Maximum of two integers */
-inline int_t getMax(	int_t x,	/**< First integer. */
-						int_t y		/**< Second integer. */
-						);
-					
-/** Returns minimum of two integers.
- * \return	Minimum of two integers */
-inline int_t getMin(	int_t x,	/**< First integer. */
-						int_t y		/**< Second integer. */
-						);
-
-	
-/** Returns maximum of two reals.
- * \return	Maximum of two reals */
-inline real_t getMax(	real_t x,	/**< First real number. */
-						real_t y	/**< Second real number. */
-						);
-
-/** Returns minimum of two reals.
- * \return	Minimum of two reals */
-inline real_t getMin(	real_t x,	/**< First real number. */
-						real_t y	/**< Second real number. */
-						);
-
-/** Returns the absolute value of a real number.
- * \return	Absolute value of a real number */
-inline real_t getAbs(	real_t x	/**< Real number. */
-						);
-
-/** Returns the square-root of a real number.
- * \return	Square-root of a real number */
-inline real_t getSqrt(	real_t x	/**< Non-negative real number. */
-						);
-
-
-/** Computes the maximum violation of the KKT optimality conditions
- *	of given iterate for given QP data. */
-returnValue getKktViolation(	int_t nV,									/**< Number of variables. */
-								int_t nC,									/**< Number of constraints. */
-								const real_t* const H,						/**< Hessian matrix (may be NULL if Hessian is zero or identity matrix). */
-								const real_t* const g,						/**< Gradient vector. */
-								const real_t* const A,						/**< Constraint matrix. */
-								const real_t* const lb,						/**< Lower bound vector (on variables). */
-								const real_t* const ub,						/**< Upper bound vector (on variables). */
-								const real_t* const lbA,					/**< Lower constraints' bound vector. */
-								const real_t* const ubA,					/**< Upper constraints' bound vector. */
-								const real_t* const x,						/**< Primal trial vector. */
-								const real_t* const y,						/**< Dual trial vector. */
-								real_t& stat,								/**< Output: maximum value of stationarity condition residual. */
-								real_t& feas,								/**< Output: maximum value of primal feasibility violation. */
-								real_t& cmpl,								/**< Output: maximum value of complementarity residual. */
-								const real_t* const workingSetB = 0,		/**< Working set of bounds (used to determine active bounds). */
-								const real_t* const workingSetC = 0,		/**< Working set of constraints (used to determine active constraints). */
-								BooleanType hasIdentityHessian = BT_FALSE	/**< Indicating whether Hessian matrix is identity matrix or not if NULL pointer is passed. */
-								);
-
-/** Computes the maximum violation of the KKT optimality conditions
- *	of given iterate for given QP data. */
-returnValue getKktViolation(	int_t nV,									/**< Number of variables. */
-								const real_t* const H,						/**< Hessian matrix (may be NULL if Hessian is zero or identity matrix). */
-								const real_t* const g,						/**< Gradient vector. */
-								const real_t* const lb,						/**< Lower bound vector (on variables). */
-								const real_t* const ub,						/**< Upper bound vector (on variables). */
-								const real_t* const x,						/**< Primal trial vector. */
-								const real_t* const y,						/**< Dual trial vector. */
-								real_t& stat,								/**< Output: maximum value of stationarity condition residual. */
-								real_t& feas,								/**< Output: maximum value of primal feasibility violation. */
-								real_t& cmpl,								/**< Output: maximum value of complementarity residual. */
-								const real_t* const workingSetB = 0,		/**< Working set of bounds (used to determine active bounds). */
-								BooleanType hasIdentityHessian = BT_FALSE	/**< Indicating whether Hessian matrix is identity matrix or not if NULL pointer is passed */
-								);
-
-
-/** Writes a value of BooleanType into a string.
- * \return SUCCESSFUL_RETURN */
-returnValue convertBooleanTypeToString(	BooleanType value, 		/**< Value to be written. */
-										char* const string		/**< Input: String of sufficient size, \n
-																	 Output: String containing value. */
-										);
-
-/** Writes a value of SubjectToStatus into a string.
- * \return SUCCESSFUL_RETURN */
-returnValue convertSubjectToStatusToString(	SubjectToStatus value,	/**< Value to be written. */
-											char* const string		/**< Input: String of sufficient size, \n
-																		 Output: String containing value. */
-											);
-
-/** Writes a value of PrintLevel into a string.
- * \return SUCCESSFUL_RETURN */
-returnValue convertPrintLevelToString(	PrintLevel value, 		/**< Value to be written. */
-										char* const string		/**< Input: String of sufficient size, \n
-																	 Output: String containing value. */
-										);
-
-
-/** Converts a returnValue from an (S)QProblem(B) object into a more 
- *	simple status flag.
- *
- * \return  0: QP problem solved
- *          1: QP could not be solved within given number of iterations
- *         -1: QP could not be solved due to an internal error
- *         -2: QP is infeasible (and thus could not be solved)
- *         -3: QP is unbounded (and thus could not be solved)
- */
-int_t getSimpleStatus(	returnValue returnvalue, 				/**< ReturnValue to be analysed. */
-						BooleanType doPrintStatus = BT_FALSE	/**< Flag indicating whether simple status shall be printed to screen. */
-						);
-
-
-/** Normalises QP constraints.
- * \return SUCCESSFUL_RETURN \n
- *		   RET_INVALID_ARGUMENTS */
-returnValue normaliseConstraints(	int_t nV,		/**< Number of variables. */
-									int_t nC, 		/**< Number of constraints. */
-									real_t* A,		/**< Input:  Constraint matrix, \n
-														 Output: Normalised constraint matrix. */
-									real_t* lbA,	/**< Input:  Constraints' lower bound vector, \n
-														 Output: Normalised constraints' lower bound vector. */
-									real_t* ubA,	/**< Input:  Constraints' upper bound vector, \n
-														 Output: Normalised constraints' upper bound vector. */
-									int_t type = 1	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-									);
-
-
-#ifdef __DEBUG__
-/** Writes matrix with given dimension into specified file. */
-extern "C" void gdb_printmat(	const char *fname,			/**< File name. */
-								real_t *M,					/**< Matrix to be written. */
-								int_t n,					/**< Number of rows. */
-								int_t m,					/**< Number of columns. */
-								int_t ldim					/**< Leading dimension. */
-								);
-#endif /* __DEBUG__ */
-
-
-#if defined(__DSPACE__) || defined(__XPCTARGET__) || defined(__C_WRAPPER__)
-extern "C" void __cxa_pure_virtual( void );
-#endif /* __DSPACE__ || __XPCTARGET__*/ 
-
-
-
-END_NAMESPACE_QPOASES
-
-
-#include <qpOASES/Utils.ipp>
-
-#endif	/* QPOASES_UTILS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.ipp
deleted file mode 100644
index ff7482a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.ipp
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-
-/**
- *	\file include/qpOASES/Utils.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of some inlined utilities for working with the different QProblem classes.
- */
-
-
-#include <math.h>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*
- *   i s E q u a l
- */
-inline BooleanType isEqual(	real_t x,
-							real_t y,
-							real_t TOL
-							)
-{
-    if ( getAbs(x-y) <= TOL )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *   i s Z e r o
- */
-inline BooleanType isZero(	real_t x,
-							real_t TOL
-							)
-{
-    if ( getAbs(x) <= TOL )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *   g e t S i g n
- */
-inline real_t getSign(	real_t arg
-						)
-{
-	if ( arg >= 0.0 )
-		return 1.0;
-	else
-		return -1.0;
-}
-
-
-
-/*
- *   g e t M a x
- */
-inline int_t getMax(	int_t x,
-						int_t y
-						)
-{
-    return (y<x) ? x : y;
-}
-
-
-/*
- *   g e t M i n
- */
-inline int_t getMin(	int_t x,
-						int_t y
-						)
-{
-    return (y>x) ? x : y;
-}
-
-
-
-/*
- *   g e t M a x
- */
-inline real_t getMax(	real_t x,
-						real_t y
-						)
-{
-	#ifdef __NO_FMATH__
-    return (y<x) ? x : y;
-	#else
-	return (y<x) ? x : y;
-	//return fmax(x,y); /* seems to be slower */
-	#endif
-}
-
-
-/*
- *   g e t M i n
- */
-inline real_t getMin(	real_t x,
-						real_t y
-						)
-{
-	#ifdef __NO_FMATH__
-    return (y>x) ? x : y;
-	#else
-	return (y>x) ? x : y;
-	//return fmin(x,y); /* seems to be slower */
-	#endif
-}
-
-
-/*
- *   g e t A b s
- */
-inline real_t getAbs(	real_t x
-						)
-{
-	#ifdef __NO_FMATH__
-	return (x>=0.0) ? x : -x;
-	#else
-	return fabs(x);
-	#endif
-}
-
-
-/*
- *   g e t S q r t
- */
-inline real_t getSqrt(	real_t x
-						)
-{
-	#ifdef __NO_FMATH__
-	return sqrt(x); /* put your custom sqrt-replacement here */
-	#else
-	return sqrt(x);
-	#endif
-}
-
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/OQPinterface.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/extras/OQPinterface.hpp
deleted file mode 100644
index a34ef2c..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/OQPinterface.hpp
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/extras/OQPinterface.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of an interface comprising several utility functions
- *	for solving test problems from the Online QP Benchmark Collection
- *	(This collection is no longer maintained, see 
- *	http://www.qpOASES.org/onlineQP for a backup).
- */
-
-
-#ifndef QPOASES_OQPINTERFACE_HPP
-#define QPOASES_OQPINTERFACE_HPP
-
-
-#include <qpOASES/Options.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** Reads dimensions of an Online QP Benchmark problem from file.
- *
- * \return SUCCESSFUL_RETURN \n
-		   RET_UNABLE_TO_READ_FILE \n
-		   RET_FILEDATA_INCONSISTENT */
-returnValue readOqpDimensions(	const char* path,	/**< Full path of the data files (without trailing slash!). */
-								int_t& nQP,			/**< Output: Number of QPs. */
-								int_t& nV,			/**< Output: Number of variables. */
-								int_t& nC,			/**< Output: Number of constraints. */
-								int_t& nEC			/**< Output: Number of equality constraints. */
-								);
-
-/** Reads data of an Online QP Benchmark problem from file.
- *  This function allocates the required memory for all data; after successfully calling it,
- *  you have to free this memory yourself!
- *
- * \return SUCCESSFUL_RETURN \n
-		   RET_INVALID_ARGUMENTS \n
-		   RET_UNABLE_TO_READ_FILE \n
-		   RET_FILEDATA_INCONSISTENT */
-returnValue readOqpData(	const char* path,	/**< Full path of the data files (without trailing slash!). */
-							int_t& nQP,			/**< Output: Number of QPs. */
-							int_t& nV,			/**< Output: Number of variables. */
-							int_t& nC,			/**< Output: Number of constraints. */
-							int_t& nEC,			/**< Output: Number of equality constraints. */
-							real_t** H,		 	/**< Output: Hessian matrix. */
-							real_t** g,		 	/**< Output: Sequence of gradient vectors. */
-							real_t** A,		 	/**< Output: Constraint matrix. */
-							real_t** lb,		/**< Output: Sequence of lower bound vectors (on variables). */
-							real_t** ub,		/**< Output: Sequence of upper bound vectors (on variables). */
-							real_t** lbA,		/**< Output: Sequence of lower constraints' bound vectors. */
-							real_t** ubA,		/**< Output: Sequence of upper constraints' bound vectors. */
-							real_t** xOpt,		/**< Output: Sequence of primal solution vectors
-												 *           (not read if a null pointer is passed). */
-							real_t** yOpt,		/**< Output: Sequence of dual solution vectors
-												 *           (not read if a null pointer is passed). */
-							real_t** objOpt		/**< Output: Sequence of optimal objective function values
-												 *           (not read if a null pointer is passed). */
-							);
-
-
-/** Solves an Online QP Benchmark problem as specified by the arguments.
- *  The maximum deviations from the given optimal solution as well as the
- *  maximum CPU time to solve each QP are determined.
- *
- *	Note: This variant is outdated and only kept to ensure 
- *		  backwards-compatibility!
- *
- * \return SUCCESSFUL_RETURN \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue solveOqpBenchmark(	int_t nQP,					/**< Number of QPs. */
-								int_t nV,					/**< Number of variables. */
-								int_t nC,					/**< Number of constraints. */
-								int_t nEC,					/**< Number of equality constraints. */
-								const real_t* const _H,		/**< Hessian matrix. */
-								const real_t* const g,		/**< Sequence of gradient vectors. */
-								const real_t* const _A,		/**< Constraint matrix. */
-								const real_t* const lb,		/**< Sequence of lower bound vectors (on variables). */
-								const real_t* const ub,		/**< Sequence of upper bound vectors (on variables). */
-								const real_t* const lbA,	/**< Sequence of lower constraints' bound vectors. */
-								const real_t* const ubA,	/**< Sequence of upper constraints' bound vectors. */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t& nWSR, 				/**< Input: Maximum number of working set recalculations; \n
-																 Output: Maximum number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-/** Solves an Online QP Benchmark problem as specified by the arguments.
- *  The maximum deviations from the given optimal solution as well as the
- *  maximum CPU time to solve each QP are determined.
- *
- * \return SUCCESSFUL_RETURN \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue solveOqpBenchmark(	int_t nQP,					/**< Number of QPs. */
-								int_t nV,					/**< Number of variables. */
-								int_t nC,					/**< Number of constraints. */
-								int_t nEC,					/**< Number of equality constraints. */
-								const real_t* const _H,		/**< Hessian matrix. */
-								const real_t* const g,		/**< Sequence of gradient vectors. */
-								const real_t* const _A,		/**< Constraint matrix. */
-								const real_t* const lb,		/**< Sequence of lower bound vectors (on variables). */
-								const real_t* const ub,		/**< Sequence of upper bound vectors (on variables). */
-								const real_t* const lbA,	/**< Sequence of lower constraints' bound vectors. */
-								const real_t* const ubA,	/**< Sequence of upper constraints' bound vectors. */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								BooleanType useHotstarts,	/**< Shall QP solution be hotstarted? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t maxAllowedNWSR, 		/**< Maximum number of working set recalculations to be performed. */
-								real_t& maxNWSR,			/**< Output: Maximum number of performed working set recalculations. */
-								real_t& avgNWSR,			/**< Output: Average number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& avgCPUtime,			/**< Output: Average CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-
-/** Solves an Online QP Benchmark problem (without constraints) as specified
- *  by the arguments. The maximum deviations from the given optimal solution
- *  as well as the maximum CPU time to solve each QP are determined.
- *
- *	Note: This variant is outdated and only kept to ensure 
- *		  backwards-compatibility!
- *
- * \return SUCCESSFUL_RETURN \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue solveOqpBenchmark(	int_t nQP,					/**< Number of QPs. */
-								int_t nV,					/**< Number of variables. */
-								const real_t* const _H,		/**< Hessian matrix. */
-								const real_t* const g,		/**< Sequence of gradient vectors. */
-								const real_t* const lb,		/**< Sequence of lower bound vectors (on variables). */
-								const real_t* const ub,		/**< Sequence of upper bound vectors (on variables). */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t& nWSR, 				/**< Input: Maximum number of working set recalculations; \n
-																 Output: Maximum number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-/** Solves an Online QP Benchmark problem (without constraints) as specified
- *  by the arguments. The maximum deviations from the given optimal solution
- *  as well as the maximum CPU time to solve each QP are determined.
- *
- * \return SUCCESSFUL_RETURN \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue solveOqpBenchmark(	int_t nQP,					/**< Number of QPs. */
-								int_t nV,					/**< Number of variables. */
-								const real_t* const _H,		/**< Hessian matrix. */
-								const real_t* const g,		/**< Sequence of gradient vectors. */
-								const real_t* const lb,		/**< Sequence of lower bound vectors (on variables). */
-								const real_t* const ub,		/**< Sequence of upper bound vectors (on variables). */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								BooleanType useHotstarts,	/**< Shall QP solution be hotstarted? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t maxAllowedNWSR, 		/**< Maximum number of working set recalculations to be performed. */
-								real_t& maxNWSR,			/**< Output: Maximum number of performed working set recalculations. */
-								real_t& avgNWSR,			/**< Output: Average number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& avgCPUtime,			/**< Output: Average CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-
-/** Runs an Online QP Benchmark problem and determines the maximum
- *  violation of the KKT optimality conditions as well as the 
- *  maximum CPU time to solve each QP.
- *
- * \return SUCCESSFUL_RETURN \n
-		   RET_UNABLE_TO_READ_BENCHMARK \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue runOqpBenchmark(	const char* path,			/**< Full path of the benchmark files (without trailing slash!). */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t& nWSR, 				/**< Input: Maximum number of working set recalculations; \n
-																 Output: Maximum number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-
-/** Runs an Online QP Benchmark problem and determines the maximum
- *  violation of the KKT optimality conditions as well as the 
- *  maximum and average number of iterations and CPU time to solve 
- *	each QP.
- *
- * \return SUCCESSFUL_RETURN \n
-		   RET_UNABLE_TO_READ_BENCHMARK \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue runOqpBenchmark(	const char* path,			/**< Full path of the benchmark files (without trailing slash!). */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								BooleanType useHotstarts,	/**< Shall QP solution be hotstarted? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t maxAllowedNWSR, 		/**< Maximum number of working set recalculations to be performed. */
-								real_t& maxNWSR,			/**< Output: Maximum number of performed working set recalculations. */
-								real_t& avgNWSR,			/**< Output: Average number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& avgCPUtime,			/**< Output: Average CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_OQPINTERFACE_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.hpp
deleted file mode 100644
index c0988e4..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.hpp
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/extras/SolutionAnalysis.hpp
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Declaration of the SolutionAnalysis class designed to perform
- *	additional analysis after solving a QP with qpOASES.
- */
-
-
-#ifndef QPOASES_SOLUTIONANALYSIS_HPP
-#define QPOASES_SOLUTIONANALYSIS_HPP
-
-
-#include <qpOASES/SQProblem.hpp>
-#include <qpOASES/SQProblemSchur.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Provides additional tools for analysing QP solutions.
- *
- *	This class is intended to provide additional tools for analysing
- *  a QP solution obtained with qpOASES.
- *
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- */
-class SolutionAnalysis
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		SolutionAnalysis( );
-
-		/** Copy constructor (deep copy). */
-		SolutionAnalysis(	const SolutionAnalysis& rhs		/**< Rhs object. */
-							);
-
-		/** Destructor. */
-		~SolutionAnalysis( );
-
-		/** Assignment operator (deep copy). */
-		SolutionAnalysis& operator=(	const SolutionAnalysis& rhs		/**< Rhs object. */
-										);
-
-
-		/** Computes the maximum violation of the KKT optimality conditions
-		 *  of the current iterate within the QProblemB object.
-		 *	\return Maximum violation of the KKT conditions (or INFTY on error). */
-		real_t getKktViolation(	QProblemB* const qp,		/**< QProblemB to be analysed. */
-								real_t* const maxStat = 0,	/**< Output: maximum value of stationarity condition residual. */
-								real_t* const maxFeas = 0,	/**< Output: maximum value of primal feasibility violation. */
-								real_t* const maxCmpl = 0	/**< Output: maximum value of complementarity residual. */
-								) const;
-
-		/** Computes the maximum violation of the KKT optimality conditions
-		 *  of the current iterate within the QProblem object.
-		 *	\return Maximum violation of the KKT conditions (or INFTY on error). */
-		real_t getKktViolation(	QProblem* const qp,			/**< QProblem to be analysed. */
-								real_t* const maxStat = 0,	/**< Output: maximum value of stationarity condition residual. */
-								real_t* const maxFeas = 0,	/**< Output: maximum value of primal feasibility violation. */
-								real_t* const maxCmpl = 0	/**< Output: maximum value of complementarity residual. */
-								) const;
-
-		/** Computes the maximum violation of the KKT optimality conditions
-		 *  of the current iterate within the SQProblem object.
-		 *	\return Maximum violation of the KKT conditions (or INFTY on error). */
-		real_t getKktViolation(	SQProblem* const qp,		/**< SQProblem to be analysed. */
-								real_t* const maxStat = 0,	/**< Output: maximum value of stationarity condition residual. */
-								real_t* const maxFeas = 0,	/**< Output: maximum value of primal feasibility violation. */
-								real_t* const maxCmpl = 0	/**< Output: maximum value of complementarity residual. */
-								) const;
-
-
-		/** Computes the variance-covariance matrix of the QP output for uncertain
-			inputs.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HOTSTART_FAILED \n
-		 			RET_STEPDIRECTION_FAILED_TQ \n
-					RET_STEPDIRECTION_FAILED_CHOLESKY */
-		returnValue getVarianceCovariance(	QProblemB* const qp,			/**< QProblemB to be analysed. */
-											const real_t* const g_b_bA_VAR,	/**< Input:  Variance-covariance of g, the bounds lb and ub, 
-																			 *			 and lbA and ubA respectively. Dimension: 2nV x 2nV */
-											real_t* const Primal_Dual_VAR	/**< Output: The result for the variance-covariance of the primal 
-																			 *			 and dual variables. Dimension: 2nV x 2nV */
-											) const;
-
-		/** Computes the variance-covariance matrix of the QP output for uncertain
-			inputs.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HOTSTART_FAILED \n
-		 			RET_STEPDIRECTION_FAILED_TQ \n
-					RET_STEPDIRECTION_FAILED_CHOLESKY */
-		returnValue getVarianceCovariance(	QProblem* const qp,				/**< QProblem to be analysed. */
-											const real_t* const g_b_bA_VAR,	/**< Input:  Variance-covariance of g, the bounds lb and ub, 
-																			 *			 and lbA and ubA respectively. Dimension:  (2nV+nC) x (2nV+nC) */
-											real_t* const Primal_Dual_VAR	/**< Output: The result for the variance-covariance of the primal 
-																			 *			 and dual variables. Dimension:  (2nV+nC) x (2nV+nC) */
-											) const;
-
-		/** Computes the variance-covariance matrix of the QP output for uncertain
-			inputs.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HOTSTART_FAILED \n
-		 			RET_STEPDIRECTION_FAILED_TQ \n
-					RET_STEPDIRECTION_FAILED_CHOLESKY */
-		returnValue getVarianceCovariance(	SQProblem* const qp,			/**< SQProblem to be analysed. */
-											const real_t* const g_b_bA_VAR,	/**< Input:  Variance-covariance of g, the bounds lb and ub, 
-																			 *			 and lbA and ubA respectively. Dimension:  (2nV+nC) x (2nV+nC) */
-											real_t* const Primal_Dual_VAR	/**< Output: The result for the variance-covariance of the primal 
-																			 *			 and dual variables. Dimension:  (2nV+nC) x (2nV+nC) */
-											) const;
-
-		/** Checks if a direction of negative curvature shows up if we remove all bounds that just recently became active */
-		returnValue checkCurvatureOnStronglyActiveConstraints(	SQProblemSchur* qp );
-		returnValue checkCurvatureOnStronglyActiveConstraints(	SQProblem* qp );
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/extras/SolutionAnalysis.ipp>
-
-#endif	/* QPOASES_SOLUTIONANALYSIS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.ipp
deleted file mode 100644
index 3404cbe..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.ipp
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/extras/SolutionAnalysis.ipp
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Implementation of inlined member functions of the SolutionAnalysis class
- *	designed to perform additional analysis after solving a QP with qpOASES.
- *
- */
-
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/Makefile b/extlibs/qpOASES-3.2.0/interfaces/CUTEst/Makefile
deleted file mode 100644
index 0b74458..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/Makefile
+++ /dev/null
@@ -1,79 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  cutestDriver/Makefile
-##	Author:    Dennis Janka
-##	Version:   3.2
-##	Date:      2015
-##
-
-# include directories, relative
-IDIR = ../../include
-SRCDIR = ../../src
-BINDIR = ../../bin
-CUTESTLIBPATH = ${CUTEST}/objects/${MYARCH}/double
-
-# don't change that (for now) ...
-PROBLEMPATH = ./prob
-
-# file extensions
-CPP = g++
-CPPFLAGS = -Wall -pedantic -Wshadow -O0 -finline-functions -fPIC -DLINUX -g
-FF = gfortran
-FFLAGS =
-
-#link against CUTEst library, qpOASES library and compiled test problem
-LINKOPTS = -L${CUTESTLIBPATH} -L${PROBLEMPATH} -Wl,-rpath=${PROBLEMPATH} \
-		-L${BINDIR} -Wl,-rpath=${BINDIR} -lqpOASES \
-		-lcutest -llapack -lm -lgfortran -lprob
-
-IFLAGS      = -I${IDIR} \
-	      -I${CUTEST}/include
-
-QPOASES_EXES = \
-	qpoasesCutest
-
-##
-##	targets
-##
-
-all: ${QPOASES_EXES}
-
-qpoasesCutest: qpoasesCutest.o
-	@echo "Creating" $@
-	${CPP} -o $@ ${CPPFLAGS} $< ${LINKOPTS}
-
-clean:
-	rm -f *.o ${QPOASES_EXES}
-
-clobber: clean
-
-%.o: %.cpp
-	@echo "Creating" $@
-	@${CPP} -c ${IFLAGS} ${CPPFLAGS} $< -o $@
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/makeprob b/extlibs/qpOASES-3.2.0/interfaces/CUTEst/makeprob
deleted file mode 100755
index 237a895..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/makeprob
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/bin/bash
-
-if [ -z "$1" ]; then
-    echo Usage: $0 problemname
-    exit
-fi
-
-PROBLEMPATH="./prob"
-mkdir -p $PROBLEMPATH
-cd $PROBLEMPATH
-
-# Call sifdecoder (additional parameter for problem size can be passed)
-if [ -z "$2" ]; then
-    sifdecoder $MASTSIF/$1
-else
-    sifdecoder -param N=$2 $MASTSIF/$1
-fi
-
-# Compile objects
-gfortran -c RANGE.f -fPIC -o RANGE.o
-gfortran -c ELFUN.f -fPIC -o ELFUN.o
-gfortran -c GROUP.f -fPIC -o GROUP.o
-
-# Build shared library
-gfortran -shared -o libprob.so RANGE.o ELFUN.o GROUP.o
-
-cd ../
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/qpoasesCutest.cpp b/extlibs/qpOASES-3.2.0/interfaces/CUTEst/qpoasesCutest.cpp
deleted file mode 100644
index 4045b9b..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/qpoasesCutest.cpp
+++ /dev/null
@@ -1,498 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/CUTEst/qpoasesCutest.cpp
- *	\author Dennis Janka
- *	\version 3.2
- *	\date 2015
- *
- *	Solve the CUTEst problem in prob/ subdirectory
- */
-
-/* Choose one or more methods to solve the QP */
-#define SOLVE_DENSE  0          /* Standard qpOASES, matrices passed dense */
-#define SOLVE_SPARSE 0          /* Standard qpOASES, matrices passed sparse */
-#define SOLVE_SCHUR  1          /* Schur complement qpOASES */
-
-
-#include <qpOASES.hpp>
-#include <sys/time.h>
-
-extern "C" {   /* To prevent C++ compilers from mangling symbols */
-#include <cutest.h>
-}
-
-
-int convertTripletToHbf( int m, int n, int nnz,
-                         double *vals, int *iRow, int *jCol,
-                         double *vals_hbf, int *iRow_hbf, int *jCol_hbf )
-{
-    int i, ii, j, k;
-
-    /* Initialize output arrays */
-    for( k=0; k<n+1; k++ )
-        jCol_hbf[k] = 0;
-    for( k=0; k<nnz; k++ )
-    {
-        iRow_hbf[k] = 0;
-        vals_hbf[k] = 0.0;
-    }
-
-    /* Count elements for each column */
-    for( k=0; k<nnz; k++ )
-    {
-        j = jCol[k]-1; // Convert Fortran to C indices!
-        jCol_hbf[j]++;
-    }
-
-    /* Set the column pointers */
-    jCol_hbf[n] = nnz;
-    for( k=n-1; k>-1; k-- )
-        jCol_hbf[k] = jCol_hbf[k+1] - jCol_hbf[k];
-
-    /* Put row indices and values at the right places, use jCol_hbf[j] to track elements of the jth column */
-    for( k=0; k<nnz; k++ )
-    {
-        i = iRow[k]-1; // Convert Fortran to C indices!
-        j = jCol[k]-1;
-        ii = jCol_hbf[j];
-
-        vals_hbf[ii] = vals[k];
-        iRow_hbf[ii] = i;
-        jCol_hbf[j] = ii + 1;
-    }
-
-    /* Shift all column pointers back again */
-    for( k=n-1; k>0; k-- )
-        jCol_hbf[k] = jCol_hbf[k-1];
-    jCol_hbf[0] = 0;
-
-    return 0;
-}
-
-
-
-int main( )
-{
-    /*
-     * PART I: Extract CUTEst problemdata:
-     *
-     * - problem dimension
-     * - variable and constraint bounds
-     * - objective gradient
-     * - sparse and dense Jacobian
-     * - sparse and dense Hessian
-     * - initial values for x and y
-     */
-
-    /* From CUTEst generic c package */
-    char *fname = "prob/OUTSDIF.d"; /* CUTEst data file */
-    int funit = 42;                 /* FORTRAN unit number for OUTSDIF.d */
-    int iout = 6;                   /* FORTRAN unit number for error output */
-    int io_buffer = 11;             /* FORTRAN unit internal input/output */
-    int ierr;                       /* Exit flag from OPEN and CLOSE */
-    int status;                     /* Exit flag from CUTEst tools */
-    int e_order = 0, l_order = 0, v_order = 0;
-
-
-    /* Problem description: the following variables will be set for qpOASES call */
-    int nVar;                       /* number of variables */
-    int nCon;                       /* number of constraints */
-    double *lb, *ub;                /* lower and upper bounds for variables */
-    double *lbA, *ubA;              /* lower and upper bounds for constraints */
-    double *g;                      /* objective gradient */
-#if SOLVE_DENSE
-    double *hesDense, *jacDense;    /* dense Hessian and Jacobian */
-#endif
-#if SOLVE_SCHUR || SOLVE_SPARSE
-                                    /* Sparse Hessian and Jacobian in Harwell-Boeing format: */
-    int nnzj, nnzh;                 /* number of nonzero elements in Jacobian and Hessian */
-    double *hesVal, *jacVal;        /* nonzero elements of Hessian and Jacobian */
-    int *hesIndCol, *hesIndRow;     /* column and row indices of Hessian */
-    int *jacIndCol, *jacIndRow;     /* column and row indices of Jacobian */
-#endif
-
-    /* Additional problem description: these variables are set and may also be used by qpOASES */
-    double obj;                     /* constant objective offset */
-    double *xInit;                  /* initial values for primal variables */
-    double *yInit;                  /* initial values for dual variables */
-    logical *isEq;                  /* logical array to mark equality constraints */
-
-
-    /* Open problem description file OUTSDIF.d */
-    ierr = 0;
-    FORTRAN_open( &funit, fname, &ierr );
-    if( ierr ) {
-        printf("Error opening file OUTSDIF.d.\nAborting.\n");
-        exit(1);
-    }
-
-    /* Determine problem size */
-    CUTEST_cdimen( &status, &funit, &nVar, &nCon );
-    if( status ) {
-        printf("** CUTEst error, status = %d, aborting\n", status);
-        exit(status);
-    }
-
-    /* Reserve memory for variables, bounds, and multipliers */
-    /* and call appropriate initialization routine for CUTEst */
-    logical *isLinear;
-    xInit = new double[nVar];
-    yInit = new double[nCon];
-    lb = new double[nVar];
-    ub = new double[nVar];
-    lbA = new double[nCon];
-    ubA = new double[nCon];
-    isEq = new logical[nCon];
-    isLinear = new logical[nCon];
-
-    CUTEST_csetup( &status, &funit, &iout, &io_buffer,
-                    &nVar, &nCon, xInit, lb, ub,
-                    yInit, lbA, ubA, isEq, isLinear,
-                    &e_order, &l_order, &v_order );
-    if( status ) {
-        printf("** CUTEst_csetup: error, status = %d, aborting\n", status);
-        exit(status);
-    }
-
-    /* Evaluate gradient and objective at x=0 to get g */
-    logical grad = 1;
-    g = new double[nVar];
-    double *xZero = new double[nVar];
-    for( int k=0; k<nVar; k++ ) xZero[k] = 0.0;
-    CUTEST_cofg( &status, &nVar, xZero, &obj, g, &grad );
-    if( status ) {
-        printf("** CUTEst_cofg: error, status = %d, aborting\n", status);
-        exit(status);
-    }
-
-    double *cVal = new double[nCon];
-#if SOLVE_SPARSE || SOLVE_SCHUR
-    /* Evaluate sparse Jacobian in triplet format */
-    int lj = nCon*nVar; // overestimate
-    double *J_val = new double[lj];
-    int *J_var = new int[lj];
-    int *J_fun = new int[lj];
-
-    if( nCon > 0 )
-    {
-        /* Evaluate sparse constraints at x=0 to get the rhs of equality constraints (they are not set by csetup!) */
-        CUTEST_ccfsg( &status, &nVar, &nCon, xZero, cVal, &nnzj, &lj, J_val, J_var, J_fun, &grad );
-        if( status ) {
-            printf("** CUTEst_ccfsg: error, status = %d, aborting\n", status);
-            exit(status);
-        }
-
-        for( int k=0; k<nCon; k++ )
-            if( isEq[k] )
-                lbA[k] = ubA[k] = -cVal[k];
-
-        jacIndCol = new int[nVar+1];
-        jacIndRow = new int[nnzj];
-        jacVal = new double[nnzj];
-        convertTripletToHbf( nCon, nVar, nnzj, J_val, J_fun, J_var, jacVal, jacIndRow, jacIndCol );
-
-    }
-    delete[] J_val;
-    delete[] J_fun;
-    delete[] J_var;
-
-    /* Evaluate sparse Hessian in triplet format */
-    int lh = nVar*nVar; // overestimate
-    double *H_val = new double[lh];
-    int *H_col = new int[lh];
-    int *H_row = new int[lh];
-    CUTEST_csh( &status, &nVar, &nCon, xInit, yInit, &nnzh, &lh, H_val, H_row, H_col );
-    if( status ) {
-        printf("** CUTEst_csh: error, status = %d, aborting\n", status);
-        exit(status);
-    }
-    /* Only upper triangular matrix is returned by CUTEst, to be safe, set H to be the full matrix */
-    int count = 0;
-    for( int k=0; k<nnzh; k++ )
-        if( H_row[k] != H_col[k] )
-        {
-            H_val[nnzh+count] = H_val[k];
-            H_col[nnzh+count] = H_row[k];
-            H_row[nnzh+count] = H_col[k];
-            count++;
-        }
-    nnzh = nnzh + count;
-
-    hesIndCol = new int[nVar+1];
-    hesIndRow = new int[nnzh];
-    hesVal = new double[nnzh];
-    convertTripletToHbf( nVar, nVar, nnzh, H_val, H_row, H_col, hesVal, hesIndRow, hesIndCol );
-
-    delete[] H_val;
-    delete[] H_row;
-    delete[] H_col;
-#endif
-
-#if SOLVE_DENSE
-    if( nCon > 0 )
-    {
-        /* Evaluate dense constraints at x=0 to get the rhs of equality constraints (they are not set by csetup!) */
-        logical trans = 1;
-        jacDense = new double[nCon*nVar];
-        CUTEST_ccfg( &status, &nVar, &nCon, xZero, cVal, &trans, &nVar, &nCon, jacDense, &grad );
-    }
-
-    /* Evaluate dense Hessian */
-    hesDense = new double[nVar*nVar];
-    CUTEST_cdh( &status, &nVar, &nCon, xInit, yInit, &nVar, hesDense );
-    if( status ) {
-        printf("** CUTEst_cdh: error, status = %d, aborting\n", status);
-        exit(status);
-    }
-#endif
-    delete[] xZero;
-
-    /*
-     * End of CUTEst stuff
-     */
-
-
-    /*
-     * PART II: qpOASES
-     */
-
-    USING_NAMESPACE_QPOASES
-
-    Options opts;
-#if SOLVE_DENSE
-    SymDenseMat *H_d;
-    DenseMatrix *A_d;
-#endif
-#if SOLVE_SCHUR || SOLVE_SPARSE
-    SymSparseMat *H_s;
-    SparseMatrix *A_s;
-#endif
-    Bounds bInit( nVar );
-    Constraints cInit( nCon );
-    double *xOpt = new double[nVar];
-    double *yOpt = new double[nVar+nCon];
-    Bounds bOpt( nVar );
-    Constraints cOpt( nCon );
-
-#if SOLVE_DENSE
-    A_d = new DenseMatrix( nCon, nVar, nVar, jacDense );
-    H_d = new SymDenseMat( nVar, nVar, nVar, hesDense );
-#endif
-#if SOLVE_SCHUR || SOLVE_SPARSE
-    A_s = new SparseMatrix( nCon, nVar, jacIndRow, jacIndCol, jacVal );
-    H_s = new SymSparseMat( nVar, nVar, hesIndRow, hesIndCol, hesVal );
-    H_s->createDiagInfo();
-#endif
-
-    /* Set initial working set depending on initial values for x and y */
-    /// \todo I have not tested this
-    double eps = 2.0e-16;
-    for( int k=0; k<nVar; k++ )
-    {
-        if( getAbs( xInit[k] - lb[k] ) < eps )
-            bInit.setStatus( k, ST_LOWER );
-        else if( getAbs( xInit[k] - ub[k] ) < eps )
-            bInit.setStatus( k, ST_UPPER );
-        else
-            bInit.setStatus( k, ST_INACTIVE );
-
-        bInit.setType( k, ST_UNKNOWN );
-    }
-    /// \todo should do this based on yInit (take care of signs of lambda)
-    for( int k=0; k<nCon; k++ )
-    {
-        if( getAbs( cVal[k] - lbA[k] ) < eps )
-            cInit.setStatus( k, ST_LOWER );
-        else if( getAbs( cVal[k] - ubA[k] ) < eps )
-            cInit.setStatus( k, ST_UPPER );
-        else
-            cInit.setStatus( k, ST_INACTIVE );
-
-        if( isEq[k] )
-            cInit.setType( k, ST_EQUALITY );
-        else
-            cInit.setType( k, ST_UNKNOWN );
-    }
-    delete[] cVal;
-
-    /* Set up QProblem object(s). */
-#if SOLVE_SCHUR
-    SQProblemSchur qpSchur( nVar, nCon, HST_UNKNOWN, 75 );
-#endif
-#if SOLVE_DENSE
-    SQProblem qpDense( nVar, nCon, HST_UNKNOWN );
-#endif
-#if SOLVE_SPARSE
-    SQProblem qpSparse( nVar, nCon, HST_UNKNOWN );
-#endif
-
-    /* Set options */
-    returnValue ret;
-    int maxIt = 10000;
-    double maxTime = 100000;
-
-    //opts.setToReliable();
-    opts.setToDefault();
-
-    //opts.printLevel = PL_HIGH;
-    //opts.enableRamping = BT_TRUE;
-    //opts.enableFarBounds = BT_TRUE;
-    //opts.enableFlippingBounds = BT_TRUE;
-    //opts.enableRegularisation = BT_FALSE;
-    //opts.enableFullLITests = BT_TRUE;
-    //opts.enableNZCTests = BT_TRUE;
-    //opts.enableDriftCorrection = 1;
-    //opts.enableCholeskyRefactorisation = 1;
-    opts.enableEqualities = BT_TRUE;
-    //opts.terminationTolerance =  2.2204e-09;
-    //opts.boundTolerance =  2.2204e-10;
-    //opts.boundRelaxation =  10000;
-    //opts.epsNum = -2.2204e-13;
-    //opts.epsDen =  2.2204e-13;
-    //opts.maxPrimalJump =  100000000;
-    //opts.maxDualJump =  100000000;
-    //opts.initialRamping =  0.50000;
-    //opts.finalRamping =  1;
-    //opts.initialFarBounds =  1000000;
-    //opts.growFarBounds =  1000;
-    opts.initialStatusBounds =  ST_INACTIVE;
-    //opts.epsFlipping =  2.2204e-13;
-    //opts.numRegularisationSteps = 4;
-    //opts.epsRegularisation =  2.2204e-13;
-    opts.numRefinementSteps = 3;
-    //opts.epsIterRef =  2.2204e-14;
-    //opts.epsLITests =  2.2204e-09;
-    //opts.epsNZCTests =  6.6613e-13;
-    opts.enableInertiaCorrection = BT_TRUE;
-    opts.rcondSMin = 1.0e-14;
-
-
-    /* Solve QPs. */
-    int nWSR;
-    double time;
-    struct timeval startTime;
-    struct timeval endTime;
-    int elapsedTime;
-    gettimeofday(&startTime, NULL);
-#if SOLVE_DENSE
-    printf( "\n----------Begin Standard version with dense matrices----------\n" );
-    qpDense.setOptions( opts );
-    nWSR = maxIt;
-    time = maxTime;
-
-    for( int k=0; k<nVar; k++ )
-    {
-        xOpt[k] = xInit[k];
-        yOpt[k] = 0.0;
-    }
-    for( int k=0; k<nCon; k++ ) yOpt[k+nVar] = yInit[k]; // what about lambda for bound constraints?
-    bOpt = Bounds( bInit );
-    cOpt = Constraints( cInit );
-    ret = qpDense.init( H_d, g, A_d, lb, ub, lbA, ubA, nWSR, &time, xOpt, yOpt, &bOpt, &cOpt );
-
-    if( ret == SUCCESSFUL_RETURN ) printf("Obj. = %23.16e\n", qpDense.getObjVal() + obj );
-    printf( "\n-----------End Standard version with dense matrices-----------\n" );
-#endif
-
-#if SOLVE_SCHUR
-    printf( "\n----------Begin Schur complement version----------\n" );
-    qpSchur.setOptions( opts );
-    nWSR = maxIt;
-    time = maxTime;
-
-    for( int k=0; k<nVar; k++ )
-    {
-        xOpt[k] = xInit[k];
-        yOpt[k] = 0.0;
-    }
-    for( int k=0; k<nCon; k++ ) yOpt[k+nVar] = yInit[k]; // what about lambda for bound constraints?
-    bOpt = Bounds( bInit );
-    cOpt = Constraints( cInit );
-    //ret = qpSchur.init( H_s, g, A_s, lb, ub, lbA, ubA, nWSR, &time, xOpt, yOpt, &bOpt, &cOpt );
-    ret = qpSchur.init( H_s, g, A_s, lb, ub, lbA, ubA, nWSR, &time );
-
-    if( ret == SUCCESSFUL_RETURN ) printf("Obj. = %23.16e\n", qpSchur.getObjVal() + obj );
-    printf( "\n\n-----------End Schur complement version-----------\n" );
-#endif
-
-#if SOLVE_SPARSE
-    printf( "\n----------Begin Standard version with sparse matrices----------\n" );
-    qpSparse.setOptions( opts );
-    nWSR = maxIt;
-    time = maxTime;
-
-    for( int k=0; k<nVar; k++ )
-    {
-        xOpt[k] = xInit[k];
-        yOpt[k] = 0.0;
-    }
-    for( int k=0; k<nCon; k++ ) yOpt[k+nVar] = yInit[k]; // what about lambda for bound constraints?
-    bOpt = Bounds( bInit );
-    cOpt = Constraints( cInit );
-    ret = qpSparse.init( H_s, g, A_s, lb, ub, lbA, ubA, nWSR, &time, xOpt, yOpt, &bOpt, &cOpt );
-
-    if( ret == SUCCESSFUL_RETURN ) printf("Obj. = %23.16e\n", qpSparse.getObjVal() + obj );
-    printf( "\n-----------End Standard version with sparse matrices-----------\n" );
-#endif
-    gettimeofday(&endTime, NULL);
-
-    elapsedTime = (endTime.tv_sec*1000000  + (endTime.tv_usec)) -
-                  (startTime.tv_sec*1000000  + (startTime.tv_usec));
-    printf( "Took %g seconds.\n", elapsedTime/1000000.0 );
-
-    /* Clean up */
-    delete[] g;
-    delete[] lb;
-    delete[] ub;
-    delete[] lbA;
-    delete[] ubA;
-    delete[] isEq;
-    delete[] isLinear;
-    delete[] xOpt;
-    delete[] yOpt;
-    delete[] xInit;
-    delete[] yInit;
-
-#if SOLVE_SCHUR || SOLVE_SPARSE
-    delete[] hesVal;
-    delete[] hesIndRow;
-    delete[] hesIndCol;
-    if( nCon > 0 )
-    {
-        delete[] jacVal;
-        delete[] jacIndRow;
-        delete[] jacIndCol;
-    }
-#endif
-#if SOLVE_DENSE
-    delete[] hesDense;
-    if( nCon > 0 )
-        delete[] jacDense;
-#endif
-
-    return ret;
-}
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/readme.txt b/extlibs/qpOASES-3.2.0/interfaces/CUTEst/readme.txt
deleted file mode 100644
index 2983489..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/readme.txt
+++ /dev/null
@@ -1,39 +0,0 @@
-CUTEst interface for qpOASES
-by Dennis Janka <dennis.janka@iwr.uni.heidelberg.de>
-
-====================================================
-
-0.) Files included:
-
-    - qpoasesCutest.cpp
-    - Makefile
-    - makeprob
-    - readme.txt
-
-1.) Download and install CUTEst from
-
-    http://ccpforge.cse.rl.ac.uk/gf/project/cutest/wiki/
-
-    Make sure all environment variables are set as instructed.
-    (in particular $CUTEST, $MYARCH and $MASTSIF)
-
-2.) To decode and compile a problem, type:
-
-    ./makeprob <problemname>
-
-    For problems that come in different sizes (e.g. NCVXQP[1-9]) the size
-    parameter ( N=<size> ) may be passed as a second argument:
-
-    ./makeprob <problemname> <size>
-
-    This calls "sifdecoder" to decode the .sif file and creates a shared
-    library libprob.so in prob/ that will be linked against the
-    qpOASES CUTEst interface.
-
-3.) Finally, call "make" to compile and link qpoasesCutest.
-    You may have to set the correct paths for the qpOASES library and
-    header files in the makefile.
-
-4.) The command ./qpoasesCutest runs qpOASES with the latest compiled
-    .sif problem. For solving further problems, only the appropriate
-    "./makeprob" call is required.
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/Makefile b/extlibs/qpOASES-3.2.0/interfaces/c/Makefile
deleted file mode 100644
index 403004e..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/Makefile
+++ /dev/null
@@ -1,128 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  interfaces/c/Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014-2015
-##
-
-
-include ../../make.mk
-
-##
-##	flags
-##
-
-IFLAGS =	-I. \
-		-I${IDIR} \
-		-I${SRCDIR}
-
-QPOASES_WRAPPER_OBJECTS = \
-	${SRCDIR}/SQProblem.${OBJEXT} \
-	${SRCDIR}/QProblem.${OBJEXT} \
-	${SRCDIR}/QProblemB.${OBJEXT} \
-	${SRCDIR}/Bounds.${OBJEXT} \
-	${SRCDIR}/Constraints.${OBJEXT} \
-	${SRCDIR}/SubjectTo.${OBJEXT} \
-	${SRCDIR}/Indexlist.${OBJEXT} \
-	${SRCDIR}/Flipper.${OBJEXT} \
-	${SRCDIR}/Utils.${OBJEXT} \
-	${SRCDIR}/Options.${OBJEXT} \
-	${SRCDIR}/Matrices.${OBJEXT} \
-	${SRCDIR}/MessageHandling.${OBJEXT} \
-	qpOASES_wrapper.${OBJEXT}
-
-QPOASES_DEPENDS = \
-	${IDIR}/qpOASES.hpp \
-	${IDIR}/qpOASES/SQProblem.hpp \
-	${IDIR}/qpOASES/QProblem.hpp \
-	${IDIR}/qpOASES/Flipper.hpp \
-	${IDIR}/qpOASES/QProblemB.hpp \
-	${IDIR}/qpOASES/Bounds.hpp \
-	${IDIR}/qpOASES/Constraints.hpp \
-	${IDIR}/qpOASES/SubjectTo.hpp \
-	${IDIR}/qpOASES/Indexlist.hpp \
-	${IDIR}/qpOASES/Utils.hpp \
-	${IDIR}/qpOASES/Constants.hpp \
-	${IDIR}/qpOASES/Types.hpp \
-	${IDIR}/qpOASES/Options.hpp \
-	${IDIR}/qpOASES/Matrices.hpp \
-	${IDIR}/qpOASES/MessageHandling.hpp \
-	qpOASES_wrapper.h
-
-QPOASES_C_EXAMPLES = \
-	${BINDIR}/c_example1${EXE} \
-	${BINDIR}/c_example1a${EXE} \
-	${BINDIR}/c_example1b${EXE}
-
-
-##
-##	targets
-##
-
-all: ${LINK_DEPENDS_WRAPPER} ${QPOASES_C_EXAMPLES}
-
-
-${BINDIR}/libqpOASES_wrapper.${LIBEXT}: ${QPOASES_WRAPPER_OBJECTS}
-	@${ECHO} "Creating" $@
-	@${AR} r $@ qpOASES_wrapper.${OBJEXT}
-
-${BINDIR}/libqpOASES_wrapper.${DLLEXT}: ${QPOASES_WRAPPER_OBJECTS}
-	@${ECHO} "Creating" $@
-	${CC} ${SHARED} ${DEF_TARGET} qpOASES_wrapper.${OBJEXT} ${LINK_LIBRARIES_WRAPPER}
-
-clean:
-	@${ECHO} "Cleaning up (interfaces/c)"
-	@${RM} -f *.${OBJEXT} ${BINDIR}/*.${LIBEXT} ${BINDIR}/*.${DLLEXT} ${BINDIR}/c_example*${EXE}
-
-clobber: clean
-
-
-%.${OBJEXT}: %.cpp ${QPOASES_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} -D__C_WRAPPER__ $<
-
-c_example1.${OBJEXT}: c_example1.c ${LINK_DEPENDS_WRAPPER}
-	@${ECHO} "Creating" $@
-	@${CC} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-c_example1a.${OBJEXT}: c_example1a.c ${LINK_DEPENDS_WRAPPER}
-	@${ECHO} "Creating" $@
-	@${CC} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-c_example1b.${OBJEXT}: c_example1b.c ${LINK_DEPENDS_WRAPPER}
-	@${ECHO} "Creating" $@
-	@${CC} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-
-${BINDIR}/%${EXE}: %.${OBJEXT} ${LINK_DEPENDS_WRAPPER}
-	@${ECHO} "Creating" $@
-	${CC} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} $< ${QPOASES_LINK_WRAPPER} ${LINK_LIBRARIES_WRAPPER}
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1.c b/extlibs/qpOASES-3.2.0/interfaces/c/c_example1.c
deleted file mode 100644
index 71320e8..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1.c
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/c/c_example1.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using QProblem class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-	int nWSR;
-	qpOASES_Options options;
-	
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	real_t obj;
-	int status;
-
-	qpOASES_Options_init( &options,0 );
-	options.printLevel = PL_MEDIUM;
-
-
-	QProblem_setup(	2,1,HST_UNKNOWN );
-
-	/* Solve first QP. */
-	nWSR = 10;
-	QProblem_init(	H,g,A,lb,ub,lbA,ubA,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	QProblem_hotstart(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-	
-	QProblem_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1a.c b/extlibs/qpOASES-3.2.0/interfaces/c/c_example1a.c
deleted file mode 100644
index 61cb308..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1a.c
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/c/c_example1a.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using SQProblem class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-	int nWSR;
-
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	real_t obj;
-	int status;
-
-	qpOASES_Options options;
-	qpOASES_Options_init( &options,0 );
-
-	
-	SQProblem_setup( 2,1,HST_UNKNOWN );
-	
-	/* Solve first QP. */
-	nWSR = 10;
-	SQProblem_init(	H,g,A,lb,ub,lbA,ubA,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	SQProblem_hotstart(	H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-	
-	SQProblem_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1b.c b/extlibs/qpOASES-3.2.0/interfaces/c/c_example1b.c
deleted file mode 100644
index eca60d6..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1b.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/c/example1b.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using QProblemB class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-
-	int nWSR;
-	qpOASES_Options options;
-
-	real_t xOpt[2];
-	real_t yOpt[2];
-	real_t obj;
-	int status;
-
-	qpOASES_Options_init( &options,0 );
-	/*options.enableFlippingBounds = 0; */
-	options.initialStatusBounds = ST_INACTIVE;
-	options.numRefinementSteps = 1;
-	options.enableCholeskyRefactorisation = 1;
-
-
-	QProblemB_setup( 2,HST_UNKNOWN );
-
-	/* Solve first QP. */
-	nWSR = 10;
-	QProblemB_init(	H,g,lb,ub,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	QProblemB_hotstart(	g_new,lb_new,ub_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1], obj );
-
-	
-	QProblemB_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.cpp b/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.cpp
deleted file mode 100644
index 4d17c4a..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.cpp
+++ /dev/null
@@ -1,576 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/c/qpOASES_wrapper.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Interface that enables to call qpOASES from plain C.
- *
- */
-
-
-#include <qpOASES.hpp>
-
-USING_NAMESPACE_QPOASES
-
-
-extern "C" {
-#include "qpOASES_wrapper.h"
-}
-
-
-
-
-/*
- *	q p O A S E S _ O p t i o n s _ i n i t
- */
-int_t qpOASES_Options_init(	qpOASES_Options* const options,
-							int_t mode
-							)
-{
-	if ( ( mode < 0 ) || ( mode > 2 ) )
-		return -1;
-
-	if ( options == 0 )
-		return -1;
-
-
-	/* setup default */
-	options->printLevel = PL_MEDIUM;
-	#ifdef __DEBUG__
-	options->printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	options->printLevel = PL_NONE;
-	#endif
-
-	options->enableRamping                 =  BT_TRUE;
-	options->enableFarBounds               =  BT_TRUE;
-	options->enableFlippingBounds          =  BT_TRUE;
-	options->enableRegularisation          =  BT_FALSE;
-	options->enableFullLITests             =  BT_FALSE;
-	options->enableNZCTests                =  BT_TRUE;
-	options->enableDriftCorrection         =  1;
-	options->enableCholeskyRefactorisation =  0;
-	options->enableEqualities              =  BT_FALSE;
-
-	#ifdef __USE_SINGLE_PRECISION__
-	options->terminationTolerance          =  1.0e2 * EPS;
-	options->boundTolerance                =  1.0e2 * EPS;
-	#else
-	options->terminationTolerance          =  5.0e6 * EPS;
-	options->boundTolerance                =  1.0e6 * EPS;
-	#endif
-	options->boundRelaxation               =  1.0e4;
-	#ifdef __USE_SINGLE_PRECISION__
-	options->epsNum                        = -1.0e2 * EPS;
-	options->epsDen                        =  1.0e2 * EPS;
-	#else
-	options->epsNum                        = -1.0e3 * EPS;
-	options->epsDen                        =  1.0e3 * EPS;
-	#endif
-	options->maxPrimalJump                 =  1.0e8;
-	options->maxDualJump                   =  1.0e8;
-
-	options->initialRamping                =  0.5;
-	options->finalRamping                  =  1.0;
-	options->initialFarBounds              =  1.0e6;
-	options->growFarBounds                 =  1.0e3;
- 	options->initialStatusBounds           =  ST_LOWER;
-	#ifdef __USE_SINGLE_PRECISION__
-	options->epsFlipping                   =  5.0e1 * EPS;
-	#else
-	options->epsFlipping                   =  1.0e3 * EPS;
-	#endif
-	options->numRegularisationSteps        =  0;
-	#ifdef __USE_SINGLE_PRECISION__
-	options->epsRegularisation             =  2.0e1 * EPS;
-	options->numRefinementSteps            =  2;
-	#else
-	options->epsRegularisation             =  1.0e3 * EPS;
-	options->numRefinementSteps            =  1;
-	#endif
-	options->epsIterRef                    =  1.0e2 * EPS;
-	#ifdef __USE_SINGLE_PRECISION__
-	options->epsLITests                    =  5.0e1 * EPS;
-	options->epsNZCTests                   =  1.0e2 * EPS;
-	#else
-	options->epsLITests                    =  1.0e5 * EPS;
-	options->epsNZCTests                   =  3.0e3 * EPS;
-	#endif
-
-	options->enableDropInfeasibles         =  BT_FALSE;
-    options->dropBoundPriority             =  1;
-    options->dropEqConPriority             =  1;
-    options->dropIneqConPriority           =  1;
-
-
-	switch ( mode )
-	{
-		case 0:
-			/* default, already set */
-			break;
-
-
-		case 1:
-			/* reliable */
-			options->enableFullLITests             =  BT_TRUE;
-			options->enableCholeskyRefactorisation =  1;
-
-			#ifdef __USE_SINGLE_PRECISION__
-			options->numRefinementSteps            =  3;
-			#else
-			options->numRefinementSteps            =  2;
-			#endif
-
-			
-		case 2:
-			/* MPC */
-			options->enableRamping                 =  BT_FALSE;
-			options->enableFarBounds               =  BT_TRUE;
-			options->enableFlippingBounds          =  BT_FALSE;
-			options->enableRegularisation          =  BT_TRUE;
-			options->enableNZCTests                =  BT_FALSE;
-			options->enableDriftCorrection         =  0;
-			options->enableEqualities              =  BT_TRUE;
-
-			#ifdef __USE_SINGLE_PRECISION__
-			options->terminationTolerance          =  1.0e3 * EPS;
-			#else
-			options->terminationTolerance          =  1.0e9 * EPS;
-			#endif
-
-			options->initialStatusBounds           =  ST_INACTIVE;
-			options->numRegularisationSteps        =  1;
-			#ifdef __USE_SINGLE_PRECISION__
-			options->numRefinementSteps            =  2;
-			#else
-			options->numRefinementSteps            =  0;
-			#endif
-	}
-	
-	return 0;
-}
-
-
-/*
- *	q p O A S E S _ O p t i o n s _ c o p y
- */
-int_t qpOASES_Options_copy(	const qpOASES_Options* const from,
-							Options* const to
-							)
-{
-	if ( ( from == 0 ) || ( to == 0 ) )
-		return -1;
-
-
-	to->printLevel                    =  (PrintLevel)(from->printLevel);
-
-	to->enableRamping                 =  (BooleanType)(from->enableRamping);
-	to->enableFarBounds               =  (BooleanType)(from->enableFarBounds);
-	to->enableFlippingBounds          =  (BooleanType)(from->enableFlippingBounds);
-	to->enableRegularisation          =  (BooleanType)(from->enableRegularisation);
-	to->enableFullLITests             =  (BooleanType)(from->enableFullLITests);
-	to->enableNZCTests                =  (BooleanType)(from->enableNZCTests);
-	to->enableDriftCorrection         =  from->enableDriftCorrection;
-	to->enableCholeskyRefactorisation =  from->enableCholeskyRefactorisation;
-	to->enableEqualities              =  (BooleanType)(from->enableEqualities);
-
-	to->terminationTolerance          =  from->terminationTolerance;
-	to->boundTolerance                =  from->boundTolerance;
-	to->boundRelaxation               =  from->boundRelaxation;
-	to->epsNum                        =  from->epsNum;
-	to->epsDen                        =  from->epsDen;
-	to->maxPrimalJump                 =  from->maxPrimalJump;
-	to->maxDualJump                   =  from->maxDualJump;
-
-	to->initialRamping                =  from->initialRamping;
-	to->finalRamping                  =  from->finalRamping;
-	to->initialFarBounds              =  from->initialFarBounds;
-	to->growFarBounds                 =  from->growFarBounds;
- 	to->initialStatusBounds           =  (SubjectToStatus)(from->initialStatusBounds);
-	to->epsFlipping                   =  from->epsFlipping;
-	to->numRegularisationSteps        =  from->numRegularisationSteps;
-	to->epsRegularisation             =  from->epsRegularisation;
-	to->numRefinementSteps            =  from->numRefinementSteps;
-	to->epsIterRef                    =  from->epsIterRef;
-	to->epsLITests                    =  from->epsLITests;
-	to->epsNZCTests                   =  from->epsNZCTests;
-
-	to->enableDropInfeasibles         =  (BooleanType)(from->enableDropInfeasibles);
-    to->dropBoundPriority             =  from->dropBoundPriority;
-    to->dropEqConPriority             =  from->dropEqConPriority;
-    to->dropIneqConPriority           =  from->dropIneqConPriority;
-
-	return 0;
-}
-
-
-
-/*
- *	q p O A S E S _ o b t a i n O u t p u t s
- */
-int_t qpOASES_obtainOutputs(	const QProblemB* const globalQpObject,
-								returnValue returnvalue,
-								real_t* const x,
-								real_t* const y,
-								real_t* const obj,
-								int_t* const status
-								)
-{
-	if ( globalQpObject == 0 )
-		return -1;
-
-	globalQpObject->getPrimalSolution( x );
-	globalQpObject->getDualSolution( y );
-	*obj = globalQpObject->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m _ s e t u p
- */
-int_t QProblem_setup(	int_t nV,
-						int_t nC,
-						int_t hessianType
-						)
-{
-	if ( ( nV < 1 ) || ( nC < 0 ) )
-		return -1;
-
-	if ( ( hessianType < 0 ) || ( hessianType > 6 ) )
-		return -1;
-
-	if ( QProblem_cleanup() != 0 )
-		return -1;
-
-	globalQProblemObject = new QProblem( nV,nC,(HessianType)hessianType );
-	
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m _ i n i t
- */
-int_t QProblem_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const A,
-						const real_t* const lb,
-						const real_t* const ub,
-						const real_t* const lbA,
-						const real_t* const ubA,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						)
-{
-	/* abort if QProblem_setup has not been called */
-	if ( globalQProblemObject == 0 )
-		return -1;
-
-	/* adjust options if provided */
-	if ( options != 0 )
-	{
-		qpOASES_Options_copy( options,&globalOptionsObject );
-		globalQProblemObject->setOptions( globalOptionsObject );
-	}
-
-	/* actually call solver */
-	returnValue returnvalue = globalQProblemObject->init( H,g,A,lb,ub,lbA,ubA, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalQProblemObject,returnvalue, x,y,obj,status );
-}
-
-
-/*
- *	Q P r o b l e m _ h o t s t a r t
- */
-int_t QProblem_hotstart(	const real_t* const g,
-							const real_t* const lb,
-							const real_t* const ub,
-							const real_t* const lbA,
-							const real_t* const ubA,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							)
-{
-	/* abort if QProblem_setup has not been called */
-	if ( globalQProblemObject == 0 )
-		return -1;
-
-	/* actually call solver */
-	returnValue returnvalue = globalQProblemObject->hotstart( g,lb,ub,lbA,ubA, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalQProblemObject,returnvalue, x,y,obj,status );
-
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m _ c l e a n u p
- */
-int_t QProblem_cleanup( )
-{
-	if ( globalQProblemObject != 0 )
-	{
-		delete globalQProblemObject;
-		globalQProblemObject = 0;
-	}
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m B _ s e t u p
- */
-int_t QProblemB_setup(	int_t nV,
-						int_t hessianType
-						)
-{
-	if ( nV < 1 )
-		return -1;
-
-	if ( ( hessianType < 0 ) || ( hessianType > 6 ) )
-		return -1;
-
-	if ( QProblemB_cleanup() != 0 )
-		return -1;
-
-	globalQProblemBObject = new QProblemB( nV,(HessianType)hessianType );
-	
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m B _ i n i t
- */
-int_t QProblemB_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const lb,
-						const real_t* const ub,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						)
-{
-	/* abort if QProblemB_setup has not been called */
-	if ( globalQProblemBObject == 0 )
-		return -1;
-
-	/* adjust options if provided */
-	if ( options != 0 )
-	{
-		qpOASES_Options_copy( options,&globalOptionsObject );
-		globalQProblemBObject->setOptions( globalOptionsObject );
-	}
-
-	/* actually call solver */
-	returnValue returnvalue = globalQProblemBObject->init( H,g,lb,ub, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalQProblemBObject,returnvalue, x,y,obj,status );
-}
-
-
-/*
- *	Q P r o b l e m B _ h o t s t a r t
- */
-int_t QProblemB_hotstart(	const real_t* const g,
-							const real_t* const lb,
-							const real_t* const ub,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							)
-{
-	/* abort if QProblemB_setup has not been called */
-	if ( globalQProblemBObject == 0 )
-		return -1;
-
-	/* actually call solver */
-	returnValue returnvalue = globalQProblemBObject->hotstart( g,lb,ub, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalQProblemBObject,returnvalue, x,y,obj,status );
-
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m B _ c l e a n u p
- */
-int_t QProblemB_cleanup( )
-{
-	if ( globalQProblemBObject != 0 )
-	{
-		delete globalQProblemBObject;
-		globalQProblemBObject = 0;
-	}
-
-	return 0;
-}
-
-
-
-/*
- *	S Q P r o b l e m _ s e t u p
- */
-int_t SQProblem_setup(	int_t nV,
-						int_t nC,
-						int_t hessianType
-						)
-{
-	if ( ( nV < 1 ) || ( nC < 0 ) )
-		return -1;
-
-	if ( ( hessianType < 0 ) || ( hessianType > 6 ) )
-		return -1;
-
-	if ( SQProblem_cleanup() != 0 )
-		return -1;
-
-	globalSQProblemObject = new SQProblem( nV,nC,(HessianType)hessianType );
-	
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ i n i t
- */
-int_t SQProblem_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const A,
-						const real_t* const lb,
-						const real_t* const ub,
-						const real_t* const lbA,
-						const real_t* const ubA,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						)
-{
-	/* abort if SQProblem_setup has not been called */
-	if ( globalSQProblemObject == 0 )
-		return -1;
-
-	/* adjust options if provided */
-	if ( options != 0 )
-	{
-		qpOASES_Options_copy( options,&globalOptionsObject );
-		globalSQProblemObject->setOptions( globalOptionsObject );
-	}
-
-	/* actually call solver */
-	returnValue returnvalue = globalSQProblemObject->init( H,g,A,lb,ub,lbA,ubA, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalSQProblemObject,returnvalue, x,y,obj,status );
-}
-
-
-/*
- *	S Q P r o b l e m _ h o t s t a r t
- */
-int_t SQProblem_hotstart(	const real_t* const H,
-							const real_t* const g,
-							const real_t* const A,
-							const real_t* const lb,
-							const real_t* const ub,
-							const real_t* const lbA,
-							const real_t* const ubA,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							)
-{
-	/* abort if SQProblem_setup has not been called */
-	if ( globalSQProblemObject == 0 )
-		return -1;
-
-	/* actually call solver */
-	returnValue returnvalue = globalSQProblemObject->hotstart( H,g,A,lb,ub,lbA,ubA, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalSQProblemObject,returnvalue, x,y,obj,status );
-
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ c l e a n u p
- */
-int_t SQProblem_cleanup( )
-{
-	if ( globalSQProblemObject != 0 )
-	{
-		delete globalSQProblemObject;
-		globalSQProblemObject = 0;
-	}
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.h b/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.h
deleted file mode 100644
index 0f7b637..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.h
+++ /dev/null
@@ -1,293 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/c/qpOASES_wrapper.h
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Interface that enables to call qpOASES from plain C.
- *
- */
-
-
-#ifndef QPOASES_WRAPPER_H
-#define QPOASES_WRAPPER_H
-
-
-#ifndef QPOASES_TYPES_HPP
-
-	/** Defines real_t for facilitating switching between double and float. */
-	#ifdef __USE_SINGLE_PRECISION__
-	typedef float real_t;
-	#else
-	typedef double real_t;
-	#endif /* __USE_SINGLE_PRECISION__ */
-
-	/** Defines int_t for facilitating switching between int and long int. */
-	#ifdef __USE_LONG_INTEGERS__
-	typedef long int_t;
-	typedef unsigned long uint_t;
-	#else
-	typedef int int_t;
-	typedef unsigned int uint_t;
-	#endif /* __USE_LONG_INTEGERS__ */
-
-	/* dummy definitions, not used when calling from C */
-	#define QProblemBClass int_t
-	#define OptionsClass int_t
-	#define returnValue int_t
-
-	/* HessianType */
-	#define HST_ZERO             0
-	#define HST_IDENTITY         1
-	#define HST_POSDEF           2
-	#define HST_POSDEF_NULLSPACE 3
-	#define HST_SEMIDEF          4
-	#define HST_INDEF            5
-	#define HST_UNKNOWN	         6
-
-	/* SubjectToStatus */
-	#define ST_LOWER            -1
-	#define ST_INACTIVE          0
-	#define ST_UPPER             1
-	#define ST_INFEASIBLE_LOWER  2
-	#define ST_INFEASIBLE_UPPER  3
-	#define ST_UNDEFINED         4
-
-	/* PrintLevel */
-	#define PL_DEBUG_ITER       -2
-	#define PL_TABULAR          -1
-	#define PL_NONE              0
-	#define PL_LOW               1
-	#define PL_MEDIUM            2
-	#define PL_HIGH              3
-
-#else 
-
-	#define QProblemBClass QProblemB
-	#define OptionsClass REFER_NAMESPACE_QPOASES Options 
-
-	/* only declare when compiling C++ library */
-	static QProblem*  globalQProblemObject  = 0;
-	static QProblemB* globalQProblemBObject = 0;
-	static SQProblem* globalSQProblemObject = 0;
-	static Options globalOptionsObject;
-
-#endif /* QPOASES_TYPES_HPP */
-
-
-
-/**
- *	\brief Manages all user-specified options for solving QPs.
- *
- *	This struct manages all user-specified options used for solving
- *	quadratic programs.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- */
-typedef struct
-{
-	int_t printLevel;						/**< Print level. */
-
-	int_t enableRamping;					/**< Specifies whether ramping shall be enabled or not. */
-	int_t enableFarBounds;					/**< Specifies whether far bounds shall be used or not. */
-	int_t enableFlippingBounds;				/**< Specifies whether flipping bounds shall be used or not. */
-	int_t enableRegularisation;				/**< Specifies whether Hessian matrix shall be regularised in case semi-definiteness is detected. */
-	int_t enableFullLITests;				/**< Specifies whether condition-hardened LI test shall be used or not. */
-	int_t enableNZCTests;					/**< Specifies whether nonzero curvature tests shall be used. */
-	int_t enableDriftCorrection;			/**< Specifies the frequency of drift corrections (0 = off). */
-	int_t enableCholeskyRefactorisation;	/**< Specifies the frequency of full refactorisation of proj. Hessian (otherwise updates). */
-	int_t enableEqualities;					/**< Specifies whether equalities shall be always treated as active constraints. */
-
-	real_t terminationTolerance;			/**< Termination tolerance. */
-	real_t boundTolerance;					/**< Lower/upper (constraints') bound tolerance (an inequality constraint whose lower and 
-												 upper bounds differ by less is regarded to be an equality constraint). */
-	real_t boundRelaxation;					/**< Offset for relaxing (constraints') bounds at beginning of an initial homotopy. It is also as initial value for far bounds. */
-	real_t epsNum;							/**< Numerator tolerance for ratio tests. */
-	real_t epsDen;							/**< Denominator tolerance for ratio tests. */
-	real_t maxPrimalJump;					/**< Maximum allowed jump in primal variables in nonzero curvature tests. */
-	real_t maxDualJump;						/**< Maximum allowed jump in dual variables in linear independence tests. */
-
-	real_t initialRamping;					/**< Start value for Ramping Strategy. */
-	real_t finalRamping;					/**< Final value for Ramping Strategy. */
-	real_t initialFarBounds;				/**< Initial size of Far Bounds. */
-	real_t growFarBounds;					/**< Factor to grow Far Bounds. */
-	int_t initialStatusBounds;				/**< Initial status of bounds at first iteration. */
-	real_t epsFlipping;						/**< Tolerance of squared Cholesky diagonal factor which triggers flipping bound. */
-	int_t numRegularisationSteps;			/**< Maximum number of successive regularisation steps. */
-	real_t epsRegularisation;				/**< Scaling factor of identity matrix used for Hessian regularisation. */
-	int_t numRefinementSteps;				/**< Maximum number of iterative refinement steps. */
-	real_t epsIterRef;						/**< Early termination tolerance for iterative refinement. */
-	real_t epsLITests;						/**< Tolerance for linear independence tests. */
-	real_t epsNZCTests;						/**< Tolerance for nonzero curvature tests. */
-
-	real_t rcondSMin;						/**< Minimum reciprocal condition number of S before refactorization is triggered */
-	int_t enableInertiaCorrection;			/**< Specifies whether the working set should be repaired when negative curvature is discovered during hotstart. */
-
-	int_t enableDropInfeasibles;			/**< ... */
-	int_t dropBoundPriority;				/**< ... */
-	int_t dropEqConPriority;				/**< ... */
-	int_t dropIneqConPriority;				/**< ... */
-	int_t printResiduals;					/**< If true, it will print the internal qpOASES residuals and other information per iteration */
-
-} qpOASES_Options;
-
-
-int_t qpOASES_Options_init(	qpOASES_Options* const options,
-							int_t mode
-							);
-
-int_t qpOASES_Options_copy(	const qpOASES_Options* const from,
-							OptionsClass* const to
-							);
-
-
-int_t qpOASES_obtainOutputs(	const QProblemBClass* const globalQpObject,
-								returnValue returnvalue,
-								real_t* const x,
-								real_t* const y,
-								real_t* const obj,
-								int_t* const status
-								);
-
-
-int_t QProblem_setup(	int_t nV,
-						int_t nC,
-						int_t hessianType
-						);
-
-int_t QProblem_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const A,
-						const real_t* const lb,
-						const real_t* const ub,
-						const real_t* const lbA,
-						const real_t* const ubA,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						);
-
-int_t QProblem_hotstart(	const real_t* const g,
-							const real_t* const lb,
-							const real_t* const ub,
-							const real_t* const lbA,
-							const real_t* const ubA,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							);
-
-int_t QProblem_cleanup( );
-
-
-
-int_t QProblemB_setup(	int_t nV,
-						int_t hessianType
-						);
-
-int_t QProblemB_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const lb,
-						const real_t* const ub,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						);
-
-int_t QProblemB_hotstart(	const real_t* const g,
-							const real_t* const lb,
-							const real_t* const ub,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							);
-
-int_t QProblemB_cleanup( );
-
-
-
-int_t SQProblem_setup(	int_t nV,
-						int_t nC,
-						int_t hessianType
-						);
-
-int_t SQProblem_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const A,
-						const real_t* const lb,
-						const real_t* const ub,
-						const real_t* const lbA,
-						const real_t* const ubA,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						);
-
-int_t SQProblem_hotstart(	const real_t* const H,
-							const real_t* const g,
-							const real_t* const A,
-							const real_t* const lb,
-							const real_t* const ub,
-							const real_t* const lbA,
-							const real_t* const ubA,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							);
-
-int_t SQProblem_cleanup( );
-
-
-#endif /* QPOASES_WRAPPER_H */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/Makefile b/extlibs/qpOASES-3.2.0/interfaces/matlab/Makefile
deleted file mode 100644
index 7ee3e13..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/Makefile
+++ /dev/null
@@ -1,85 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  src/interfaces/matlab/Makefile
-##	Author:    Christian Kirches, Hans Joachim Ferreau, Andreas Potschka
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-include ../../make.mk
-
-##
-##	flags
-##
-
-IDIR   = ../../include
-
-IFLAGS      =  -I. \
-               -I${IDIR} \
-               -I${MATLAB_IDIR}
-			   
-LINK_MATLAB_LIBS = -L${MATLAB_LIBDIR} -lmex -lmat -lmx
-
-EXTRAFLAGS = -largeArrayDims -O -D__cpluplus -D__MATLAB__ -fexceptions
-
-QPOASES_OBJECT = qpOASES.${OBJEXT}
-QPOASES_SEQUENCE_OBJECT = qpOASES_sequence.${OBJEXT}
-
-##
-##	targets
-##
-
-all: ${BINDIR}/qpOASES.${MEXEXT} ${BINDIR}/qpOASES_sequence.${MEXEXT} copyMs
-
-${BINDIR}/qpOASES.${MEXEXT}: ${QPOASES_OBJECT} 
-	@${ECHO} "Creating" $@
-	@${CPP} -shared -o $@ $? ${QPOASES_LINK} ${LINK_LIBRARIES} ${LINK_MATLAB_LIBS}
-
-${BINDIR}/qpOASES_sequence.${MEXEXT}: ${QPOASES_SEQUENCE_OBJECT} 
-	@${ECHO} "Creating" $@
-	@${CPP} -shared -o $@ $? ${QPOASES_LINK} ${LINK_LIBRARIES} ${LINK_MATLAB_LIBS}
-
-copyMs:
-	@${ECHO} "Copying M files ..."
-	@${CP} qpOASES.m ${BINDIR}
-	@${CP} qpOASES_options.m ${BINDIR}
-	@${CP} qpOASES_sequence.m ${BINDIR}
-
-#@${CP} qpOASES_sequenceVM.m ${BINDIR}
-	
-clean:
-	@${RM} -f *.${OBJEXT} *.mex*
-
-clobber: clean
-
-%.${OBJEXT}: %.cpp 
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} -c ${IFLAGS} ${EXTRAFLAGS} ${CPPFLAGS} $<
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/example1.mat b/extlibs/qpOASES-3.2.0/interfaces/matlab/example1.mat
deleted file mode 100644
index c0bd0d2ed4364ebaf2b16eeb1791b99510164d60..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 790
zcmeZu4DoSvQZUssQ1EpO(M`+DN!3vZ$Vn_o%P-2cQgHY2i?A@$QE)CwO)N=GQOM7;
zQV7W?Rq#(PQBW{ZFtoHXwy-iZQZO<wFjpWIFfe-h@-r|n=m2rWoX5!t2^<VbW(v<5
zE-4(~dTQ)ws4P&$km;uomeA11|BWZ&AagZCObxRuNRJv^j{&kCCPU#FX(<IPn`cT$
zG&V7awlb^%sn&(7E<jezXs9e<Y_x<KXonck4*72aznX0sEPR-wL7MdNXfk}FVrWpn
zbd!n4;KKpAQx*&i4u6?#K)Tf7x=<Vjw#smdTH_BNo;41R3^D<X9(eq5$k5n1bCNQ%
z@Pwl*Pna3xb}%;MF&w1YZ<6wal%ya3=QlDksCqM3;5D4vIj*8W0BATX&~U}|jQ2pQ
z4dE{TfEGw1%||Xh{v33=(L`N<+u*<f_G*s5hvgUwC0GSO8WEwp0Yl@HqDhZ{Iwd7$
zNJcd5`Tw8MMu6oVNRu%h+n#t$hG?>A%wc4c5GZW8!2gYzq2v=QA4sbvTq}xwN{M9(
rdcH+H=e>2)6PUUhjxboKF`MIYAV|YGPpF2pgrpzeL4oIZl~o4-!Xx*U

diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/example1a.mat b/extlibs/qpOASES-3.2.0/interfaces/matlab/example1a.mat
deleted file mode 100644
index 48c784fcb7c53eedc3b3124e3577f8d0822e1cb2..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 896
zcmeZu4DoSvQZUssQ1EpO(M`+DN!3vZ$Vn_o%P-2cQgHY2i?A@$QE)CwO)N=GQOM7;
zQV7W?Rq#(PQBW{ZFtoHXwzM)dRWLFzFjpWIFfe-h@-r|n=m2rWoX5!t2^<VbW(v<5
zE-4(~dTQ)ws4P&$km;uomeA11|BWZ&AagZCObxRuNRJv^j{&kCCPU#FX(<IPn`cT$
zG&V7awlb^%sn&(7E<jezXs9e<Y_x<KXonck4*72aznX0sEPR-wL7MdNXfk}FVrWpn
zbd!n4;KKpAQx*&i4u6?#K)Tf7x=<Vjw#smdTH_BNo;41R3^D<X9(eq5$k5n1bCNQ%
z@Pwl*Pna3xb}%;MF&w1YZ<6wal%ya3=QlDksCqM3;5D4vIj*8W0BATX&~U}|jQ2pQ
z4dE{TfEGw1%||Xh{v33=(L`N<+u*<f_G*s5hvgUwC0GSO8WEwp0Yl@HqDhZ{Iwd7$
zNJcd5`Tw8MMu6oVNRu%h+n#t$hG?>A%wc4c5GZW8!2gYzq2v=QA4sbvTq}xwN{M9(
zdcH+H=e>2)6PUUhjxboKF`MIYAV|YGPpF2pgrpzeL4oIZl~o6%$pCIk2ePk#sWRk@
zvYq}`8INM7jZDluH5=M5@Ec?>oIk~G0n(=h*N5UdV9K1r)@ga{`O<04M`r+2CliB_
HDN`x{YE&BX

diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/example1b.mat b/extlibs/qpOASES-3.2.0/interfaces/matlab/example1b.mat
deleted file mode 100644
index b45b4f74c6a935c350dac6de0673396f20801338..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 549
zcmeZu4DoSvQZUssQ1EpO(M`+DN!3vZ$Vn_o%P-2cQgHY2i?A@$QE)CwO)N=GQOM7;
zQV7W?Rq#(PQBW{ZFtoHXwy-iXRWLFzFjpWIFfe-h@-r|n=m2rWoX5!t2^<VbW(v<5
zE-4(~dTQ)ws4P&$km;uomeA11|BWZ&AagZCObxRuNRKXDPXV$XMnh!@W1}U^KwV-$
zUGm=qel^=NSoknUgEZ;k(Pa2U#n7OD=_V78!G{BKrz{v49R4!ffOM(Dbs1n-WjIBx
z@rMu38V5%PnE*x)ka9Kb$`2WGJI7TN2nbI&%KC(vL2*6fJ&<ZcxatpRhKn>Gx%BvR
z(CJ1KbpdXJ0|(fvIsP7&V<?nh6#!{O1i%IijZcauJp$^Kl$aqI(Xi+Le?}VtmUkdc
f#&~Rd;x!qf$)YibkxfFNu;Bv#H)e*CPpo_Z46>$n

diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/make.m b/extlibs/qpOASES-3.2.0/interfaces/matlab/make.m
deleted file mode 100644
index 1ba7768..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/make.m
+++ /dev/null
@@ -1,238 +0,0 @@
-function [] = make( varargin )
-%MAKE Compiles the Matlab interface of qpOASES.
-%
-%Type  make            to compile all interfaces that 
-%                      have been modified,
-%type  make clean      to delete all compiled interfaces,
-%type  make clean all  to first delete and then compile 
-%                      all interfaces,
-%type  make 'name'     to compile only the interface with
-%                      the given name (if it has been modified),
-%type  make 'opt'      to compile all interfaces using the 
-%                      given compiler options.
-%
-%Copyright (C) 2013-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-%%
-%%	Filename:  interfaces/matlab/make.m
-%%	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-       
-    %% consistency check
-    if ( exist( [pwd, '/make.m'],'file' ) == 0 )
-        error( ['ERROR (',mfilename '.m): Run this make script directly within the directory', ...
-                '<qpOASES-inst-dir>/interfaces/matlab, please.'] );
-    end
-
-
-    if ( nargin > 2 )
-        error( ['ERROR (',mfilename '.m): At most two make arguments supported!'] );
-    else
-        [ doClean,fcnNames,userFlags ] = analyseMakeArguments( nargin,varargin );
-    end
-
-    
-    %% define compiler settings
-    QPOASESPATH = '../../';
-    
-    DEBUGFLAGS = ' ';
-    %DEBUGFLAGS = ' -g CXXDEBUGFLAGS=''$CXXDEBUGFLAGS -Wall -pedantic -Wshadow'' ';
-
-    IFLAGS = [ '-I. -I',QPOASESPATH,'include',' -I',QPOASESPATH,'src',' ' ];
-    CPPFLAGS = [ IFLAGS, DEBUGFLAGS, '-largeArrayDims -D__cpluplus -D__MATLAB__ -D__SINGLE_OBJECT__',' ' ];
-    defaultFlags = '-O -D__NO_COPYRIGHT__ '; %% -D__SUPPRESSANYOUTPUT__
-
-    if ( ispc == 0 )
-        CPPFLAGS  = [ CPPFLAGS, '-DLINUX ',' ' ]; 
-    else
-        CPPFLAGS  = [ CPPFLAGS, '-DWIN32 ',' ' ];
-    end
-
-    if ( isempty(userFlags) > 0 )
-        CPPFLAGS = [ CPPFLAGS, defaultFlags,' ' ];
-    else
-        CPPFLAGS = [ CPPFLAGS, userFlags,' ' ];
-    end
-
-    mexExt = eval('mexext');
-    
-    
-    %% ensure copyright notice is displayed
-    if ~isempty( strfind( CPPFLAGS,'-D__NO_COPYRIGHT__' ) )
-        printCopyrightNotice( );
-    end
-    
-    
-    %% clean if desired
-    if ( doClean > 0 )
-        
-        eval( 'delete *.o;' );
-        eval( ['delete *.',mexExt,'*;'] );
-        disp( [ 'INFO (',mfilename '.m): Cleaned all compiled files.'] );
-        pause( 0.2 );
-        
-    end
-    
-    
-    if ( ~isempty(userFlags) )
-        disp( [ 'INFO (',mfilename '.m): Compiling all files with user-defined compiler flags (''',userFlags,''')...'] );
-    end
-    
-
-    %% call mex compiler
-    for ii=1:length(fcnNames)
-        
-        cmd = [ 'mex -output ', fcnNames{ii}, ' ', CPPFLAGS, [fcnNames{ii},'.cpp'] ];
-        
-        if ( exist( [fcnNames{ii},'.',mexExt],'file' ) == 0 )
-            
-            eval( cmd );
-            disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            
-        else
-            
-            % check modification time of source/Make files and compiled mex file
-            cppFile = dir( [pwd,'/',fcnNames{ii},'.cpp'] );
-            cppFileTimestamp = getTimestamp( cppFile );
-            
-            utilsFile = dir( [pwd,'/qpOASES_matlab_utils.cpp'] );
-            utilsFileTimestamp = getTimestamp( utilsFile );
-            
-            makeFile = dir( [pwd,'/make.m'] );
-            makeFileTimestamp = getTimestamp( makeFile );
-            
-            mexFile = dir( [pwd,'/',fcnNames{ii},'.',mexExt] );
-            if ( isempty(mexFile) == 0 )
-                mexFileTimestamp = getTimestamp( mexFile );
-            else
-                mexFileTimestamp = 0;
-            end
-            
-            if ( ( cppFileTimestamp   >= mexFileTimestamp ) || ...
-                 ( utilsFileTimestamp >= mexFileTimestamp ) || ...
-                 ( makeFileTimestamp  >= mexFileTimestamp ) )
-                eval( cmd );
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            else            
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' already exists.'] );
-            end
-            
-        end
-        
-    end
-
-    %% add qpOASES directory to path
-    path( path,pwd );
-
-end
-
-
-function [ doClean,fcnNames,userIFlags ] = analyseMakeArguments( nArgs,args )
-
-    doClean = 0;
-    fcnNames = [];
-    userIFlags = [];
-
-    switch ( nArgs )
-        
-        case 1
-            if ( strcmp( args{1},'all' ) > 0 )
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            elseif ( strcmp( args{1},'qpOASES' ) > 0 )
-                fcnNames = { 'qpOASES' };
-            elseif ( strcmp( args{1},'qpOASES_sequence' ) > 0 )
-                fcnNames = { 'qpOASES_sequence' };
-            elseif ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            elseif ( strcmp( args{1}(1),'-' ) > 0 )
-                % make clean all with user-specified compiler flags
-                userIFlags = args{1};
-                doClean = 1;
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid first argument (''',args{1},''')!'] );
-            end
-
-        case 2
-            if ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            else
-                error( ['ERROR (',mfilename '.m): First argument must be ''clean'' if two arguments are provided!'] );
-            end
-            
-            if ( strcmp( args{2},'all' ) > 0 )
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            elseif ( strcmp( args{2},'qpOASES' ) > 0 )
-                fcnNames = { 'qpOASES' };
-            elseif ( strcmp( args{2},'qpOASES_sequence' ) > 0 )
-                fcnNames = { 'qpOASES_sequence' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid second argument (''',args{2},''')!'] );
-            end
-            
-        otherwise
-            fcnNames = { 'qpOASES','qpOASES_sequence' };
-            
-    end
-    
-end
-
-
-function [ timestamp ] = getTimestamp( dateString )
-
-    try 
-        timestamp = dateString.datenum;
-    catch
-        timestamp = Inf;
-    end
-
-end
-
-
-function [ ] = printCopyrightNotice( )
-
-    disp( ' ' );
-    disp( 'qpOASES -- An Implementation of the Online Active Set Strategy.' );
-    disp( 'Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,' );
-    disp( 'Christian Kirches et al. All rights reserved.' );
-    disp( ' ' );
-    disp( 'qpOASES is distributed under the terms of the' );
-    disp( 'GNU Lesser General Public License 2.1 in the hope that it will be' );
-    disp( 'useful, but WITHOUT ANY WARRANTY; without even the implied warranty' );
-    disp( 'of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.' );
-    disp( 'See the GNU Lesser General Public License for more details.' );
-    disp( ' ' );
-    disp( ' ' );
-
-end
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.cpp b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.cpp
deleted file mode 100644
index 957636f..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.cpp
+++ /dev/null
@@ -1,584 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/matlab/qpOASES.cpp
- *	\author Hans Joachim Ferreau, Alexander Buchner (thanks to Aude Perrin)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Matlab(R) that enables to call qpOASES as a MEX function.
- *
- */
-
-
-#include <qpOASES.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-#include "qpOASES_matlab_utils.hpp"
-
-/** initialise handle counter of QPInstance class */
-int_t QPInstance::s_nexthandle = 1;
-
-/** global pointer to QP objects */
-static std::vector<QPInstance *> g_instances;
-
-#include "qpOASES_matlab_utils.cpp"
-
-
-/*
- *	Q P r o b l e m _ q p O A S E S
- */
-int_t QProblem_qpOASES(	int_t nV, int_t nC, HessianType hessianType, int_t nP,
-						SymmetricMatrix* H, double* g, Matrix* A,
-						double* lb, double* ub,
-						double* lbA, double* ubA,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds, const double* const guessedConstraints,
-						const double* const _R
-						)
-{
-	int_t nWSRout;
-	real_t maxCpuTimeOut;
-	
-	/* 1) Setup initial QP. */
-	QProblem QP( nV,nC,hessianType );
-	QP.setOptions( *options );
-
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-
-	Bounds bounds(nV);
-	Constraints constraints(nC);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	if (guessedConstraints != 0) {
-		for (int_t i = 0; i < nC; i++) {
-			if ( isEqual(guessedConstraints[i],-1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_LOWER);
-			} else if ( isEqual(guessedConstraints[i],1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_UPPER);
-			} else if ( isEqual(guessedConstraints[i],0.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of constraints!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	nWSRout = nWSRin;
-	maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	returnvalue = QP.init(	H,g,A,lb,ub,lbA,ubA,
-							nWSRout,&maxCpuTimeOut,
-							x0,0,
-							(guessedBounds != 0) ? &bounds : 0, (guessedConstraints != 0) ? &constraints : 0,
-							_R
-							);
-
-	/* 3) Solve remaining QPs and assign lhs arguments. */
-	/*    Set up pointers to the current QP vectors */
-	real_t* g_current   = g;
-	real_t* lb_current  = lb;
-	real_t* ub_current  = ub;
-	real_t* lbA_current = lbA;
-	real_t* ubA_current = ubA;
-
-	/* Loop through QP sequence. */
-	for ( int_t k=0; k<nP; ++k )
-	{
-		if ( k > 0 )
-		{
-			/* update pointers to the current QP vectors */
-			g_current = &(g[k*nV]);
-			if ( lb != 0 )
-				lb_current = &(lb[k*nV]);
-			if ( ub != 0 )
-				ub_current = &(ub[k*nV]);
-			if ( lbA != 0 )
-				lbA_current = &(lbA[k*nC]);
-			if ( ubA != 0 )
-				ubA_current = &(ubA[k*nC]);
-
-			nWSRout = nWSRin;
-			maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-			returnvalue = QP.hotstart( g_current,lb_current,ub_current,lbA_current,ubA_current, nWSRout,&maxCpuTimeOut );
-		}
-
-		/* write results into output vectors */
-		obtainOutputs(	k,&QP,returnvalue,nWSRout,maxCpuTimeOut,
-						nOutputs,plhs,nV,nC );
-	}
-
-	//QP.writeQpDataIntoMatFile( "qpDataMat0.mat" );
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m B _ q p O A S E S
- */
-int_t QProblemB_qpOASES(	int_t nV, HessianType hessianType, int_t nP,
-							SymmetricMatrix *H, double* g,
-							double* lb, double* ub,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							const double* const x0, Options* options,
-							int_t nOutputs, mxArray* plhs[],
-							const double* const guessedBounds,
-							const double* const _R
-							)
-{
-	int_t nWSRout;
-	real_t maxCpuTimeOut;
-
-	/* 1) Setup initial QP. */
-	QProblemB QP( nV,hessianType );
-	QP.setOptions( *options );
-
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-
-	Bounds bounds(nV);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	nWSRout = nWSRin;
-	maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-	
-	returnvalue = QP.init(	H,g,lb,ub,
-							nWSRout,&maxCpuTimeOut,
-							x0,0,
-							(guessedBounds != 0) ? &bounds : 0,
-							_R
-							);
-
-	/* 3) Solve remaining QPs and assign lhs arguments. */
-	/*    Set up pointers to the current QP vectors */
-	real_t* g_current  = g;
-	real_t* lb_current = lb;
-	real_t* ub_current = ub;
-
-	/* Loop through QP sequence. */
-	for ( int_t k=0; k<nP; ++k )
-	{
-		if ( k > 0 )
-		{
-			/* update pointers to the current QP vectors */
-			g_current = &(g[k*nV]);
-			if ( lb != 0 )
-				lb_current = &(lb[k*nV]);
-			if ( ub != 0 )
-				ub_current = &(ub[k*nV]);
-
-            nWSRout = nWSRin;
-			maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-			returnvalue = QP.hotstart( g_current,lb_current,ub_current, nWSRout,&maxCpuTimeOut );
-		}
-
-		/* write results into output vectors */
-		obtainOutputs(	k,&QP,returnvalue,nWSRout,maxCpuTimeOut,
-						nOutputs,plhs,nV );
-	}
-
-	return 0;
-}
-
-
-
-/*
- *	m e x F u n c t i o n
- */
-void mexFunction( int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[] )
-{
-	/* inputs */
-	SymmetricMatrix *H=0;
-	Matrix *A=0;
-
-	real_t *g=0, *lb=0, *ub=0, *lbA=0, *ubA=0;
-	HessianType hessianType = HST_UNKNOWN;
-	double *x0=0, *R=0, *R_for=0;
-	double *guessedBounds=0, *guessedConstraints=0;
-
-	int H_idx=-1, g_idx=-1, A_idx=-1, lb_idx=-1, ub_idx=-1, lbA_idx=-1, ubA_idx=-1;
-	int options_idx=-1, x0_idx=-1, auxInput_idx=-1;
-
-    /* Setup default options */
-	Options options;
-	options.printLevel = PL_LOW;
-	#ifdef __DEBUG__
-	options.printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	options.printLevel = PL_NONE;
-	#endif
-
-	/* dimensions */
-	uint_t nV=0, nC=0, nP=0;
-	BooleanType isSimplyBoundedQp = BT_FALSE;
-
-	/* sparse matrix indices and values */
-	sparse_int_t *Hir=0, *Hjc=0, *Air=0, *Ajc=0;
-	real_t *Hv=0, *Av=0;
-
-	/* I) CONSISTENCY CHECKS: */
-	/* 1a) Ensure that qpOASES is called with a feasible number of input arguments. */
-	if ( ( nrhs < 4 ) || ( nrhs > 9 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES' for further information." );
-		return;
-	}
-    
-	/* 2) Check for proper number of output arguments. */
-	if ( nlhs > 6 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): At most six output arguments are allowed: \n    [x,fval,exitflag,iter,lambda,auxOutput]!" );
-		return;
-	}
-	if ( nlhs < 1 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): At least one output argument is required: [x,...]!" );
-		return;
-	}
-
-
-	/* II) PREPARE RESPECTIVE QPOASES FUNCTION CALL: */
-	/*     Choose between QProblem and QProblemB object and assign the corresponding
-	 *     indices of the input pointer array in to order to access QP data correctly. */
-	g_idx = 1;
-
-	if ( mxIsEmpty(prhs[0]) == 1 )
-	{
-		H_idx = -1;
-		nV = (int_t)mxGetM( prhs[ g_idx ] ); /* if Hessian is empty, row number of gradient vector */
-	}
-	else
-	{
-		H_idx = 0;
-		nV = (int_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-	}
-	
-	nP = (int_t)mxGetN( prhs[ g_idx ] ); /* number of columns of the gradient matrix (vectors series have to be stored columnwise!) */
-
-	if ( nrhs <= 6 )
-        isSimplyBoundedQp = BT_TRUE;
-	else
-		isSimplyBoundedQp = BT_FALSE;
-
-
-	/* 0) Check whether options are specified .*/
-	if ( isSimplyBoundedQp == BT_TRUE )
-	{
-		if ( ( nrhs >= 5 ) && ( !mxIsEmpty(prhs[4]) ) && ( mxIsStruct(prhs[4]) ) )
-			options_idx = 4;
-	}
-	else
-	{
-		/* Consistency check */
-		if ( ( !mxIsEmpty(prhs[4]) ) && ( mxIsStruct(prhs[4]) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Fifth input argument must not be a struct when solving QP with general constraints!\nType 'help qpOASES' for further information." );
-			return;
-		}
-
-		if ( ( nrhs >= 8 ) && ( !mxIsEmpty(prhs[7]) ) && ( mxIsStruct(prhs[7]) ) )
-			options_idx = 7;
-	}
-
-	// Is the third argument constraint Matrix A?
-	int_t numberOfColumns = (int_t)mxGetN(prhs[2]);
-
-	/* 1) Simply bounded QP. */
-	if ( ( isSimplyBoundedQp == BT_TRUE ) ||
-		 ( ( numberOfColumns == 1 ) && ( nV != 1 ) ) )
-	{
-		lb_idx   = 2;
-		ub_idx   = 3;
-
-		if ( ( nrhs >= 6 ) && ( !mxIsEmpty(prhs[5]) ) )
-		{ 
-			/* auxInput specified */
-			if ( mxIsStruct(prhs[5]) )
-			{
-				auxInput_idx = 5;
-				x0_idx = -1;
-			}
-			else
-			{
-				auxInput_idx = -1;
-				x0_idx = 5;
-			}
-		}
-		else
-		{
-			auxInput_idx = -1;
-			x0_idx = -1;
-		}
-	}
-	else
-	{
-		A_idx = 2;
-
-		/* If constraint matrix is empty, use a QProblemB object! */
-		if ( mxIsEmpty( prhs[ A_idx ] ) )
-		{
-			lb_idx   = 3;
-			ub_idx   = 4;
-
-			nC = 0;
-		}
-		else
-		{
-			lb_idx   = 3;
-			ub_idx   = 4;
-			lbA_idx  = 5;
-			ubA_idx  = 6;
-
-			nC = (int_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-		}
-
-		if ( ( nrhs >= 9 ) && ( !mxIsEmpty(prhs[8]) ) )
-		{ 
-			/* auxInput specified */
-			if ( mxIsStruct(prhs[8]) )
-			{
-				auxInput_idx = 8;
-				x0_idx = -1;
-			}
-			else
-			{
-				auxInput_idx = -1;
-				x0_idx = 8;
-			}
-		}
-		else
-		{
-			auxInput_idx = -1;
-			x0_idx = -1;
-		}
-	}
-
-
-	/* ensure that data is given in real_t precision */
-	if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[ H_idx ] ) == 0 ) ) ||
-		 ( mxIsDouble( prhs[ g_idx ] ) == 0 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-		return;
-	}
-
-	/* check if supplied data contains 'NaN' or 'Inf' */
-	if (containsNaNorInf( prhs,H_idx, 0 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-		return;
-
-	/* Check inputs dimensions and assign pointers to inputs. */
-	if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-	{
-		char msg[MAX_STRING_LENGTH]; 
-		snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Hessian matrix dimension mismatch (%ld != %d)!", 
-				(long int)mxGetN(prhs[H_idx]), (int)nV);
-		myMexErrMsgTxt(msg);
-		return;
-	}
-
-	if ( nC > 0 )
-	{
-		/* ensure that data is given in real_t precision */
-		if ( mxIsDouble( prhs[ A_idx ] ) == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in real_t precision!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		if ( mxGetN( prhs[ A_idx ] ) != nV )
-		{
-			char msg[MAX_STRING_LENGTH]; 
-			snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Constraint matrix input dimension mismatch (%ld != %d)!", 
-					(long int)mxGetN(prhs[A_idx]), (int)nV);
-			myMexErrMsgTxt(msg);
-			return;
-		}
-
-		if (containsNaNorInf(prhs,A_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf(prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf(prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-	}
-
-	/* check dimensions and copy auxInputs */
-	if ( smartDimensionCheck( &g,nV,nP, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &lb,nV,nP, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &ub,nV,nP, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &x0,nV,1, BT_TRUE,prhs,x0_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( nC > 0 )
-	{
-		if ( smartDimensionCheck( &lbA,nC,nP, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,nP, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-	}
-
-	if ( auxInput_idx >= 0 )
-		setupAuxiliaryInputs( prhs[auxInput_idx],nV,nC, &hessianType,&x0,&guessedBounds,&guessedConstraints,&R_for );
-
-	/* convert Cholesky factor to C storage format */
-	if ( R_for != 0 )
-	{
-		R = new real_t[nV*nV];
-		convertFortranToC( R_for, nV,nV, R );
-	}
-	
-	/* III) ACTUALLY PERFORM QPOASES FUNCTION CALL: */
-	int_t nWSRin = 5*(nV+nC);
-	real_t maxCpuTimeIn = -1.0;
-
-	if ( options_idx > 0 )
-		setupOptions( &options,prhs[options_idx],nWSRin,maxCpuTimeIn );
-
-	/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-	if ( H_idx >= 0 )
-		setupHessianMatrix(	prhs[H_idx],nV, &H,&Hir,&Hjc,&Hv );
-	
-	/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-	if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-		setupConstraintMatrix( prhs[A_idx],nV,nC, &A,&Air,&Ajc,&Av );
-
-	allocateOutputs( nlhs,plhs,nV,nC,nP );
-
-	if ( nC == 0 )
-	{
-		/* Call qpOASES (using QProblemB class). */
-		QProblemB_qpOASES(	nV,hessianType, nP,
-							H,g,
-							lb,ub,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,R
-							);
-		
-        if (R != 0) delete R;
-		if (H != 0) delete H;
-		if (Hv != 0) delete[] Hv;
-		if (Hjc != 0) delete[] Hjc;
-		if (Hir != 0) delete[] Hir;
-		return;
-	}
-	else
-	{
-		if ( A == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Internal interface error related to constraint matrix!" );
-			return;
-		}
-
-		/* Call qpOASES (using QProblem class). */
-		QProblem_qpOASES(	nV,nC,hessianType, nP,
-							H,g,A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,guessedConstraints,R
-							);
-		
-		if (R != 0) delete R;
-		if (A != 0) delete A;
-		if (H != 0) delete H;
-		if (Av != 0) delete[] Av;
-		if (Ajc != 0) delete[] Ajc;
-		if (Air != 0) delete[] Air;
-		if (Hv != 0) delete[] Hv;
-		if (Hjc != 0) delete[] Hjc;
-		if (Hir != 0) delete[] Hir;
-		return;
-	}
-}
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.m b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.m
deleted file mode 100644
index 4692b60..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.m
+++ /dev/null
@@ -1,75 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%qpOASES solves (a series) of quadratic programming (QP) problems of the
-%following form:
-%
-%                min   1/2*x'Hx + x'g
-%                s.t.  lb  <=  x <= ub
-%                      lbA <= Ax <= ubA  {optional}
-%
-%Call
-%
-%    [x,fval,exitflag,iter,lambda,auxOutput] = 
-%                     qpOASES( H,g,A,lb,ub,lbA,ubA{,options{,auxInput}} )
-%
-%for solving the above-mentioned QP. H must be a symmetric (but possibly 
-%indefinite) matrix and all vectors g, lb, ub, lbA, ubA have to be given
-%as column vectors. Options can be generated using the qpOASES_options command, 
-%otherwise default values are used. Optionally, further auxiliary inputs
-%may be generated using qpOASES_auxInput command and passed to the solver.
-%Both matrices H or A may be passed in sparse matrix format.
-%
-%Call
-%
-%    [x,fval,exitflag,iter,lambda,auxOutput] =
-%                     qpOASES( H,g,lb,ub{,options{,auxInput}} )
-%
-%for solving the above-mentioned QP without general constraints.
-%
-%
-%Optional outputs (only x is mandatory):
-%    x            -  Optimal primal solution vector (if exitflag==0).
-%    fval         -  Optimal objective function value (if exitflag==0).
-%    exitflag     -   0: QP problem solved,
-%                     1: QP could not be solved within given number of iterations,
-%                    -1: QP could not be solved due to an internal error,
-%                    -2: QP is infeasible (and thus could not be solved),
-%                    -3: QP is unbounded (and thus could not be solved).
-%    iter         -  Number of active set iterations actually performed.
-%    lambda       -  Optimal dual solution vector (if exitflag==0).
-%    auxOutput    -  Struct containing auxiliary outputs as described below.
-%
-%The auxOutput struct contains the following entries:
-%    workingSetB  -  Working set of bounds at point x.
-%    workingSetC  -  Working set of constraints at point x.
-%                    The working set is a subset of the active set (indices
-%                    of bounds/constraints that hold with equality) yielding
-%                    a set linearly independent of bounds/constraints.
-%                    The working sets are encoded as follows:
-%                     1: bound/constraint at its upper bound
-%                     0: bound/constraint not at any bound
-%                    -1: bound/constraint at its lower bound
-%    cpuTime      -  Internally measured CPU time for solving QP problem.
-%
-%
-%If not a single QP but a sequence of QPs with varying vectors is to be solved,
-%the i-th QP is given by the i-th columns of the QP vectors g, lb, ub, lbA, ubA
-%(i.e. they are matrices in this case). Both matrices H and A remain constant.
-%
-%See also QPOASES_OPTIONS, QPOASES_AUXINPUT, QPOASES_SEQUENCE
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_auxInput.m b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_auxInput.m
deleted file mode 100644
index 74c9d93..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_auxInput.m
+++ /dev/null
@@ -1,118 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%Returns a struct containing all possible auxiliary inputs to be passed 
-%to qpOASES.
-%
-%Call
-%    auxInput = qpOASES_auxInput();
-%to obtain a struct with all auxiliary inputs empty.
-%
-%Call
-%    auxInput = qpOASES_auxInput( 'input1',value1,'input2',value2,... )
-%to obtain a struct with 'input1' set to value1 etc. and all remaining
-%auxiliary inputs empty.
-%
-%Call
-%    auxInput = qpOASES_auxInput( oldInputs,'input1',value1,... )
-%to obtain a copy of the options struct oldInputs but with 'input1' set to 
-%value1 etc.
-%
-%
-%qpOASES features the following auxiliary inputs:
-%  hessianType          -  Provide information on Hessian matrix:
-%                          0: Hessian is zero matrix (i.e. LP formulation)
-%                          1: Hessian is identity matrix
-%                          2: Hessian is (strictly) positive definite
-%                          3: Hessian is positive definite on null space 
-%                             of active bounds/constraints
-%                          4: Hessian is positive semi-definite.
-%                          5: Hessian is indefinite
-%                          Leave hessianType empty if Hessian type is unknown.
-%  x0                   -  Initial guess for optimal primal solution.
-%  guessedWorkingSetB   -  Initial guess for working set of bounds at 
-%                          optimal solution (nV elements or empty).
-%  guessedWorkingSetC   -  Initial guess for working set of constraints at 
-%                          optimal solution (nC elements or empty).
-%                          The working sets needs to be encoded as follows:
-%                           1: bound/constraint at its upper bound
-%                           0: bound/constraint not at any bound
-%                          -1: bound/constraint at its lower bound
-%  R                    -  Cholesky factor of Hessian matrix (upper-triangular);
-%                          only used if both guessedWorkingSets are empty
-%                          and option initialStatusBounds is set to 0.
-%
-%
-%See also QPOASES, QPOASES_SEQUENCE, QPOASES_OPTIONS
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
-function [ auxInput ] = qpOASES_auxInput( varargin )
-
-	firstIsStruct = 0;
-
-	if ( nargin == 0 ) 
-		auxInput = qpOASES_emptyAuxInput();
-	else
-		if ( isstruct( varargin{1} ) )
-			if ( mod( nargin,2 ) ~= 1 )
-				error('ERROR (qpOASES_auxInput): Auxiliary inputs must be specified in pairs!');
-			end
-			auxInput = varargin{1};
-			firstIsStruct = 1;
-        else
-            if ( mod( nargin,2 ) ~= 0 )
-				error('ERROR (qpOASES_auxInput): Auxiliary inputs must be specified in pairs!');
-            end
-            auxInput = qpOASES_emptyAuxInput();
-		end
-	end
-
-	% set options to user-defined values  
-	for i=(1+firstIsStruct):2:nargin
-
-		argName  = varargin{i};
-		argValue = varargin{i+1};
-
-        if ( ( isempty( argName ) ) || ( ~ischar( argName ) ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d has to be a non-empty string!',i );
-        end
-			
-        if ( ( ischar(argValue) ) || ( ~isnumeric( argValue ) ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d has to be a numerical constant!',i+1 );
-        end
-
-        if ( ~isfield( auxInput,argName ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d is not a valid auxiliary input!',i );
-        end
-
-		eval( ['auxInput.',argName,' = argValue;'] );
-
-	end
-
-end
-
-
-function [ auxInput ] = qpOASES_emptyAuxInput( )
-
-	% setup auxiliary input struct with all entries empty
-	auxInput = struct(	'hessianType',        [], ...
-                        'x0',                 [], ...
-						'guessedWorkingSetB', [], ...
-                        'guessedWorkingSetC', [], ...
-                        'R',                  []  ...
-                        );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.cpp b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.cpp
deleted file mode 100644
index ee96ee2..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.cpp
+++ /dev/null
@@ -1,950 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/matlab/qpOASES_matlab_utils.cpp
- *	\author Hans Joachim Ferreau, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Collects utility functions for Interface to Matlab(R) that
- *	enables to call qpOASES as a MEX function.
- *
- */
-
-
-
-QPInstance::QPInstance(	uint_t _nV, uint_t _nC, HessianType _hessianType,
-						BooleanType _isSimplyBounded
-						)
-{
-	handle = s_nexthandle++;
-
-	if ( _nC > 0 )
-		isSimplyBounded = BT_FALSE;
-	else
-		isSimplyBounded = _isSimplyBounded;
-	
-	if ( isSimplyBounded == BT_TRUE )
-	{
-		sqp = 0;
-		qpb = new QProblemB( _nV,_hessianType );
-	}
-	else
-	{
-		sqp = new SQProblem( _nV,_nC,_hessianType );
-		qpb = 0;
-	}
-
-	H = 0;
-	A = 0;
-	Hir = 0; 
-	Hjc = 0; 
-	Air = 0; 
-	Ajc = 0;
-	Hv = 0;
-	Av = 0;
-}	
-
-
-QPInstance::~QPInstance( )
-{		
-	deleteQPMatrices();
-
-	if ( sqp != 0 )
-	{
-		delete sqp;
-		sqp = 0;
-	}
-
-	if ( qpb != 0 )
-	{
-		delete qpb;
-		qpb = 0;
-	}
-}
-
-
-returnValue QPInstance::deleteQPMatrices( )
-{
-	if ( H != 0 )
-	{
-		delete H;
-		H = 0;
-	}
-
-	if ( Hv != 0 )
-	{
-		delete[] Hv;
-		Hv = 0;
-	}
-	
-	if ( Hjc != 0 )
-	{
-		delete[] Hjc;
-		Hjc = 0;
-	}
-	
-	if ( Hir != 0 )
-	{
-		delete[] Hir;
-		Hir = 0;
-	}
-	
-	if ( A != 0 )
-	{
-		delete A;
-		A = 0;
-	}
-
-	if ( Av != 0 )
-	{
-		delete[] Av;
-		Av = 0;
-	}
-	
-	if ( Ajc != 0 )
-	{
-		delete[] Ajc;
-		Ajc = 0;
-	}
-	
-	if ( Air != 0 )
-	{
-		delete[] Air;
-		Air = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-int_t QPInstance::getNV() const
-{
-    if ( sqp != 0 )
-        return sqp->getNV();
-    
-    if ( qpb != 0 )
-        return qpb->getNV();
-    
-    return 0;
-}
-
-
-int_t QPInstance::getNC() const
-{
-    if ( sqp != 0 )
-        return sqp->getNC();
-   
-    return 0;
-}
-
-
-
-/*
- *	m x I s S c a l a r
- */
-bool mxIsScalar( const mxArray *pm )
-{
-	if ( ( mxGetM(pm) == 1 ) && ( mxGetN(pm) == 1 ) )
-		return true;
-	else
-		return false;
-}
-
-
-
-/*
- *	a l l o c a t e Q P r o b l e m I n s t a n c e
- */
-int_t allocateQPInstance(	int_t nV, int_t nC, HessianType hessianType,
-							BooleanType isSimplyBounded, const Options* options
-							)
-{
-	QPInstance* inst = new QPInstance( nV,nC,hessianType, isSimplyBounded );
-
-	if ( ( inst->sqp != 0 ) && ( options != 0 ) )
-		inst->sqp->setOptions( *options );
-	
-	if ( ( inst->qpb != 0 ) && ( options != 0 ) )
-		inst->qpb->setOptions( *options );
-
-	g_instances.push_back(inst);
-	return inst->handle;
-}
-
-
-/*
- *  g e t Q P r o b l e m I n s t a n c e
- */
-QPInstance* getQPInstance( int_t handle )
-{
-	uint_t ii;
-	// TODO: this may become slow ...
-	for (ii = 0; ii < g_instances.size (); ++ii)
-		if (g_instances[ii]->handle == handle)
-			return g_instances[ii];
-	return 0;
-}
-
-
-/*
- *	d e l e t e Q P r o b l e m I n s t a n c e
- */
-void deleteQPInstance( int_t handle )
-{
-	QPInstance *instance = getQPInstance (handle);
-	if (instance != 0) {
-		for (std::vector<QPInstance*>::iterator itor = g_instances.begin ();
-		     itor != g_instances.end (); ++itor)
-		     if ((*itor)->handle == handle) {
-				g_instances.erase (itor);
-				break;
-			}
-		delete instance;
-	}
-}
-
-
-
-/*
- *	s m a r t D i m e n s i o n C h e c k
- */
-returnValue smartDimensionCheck(	real_t** input, uint_t m, uint_t n, BooleanType emptyAllowed,
-									const mxArray* prhs[], int_t idx
-									)
-{
-	/* If index is negative, the input does not exist. */
-	if ( idx < 0 )
-	{
-		*input = 0;
-		return SUCCESSFUL_RETURN;
-	}
-
-	/* Otherwise the input has been passed by the user. */
-	if ( mxIsEmpty( prhs[ idx ] ) )
-	{
-		/* input is empty */
-		if ( ( emptyAllowed == BT_TRUE ) || ( idx == 0 ) ) /* idx==0 used for auxInput */
-		{
-			*input = 0;
-			return SUCCESSFUL_RETURN;
-		}
-		else
-		{
-			char msg[MAX_STRING_LENGTH];
-			if ( idx > 0 )
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Empty argument %d not allowed!", idx+1);
-			myMexErrMsgTxt( msg );
-			return RET_INVALID_ARGUMENTS;
-		}
-	}
-	else
-	{
-		/* input is non-empty */
-        if ( mxIsSparse( prhs[ idx ] ) == 0 )
-        {
-            if ( ( mxGetM( prhs[ idx ] ) == m ) && ( mxGetN( prhs[ idx ] ) == n ) )
-            {
-                *input = (real_t*) mxGetPr( prhs[ idx ] );
-                return SUCCESSFUL_RETURN;
-            }
-            else
-            {
-                char msg[MAX_STRING_LENGTH];
-				if ( idx > 0 )
-					snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Input dimension mismatch for argument %d ([%ld,%ld] ~= [%d,%d]).",
-							 idx+1, (long int)mxGetM(prhs[idx]), (long int)mxGetN(prhs[idx]), (int)m,(int)n);
-				else /* idx==0 used for auxInput */
-					snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Input dimension mismatch for some auxInput entry ([%ld,%ld] ~= [%d,%d]).",
-							 (long int)mxGetM(prhs[idx]), (long int)mxGetN(prhs[idx]), (int)m,(int)n);
-                myMexErrMsgTxt( msg );
-                return RET_INVALID_ARGUMENTS;
-            }
-        }
-        else
-        {
-            char msg[MAX_STRING_LENGTH];
-			if ( idx > 0 )
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Vector argument %d must not be in sparse format!", idx+1);
-			else /* idx==0 used for auxInput */
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): auxInput entries must not be in sparse format!" );
-			myMexErrMsgTxt( msg );
-			return RET_INVALID_ARGUMENTS;
-        }
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	c o n t a i n s N a N
- */
-BooleanType containsNaN( const real_t* const data, uint_t dim )
-{
-	uint_t i;
-
-	if ( data == 0 )
-		return BT_FALSE;
-
-	for ( i = 0; i < dim; ++i )
-		if ( mxIsNaN(data[i]) == 1 )
-			return BT_TRUE;
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n t a i n s I n f
- */
-BooleanType containsInf( const real_t* const data, uint_t dim )
-{
-	uint_t i;
-
-	if ( data == 0 )
-		return BT_FALSE;
-
-	for ( i = 0; i < dim; ++i )
-		if ( mxIsInf(data[i]) == 1 )
-			return BT_TRUE;
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n t a i n s N a N o r I n f
- */
-BooleanType containsNaNorInf(	const mxArray* prhs[], int_t rhs_index,
-								bool mayContainInf
-								)
-{
-	uint_t dim;
-	char msg[MAX_STRING_LENGTH];
-
-	if ( rhs_index < 0 )
-		return BT_FALSE;
-
-	/* overwrite dim for sparse matrices */
-	if (mxIsSparse(prhs[rhs_index]) == 1)
-		dim = (uint_t)mxGetNzmax(prhs[rhs_index]);
-	else
-		dim = (uint_t)(mxGetM(prhs[rhs_index]) * mxGetN(prhs[rhs_index]));
-
-	if (containsNaN((real_t*) mxGetPr(prhs[rhs_index]), dim) == BT_TRUE) {
-		snprintf(msg, MAX_STRING_LENGTH,
-				"ERROR (qpOASES): Argument %d contains 'NaN' !", rhs_index + 1);
-		myMexErrMsgTxt(msg);
-		return BT_TRUE;
-	}
-
-	if (mayContainInf == 0) {
-		if (containsInf((real_t*) mxGetPr(prhs[rhs_index]), dim) == BT_TRUE) {
-			snprintf(msg, MAX_STRING_LENGTH,
-					"ERROR (qpOASES): Argument %d contains 'Inf' !",
-					rhs_index + 1);
-			myMexErrMsgTxt(msg);
-			return BT_TRUE;
-		}
-	}
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n v e r t F o r t r a n T o C
- */
-returnValue convertFortranToC( const real_t* const M_for, int_t nV, int_t nC, real_t* const M )
-{
-	int_t i,j;
-
-	if ( ( M_for == 0 ) || ( M == 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	if ( ( nV < 0 ) || ( nC < 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	for ( i=0; i<nC; ++i )
-		for ( j=0; j<nV; ++j )
-			M[i*nV + j] = M_for[j*nC + i];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	h a s O p t i o n s V a l u e
- */
-BooleanType hasOptionsValue( const mxArray* optionsPtr, const char* const optionString, double** optionValue )
-{
-	mxArray* optionName = mxGetField( optionsPtr,0,optionString );
-
-	if ( optionName == 0 )
-	{
-		char msg[MAX_STRING_LENGTH];
-		snprintf(msg, MAX_STRING_LENGTH, "Option struct does not contain entry '%s', using default value instead!", optionString );
-		mexWarnMsgTxt( msg );
-		return BT_FALSE;
-	}
-
-	if ( ( mxIsEmpty(optionName) == false ) && ( mxIsScalar( optionName ) == true ) )
-	{
-		*optionValue = mxGetPr( optionName );
-		return BT_TRUE;
-	}
-	else
-	{
-		char msg[MAX_STRING_LENGTH];
-		snprintf(msg, MAX_STRING_LENGTH, "Option '%s' is not a scalar, using default value instead!", optionString );
-		mexWarnMsgTxt( msg );
-		return BT_FALSE;
-	}
-}
-
-
-/*
- *	s e t u p O p t i o n s
- */
-returnValue setupOptions( Options* options, const mxArray* optionsPtr, int_t& nWSRin, real_t& maxCpuTime )
-{
-	double* optionValue;
-	int_t optionValueInt;
-
-	/* Check for correct number of option entries;
-	 * may occur, e.g., if user types options.<misspelledName> = <someValue>; */
-	if ( mxGetNumberOfFields(optionsPtr) != 31 )
-		mexWarnMsgTxt( "Options might be set incorrectly as struct has wrong number of entries!\n         Type 'help qpOASES_options' for further information." );
-
-
-	if ( hasOptionsValue( optionsPtr,"maxIter",&optionValue ) == BT_TRUE )
-		if ( *optionValue >= 0.0 )
-			nWSRin = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxCpuTime",&optionValue ) == BT_TRUE )
-		if ( *optionValue >= 0.0 )
-			maxCpuTime = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"printLevel",&optionValue ) == BT_TRUE )
-	{
-        #ifdef __SUPPRESSANYOUTPUT__
-        options->printLevel = PL_NONE;
-        #else
-		optionValueInt = (int_t)*optionValue;
-		options->printLevel = (REFER_NAMESPACE_QPOASES PrintLevel)optionValueInt;
-        if ( options->printLevel < PL_DEBUG_ITER )
-            options->printLevel = PL_DEBUG_ITER;
-        if ( options->printLevel > PL_HIGH )
-            options->printLevel = PL_HIGH;       
-        #endif
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableRamping",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableRamping = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFarBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFarBounds = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFlippingBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFlippingBounds = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableRegularisation",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableRegularisation = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFullLITests",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFullLITests = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableNZCTests",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableNZCTests = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableDriftCorrection",&optionValue ) == BT_TRUE )
-		options->enableDriftCorrection = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"enableCholeskyRefactorisation",&optionValue ) == BT_TRUE )
-		options->enableCholeskyRefactorisation = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"enableEqualities",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableEqualities = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-
-	if ( hasOptionsValue( optionsPtr,"terminationTolerance",&optionValue ) == BT_TRUE )
-		options->terminationTolerance = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"boundTolerance",&optionValue ) == BT_TRUE )
-		options->boundTolerance = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"boundRelaxation",&optionValue ) == BT_TRUE )
-		options->boundRelaxation = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsNum",&optionValue ) == BT_TRUE )
-		options->epsNum = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsDen",&optionValue ) == BT_TRUE )
-		options->epsDen = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxPrimalJump",&optionValue ) == BT_TRUE )
-		options->maxPrimalJump = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxDualJump",&optionValue ) == BT_TRUE )
-		options->maxDualJump = *optionValue;
-
-
-	if ( hasOptionsValue( optionsPtr,"initialRamping",&optionValue ) == BT_TRUE )
-		options->initialRamping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"finalRamping",&optionValue ) == BT_TRUE )
-		options->finalRamping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"initialFarBounds",&optionValue ) == BT_TRUE )
-		options->initialFarBounds = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"growFarBounds",&optionValue ) == BT_TRUE )
-		options->growFarBounds = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"initialStatusBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		if ( optionValueInt < -1 ) 
-			optionValueInt = -1;
-		if ( optionValueInt > 1 ) 
-			optionValueInt = 1;
-		options->initialStatusBounds = (REFER_NAMESPACE_QPOASES SubjectToStatus)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"epsFlipping",&optionValue ) == BT_TRUE )
-		options->epsFlipping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"numRegularisationSteps",&optionValue ) == BT_TRUE )
-		options->numRegularisationSteps = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsRegularisation",&optionValue ) == BT_TRUE )
-		options->epsRegularisation = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"numRefinementSteps",&optionValue ) == BT_TRUE )
-		options->numRefinementSteps = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsIterRef",&optionValue ) == BT_TRUE )
-		options->epsIterRef = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsLITests",&optionValue ) == BT_TRUE )
-		options->epsLITests = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsNZCTests",&optionValue ) == BT_TRUE )
-		options->epsNZCTests = *optionValue;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p A u x i l i a r y I n p u t s
- */
-returnValue setupAuxiliaryInputs(	const mxArray* auxInput, uint_t nV, uint_t nC,
-									HessianType* hessianType, double** x0, double** guessedBounds, double** guessedConstraints, double** R
-									)
-{
-	mxArray* curField = 0;
-
-	/* hessianType */
-	curField = mxGetField( auxInput,0,"hessianType" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'hessianType'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		if ( mxIsEmpty(curField) == true )
-		{
-			*hessianType = HST_UNKNOWN;
-		}
-		else
-		{
-			if ( mxIsScalar(curField) == false )
-				return RET_INVALID_ARGUMENTS;
-
-			double* hessianTypeTmp = mxGetPr(curField);
-			int_t hessianTypeInt = (int_t)*hessianTypeTmp;
-			if ( hessianTypeInt < 0 ) 
-				hessianTypeInt = 6; /* == HST_UNKNOWN */
-			if ( hessianTypeInt > 5 ) 
-				hessianTypeInt = 6; /* == HST_UNKNOWN */
-			*hessianType = (REFER_NAMESPACE_QPOASES HessianType)hessianTypeInt;
-		}
-	}
-
-	/* x0 */
-	curField = mxGetField( auxInput,0,"x0" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'x0'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*x0 = mxGetPr(curField);
-		if ( smartDimensionCheck( x0,nV,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* guessedWorkingSetB */
-	curField = mxGetField( auxInput,0,"guessedWorkingSetB" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'guessedWorkingSetB'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*guessedBounds = mxGetPr(curField);
-		if ( smartDimensionCheck( guessedBounds,nV,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* guessedWorkingSetC */
-	curField = mxGetField( auxInput,0,"guessedWorkingSetC" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'guessedWorkingSetC'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*guessedConstraints = mxGetPr(curField);
-		if ( smartDimensionCheck( guessedConstraints,nC,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* R */
-	curField = mxGetField( auxInput,0,"R" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'R'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*R = mxGetPr(curField);
-		if ( smartDimensionCheck( R,nV,nV, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	a l l o c a t e O u t p u t s
- */
-returnValue allocateOutputs(	int nlhs, mxArray* plhs[], int_t nV, int_t nC = 0, int_t nP = 1, int_t handle = -1
-								)
-{
-	/* Create output vectors and assign pointers to them. */
-	int_t curIdx = 0;
-
-	/* handle */
-	if ( handle >= 0 )
-		plhs[curIdx++] = mxCreateDoubleMatrix( 1, 1, mxREAL );
-
-	/* x */
-	plhs[curIdx++] = mxCreateDoubleMatrix( nV, nP, mxREAL );
-
-	if ( nlhs > curIdx )
-	{
-		/* fval */
-		plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-		if ( nlhs > curIdx )
-		{
-			/* exitflag */
-			plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-			if ( nlhs > curIdx )
-			{
-				/* iter */
-				plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-				if ( nlhs > curIdx )
-				{
-					/* lambda */
-					plhs[curIdx++] = mxCreateDoubleMatrix( nV+nC, nP, mxREAL );
-
-					if ( nlhs > curIdx )
-					{
-						/* setup auxiliary output struct */
-						mxArray* auxOutput = mxCreateStructMatrix( 1,1,0,0 );
-						int_t curFieldNum;
-						
-						/* working set */
-						curFieldNum = mxAddField( auxOutput,"workingSetB" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( nV, nP, mxREAL ) );
-
-						curFieldNum = mxAddField( auxOutput,"workingSetC" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( nC, nP, mxREAL ) );
-
-						curFieldNum = mxAddField( auxOutput,"cpuTime" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( 1, nP, mxREAL ) );
-
-						plhs[curIdx] = auxOutput;
-					}
-				}
-			}
-		}
-	}
-	
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	o b t a i n O u t p u t s
- */
-returnValue obtainOutputs(	int_t k, QProblemB* qp, returnValue returnvalue, int_t _nWSRout, double _cpuTime,
-							int nlhs, mxArray* plhs[], int_t nV, int_t nC = 0, int_t handle = -1
-							)
-{
-	/* Create output vectors and assign pointers to them. */
-	int_t curIdx = 0;
-
-	/* handle */
-	if ( handle >= 0 )
-		plhs[curIdx++] = mxCreateDoubleScalar( handle );
-
-	/* x */
-	double* x = mxGetPr( plhs[curIdx++] );
-	qp->getPrimalSolution( &(x[k*nV]) );
-
-	if ( nlhs > curIdx )
-	{
-		/* fval */
-		double* obj = mxGetPr( plhs[curIdx++] );
-		obj[k] = qp->getObjVal( );
-
-		if ( nlhs > curIdx )
-		{
-			/* exitflag */
-			double* status = mxGetPr( plhs[curIdx++] );
-			status[k] = (double)getSimpleStatus( returnvalue );
-
-			if ( nlhs > curIdx )
-			{
-				/* iter */
-				double* nWSRout = mxGetPr( plhs[curIdx++] );
-				nWSRout[k] = (double) _nWSRout;
-
-				if ( nlhs > curIdx )
-				{
-					/* lambda */
-					double* y = mxGetPr( plhs[curIdx++] );
-					qp->getDualSolution( &(y[k*(nV+nC)]) );
-
-					/* auxOutput */
-					if ( nlhs > curIdx )
-					{
-						QProblem* problemPointer;
-						problemPointer = dynamic_cast<QProblem*>(qp);
-
-						mxArray* auxOutput = plhs[curIdx];
-						mxArray* curField = 0;
-
-						/* working set bounds */
-						if ( nV > 0 )
-						{
-							curField = mxGetField( auxOutput,0,"workingSetB" );
-							double* workingSetB = mxGetPr(curField);
-
-							/* cast successful? */
-							if (problemPointer != NULL) {
-								problemPointer->getWorkingSetBounds( &(workingSetB[k*nV]) );
-							} else {
-								qp->getWorkingSetBounds( &(workingSetB[k*nV]) );
-							}
-						}
-
-						/* working set constraints */
-						if ( nC > 0 )
-						{
-							curField = mxGetField( auxOutput,0,"workingSetC" );
-							double* workingSetC = mxGetPr(curField);
-
-							/* cast successful? */
-							if (problemPointer != NULL) {
-								problemPointer->getWorkingSetConstraints( &(workingSetC[k*nC]) );
-							} else {
-								qp->getWorkingSetConstraints( &(workingSetC[k*nC]) );
-							}
-						}
-
-						/* cpu time */
-						curField = mxGetField( auxOutput,0,"cpuTime" );
-						double* cpuTime = mxGetPr(curField);
-						cpuTime[0] = (double) _cpuTime;
-					}
-				}
-			}
-		}
-	}
-	
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p H e s s i a n M a t r i x
- */
-returnValue setupHessianMatrix(	const mxArray* prhsH, int_t nV,
-								SymmetricMatrix** H, sparse_int_t** Hir, sparse_int_t** Hjc, real_t** Hv
-								)
-{
-	if ( prhsH == 0 )
-		return SUCCESSFUL_RETURN;
-
-	if ( mxIsSparse( prhsH ) != 0 )
-	{
-		mwIndex *mat_ir = mxGetIr( prhsH );
-		mwIndex *mat_jc = mxGetJc( prhsH );
-		double *v = (double*)mxGetPr( prhsH );
-		sparse_int_t nfill = 0;
-		mwIndex i, j;
-		BooleanType needInsertDiag;
-
-		/* copy indices to avoid 64/32-bit integer confusion */
-		/* also add explicit zeros on diagonal for regularization strategy */
-		/* copy values, too */
-		*Hir = new sparse_int_t[mat_jc[nV] + nV];
-		*Hjc = new sparse_int_t[nV+1];
-		*Hv = new real_t[mat_jc[nV] + nV];
-        for (j = 0; j < nV; j++) 
-		{
-            needInsertDiag = BT_TRUE;
-                
-            (*Hjc)[j] = (sparse_int_t)(mat_jc[j]) + nfill;
-            /* fill up to diagonal */
-            for (i = mat_jc[j]; i < mat_jc[j+1]; i++) 
-			{
-                if ( mat_ir[i] == j )
-                    needInsertDiag = BT_FALSE;
-                    
-                /* add zero diagonal element if not present */
-                if ( ( mat_ir[i] > j ) && ( needInsertDiag == BT_TRUE ) )
-                {
-                    (*Hir)[i + nfill] = (sparse_int_t)j;
-                    (*Hv)[i + nfill] = 0.0;
-                    nfill++;
-                    /* only add diag once */
-                    needInsertDiag = BT_FALSE;
-                }
-                        
-				(*Hir)[i + nfill] = (sparse_int_t)(mat_ir[i]);
-				(*Hv)[i + nfill] = (real_t)(v[i]);
-			}
-		}
-		(*Hjc)[nV] = (sparse_int_t)(mat_jc[nV]) + nfill;
-
-		SymSparseMat *sH;
-		*H = sH = new SymSparseMat(nV, nV, *Hir, *Hjc, *Hv);
-		sH->createDiagInfo();
-	}
-	else
-	{
-		/* make a deep-copy in order to avoid modifying input data when regularising */
-		real_t* H_for = (real_t*) mxGetPr( prhsH );
-		real_t* H_mem = new real_t[nV*nV];
-		memcpy( H_mem,H_for, nV*nV*sizeof(real_t) );
-
-		*H = new SymDenseMat( nV,nV,nV, H_mem );
-		(*H)->doFreeMemory( );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p C o n s t r a i n t M a t r i x
- */
-returnValue setupConstraintMatrix(	const mxArray* prhsA, int_t nV, int_t nC,
-									Matrix** A, sparse_int_t** Air, sparse_int_t** Ajc, real_t** Av
-									)
-{
-	if ( prhsA == 0 )
-		return SUCCESSFUL_RETURN;
-
-	if ( mxIsSparse( prhsA ) != 0 )
-	{
-		mwIndex i;
-		long j;
-
-		mwIndex *mat_ir = mxGetIr( prhsA );
-		mwIndex *mat_jc = mxGetJc( prhsA );
-		double *v = (double*)mxGetPr( prhsA );
-
-		/* copy indices to avoid 64/32-bit integer confusion */
-		*Air = new sparse_int_t[mat_jc[nV]];
-		*Ajc = new sparse_int_t[nV+1];
-		for (i = 0; i < mat_jc[nV]; i++)
-			(*Air)[i] = (sparse_int_t)(mat_ir[i]);
-		for (i = 0; i < nV + 1; i++)
-			(*Ajc)[i] = (sparse_int_t)(mat_jc[i]);
-		
-		/* copy values, too */
-		*Av = new real_t[(*Ajc)[nV]];
-		for (j = 0; j < (*Ajc)[nV]; j++)
-			(*Av)[j] = (real_t)(v[j]);
-
-		*A = new SparseMatrix(nC, nV, *Air, *Ajc, *Av);
-	}
-	else
-	{
-		/* Convert constraint matrix A from FORTRAN to C style
-		* (not necessary for H as it should be symmetric!). */
-		real_t* A_for = (real_t*) mxGetPr( prhsA );
-		real_t* A_mem = new real_t[nC*nV];
-		convertFortranToC( A_for,nV,nC, A_mem );
-		*A = new DenseMatrix(nC, nV, nV, A_mem );
-		(*A)->doFreeMemory();
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.hpp b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.hpp
deleted file mode 100644
index 135cdb9..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.hpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/matlab/qpOASES_matlab_utils.hpp
- *	\author Hans Joachim Ferreau, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Collects utility functions for Interface to Matlab(R) that
- *	enables to call qpOASES as a MEX function.
- *
- */
-
-
-
-/* Work-around for settings where mexErrMsgTxt causes unexpected behaviour. */
-#ifdef __AVOID_MEXERRMSGTXT__
-	#define myMexErrMsgTxt( TEXT ) mexPrintf( "%s\n\n",(TEXT) );
-#else
-	#define myMexErrMsgTxt mexErrMsgTxt
-#endif
-
-
-#include "mex.h"
-#include "matrix.h"
-#include "string.h"
-#include <vector>
-
-
-/*
- * QProblem instance class
- */
-class QPInstance
-{
-	private:
-		static int_t s_nexthandle;
-
-	public:
-		QPInstance(	uint_t _nV = 0,
-					uint_t _nC = 0,
-					HessianType _hessianType = HST_UNKNOWN,
-					BooleanType _isSimplyBounded = BT_FALSE
-					);
-
-		~QPInstance( );
-	
-		returnValue deleteQPMatrices();
-		
-		int_t getNV() const;
-		int_t getNC() const;
-
-		int_t handle;
-
-		SQProblem* sqp;
-		QProblemB* qpb;
-		BooleanType isSimplyBounded;
-
-		SymmetricMatrix* H;
-		Matrix* A;
-		sparse_int_t* Hir; 
-		sparse_int_t* Hjc; 
-		sparse_int_t* Air; 
-		sparse_int_t* Ajc;
-		real_t* Hv;
-		real_t* Av;
-};
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_options.m b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_options.m
deleted file mode 100644
index 0f37b97..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_options.m
+++ /dev/null
@@ -1,251 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%Returns a struct containing values for all options to be used within qpOASES.
-%
-%Call
-%    options = qpOASES_options( 'default' );
-%    options = qpOASES_options( 'reliable' );
-%    options = qpOASES_options( 'MPC' );
-%to obtain a set of default options or a pre-defined set of options tuned
-%for reliable or fast QP solution, respectively.
-%
-%Call
-%    options = qpOASES_options( 'option1',value1,'option2',value2,... )
-%to obtain a set of default options but with 'option1' set to value1 etc.
-%
-%Call
-%    options = qpOASES_options( oldOptions,'option1',value1,... )
-%to obtain a copy of the options struct oldOptions but with 'option1' set
-%to value1 etc.
-%
-%Call
-%    options = qpOASES_options( 'default', 'option1',value1,... )
-%    options = qpOASES_options( 'reliable','option1',value1,... )
-%    options = qpOASES_options( 'MPC',     'option1',value1,... )
-%to obtain a set of default options or a pre-defined set of options tuned
-%for reliable or fast QP solution, respectively, but with 'option1' set to 
-%value1 etc.
-%
-%
-%qpOASES features the following options:
-%  maxIter                    -  Maximum number of iterations (if set
-%                                to -1, a value is chosen heuristically)
-%  maxCpuTime                 -  Maximum CPU time in seconds (if set
-%                                to -1, only iteration limit is used)
-%  printLevel                 -  0: no printed output,
-%                                1: only error messages are printed,
-%                                2: iterations and error messages are printed,
-%                                3: all available messages are printed.
-%
-%  enableRamping              -  Enables (1) or disables (0) ramping.
-%  enableFarBounds            -  Enables (1) or disables (0) the use of 
-%                                far bounds.
-%  enableFlippingBounds       -  Enables (1) or disables (0) the use of 
-%                                flipping bounds.
-%  enableRegularisation       -  Enables (1) or disables (0) automatic 
-%                                Hessian regularisation.
-%  enableFullLITests          -  Enables (1) or disables (0) condition-hardened 
-%                                (but more expensive) LI test.
-%  enableNZCTests             -  Enables (1) or disables (0) nonzero curvature 
-%                                tests.
-%  enableDriftCorrection      -  Specifies the frequency of drift corrections:
-%                                0: turns them off, 
-%                                1: uses them at each iteration etc.
-%  enableCholeskyRefactorisation - Specifies the frequency of a full re-
-%                                factorisation of projected Hessian matrix:
-%                                0: turns them off, 
-%                                1: uses them at each iteration etc.
-%  enableEqualities           -  Specifies whether equalities should be treated 
-%                                as always active (1) or not (0)
-%
-%  terminationTolerance       -  Relative termination tolerance to stop homotopy.
-%  boundTolerance             -  If upper and lower bounds differ less than this
-%                                tolerance, they are regarded equal, i.e. as 
-%                                equality constraint.
-%  boundRelaxation            -  Initial relaxation of bounds to start homotopy 
-%                                and initial value for far bounds.
-%  epsNum                     -  Numerator tolerance for ratio tests.
-%  epsDen                     -  Denominator tolerance for ratio tests.
-%  maxPrimalJump              -  Maximum allowed jump in primal variables in 
-%                                nonzero curvature tests.
-%  maxDualJump                -  Maximum allowed jump in dual variables in 
-%                                linear independence tests.
-%
-%  initialRamping             -  Start value for ramping strategy.
-%  finalRamping               -  Final value for ramping strategy.
-%  initialFarBounds           -  Initial size for far bounds.
-%  growFarBounds              -  Factor to grow far bounds.
-%  initialStatusBounds        -  Initial status of bounds at first iteration:
-%                                 0: all bounds inactive,
-%                                -1: all bounds active at their lower bound,
-%                                +1: all bounds active at their upper bound.
-%  epsFlipping                -  Tolerance of squared Cholesky diagonal factor 
-%                                which triggers flipping bound.
-%  numRegularisationSteps     -  Maximum number of successive regularisation steps.
-%  epsRegularisation          -  Scaling factor of identity matrix used for 
-%                                Hessian regularisation.
-%  numRefinementSteps         -  Maximum number of iterative refinement steps.
-%  epsIterRef                 -  Early termination tolerance for iterative 
-%                                refinement.
-%  epsLITests                 -  Tolerance for linear independence tests.
-%  epsNZCTests                -  Tolerance for nonzero curvature tests.
-%
-%
-%See also QPOASES, QPOASES_SEQUENCE, QPOASES_AUXINPUT
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
-function [ options ] = qpOASES_options( varargin )
-
-	firstIsStructOrScheme = 0;
-
-	if ( nargin == 0 ) 
-		options = qpOASES_default_options();
-	else
-		if ( isstruct( varargin{1} ) )
-			if ( mod( nargin,2 ) ~= 1 )
-				error('ERROR (qpOASES_options): Options must be specified in pairs!');
-			end
-			options = varargin{1};
-			firstIsStructOrScheme = 1;
-		else
-			if ( ischar( varargin{1} ) )
-				if ( mod( nargin,2 ) == 0 )
-					options = qpOASES_default_options();
-				else
-					if ( ( nargin > 1 ) && ( ischar( varargin{nargin} ) ) )
-						error('ERROR (qpOASES_options): Options must be specified in pairs!');
-					end
-
-					switch ( varargin{1} )
-						case 'default'
-							options = qpOASES_default_options();
-						case 'reliable'
-							options = qpOASES_reliable_options();
-						case {'MPC','mpc','fast'}
-							options = qpOASES_MPC_options();
-						otherwise
-							error( ['ERROR (qpOASES_options): Only the following option schemes are defined: ''default'', ''reliable'', ''MPC''!'] );
-							
-					end
-					firstIsStructOrScheme = 1;
-				end
-			else
-				error('ERROR (qpOASES_options): First argument needs to be a string or an options struct!');
-			end
-		end
-	end
-
-	% set options to user-defined values  
-	for i=(1+firstIsStructOrScheme):2:nargin
-
-		argName  = varargin{i};
-		argValue = varargin{i+1};
-
-		if ( ( isempty( argName ) ) || ( ~ischar( argName ) ) )
-			error('ERROR (qpOASES_options): Argmument no. %d has to be a non-empty string!',i );
-        end
-			
-		if ( ( ischar(argValue) ) || ( ~isscalar( argValue ) ) )
-			error('ERROR (qpOASES_options): Argmument no. %d has to be a scalar constant!',i+1 );
-        end
-
-		if ( ~isfield( options,argName ) )
-			error('ERROR (qpOASES_options): Argmument no. %d is an invalid option!',i );
-		end
-
-		eval( ['options.',argName,' = ',num2str(argValue),';'] );
-
-	end
-
-end
-
-
-function [ options ] = qpOASES_default_options( )
-
-	% setup options struct with default values
-	options = struct(	'maxIter',                       -1, ...
-						'maxCpuTime',                    -1, ...
-						'printLevel',                     1, ...
-						...
-						'enableRamping',                  1, ...
-						'enableFarBounds',                1, ...
-						'enableFlippingBounds',           1, ...
-						'enableRegularisation',           0, ...
-						'enableFullLITests',              0, ...
-						'enableNZCTests',                 1, ...
-						'enableDriftCorrection',          1, ...
-						'enableCholeskyRefactorisation',  0, ...
-						'enableEqualities',               0, ...
-						...
-						'terminationTolerance',           5.0e6*eps, ...
-						'boundTolerance',                 1.0e6*eps, ...
-						'boundRelaxation',                1.0e4, ...
-						'epsNum',                        -1.0e3*eps, ...
-						'epsDen',                         1.0e3*eps, ...
-						'maxPrimalJump',                  1.0e8, ...
-						'maxDualJump',                    1.0e8, ...
-						...
-    					'initialRamping',                 0.5, ...
-						'finalRamping',                   1.0, ...
-						'initialFarBounds',               1.0e6, ...
-						'growFarBounds',                  1.0e3, ...
-						'initialStatusBounds',            -1, ...
-						'epsFlipping',                    1.0e3*eps, ...
-						'numRegularisationSteps',         0, ...
-						'epsRegularisation',              1.0e3*eps, ...
-						'numRefinementSteps',             1, ...
-						'epsIterRef',                     1.0e2*eps, ...
-						'epsLITests',                     1.0e5*eps, ...
-						'epsNZCTests',                    3.1e3*eps );
-
-end
-
-
-
-function [ options ] = qpOASES_reliable_options( )
-
-	% setup options struct with values for most reliable QP solution
-	options = qpOASES_default_options( );
-
-	options.enableFullLITests             =  1;
-	options.enableCholeskyRefactorisation =  1;
-
-	options.numRefinementSteps            =  2;
-
-end
-
-
-function [ options ] = qpOASES_MPC_options( )
-
-	% setup options struct with values for most reliable QP solution
-	options = qpOASES_default_options( );
-
-	options.enableRamping                 =  0;
-	options.enableFarBounds               =  1;
-	options.enableFlippingBounds          =  0;
-	options.enableRegularisation          =  1;
-	options.enableNZCTests                =  0;
-	options.enableDriftCorrection         =  0;
-	options.enableEqualities              =  1;
-
-	options.terminationTolerance          =  1.0e9*eps;
-	
-	options.initialStatusBounds           =  0;
-	options.numRegularisationSteps        =  1;
-	options.numRefinementSteps            =  0;
-
-end
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.cpp b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.cpp
deleted file mode 100644
index 95b3038..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.cpp
+++ /dev/null
@@ -1,1104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/matlab/qpOASES_sequence.cpp
- *	\author Hans Joachim Ferreau, Christian Kirches, Andreas Potschka, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Matlab(R) that enables to call qpOASES as a MEX function
- *  (variant for solving QP sequences).
- *
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-
-#include "qpOASES_matlab_utils.hpp"
-
-/** initialise handle counter of QPInstance class */
-int_t QPInstance::s_nexthandle = 1;
-
-/** global pointer to QP objects */
-static std::vector<QPInstance *> g_instances;
-
-#include "qpOASES_matlab_utils.cpp"
-
-
-/*
- *	Q P r o b l e m B _ i n i t
- */
-int_t QProblemB_init(	int_t handle, 
-						SymmetricMatrix* H, real_t* g,
-						const real_t* const lb, const real_t* const ub,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds,
-						const double* const _R
-						)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	/* 1) setup initial QP. */
-	QProblemB* globalQPB = getQPInstance(handle)->qpb;
-
-	if ( globalQPB == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-		return -1;
-	}
-
-	globalQPB->setOptions( *options );
-	
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-	int_t nV = globalQPB->getNV();
-	
-	/* 3) Fill the working set. */
-	Bounds bounds(nV);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	returnvalue = globalQPB->init(	H,g,lb,ub,
-									nWSRout,&maxCpuTimeOut,
-									x0,0,
-									(guessedBounds != 0) ? &bounds : 0,
-									_R
-									);
-
-	/* 3) Assign lhs arguments. */
-	obtainOutputs(	0,globalQPB,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,0,handle );
-
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ i n i t
- */
-int_t SQProblem_init(	int_t handle, 
-						SymmetricMatrix* H, real_t* g, Matrix* A,
-						const real_t* const lb, const real_t* const ub,
-						const real_t* const lbA, const real_t* const ubA,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds, const double* const guessedConstraints,
-						const double* const _R
-						)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	/* 1) setup initial QP. */
-	SQProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-		return -1;
-	}
-
-	globalSQP->setOptions( *options );
-	
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-	
-	/* 3) Fill the working set. */
-	Bounds bounds(nV);
-	Constraints constraints(nC);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	if (guessedConstraints != 0) {
-		for (int_t i = 0; i < nC; i++) {
-			if ( isEqual(guessedConstraints[i],-1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_LOWER);
-			} else if ( isEqual(guessedConstraints[i],1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_UPPER);
-			} else if ( isEqual(guessedConstraints[i],0.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of constraints!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-	
-	returnvalue = globalSQP->init(	H,g,A,lb,ub,lbA,ubA,
-									nWSRout,&maxCpuTimeOut,
-									x0,0,
-									(guessedBounds != 0) ? &bounds : 0, (guessedConstraints != 0) ? &constraints : 0,
-									_R
-									);
-
-	/* 3) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC,handle );
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m B _ h o t s t a r t
- */
-int_t QProblemB_hotstart(	int_t handle,
-							const real_t* const g,
-							const real_t* const lb, const real_t* const ub,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	QProblemB* globalQPB = getQPInstance(handle)->qpb;
-
-	if ( globalQPB == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalQPB->getNV();
-
-	/* 1) Solve QP with given options. */
-	globalQPB->setOptions( *options );
-	returnValue returnvalue = globalQPB->hotstart( g,lb,ub, nWSRout,&maxCpuTimeOut );
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalQPB,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,0 );
-
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m _ h o t s t a r t
- */
-int_t QProblem_hotstart(	int_t handle,
-							const real_t* const g,
-							const real_t* const lb, const real_t* const ub,
-							const real_t* const lbA, const real_t* const ubA,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	QProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-
-	/* 1) Solve QP with given options. */
-	globalSQP->setOptions( *options );
-	returnValue returnvalue = globalSQP->hotstart( g,lb,ub,lbA,ubA, nWSRout,&maxCpuTimeOut );
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC );
-
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ h o t s t a r t
- */
-int_t SQProblem_hotstart(	int_t handle,
-							SymmetricMatrix* H, real_t* g, Matrix* A,
-							const real_t* const lb, const real_t* const ub, const real_t* const lbA, const real_t* const ubA,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	SQProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-
-	/* 1) Solve QP. */
-	globalSQP->setOptions( *options );
-	returnValue returnvalue = globalSQP->hotstart( H,g,A,lb,ub,lbA,ubA, nWSRout,&maxCpuTimeOut );
-
-	switch (returnvalue)
-	{
-		case SUCCESSFUL_RETURN:
-		case RET_QP_UNBOUNDED:
-		case RET_QP_INFEASIBLE:
-			break;
-
-		default:
-			myMexErrMsgTxt( "ERROR (qpOASES): Hotstart failed." );
-			return -1;
-	}
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC );
-
-	return 0;
-}
-
-
-
-/*
- *	m e x F u n c t i o n
- */
-void mexFunction( int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[] )
-{
-	/* inputs */
-	char typeString[2];
-
-	real_t *g=0, *lb=0, *ub=0, *lbA=0, *ubA=0;
-	HessianType hessianType = HST_UNKNOWN;
-	double *x0=0, *R=0, *R_for=0;
-	double *guessedBounds=0, *guessedConstraints=0;
-
-	int_t H_idx=-1, g_idx=-1, A_idx=-1, lb_idx=-1, ub_idx=-1, lbA_idx=-1, ubA_idx=-1;
-	int_t x0_idx=-1, auxInput_idx=-1;
-
-	BooleanType isSimplyBoundedQp = BT_FALSE;
-
-	Options options;
-	options.printLevel = PL_LOW;
-	#ifdef __DEBUG__
-	options.printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	options.printLevel = PL_NONE;
-	#endif
-
-	/* dimensions */
-	uint_t nV=0, nC=0, handle=0;
-	int_t nWSRin;
-	real_t maxCpuTimeIn = -1.0;
-	QPInstance* globalQP = 0;
-
-	/* I) CONSISTENCY CHECKS: */
-	/* 1) Ensure that qpOASES is called with a feasible number of input arguments. */
-	if ( ( nrhs < 5 ) || ( nrhs > 10 ) )
-	{
-		if ( nrhs != 2 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-	}
-	
-	/* 2) Ensure that first input is a string ... */
-	if ( mxIsChar( prhs[0] ) != 1 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): First input argument must be a string!" );
-		return;
-	}
-
-	mxGetString( prhs[0], typeString, 2 );
-
-	/*    ... and if so, check if it is an allowed one. */
-	if ( ( strcmp( typeString,"i" ) != 0 ) && ( strcmp( typeString,"I" ) != 0 ) &&
-		 ( strcmp( typeString,"h" ) != 0 ) && ( strcmp( typeString,"H" ) != 0 ) &&
-		 ( strcmp( typeString,"m" ) != 0 ) && ( strcmp( typeString,"M" ) != 0 ) &&
-		 ( strcmp( typeString,"e" ) != 0 ) && ( strcmp( typeString,"E" ) != 0 ) &&
-		 ( strcmp( typeString,"c" ) != 0 ) && ( strcmp( typeString,"C" ) != 0 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Undefined first input argument!\nType 'help qpOASES_sequence' for further information." );
-		return;
-	}
-
-
-	/* II) SELECT RESPECTIVE QPOASES FUNCTION CALL: */
-	/* 1) Init (without or with initial guess for primal solution). */
-	if ( ( strcmp( typeString,"i" ) == 0 ) || ( strcmp( typeString,"I" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 7 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 5 ) || ( nrhs > 10 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		g_idx = 2;
-
-		if ( mxIsEmpty(prhs[1]) == 1 )
-		{
-			H_idx = -1;
-			nV = (uint_t)mxGetM( prhs[ g_idx ] ); /* row number of Hessian matrix */
-		}
-		else
-		{
-			H_idx = 1;
-			nV = (uint_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-		}
-
-
-		/* ensure that data is given in double precision */
-		if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[ H_idx ] ) == 0 ) ) ||
-		     ( mxIsDouble( prhs[ g_idx ] ) == 0 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-			return;
-		}
-
-		if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Hessian matrix dimension mismatch!" );
-			return;
-		}
-
-
-		/* Check for 'Inf' and 'Nan' in Hessian */
-		if (containsNaNorInf( prhs,H_idx, 0 ) == BT_TRUE)
-			return;
-
-		/* Check for 'Inf' and 'Nan' in gradient */
-		if (containsNaNorInf(prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		/* determine whether is it a simply bounded QP */
-		if ( nrhs <= 7 )
-			isSimplyBoundedQp = BT_TRUE;
-		else
-			isSimplyBoundedQp = BT_FALSE;
-
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			lb_idx = 3;
-			ub_idx = 4;
-
-			if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-				return;
-
-			/* Check inputs dimensions and assign pointers to inputs. */
-			nC = 0; /* row number of constraint matrix */
-
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,2 ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,3 ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,4 ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*nV;
-
-			/* Check whether x0 and options are specified .*/
-			if ( nrhs >= 6 )
-			{
-				if ((!mxIsEmpty(prhs[5])) && (mxIsStruct(prhs[5])))
-					setupOptions( &options,prhs[5],nWSRin,maxCpuTimeIn );
-
-				if ( ( nrhs >= 7 ) && ( !mxIsEmpty(prhs[6]) ) )
-				{ 
-					/* auxInput specified */
-					if ( mxIsStruct(prhs[6]) )
-					{
-						auxInput_idx = 6;
-						x0_idx = -1;
-					}
-					else
-					{
-						auxInput_idx = -1;
-						x0_idx = 6;
-					}
-				}
-				else
-				{
-					auxInput_idx = -1;
-					x0_idx = -1;
-				}
-			}
-		}
-		else
-		{
-			A_idx = 3;
-
-			/* ensure that data is given in double precision */
-			if ( mxIsDouble( prhs[ A_idx ] ) == 0 )
-			{
-				myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-				return;
-			}
-		
-			/* Check inputs dimensions and assign pointers to inputs. */
-			nC = (uint_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-
-			lb_idx = 4;
-			ub_idx = 5;
-			lbA_idx = 6;
-			ubA_idx = 7;
-
-			if (containsNaNorInf( prhs,A_idx, 0 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if ( ( mxGetN( prhs[ A_idx ] ) != 0 ) && ( mxGetN( prhs[ A_idx ] ) != nV ) )
-			{
-				myMexErrMsgTxt( "ERROR (qpOASES): Constraint matrix dimension mismatch!" );
-				return;
-			}
-		
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-				return;
-			
-			if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*(nV+nC);
-
-			/* Check whether x0 and options are specified .*/
-			if ( nrhs >= 9 )
-			{
-				if ((!mxIsEmpty(prhs[8])) && (mxIsStruct(prhs[8])))
-					setupOptions( &options,prhs[8],nWSRin,maxCpuTimeIn );
-
-				if ( ( nrhs >= 10 ) && ( !mxIsEmpty(prhs[9]) ) )
-				{ 
-					/* auxInput specified */
-					if ( mxIsStruct(prhs[9]) )
-					{
-						auxInput_idx = 9;
-						x0_idx = -1;
-					}
-					else
-					{
-						auxInput_idx = -1;
-						x0_idx = 9;
-					}
-				}
-				else
-				{
-					auxInput_idx = -1;
-					x0_idx = -1;
-				}
-			}
-		}
-
-
-		/* check dimensions and copy auxInputs */
-		if ( smartDimensionCheck( &x0,nV,1, BT_TRUE,prhs,x0_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( auxInput_idx >= 0 )
-			setupAuxiliaryInputs( prhs[auxInput_idx],nV,nC, &hessianType,&x0,&guessedBounds,&guessedConstraints,&R_for );
-
-		/* convert Cholesky factor to C storage format */
-		if ( R_for != 0 )
-		{
-			R = new real_t[nV*nV];
-			convertFortranToC( R_for, nV,nV, R );
-		}
-		
-		/* allocate instance */
-		handle = allocateQPInstance( nV,nC,hessianType, isSimplyBoundedQp,&options );	
-		globalQP = getQPInstance( handle );
-
-		/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-		if ( H_idx >= 0 )
-			setupHessianMatrix(	prhs[H_idx],nV, &(globalQP->H),&(globalQP->Hir),&(globalQP->Hjc),&(globalQP->Hv) );
-		
-		/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-		if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-			setupConstraintMatrix( prhs[A_idx],nV,nC, &(globalQP->A),&(globalQP->Air),&(globalQP->Ajc),&(globalQP->Av) );
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC,1,handle );
-
-		/* Call qpOASES. */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			QProblemB_init(	handle,
-							globalQP->H,g,
-							lb,ub,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,R
-							);
-		}
-		else
-		{
-			SQProblem_init(	handle,
-							globalQP->H,g,globalQP->A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,guessedConstraints,R
-							);
-		}
-
-		if (R != 0) delete R;
-		return;
-	}
-
-	/* 2) Hotstart. */
-	if ( ( strcmp( typeString,"h" ) == 0 ) || ( strcmp( typeString,"H" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 6 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 5 ) || ( nrhs > 8 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* determine whether is it a simply bounded QP */
-		if ( nrhs < 7 )
-			isSimplyBoundedQp = BT_TRUE;
-		else
-			isSimplyBoundedQp = BT_FALSE;
-
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		nV = globalQP->getNV();
-
-		g_idx = 2;
-		lb_idx = 3;
-		ub_idx = 4;
-
-		if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			nC = 0;
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*nV;
-
-			/* Check whether options are specified .*/
-			if ( nrhs == 6 )
-				if ( ( !mxIsEmpty( prhs[5] ) ) && ( mxIsStruct( prhs[5] ) ) )
-					setupOptions( &options,prhs[5],nWSRin,maxCpuTimeIn );
-		}
-		else
-		{
-			nC = globalQP->getNC( );
-
-			lbA_idx = 5;
-			ubA_idx = 6;
-
-			if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*(nV+nC);
-
-			/* Check whether options are specified .*/
-			if ( nrhs == 8 )
-				if ( ( !mxIsEmpty( prhs[7] ) ) && ( mxIsStruct( prhs[7] ) ) )
-					setupOptions( &options,prhs[7],nWSRin,maxCpuTimeIn );
-		}
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC );
-
-		/* call qpOASES */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			QProblemB_hotstart(	handle, g,
-								lb,ub,
-								nWSRin,maxCpuTimeIn,
-								&options,
-								nlhs,plhs
-								);
-		}
-		else
-		{
-			QProblem_hotstart(	handle, g,
-								lb,ub,lbA,ubA,
-								nWSRin,maxCpuTimeIn,
-								&options,
-								nlhs,plhs
-								);
-		}
-
-		return;
-	}
-
-	/* 3) Modify matrices. */
-	if ( ( strcmp( typeString,"m" ) == 0 ) || ( strcmp( typeString,"M" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 6 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 9 ) || ( nrhs > 10 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		g_idx = 3;
-		
-		if ( mxIsEmpty(prhs[2]) == 1 )
-		{
-			H_idx = -1;
-			nV = (uint_t)mxGetM( prhs[ g_idx ] ); /* if Hessian is empty, row number of gradient vector */
-		}
-		else
-		{
-			H_idx = 2;
-			nV = (uint_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-		}
-		
-		A_idx = 4;
-		nC = (uint_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-				
-		lb_idx = 5;
-		ub_idx = 6;
-		lbA_idx = 7;
-		ubA_idx = 8;
-
-
-		/* ensure that data is given in double precision */
-		if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[H_idx] ) == 0 ) ) ||
-			 ( mxIsDouble( prhs[g_idx] ) == 0 ) ||
-			 ( mxIsDouble( prhs[A_idx] ) == 0 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in real_t precision!" );
-			return;
-		}
-
-		/* check if supplied data contains 'NaN' or 'Inf' */
-		if (containsNaNorInf(prhs,H_idx, 0) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,A_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-
-		/* Check that dimensions are consistent with existing QP instance */
-		if (nV != (uint_t) globalQP->getNV () || nC != (uint_t) globalQP->getNC ())
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): QP dimensions must be constant during a sequence! Try creating a new QP instance instead." );
-			return;
-		}
-
-		if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Hessian matrix dimension mismatch!" );
-			return;
-		}
-
-		if ( ( mxGetN( prhs[ A_idx ] ) != 0 ) && ( mxGetN( prhs[ A_idx ] ) != nV ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Constraint matrix dimension mismatch!" );
-			return;
-		}
-
-		if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		/* default value for nWSR */
-		nWSRin = 5*(nV+nC);
-
-		/* Check whether options are specified .*/
-		if ( nrhs > 9 )
-			if ( ( !mxIsEmpty( prhs[9] ) ) && ( mxIsStruct( prhs[9] ) ) )
-				setupOptions( &options,prhs[9],nWSRin,maxCpuTimeIn );
-
-		globalQP->deleteQPMatrices( );
-
-		/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-		if ( H_idx >= 0 )
-			setupHessianMatrix(	prhs[H_idx],nV, &(globalQP->H),&(globalQP->Hir),&(globalQP->Hjc),&(globalQP->Hv) );
-
-		/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-		if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-			setupConstraintMatrix( prhs[A_idx],nV,nC, &(globalQP->A),&(globalQP->Air),&(globalQP->Ajc),&(globalQP->Av) );
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC );
-
-		/* Call qpOASES */
-		SQProblem_hotstart(	handle, globalQP->H,g,globalQP->A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							&options,
-							nlhs,plhs
-							);
-
-		return;
-	}
-
-	/* 4) Solve current equality constrained QP. */
-	if ( ( strcmp( typeString,"e" ) == 0 ) || ( strcmp( typeString,"E" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 4 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 7 ) || ( nrhs > 8 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		int_t nRHS = (int_t)mxGetN(prhs[2]);
-		nV = globalQP->getNV( );
-		nC = globalQP->getNC( );
-		real_t *x_out, *y_out;
-
-		g_idx = 2;
-		lb_idx = 3;
-		ub_idx = 4;
-		lbA_idx = 5;
-		ubA_idx = 6;
-
-		/* check if supplied data contains 'NaN' or 'Inf' */
-		if (containsNaNorInf(prhs,g_idx, 0) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if ( smartDimensionCheck( &g,nV,nRHS, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lb,nV,nRHS, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ub,nV,nRHS, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lbA,nC,nRHS, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,nRHS, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		/* Check whether options are specified .*/
-		if ( ( nrhs == 8 ) && ( !mxIsEmpty( prhs[7] ) ) && ( mxIsStruct( prhs[7] ) ) )
-		{
-			nWSRin = 5*(nV+nC);
-			setupOptions( &options,prhs[7],nWSRin,maxCpuTimeIn );
-			globalQP->sqp->setOptions( options );
-		}
-
-		/* Create output vectors and assign pointers to them. */
-		plhs[0] = mxCreateDoubleMatrix( nV, nRHS, mxREAL );
-		x_out = mxGetPr(plhs[0]);
-		if (nlhs >= 2)
-		{
-			plhs[1] = mxCreateDoubleMatrix( nV+nC, nRHS, mxREAL );
-			y_out = mxGetPr(plhs[1]);
-
-			if (nlhs >= 3)
-			{
-				plhs[2] = mxCreateDoubleMatrix( nV, nRHS, mxREAL );
-				real_t* workingSetB = mxGetPr(plhs[2]);
-				globalQP->sqp->getWorkingSetBounds(workingSetB);
-
-				if ( nlhs >= 4 )
-				{
-					plhs[3] = mxCreateDoubleMatrix( nC, nRHS, mxREAL );
-					real_t* workingSetC = mxGetPr(plhs[3]);
-					globalQP->sqp->getWorkingSetConstraints(workingSetC);
-				}
-			}
-		}
-		else
-			y_out = new real_t[nV+nC];
-
-		/* Solve equality constrained QP */
-		returnValue returnvalue = globalQP->sqp->solveCurrentEQP( nRHS,g,lb,ub,lbA,ubA, x_out,y_out );
-
-		if (nlhs < 2)
-			delete[] y_out;
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-		{
-			char msg[MAX_STRING_LENGTH];
-			snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Couldn't solve current EQP (code %d)!", returnvalue);
-			myMexErrMsgTxt(msg);
-			return;
-		}
-
-		return;
-	}
-
-	/* 5) Cleanup. */
-	if ( ( strcmp( typeString,"c" ) == 0 ) || ( strcmp( typeString,"C" ) == 0 ) )
-	{		
-		/* consistency checks */
-		if ( nlhs != 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( nrhs != 2 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* Cleanup SQProblem instance. */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		deleteQPInstance( handle );
-		
-		return;
-	}
-
-}
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.m b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.m
deleted file mode 100644
index b02b7c0..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.m
+++ /dev/null
@@ -1,111 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%qpOASES_sequence is intended to solve a sequence of quadratic
-%programming (QP) problems of the following form:
-%
-%                min   1/2*x'Hx + x'g
-%                s.t.  lb  <=  x <= ub
-%                      lbA <= Ax <= ubA  {optional}
-%
-%I) Call
-%
-%    [QP,x,fval,exitflag,iter,lambda,auxOutput] = ...
-%               qpOASES_sequence( 'i',H,g,A,lb,ub,lbA,ubA{,options{,auxInput}} )
-%or 
-%    [QP,x,fval,exitflag,iter,lambda,auxOutput] = ...
-%               qpOASES_sequence( 'i',H,g,lb,ub{,options{,auxInput}} )
-%
-%for initialising and solving the first above-mentioned QP of the sequence
-%starting from an initial guess x0. H must be a symmetric (possibly indefinite) 
-%matrix and all vectors g, lb, ub, lbA, ubA have to be given as column vectors. 
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used. Optionally, further auxiliary inputs may be generated 
-%using qpOASES_auxInput command and passed to the solver.
-%Both matrices H or A may be passed in sparse matrix format.
-%
-%II) Call
-%
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                      qpOASES_sequence( 'h',QP,g,lb,ub,lbA,ubA{,options} )
-%or
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                      qpOASES_sequence( 'h',QP,g,lb,ub{,options} )
-%
-%for hotstarting from the previous QP solution to the one of the next QP
-%given by the vectors g, lb, ub, lbA, ubA. Options can be generated using the 
-%qpOASES_options command, otherwise default values are used.
-%
-%III) Call
-%
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                     qpOASES_sequence( 'm',QP,H,g,A,lb,ub,lbA,ubA{,options} )
-%
-%for hotstarting from the previous QP solution to the one of the next QP
-%given by the matrices H, A and the vectors g, lb, ub, lbA, ubA. The previous
-%active set serves as a starting guess. If the new projected Hessian matrix
-%turns out to be not positive definite, qpOASES recedes to a safe initial active
-%set guess automatically. This can result in a high number of iterations iter.
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used.
-%
-%IV) Call
-%
-%     [x,lambda,workingSetB,workingSetC] = ...
-%                     qpOASES_sequence( 'e',QP,g,lb,ub,lbA,ubA{,options} )
-%
-%for solving the equality constrained QP with constraints determined by the
-%current active set. All inequalities and bounds which were not active in the
-%previous solution might be violated. This command does not alter the internal
-%state of qpOASES. Instead of calling this command multiple times, it is
-%possible to supply several columns simultaneously in g, lb, ub, lbA, and ubA.
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used.
-%
-%V) Having solved the last QP of your sequence, call
-%
-%     qpOASES_sequence( 'c',QP )
-%
-%in order to cleanup the internal memory.
-%
-%
-%Optional outputs (only x is mandatory):
-%    x            -  Optimal primal solution vector (if exitflag==0).
-%    fval         -  Optimal objective function value (if exitflag==0).
-%    exitflag     -   0: QP solved,
-%                     1: QP could not be solved within given number of iterations,
-%                    -1: QP could not be solved due to an internal error,
-%                    -2: QP is infeasible (and thus could not be solved),
-%                    -3: QP is unbounded (and thus could not be solved).
-%    iter         -  Number of active set iterations actually performed.
-%    lambda       -  Optimal dual solution vector (if exitflag==0).
-%    auxOutput    -  Struct containing auxiliary outputs as described below.
-%
-%The auxOutput struct contains the following entries:
-%    workingSetB  -  Working set of bounds at point x.
-%    workingSetC  -  Working set of constraints at point x.
-%                    The working set is a subset of the active set (indices
-%                    of bounds/constraints that hold with equality) yielding
-%                    a set linearly independent of bounds/constraints.
-%                    The working sets are encoded as follows:
-%                     1: bound/constraint at its upper bound
-%                     0: bound/constraint not at any bound
-%                    -1: bound/constraint at its lower bound
-%    cpuTime      -  Internally measured CPU time for solving QP problem.
-%
-%See also QPOASES_OPTIONS, QPOASES_AUXINPUT, QPOASES
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/clean b/extlibs/qpOASES-3.2.0/interfaces/octave/clean
deleted file mode 100644
index 2957397..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/clean
+++ /dev/null
@@ -1,3 +0,0 @@
-rm *.*~
-rm *.o
-rm qpOASES qpOASES_sequence
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/clean.sh b/extlibs/qpOASES-3.2.0/interfaces/octave/clean.sh
deleted file mode 100644
index 2957397..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/clean.sh
+++ /dev/null
@@ -1,3 +0,0 @@
-rm *.*~
-rm *.o
-rm qpOASES qpOASES_sequence
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/example1.mat b/extlibs/qpOASES-3.2.0/interfaces/octave/example1.mat
deleted file mode 100644
index c0bd0d2ed4364ebaf2b16eeb1791b99510164d60..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 790
zcmeZu4DoSvQZUssQ1EpO(M`+DN!3vZ$Vn_o%P-2cQgHY2i?A@$QE)CwO)N=GQOM7;
zQV7W?Rq#(PQBW{ZFtoHXwy-iZQZO<wFjpWIFfe-h@-r|n=m2rWoX5!t2^<VbW(v<5
zE-4(~dTQ)ws4P&$km;uomeA11|BWZ&AagZCObxRuNRJv^j{&kCCPU#FX(<IPn`cT$
zG&V7awlb^%sn&(7E<jezXs9e<Y_x<KXonck4*72aznX0sEPR-wL7MdNXfk}FVrWpn
zbd!n4;KKpAQx*&i4u6?#K)Tf7x=<Vjw#smdTH_BNo;41R3^D<X9(eq5$k5n1bCNQ%
z@Pwl*Pna3xb}%;MF&w1YZ<6wal%ya3=QlDksCqM3;5D4vIj*8W0BATX&~U}|jQ2pQ
z4dE{TfEGw1%||Xh{v33=(L`N<+u*<f_G*s5hvgUwC0GSO8WEwp0Yl@HqDhZ{Iwd7$
zNJcd5`Tw8MMu6oVNRu%h+n#t$hG?>A%wc4c5GZW8!2gYzq2v=QA4sbvTq}xwN{M9(
rdcH+H=e>2)6PUUhjxboKF`MIYAV|YGPpF2pgrpzeL4oIZl~o4-!Xx*U

diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/example1a.mat b/extlibs/qpOASES-3.2.0/interfaces/octave/example1a.mat
deleted file mode 100644
index 48c784fcb7c53eedc3b3124e3577f8d0822e1cb2..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 896
zcmeZu4DoSvQZUssQ1EpO(M`+DN!3vZ$Vn_o%P-2cQgHY2i?A@$QE)CwO)N=GQOM7;
zQV7W?Rq#(PQBW{ZFtoHXwzM)dRWLFzFjpWIFfe-h@-r|n=m2rWoX5!t2^<VbW(v<5
zE-4(~dTQ)ws4P&$km;uomeA11|BWZ&AagZCObxRuNRJv^j{&kCCPU#FX(<IPn`cT$
zG&V7awlb^%sn&(7E<jezXs9e<Y_x<KXonck4*72aznX0sEPR-wL7MdNXfk}FVrWpn
zbd!n4;KKpAQx*&i4u6?#K)Tf7x=<Vjw#smdTH_BNo;41R3^D<X9(eq5$k5n1bCNQ%
z@Pwl*Pna3xb}%;MF&w1YZ<6wal%ya3=QlDksCqM3;5D4vIj*8W0BATX&~U}|jQ2pQ
z4dE{TfEGw1%||Xh{v33=(L`N<+u*<f_G*s5hvgUwC0GSO8WEwp0Yl@HqDhZ{Iwd7$
zNJcd5`Tw8MMu6oVNRu%h+n#t$hG?>A%wc4c5GZW8!2gYzq2v=QA4sbvTq}xwN{M9(
zdcH+H=e>2)6PUUhjxboKF`MIYAV|YGPpF2pgrpzeL4oIZl~o6%$pCIk2ePk#sWRk@
zvYq}`8INM7jZDluH5=M5@Ec?>oIk~G0n(=h*N5UdV9K1r)@ga{`O<04M`r+2CliB_
HDN`x{YE&BX

diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/example1b.mat b/extlibs/qpOASES-3.2.0/interfaces/octave/example1b.mat
deleted file mode 100644
index b45b4f74c6a935c350dac6de0673396f20801338..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 549
zcmeZu4DoSvQZUssQ1EpO(M`+DN!3vZ$Vn_o%P-2cQgHY2i?A@$QE)CwO)N=GQOM7;
zQV7W?Rq#(PQBW{ZFtoHXwy-iXRWLFzFjpWIFfe-h@-r|n=m2rWoX5!t2^<VbW(v<5
zE-4(~dTQ)ws4P&$km;uomeA11|BWZ&AagZCObxRuNRKXDPXV$XMnh!@W1}U^KwV-$
zUGm=qel^=NSoknUgEZ;k(Pa2U#n7OD=_V78!G{BKrz{v49R4!ffOM(Dbs1n-WjIBx
z@rMu38V5%PnE*x)ka9Kb$`2WGJI7TN2nbI&%KC(vL2*6fJ&<ZcxatpRhKn>Gx%BvR
z(CJ1KbpdXJ0|(fvIsP7&V<?nh6#!{O1i%IijZcauJp$^Kl$aqI(Xi+Le?}VtmUkdc
f#&~Rd;x!qf$)YibkxfFNu;Bv#H)e*CPpo_Z46>$n

diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/make.m b/extlibs/qpOASES-3.2.0/interfaces/octave/make.m
deleted file mode 100644
index 2040563..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/make.m
+++ /dev/null
@@ -1,238 +0,0 @@
-function [] = make( varargin )
-%MAKE Compiles the octave interface of qpOASES.
-%
-%Type  make            to compile all interfaces that 
-%                      have been modified,
-%type  make clean      to delete all compiled interfaces,
-%type  make clean all  to first delete and then compile 
-%                      all interfaces,
-%type  make 'name'     to compile only the interface with
-%                      the given name (if it has been modified),
-%type  make 'opt'      to compile all interfaces using the 
-%                      given compiler options.
-%
-%Copyright (C) 2013-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-%%
-%%	Filename:  interfaces/octave/make.m
-%%	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-       
-    %% consistency check
-    if ( exist( [pwd, '/make.m'],'file' ) == 0 )
-        error( ['ERROR (',mfilename '.m): Run this make script directly within the directory', ...
-                '<qpOASES-inst-dir>/interfaces/octave, please.'] );
-    end
-
-
-    if ( nargin > 2 )
-        error( ['ERROR (',mfilename '.m): At most two make arguments supported!'] );
-    else
-        [ doClean,fcnNames,userFlags ] = analyseMakeArguments( nargin,varargin );
-    end
-
-    
-    %% define compiler settings
-    QPOASESPATH = '../../';
-    
-    DEBUGFLAGS = ' ';
-    %DEBUGFLAGS = ' -g CXXDEBUGFLAGS=''$CXXDEBUGFLAGS -Wall -pedantic -Wshadow'' ';
-
-    IFLAGS = [ '-I. -I',QPOASESPATH,'include',' -I',QPOASESPATH,'src',' ' ];
-    CPPFLAGS = [ IFLAGS, DEBUGFLAGS, '-D__cpluplus -D__SINGLE_OBJECT__',' ' ];  %%removed: -largeArrayDims
-    defaultFlags = '-D__NO_COPYRIGHT__ '; %% -D__SUPPRESSANYOUTPUT__                         %%removed: -O
-
-    if ( ispc == 0 )
-        CPPFLAGS  = [ CPPFLAGS, '-DLINUX ',' ' ]; 
-    else
-        CPPFLAGS  = [ CPPFLAGS, '-DWIN32 ',' ' ];
-    end
-
-    if ( isempty(userFlags) > 0 )
-        CPPFLAGS = [ CPPFLAGS, defaultFlags,' ' ];
-    else
-        CPPFLAGS = [ CPPFLAGS, userFlags,' ' ];
-    end
-
-    mexExt = mexext();
-    
-    
-    %% ensure copyright notice is displayed
-    if ~isempty( strfind( CPPFLAGS,'-D__NO_COPYRIGHT__' ) )
-        printCopyrightNotice( );
-    end
-    
-    
-    %% clean if desired
-    if ( doClean > 0 )
-        
-        eval( 'delete *.o;' );
-        eval( ['delete *.',mexExt,'*;'] );
-        disp( [ 'INFO (',mfilename '.m): Cleaned all compiled files.'] );
-        pause( 0.2 );
-        
-    end
-    
-    
-    if ( ~isempty(userFlags) )
-        disp( [ 'INFO (',mfilename '.m): Compiling all files with user-defined compiler flags (''',userFlags,''')...'] );
-    end
-    
-
-    %% call mex compiler
-    for ii=1:length(fcnNames)
-        
-        cmd = [ 'mkoctfile --mex --output ', fcnNames{ii}, '.', mexext(), ' ', CPPFLAGS, [fcnNames{ii},'.cpp'] ];
-        
-        if ( exist( [fcnNames{ii},'.',mexExt],'file' ) == 0 )
-            
-            eval( cmd );
-            disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            
-        else
-            
-            % check modification time of source/Make files and compiled mex file
-            cppFile = dir( [pwd,'/',fcnNames{ii},'.cpp'] );
-            cppFileTimestamp = getTimestamp( cppFile.date ); 
-            
-            utilsFile = dir( [pwd,'/qpOASES_octave_utils.cpp'] );
-            utilsFileTimestamp = getTimestamp( utilsFile.date );
-            
-            makeFile = dir( [pwd,'/make.m'] );
-            makeFileTimestamp = getTimestamp( makeFile.date );
-            
-            mexFile = dir( [pwd,'/',fcnNames{ii},'.',mexExt] );
-            if ( isempty(mexFile) == 0 )
-                mexFileTimestamp = getTimestamp( mexFile.date );
-            else
-                mexFileTimestamp = 0;
-            end
-            
-            if ( ( cppFileTimestamp   >= mexFileTimestamp ) || ...
-                 ( utilsFileTimestamp >= mexFileTimestamp ) || ...
-                 ( makeFileTimestamp  >= mexFileTimestamp ) )
-                eval( cmd );
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            else            
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' already exists.'] );
-            end
-            
-        end
-        
-    end
-
-    %% add qpOASES directory to path
-    path( path,pwd );
-
-end
-
-
-function [ doClean,fcnNames,userIFlags ] = analyseMakeArguments( nArgs,args )
-
-    doClean = 0;
-    fcnNames = [];
-    userIFlags = [];
-
-    switch ( nArgs )
-        
-        case 1
-            if ( strcmp( args{1},'all' ) > 0 )
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            elseif ( strcmp( args{1},'qpOASES' ) > 0 )
-                fcnNames = { 'qpOASES' };
-            elseif ( strcmp( args{1},'qpOASES_sequence' ) > 0 )
-                fcnNames = { 'qpOASES_sequence' };
-            elseif ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            elseif ( strcmp( args{1}(1),'-' ) > 0 )
-                % make clean all with user-specified compiler flags
-                userIFlags = args{1};
-                doClean = 1;
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid first argument (''',args{1},''')!'] );
-            end
-
-        case 2
-            if ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            else
-                error( ['ERROR (',mfilename '.m): First argument must be ''clean'' if two arguments are provided!'] );
-            end
-            
-            if ( strcmp( args{2},'all' ) > 0 )
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            elseif ( strcmp( args{2},'qpOASES' ) > 0 )
-                fcnNames = { 'qpOASES' };
-            elseif ( strcmp( args{2},'qpOASES_sequence' ) > 0 )
-                fcnNames = { 'qpOASES_sequence' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid second argument (''',args{2},''')!'] );
-            end
-            
-        otherwise
-            fcnNames = { 'qpOASES','qpOASES_sequence' };
-            
-    end
-    
-end
-
-
-function [ timestamp ] = getTimestamp( dateString )
-
-    try 
-        timestamp = datenum( dateString );
-    catch
-        timestamp = Inf;
-    end
-
-end
-
-
-function [ ] = printCopyrightNotice( )
-
-    disp( ' ' );
-    disp( 'qpOASES -- An Implementation of the Online Active Set Strategy.' );
-    disp( 'Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,' );
-    disp( 'Christian Kirches et al. All rights reserved.' );
-    disp( ' ' );
-    disp( 'qpOASES is distributed under the terms of the' );
-    disp( 'GNU Lesser General Public License 2.1 in the hope that it will be' );
-    disp( 'useful, but WITHOUT ANY WARRANTY; without even the implied warranty' );
-    disp( 'of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.' );
-    disp( 'See the GNU Lesser General Public License for more details.' );
-    disp( ' ' );
-    disp( ' ' );
-
-end
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.cpp b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.cpp
deleted file mode 100644
index 3e51965..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.cpp
+++ /dev/null
@@ -1,584 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/octave/qpOASES.cpp
- *	\author Hans Joachim Ferreau, Alexander Buchner, Andreas Potschka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Matlab(R) that enables to call qpOASES as a MEX function.
- *
- */
-
-
-#include <qpOASES.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-#include "qpOASES_octave_utils.hpp"
-
-/** initialise handle counter of QPInstance class */
-int_t QPInstance::s_nexthandle = 1;
-
-/** global pointer to QP objects */
-static std::vector<QPInstance *> g_instances;
-
-#include "qpOASES_octave_utils.cpp"
-
-
-/*
- *	Q P r o b l e m _ q p O A S E S
- */
-int_t QProblem_qpOASES(	int_t nV, int_t nC, HessianType hessianType, int_t nP,
-						SymmetricMatrix* H, double* g, Matrix* A,
-						double* lb, double* ub,
-						double* lbA, double* ubA,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds, const double* const guessedConstraints,
-						const double* const _R
-						)
-{
-	int_t nWSRout;
-	real_t maxCpuTimeOut;
-	
-	/* 1) Setup initial QP. */
-	QProblem QP( nV,nC,hessianType );
-	QP.setOptions( *options );
-
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-
-	Bounds bounds(nV);
-	Constraints constraints(nC);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	if (guessedConstraints != 0) {
-		for (int_t i = 0; i < nC; i++) {
-			if ( isEqual(guessedConstraints[i],-1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_LOWER);
-			} else if ( isEqual(guessedConstraints[i],1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_UPPER);
-			} else if ( isEqual(guessedConstraints[i],0.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of constraints!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	nWSRout = nWSRin;
-	maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	returnvalue = QP.init(	H,g,A,lb,ub,lbA,ubA,
-							nWSRout,&maxCpuTimeOut,
-							x0,0,
-							(guessedBounds != 0) ? &bounds : 0, (guessedConstraints != 0) ? &constraints : 0,
-							_R
-							);
-
-	/* 3) Solve remaining QPs and assign lhs arguments. */
-	/*    Set up pointers to the current QP vectors */
-	real_t* g_current   = g;
-	real_t* lb_current  = lb;
-	real_t* ub_current  = ub;
-	real_t* lbA_current = lbA;
-	real_t* ubA_current = ubA;
-
-	/* Loop through QP sequence. */
-	for ( int_t k=0; k<nP; ++k )
-	{
-		if ( k > 0 )
-		{
-			/* update pointers to the current QP vectors */
-			g_current = &(g[k*nV]);
-			if ( lb != 0 )
-				lb_current = &(lb[k*nV]);
-			if ( ub != 0 )
-				ub_current = &(ub[k*nV]);
-			if ( lbA != 0 )
-				lbA_current = &(lbA[k*nC]);
-			if ( ubA != 0 )
-				ubA_current = &(ubA[k*nC]);
-
-			nWSRout = nWSRin;
-			maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-			returnvalue = QP.hotstart( g_current,lb_current,ub_current,lbA_current,ubA_current, nWSRout,&maxCpuTimeOut );
-		}
-
-		/* write results into output vectors */
-		obtainOutputs(	k,&QP,returnvalue,nWSRout,maxCpuTimeOut,
-						nOutputs,plhs,nV,nC );
-	}
-
-	//QP.writeQpDataIntoMatFile( "qpDataMat0.mat" );
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m B _ q p O A S E S
- */
-int_t QProblemB_qpOASES(	int_t nV, HessianType hessianType, int_t nP,
-							SymmetricMatrix *H, double* g,
-							double* lb, double* ub,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							const double* const x0, Options* options,
-							int_t nOutputs, mxArray* plhs[],
-							const double* const guessedBounds,
-							const double* const _R
-							)
-{
-	int_t nWSRout;
-	real_t maxCpuTimeOut;
-
-	/* 1) Setup initial QP. */
-	QProblemB QP( nV,hessianType );
-	QP.setOptions( *options );
-
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-
-	Bounds bounds(nV);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	nWSRout = nWSRin;
-	maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-	
-	returnvalue = QP.init(	H,g,lb,ub,
-							nWSRout,&maxCpuTimeOut,
-							x0,0,
-							(guessedBounds != 0) ? &bounds : 0,
-							_R
-							);
-
-	/* 3) Solve remaining QPs and assign lhs arguments. */
-	/*    Set up pointers to the current QP vectors */
-	real_t* g_current  = g;
-	real_t* lb_current = lb;
-	real_t* ub_current = ub;
-
-	/* Loop through QP sequence. */
-	for ( int_t k=0; k<nP; ++k )
-	{
-		if ( k > 0 )
-		{
-			/* update pointers to the current QP vectors */
-			g_current = &(g[k*nV]);
-			if ( lb != 0 )
-				lb_current = &(lb[k*nV]);
-			if ( ub != 0 )
-				ub_current = &(ub[k*nV]);
-
-            nWSRout = nWSRin;
-			maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-			returnvalue = QP.hotstart( g_current,lb_current,ub_current, nWSRout,&maxCpuTimeOut );
-		}
-
-		/* write results into output vectors */
-		obtainOutputs(	k,&QP,returnvalue,nWSRout,maxCpuTimeOut,
-						nOutputs,plhs,nV );
-	}
-
-	return 0;
-}
-
-
-
-/*
- *	m e x F u n c t i o n
- */
-void mexFunction( int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[] )
-{
-	/* inputs */
-	SymmetricMatrix *H=0;
-	Matrix *A=0;
-
-	real_t *g=0, *lb=0, *ub=0, *lbA=0, *ubA=0;
-	HessianType hessianType = HST_UNKNOWN;
-	double *x0=0, *R=0, *R_for=0;
-	double *guessedBounds=0, *guessedConstraints=0;
-
-	int H_idx=-1, g_idx=-1, A_idx=-1, lb_idx=-1, ub_idx=-1, lbA_idx=-1, ubA_idx=-1;
-	int options_idx=-1, x0_idx=-1, auxInput_idx=-1;
-
-    /* Setup default options */
-	Options options;
-	options.printLevel = PL_LOW;
-	#ifdef __DEBUG__
-	options.printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	options.printLevel = PL_NONE;
-	#endif
-
-	/* dimensions */
-	uint_t nV=0, nC=0, nP=0;
-	BooleanType isSimplyBoundedQp = BT_FALSE;
-
-	/* sparse matrix indices and values */
-	sparse_int_t *Hir=0, *Hjc=0, *Air=0, *Ajc=0;
-	real_t *Hv=0, *Av=0;
-
-	/* I) CONSISTENCY CHECKS: */
-	/* 1a) Ensure that qpOASES is called with a feasible number of input arguments. */
-	if ( ( nrhs < 4 ) || ( nrhs > 9 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES' for further information." );
-		return;
-	}
-    
-	/* 2) Check for proper number of output arguments. */
-	if ( nlhs > 6 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): At most six output arguments are allowed: \n    [x,fval,exitflag,iter,lambda,auxOutput]!" );
-		return;
-	}
-	if ( nlhs < 1 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): At least one output argument is required: [x,...]!" );
-		return;
-	}
-
-
-	/* II) PREPARE RESPECTIVE QPOASES FUNCTION CALL: */
-	/*     Choose between QProblem and QProblemB object and assign the corresponding
-	 *     indices of the input pointer array in to order to access QP data correctly. */
-	g_idx = 1;
-
-	if ( mxIsEmpty(prhs[0]) == 1 )
-	{
-		H_idx = -1;
-		nV = (int_t)mxGetM( prhs[ g_idx ] ); /* if Hessian is empty, row number of gradient vector */
-	}
-	else
-	{
-		H_idx = 0;
-		nV = (int_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-	}
-	
-	nP = (int_t)mxGetN( prhs[ g_idx ] ); /* number of columns of the gradient matrix (vectors series have to be stored columnwise!) */
-
-	if ( nrhs <= 6 )
-        isSimplyBoundedQp = BT_TRUE;
-	else
-		isSimplyBoundedQp = BT_FALSE;
-
-
-	/* 0) Check whether options are specified .*/
-	if ( isSimplyBoundedQp == BT_TRUE )
-	{
-		if ( ( nrhs >= 5 ) && ( !mxIsEmpty(prhs[4]) ) && ( mxIsStruct(prhs[4]) ) )
-			options_idx = 4;
-	}
-	else
-	{
-		/* Consistency check */
-		if ( ( !mxIsEmpty(prhs[4]) ) && ( mxIsStruct(prhs[4]) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Fifth input argument must not be a struct when solving QP with general constraints!\nType 'help qpOASES' for further information." );
-			return;
-		}
-
-		if ( ( nrhs >= 8 ) && ( !mxIsEmpty(prhs[7]) ) && ( mxIsStruct(prhs[7]) ) )
-			options_idx = 7;
-	}
-
-	// Is the third argument constraint Matrix A?
-	int_t numberOfColumns = (int_t)mxGetN(prhs[2]);
-
-	/* 1) Simply bounded QP. */
-	if ( ( isSimplyBoundedQp == BT_TRUE ) ||
-		 ( ( numberOfColumns == 1 ) && ( nV != 1 ) ) )
-	{
-		lb_idx   = 2;
-		ub_idx   = 3;
-
-		if ( ( nrhs >= 6 ) && ( !mxIsEmpty(prhs[5]) ) )
-		{ 
-			/* auxInput specified */
-			if ( mxIsStruct(prhs[5]) )
-			{
-				auxInput_idx = 5;
-				x0_idx = -1;
-			}
-			else
-			{
-				auxInput_idx = -1;
-				x0_idx = 5;
-			}
-		}
-		else
-		{
-			auxInput_idx = -1;
-			x0_idx = -1;
-		}
-	}
-	else
-	{
-		A_idx = 2;
-
-		/* If constraint matrix is empty, use a QProblemB object! */
-		if ( mxIsEmpty( prhs[ A_idx ] ) )
-		{
-			lb_idx   = 3;
-			ub_idx   = 4;
-
-			nC = 0;
-		}
-		else
-		{
-			lb_idx   = 3;
-			ub_idx   = 4;
-			lbA_idx  = 5;
-			ubA_idx  = 6;
-
-			nC = (int_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-		}
-
-		if ( ( nrhs >= 9 ) && ( !mxIsEmpty(prhs[8]) ) )
-		{ 
-			/* auxInput specified */
-			if ( mxIsStruct(prhs[8]) )
-			{
-				auxInput_idx = 8;
-				x0_idx = -1;
-			}
-			else
-			{
-				auxInput_idx = -1;
-				x0_idx = 8;
-			}
-		}
-		else
-		{
-			auxInput_idx = -1;
-			x0_idx = -1;
-		}
-	}
-
-
-	/* ensure that data is given in real_t precision */
-	if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[ H_idx ] ) == 0 ) ) ||
-		 ( mxIsDouble( prhs[ g_idx ] ) == 0 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-		return;
-	}
-
-	/* check if supplied data contains 'NaN' or 'Inf' */
-	if (containsNaNorInf( prhs,H_idx, 0 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-		return;
-
-	/* Check inputs dimensions and assign pointers to inputs. */
-	if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-	{
-		char msg[MAX_STRING_LENGTH]; 
-		snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Hessian matrix dimension mismatch (%ld != %d)!", 
-				(long int)mxGetN(prhs[H_idx]), (int)nV);
-		myMexErrMsgTxt(msg);
-		return;
-	}
-
-	if ( nC > 0 )
-	{
-		/* ensure that data is given in real_t precision */
-		if ( mxIsDouble( prhs[ A_idx ] ) == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in real_t precision!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		if ( mxGetN( prhs[ A_idx ] ) != nV )
-		{
-			char msg[MAX_STRING_LENGTH]; 
-			snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Constraint matrix input dimension mismatch (%ld != %d)!", 
-					(long int)mxGetN(prhs[A_idx]), (int)nV);
-			myMexErrMsgTxt(msg);
-			return;
-		}
-
-		if (containsNaNorInf(prhs,A_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf(prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf(prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-	}
-
-	/* check dimensions and copy auxInputs */
-	if ( smartDimensionCheck( &g,nV,nP, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &lb,nV,nP, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &ub,nV,nP, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &x0,nV,1, BT_TRUE,prhs,x0_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( nC > 0 )
-	{
-		if ( smartDimensionCheck( &lbA,nC,nP, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,nP, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-	}
-
-	if ( auxInput_idx >= 0 )
-		setupAuxiliaryInputs( prhs[auxInput_idx],nV,nC, &hessianType,&x0,&guessedBounds,&guessedConstraints,&R_for );
-
-	/* convert Cholesky factor to C storage format */
-	if ( R_for != 0 )
-	{
-		R = new real_t[nV*nV];
-		convertFortranToC( R_for, nV,nV, R );
-	}
-	
-	/* III) ACTUALLY PERFORM QPOASES FUNCTION CALL: */
-	int_t nWSRin = 5*(nV+nC);
-	real_t maxCpuTimeIn = -1.0;
-
-	if ( options_idx > 0 )
-		setupOptions( &options,prhs[options_idx],nWSRin,maxCpuTimeIn );
-
-	/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-	if ( H_idx >= 0 )
-		setupHessianMatrix(	prhs[H_idx],nV, &H,&Hir,&Hjc,&Hv );
-	
-	/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-	if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-		setupConstraintMatrix( prhs[A_idx],nV,nC, &A,&Air,&Ajc,&Av );
-
-	allocateOutputs( nlhs,plhs,nV,nC,nP );
-
-	if ( nC == 0 )
-	{
-		/* Call qpOASES (using QProblemB class). */
-		QProblemB_qpOASES(	nV,hessianType, nP,
-							H,g,
-							lb,ub,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,R
-							);
-		
-        if (R != 0) delete R;
-		if (H != 0) delete H;
-		if (Hv != 0) delete[] Hv;
-		if (Hjc != 0) delete[] Hjc;
-		if (Hir != 0) delete[] Hir;
-		return;
-	}
-	else
-	{
-		if ( A == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Internal interface error related to constraint matrix!" );
-			return;
-		}
-
-		/* Call qpOASES (using QProblem class). */
-		QProblem_qpOASES(	nV,nC,hessianType, nP,
-							H,g,A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,guessedConstraints,R
-							);
-		
-		if (R != 0) delete R;
-		if (A != 0) delete A;
-		if (H != 0) delete H;
-		if (Av != 0) delete[] Av;
-		if (Ajc != 0) delete[] Ajc;
-		if (Air != 0) delete[] Air;
-		if (Hv != 0) delete[] Hv;
-		if (Hjc != 0) delete[] Hjc;
-		if (Hir != 0) delete[] Hir;
-		return;
-	}
-}
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.m b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.m
deleted file mode 100644
index 4692b60..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.m
+++ /dev/null
@@ -1,75 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%qpOASES solves (a series) of quadratic programming (QP) problems of the
-%following form:
-%
-%                min   1/2*x'Hx + x'g
-%                s.t.  lb  <=  x <= ub
-%                      lbA <= Ax <= ubA  {optional}
-%
-%Call
-%
-%    [x,fval,exitflag,iter,lambda,auxOutput] = 
-%                     qpOASES( H,g,A,lb,ub,lbA,ubA{,options{,auxInput}} )
-%
-%for solving the above-mentioned QP. H must be a symmetric (but possibly 
-%indefinite) matrix and all vectors g, lb, ub, lbA, ubA have to be given
-%as column vectors. Options can be generated using the qpOASES_options command, 
-%otherwise default values are used. Optionally, further auxiliary inputs
-%may be generated using qpOASES_auxInput command and passed to the solver.
-%Both matrices H or A may be passed in sparse matrix format.
-%
-%Call
-%
-%    [x,fval,exitflag,iter,lambda,auxOutput] =
-%                     qpOASES( H,g,lb,ub{,options{,auxInput}} )
-%
-%for solving the above-mentioned QP without general constraints.
-%
-%
-%Optional outputs (only x is mandatory):
-%    x            -  Optimal primal solution vector (if exitflag==0).
-%    fval         -  Optimal objective function value (if exitflag==0).
-%    exitflag     -   0: QP problem solved,
-%                     1: QP could not be solved within given number of iterations,
-%                    -1: QP could not be solved due to an internal error,
-%                    -2: QP is infeasible (and thus could not be solved),
-%                    -3: QP is unbounded (and thus could not be solved).
-%    iter         -  Number of active set iterations actually performed.
-%    lambda       -  Optimal dual solution vector (if exitflag==0).
-%    auxOutput    -  Struct containing auxiliary outputs as described below.
-%
-%The auxOutput struct contains the following entries:
-%    workingSetB  -  Working set of bounds at point x.
-%    workingSetC  -  Working set of constraints at point x.
-%                    The working set is a subset of the active set (indices
-%                    of bounds/constraints that hold with equality) yielding
-%                    a set linearly independent of bounds/constraints.
-%                    The working sets are encoded as follows:
-%                     1: bound/constraint at its upper bound
-%                     0: bound/constraint not at any bound
-%                    -1: bound/constraint at its lower bound
-%    cpuTime      -  Internally measured CPU time for solving QP problem.
-%
-%
-%If not a single QP but a sequence of QPs with varying vectors is to be solved,
-%the i-th QP is given by the i-th columns of the QP vectors g, lb, ub, lbA, ubA
-%(i.e. they are matrices in this case). Both matrices H and A remain constant.
-%
-%See also QPOASES_OPTIONS, QPOASES_AUXINPUT, QPOASES_SEQUENCE
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_auxInput.m b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_auxInput.m
deleted file mode 100644
index 74c9d93..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_auxInput.m
+++ /dev/null
@@ -1,118 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%Returns a struct containing all possible auxiliary inputs to be passed 
-%to qpOASES.
-%
-%Call
-%    auxInput = qpOASES_auxInput();
-%to obtain a struct with all auxiliary inputs empty.
-%
-%Call
-%    auxInput = qpOASES_auxInput( 'input1',value1,'input2',value2,... )
-%to obtain a struct with 'input1' set to value1 etc. and all remaining
-%auxiliary inputs empty.
-%
-%Call
-%    auxInput = qpOASES_auxInput( oldInputs,'input1',value1,... )
-%to obtain a copy of the options struct oldInputs but with 'input1' set to 
-%value1 etc.
-%
-%
-%qpOASES features the following auxiliary inputs:
-%  hessianType          -  Provide information on Hessian matrix:
-%                          0: Hessian is zero matrix (i.e. LP formulation)
-%                          1: Hessian is identity matrix
-%                          2: Hessian is (strictly) positive definite
-%                          3: Hessian is positive definite on null space 
-%                             of active bounds/constraints
-%                          4: Hessian is positive semi-definite.
-%                          5: Hessian is indefinite
-%                          Leave hessianType empty if Hessian type is unknown.
-%  x0                   -  Initial guess for optimal primal solution.
-%  guessedWorkingSetB   -  Initial guess for working set of bounds at 
-%                          optimal solution (nV elements or empty).
-%  guessedWorkingSetC   -  Initial guess for working set of constraints at 
-%                          optimal solution (nC elements or empty).
-%                          The working sets needs to be encoded as follows:
-%                           1: bound/constraint at its upper bound
-%                           0: bound/constraint not at any bound
-%                          -1: bound/constraint at its lower bound
-%  R                    -  Cholesky factor of Hessian matrix (upper-triangular);
-%                          only used if both guessedWorkingSets are empty
-%                          and option initialStatusBounds is set to 0.
-%
-%
-%See also QPOASES, QPOASES_SEQUENCE, QPOASES_OPTIONS
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
-function [ auxInput ] = qpOASES_auxInput( varargin )
-
-	firstIsStruct = 0;
-
-	if ( nargin == 0 ) 
-		auxInput = qpOASES_emptyAuxInput();
-	else
-		if ( isstruct( varargin{1} ) )
-			if ( mod( nargin,2 ) ~= 1 )
-				error('ERROR (qpOASES_auxInput): Auxiliary inputs must be specified in pairs!');
-			end
-			auxInput = varargin{1};
-			firstIsStruct = 1;
-        else
-            if ( mod( nargin,2 ) ~= 0 )
-				error('ERROR (qpOASES_auxInput): Auxiliary inputs must be specified in pairs!');
-            end
-            auxInput = qpOASES_emptyAuxInput();
-		end
-	end
-
-	% set options to user-defined values  
-	for i=(1+firstIsStruct):2:nargin
-
-		argName  = varargin{i};
-		argValue = varargin{i+1};
-
-        if ( ( isempty( argName ) ) || ( ~ischar( argName ) ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d has to be a non-empty string!',i );
-        end
-			
-        if ( ( ischar(argValue) ) || ( ~isnumeric( argValue ) ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d has to be a numerical constant!',i+1 );
-        end
-
-        if ( ~isfield( auxInput,argName ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d is not a valid auxiliary input!',i );
-        end
-
-		eval( ['auxInput.',argName,' = argValue;'] );
-
-	end
-
-end
-
-
-function [ auxInput ] = qpOASES_emptyAuxInput( )
-
-	% setup auxiliary input struct with all entries empty
-	auxInput = struct(	'hessianType',        [], ...
-                        'x0',                 [], ...
-						'guessedWorkingSetB', [], ...
-                        'guessedWorkingSetC', [], ...
-                        'R',                  []  ...
-                        );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.cpp b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.cpp
deleted file mode 100644
index 2d64025..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.cpp
+++ /dev/null
@@ -1,950 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/octave/qpOASES_octave_utils.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Collects utility functions for Interface to octave that
- *	enables to call qpOASES as a MEX function.
- *
- */
-
-
-
-QPInstance::QPInstance(	uint_t _nV, uint_t _nC, HessianType _hessianType,
-						BooleanType _isSimplyBounded
-						)
-{
-	handle = s_nexthandle++;
-
-	if ( _nC > 0 )
-		isSimplyBounded = BT_FALSE;
-	else
-		isSimplyBounded = _isSimplyBounded;
-	
-	if ( isSimplyBounded == BT_TRUE )
-	{
-		sqp = 0;
-		qpb = new QProblemB( _nV,_hessianType );
-	}
-	else
-	{
-		sqp = new SQProblem( _nV,_nC,_hessianType );
-		qpb = 0;
-	}
-
-	H = 0;
-	A = 0;
-	Hir = 0; 
-	Hjc = 0; 
-	Air = 0; 
-	Ajc = 0;
-	Hv = 0;
-	Av = 0;
-}	
-
-
-QPInstance::~QPInstance( )
-{		
-	deleteQPMatrices();
-
-	if ( sqp != 0 )
-	{
-		delete sqp;
-		sqp = 0;
-	}
-
-	if ( qpb != 0 )
-	{
-		delete qpb;
-		qpb = 0;
-	}
-}
-
-
-returnValue QPInstance::deleteQPMatrices( )
-{
-	if ( H != 0 )
-	{
-		delete H;
-		H = 0;
-	}
-
-	if ( Hv != 0 )
-	{
-		delete[] Hv;
-		Hv = 0;
-	}
-	
-	if ( Hjc != 0 )
-	{
-		delete[] Hjc;
-		Hjc = 0;
-	}
-	
-	if ( Hir != 0 )
-	{
-		delete[] Hir;
-		Hir = 0;
-	}
-	
-	if ( A != 0 )
-	{
-		delete A;
-		A = 0;
-	}
-
-	if ( Av != 0 )
-	{
-		delete[] Av;
-		Av = 0;
-	}
-	
-	if ( Ajc != 0 )
-	{
-		delete[] Ajc;
-		Ajc = 0;
-	}
-	
-	if ( Air != 0 )
-	{
-		delete[] Air;
-		Air = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-int_t QPInstance::getNV() const
-{
-    if ( sqp != 0 )
-        return sqp->getNV();
-    
-    if ( qpb != 0 )
-        return qpb->getNV();
-    
-    return 0;
-}
-
-
-int_t QPInstance::getNC() const
-{
-    if ( sqp != 0 )
-        return sqp->getNC();
-   
-    return 0;
-}
-
-
-
-/*
- *	m x I s S c a l a r
- */
-bool mxIsScalar( const mxArray *pm )
-{
-	if ( ( mxGetM(pm) == 1 ) && ( mxGetN(pm) == 1 ) )
-		return true;
-	else
-		return false;
-}
-
-
-
-/*
- *	a l l o c a t e Q P r o b l e m I n s t a n c e
- */
-int_t allocateQPInstance(	int_t nV, int_t nC, HessianType hessianType,
-							BooleanType isSimplyBounded, const Options* options
-							)
-{
-	QPInstance* inst = new QPInstance( nV,nC,hessianType, isSimplyBounded );
-
-	if ( ( inst->sqp != 0 ) && ( options != 0 ) )
-		inst->sqp->setOptions( *options );
-	
-	if ( ( inst->qpb != 0 ) && ( options != 0 ) )
-		inst->qpb->setOptions( *options );
-
-	g_instances.push_back(inst);
-	return inst->handle;
-}
-
-
-/*
- *  g e t Q P r o b l e m I n s t a n c e
- */
-QPInstance* getQPInstance( int_t handle )
-{
-	uint_t ii;
-	// TODO: this may become slow ...
-	for (ii = 0; ii < g_instances.size (); ++ii)
-		if (g_instances[ii]->handle == handle)
-			return g_instances[ii];
-	return 0;
-}
-
-
-/*
- *	d e l e t e Q P r o b l e m I n s t a n c e
- */
-void deleteQPInstance( int_t handle )
-{
-	QPInstance *instance = getQPInstance (handle);
-	if (instance != 0) {
-		for (std::vector<QPInstance*>::iterator itor = g_instances.begin ();
-		     itor != g_instances.end (); ++itor)
-		     if ((*itor)->handle == handle) {
-				g_instances.erase (itor);
-				break;
-			}
-		delete instance;
-	}
-}
-
-
-
-/*
- *	s m a r t D i m e n s i o n C h e c k
- */
-returnValue smartDimensionCheck(	real_t** input, uint_t m, uint_t n, BooleanType emptyAllowed,
-									const mxArray* prhs[], int_t idx
-									)
-{
-	/* If index is negative, the input does not exist. */
-	if ( idx < 0 )
-	{
-		*input = 0;
-		return SUCCESSFUL_RETURN;
-	}
-
-	/* Otherwise the input has been passed by the user. */
-	if ( mxIsEmpty( prhs[ idx ] ) )
-	{
-		/* input is empty */
-		if ( ( emptyAllowed == BT_TRUE ) || ( idx == 0 ) ) /* idx==0 used for auxInput */
-		{
-			*input = 0;
-			return SUCCESSFUL_RETURN;
-		}
-		else
-		{
-			char msg[MAX_STRING_LENGTH];
-			if ( idx > 0 )
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Empty argument %d not allowed!", idx+1);
-			myMexErrMsgTxt( msg );
-			return RET_INVALID_ARGUMENTS;
-		}
-	}
-	else
-	{
-		/* input is non-empty */
-        if ( mxIsSparse( prhs[ idx ] ) == 0 )
-        {
-            if ( ( mxGetM( prhs[ idx ] ) == m ) && ( mxGetN( prhs[ idx ] ) == n ) )
-            {
-                *input = (real_t*) mxGetPr( prhs[ idx ] );
-                return SUCCESSFUL_RETURN;
-            }
-            else
-            {
-                char msg[MAX_STRING_LENGTH];
-				if ( idx > 0 )
-					snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Input dimension mismatch for argument %d ([%ld,%ld] ~= [%d,%d]).",
-							 idx+1, (long int)mxGetM(prhs[idx]), (long int)mxGetN(prhs[idx]), (int)m,(int)n);
-				else /* idx==0 used for auxInput */
-					snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Input dimension mismatch for some auxInput entry ([%ld,%ld] ~= [%d,%d]).",
-							 (long int)mxGetM(prhs[idx]), (long int)mxGetN(prhs[idx]), (int)m,(int)n);
-                myMexErrMsgTxt( msg );
-                return RET_INVALID_ARGUMENTS;
-            }
-        }
-        else
-        {
-            char msg[MAX_STRING_LENGTH];
-			if ( idx > 0 )
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Vector argument %d must not be in sparse format!", idx+1);
-			else /* idx==0 used for auxInput */
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): auxInput entries must not be in sparse format!" );
-			myMexErrMsgTxt( msg );
-			return RET_INVALID_ARGUMENTS;
-        }
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	c o n t a i n s N a N
- */
-BooleanType containsNaN( const real_t* const data, uint_t dim )
-{
-	uint_t i;
-
-	if ( data == 0 )
-		return BT_FALSE;
-
-	for ( i = 0; i < dim; ++i )
-		if ( mxIsNaN(data[i]) == 1 )
-			return BT_TRUE;
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n t a i n s I n f
- */
-BooleanType containsInf( const real_t* const data, uint_t dim )
-{
-	uint_t i;
-
-	if ( data == 0 )
-		return BT_FALSE;
-
-	for ( i = 0; i < dim; ++i )
-		if ( mxIsInf(data[i]) == 1 )
-			return BT_TRUE;
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n t a i n s N a N o r I n f
- */
-BooleanType containsNaNorInf(	const mxArray* prhs[], int_t rhs_index,
-								bool mayContainInf
-								)
-{
-	uint_t dim;
-	char msg[MAX_STRING_LENGTH];
-
-	if ( rhs_index < 0 )
-		return BT_FALSE;
-
-	/* overwrite dim for sparse matrices */
-	if (mxIsSparse(prhs[rhs_index]) == 1)
-		dim = (uint_t)mxGetNzmax(prhs[rhs_index]);
-	else
-		dim = (uint_t)(mxGetM(prhs[rhs_index]) * mxGetN(prhs[rhs_index]));
-
-	if (containsNaN((real_t*) mxGetPr(prhs[rhs_index]), dim) == BT_TRUE) {
-		snprintf(msg, MAX_STRING_LENGTH,
-				"ERROR (qpOASES): Argument %d contains 'NaN' !", rhs_index + 1);
-		myMexErrMsgTxt(msg);
-		return BT_TRUE;
-	}
-
-	if (mayContainInf == 0) {
-		if (containsInf((real_t*) mxGetPr(prhs[rhs_index]), dim) == BT_TRUE) {
-			snprintf(msg, MAX_STRING_LENGTH,
-					"ERROR (qpOASES): Argument %d contains 'Inf' !",
-					rhs_index + 1);
-			myMexErrMsgTxt(msg);
-			return BT_TRUE;
-		}
-	}
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n v e r t F o r t r a n T o C
- */
-returnValue convertFortranToC( const real_t* const M_for, int_t nV, int_t nC, real_t* const M )
-{
-	int_t i,j;
-
-	if ( ( M_for == 0 ) || ( M == 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	if ( ( nV < 0 ) || ( nC < 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	for ( i=0; i<nC; ++i )
-		for ( j=0; j<nV; ++j )
-			M[i*nV + j] = M_for[j*nC + i];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	h a s O p t i o n s V a l u e
- */
-BooleanType hasOptionsValue( const mxArray* optionsPtr, const char* const optionString, double** optionValue )
-{
-	mxArray* optionName = mxGetField( optionsPtr,0,optionString );
-
-	if ( optionName == 0 )
-	{
-		char msg[MAX_STRING_LENGTH];
-		snprintf(msg, MAX_STRING_LENGTH, "Option struct does not contain entry '%s', using default value instead!", optionString );
-		mexWarnMsgTxt( msg );
-		return BT_FALSE;
-	}
-
-	if ( ( mxIsEmpty(optionName) == false ) && ( mxIsScalar( optionName ) == true ) )
-	{
-		*optionValue = mxGetPr( optionName );
-		return BT_TRUE;
-	}
-	else
-	{
-		char msg[MAX_STRING_LENGTH];
-		snprintf(msg, MAX_STRING_LENGTH, "Option '%s' is not a scalar, using default value instead!", optionString );
-		mexWarnMsgTxt( msg );
-		return BT_FALSE;
-	}
-}
-
-
-/*
- *	s e t u p O p t i o n s
- */
-returnValue setupOptions( Options* options, const mxArray* optionsPtr, int_t& nWSRin, real_t& maxCpuTime )
-{
-	double* optionValue;
-	int_t optionValueInt;
-
-	/* Check for correct number of option entries;
-	 * may occur, e.g., if user types options.<misspelledName> = <someValue>; */
-	if ( mxGetNumberOfFields(optionsPtr) != 31 )
-		mexWarnMsgTxt( "Options might be set incorrectly as struct has wrong number of entries!\n         Type 'help qpOASES_options' for further information." );
-
-
-	if ( hasOptionsValue( optionsPtr,"maxIter",&optionValue ) == BT_TRUE )
-		if ( *optionValue >= 0.0 )
-			nWSRin = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxCpuTime",&optionValue ) == BT_TRUE )
-		if ( *optionValue >= 0.0 )
-			maxCpuTime = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"printLevel",&optionValue ) == BT_TRUE )
-	{
-        #ifdef __SUPPRESSANYOUTPUT__
-        options->printLevel = PL_NONE;
-        #else
-		optionValueInt = (int_t)*optionValue;
-		options->printLevel = (REFER_NAMESPACE_QPOASES PrintLevel)optionValueInt;
-        if ( options->printLevel < PL_DEBUG_ITER )
-            options->printLevel = PL_DEBUG_ITER;
-        if ( options->printLevel > PL_HIGH )
-            options->printLevel = PL_HIGH;       
-        #endif
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableRamping",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableRamping = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFarBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFarBounds = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFlippingBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFlippingBounds = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableRegularisation",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableRegularisation = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFullLITests",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFullLITests = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableNZCTests",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableNZCTests = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableDriftCorrection",&optionValue ) == BT_TRUE )
-		options->enableDriftCorrection = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"enableCholeskyRefactorisation",&optionValue ) == BT_TRUE )
-		options->enableCholeskyRefactorisation = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"enableEqualities",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableEqualities = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-
-	if ( hasOptionsValue( optionsPtr,"terminationTolerance",&optionValue ) == BT_TRUE )
-		options->terminationTolerance = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"boundTolerance",&optionValue ) == BT_TRUE )
-		options->boundTolerance = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"boundRelaxation",&optionValue ) == BT_TRUE )
-		options->boundRelaxation = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsNum",&optionValue ) == BT_TRUE )
-		options->epsNum = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsDen",&optionValue ) == BT_TRUE )
-		options->epsDen = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxPrimalJump",&optionValue ) == BT_TRUE )
-		options->maxPrimalJump = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxDualJump",&optionValue ) == BT_TRUE )
-		options->maxDualJump = *optionValue;
-
-
-	if ( hasOptionsValue( optionsPtr,"initialRamping",&optionValue ) == BT_TRUE )
-		options->initialRamping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"finalRamping",&optionValue ) == BT_TRUE )
-		options->finalRamping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"initialFarBounds",&optionValue ) == BT_TRUE )
-		options->initialFarBounds = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"growFarBounds",&optionValue ) == BT_TRUE )
-		options->growFarBounds = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"initialStatusBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		if ( optionValueInt < -1 ) 
-			optionValueInt = -1;
-		if ( optionValueInt > 1 ) 
-			optionValueInt = 1;
-		options->initialStatusBounds = (REFER_NAMESPACE_QPOASES SubjectToStatus)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"epsFlipping",&optionValue ) == BT_TRUE )
-		options->epsFlipping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"numRegularisationSteps",&optionValue ) == BT_TRUE )
-		options->numRegularisationSteps = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsRegularisation",&optionValue ) == BT_TRUE )
-		options->epsRegularisation = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"numRefinementSteps",&optionValue ) == BT_TRUE )
-		options->numRefinementSteps = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsIterRef",&optionValue ) == BT_TRUE )
-		options->epsIterRef = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsLITests",&optionValue ) == BT_TRUE )
-		options->epsLITests = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsNZCTests",&optionValue ) == BT_TRUE )
-		options->epsNZCTests = *optionValue;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p A u x i l i a r y I n p u t s
- */
-returnValue setupAuxiliaryInputs(	const mxArray* auxInput, uint_t nV, uint_t nC,
-									HessianType* hessianType, double** x0, double** guessedBounds, double** guessedConstraints, double** R
-									)
-{
-	mxArray* curField = 0;
-
-	/* hessianType */
-	curField = mxGetField( auxInput,0,"hessianType" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'hessianType'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		if ( mxIsEmpty(curField) == true )
-		{
-			*hessianType = HST_UNKNOWN;
-		}
-		else
-		{
-			if ( mxIsScalar(curField) == false )
-				return RET_INVALID_ARGUMENTS;
-
-			double* hessianTypeTmp = mxGetPr(curField);
-			int_t hessianTypeInt = (int_t)*hessianTypeTmp;
-			if ( hessianTypeInt < 0 ) 
-				hessianTypeInt = 6; /* == HST_UNKNOWN */
-			if ( hessianTypeInt > 5 ) 
-				hessianTypeInt = 6; /* == HST_UNKNOWN */
-			*hessianType = (REFER_NAMESPACE_QPOASES HessianType)hessianTypeInt;
-		}
-	}
-
-	/* x0 */
-	curField = mxGetField( auxInput,0,"x0" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'x0'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*x0 = mxGetPr(curField);
-		if ( smartDimensionCheck( x0,nV,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* guessedWorkingSetB */
-	curField = mxGetField( auxInput,0,"guessedWorkingSetB" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'guessedWorkingSetB'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*guessedBounds = mxGetPr(curField);
-		if ( smartDimensionCheck( guessedBounds,nV,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* guessedWorkingSetC */
-	curField = mxGetField( auxInput,0,"guessedWorkingSetC" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'guessedWorkingSetC'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*guessedConstraints = mxGetPr(curField);
-		if ( smartDimensionCheck( guessedConstraints,nC,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* R */
-	curField = mxGetField( auxInput,0,"R" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'R'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*R = mxGetPr(curField);
-		if ( smartDimensionCheck( R,nV,nV, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	a l l o c a t e O u t p u t s
- */
-returnValue allocateOutputs(	int nlhs, mxArray* plhs[], int_t nV, int_t nC = 0, int_t nP = 1, int_t handle = -1
-								)
-{
-	/* Create output vectors and assign pointers to them. */
-	int_t curIdx = 0;
-
-	/* handle */
-	if ( handle >= 0 )
-		plhs[curIdx++] = mxCreateDoubleMatrix( 1, 1, mxREAL );
-
-	/* x */
-	plhs[curIdx++] = mxCreateDoubleMatrix( nV, nP, mxREAL );
-
-	if ( nlhs > curIdx )
-	{
-		/* fval */
-		plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-		if ( nlhs > curIdx )
-		{
-			/* exitflag */
-			plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-			if ( nlhs > curIdx )
-			{
-				/* iter */
-				plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-				if ( nlhs > curIdx )
-				{
-					/* lambda */
-					plhs[curIdx++] = mxCreateDoubleMatrix( nV+nC, nP, mxREAL );
-
-					if ( nlhs > curIdx )
-					{
-						/* setup auxiliary output struct */
-						mxArray* auxOutput = mxCreateStructMatrix( 1,1,0,0 );
-						int_t curFieldNum;
-						
-						/* working set */
-						curFieldNum = mxAddField( auxOutput,"workingSetB" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( nV, nP, mxREAL ) );
-
-						curFieldNum = mxAddField( auxOutput,"workingSetC" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( nC, nP, mxREAL ) );
-
-						curFieldNum = mxAddField( auxOutput,"cpuTime" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( 1, nP, mxREAL ) );
-
-						plhs[curIdx] = auxOutput;
-					}
-				}
-			}
-		}
-	}
-	
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	o b t a i n O u t p u t s
- */
-returnValue obtainOutputs(	int_t k, QProblemB* qp, returnValue returnvalue, int_t _nWSRout, double _cpuTime,
-							int nlhs, mxArray* plhs[], int_t nV, int_t nC = 0, int_t handle = -1
-							)
-{
-	/* Create output vectors and assign pointers to them. */
-	int_t curIdx = 0;
-
-	/* handle */
-	if ( handle >= 0 )
-		plhs[curIdx++] = mxCreateDoubleScalar( handle );
-
-	/* x */
-	double* x = mxGetPr( plhs[curIdx++] );
-	qp->getPrimalSolution( &(x[k*nV]) );
-
-	if ( nlhs > curIdx )
-	{
-		/* fval */
-		double* obj = mxGetPr( plhs[curIdx++] );
-		obj[k] = qp->getObjVal( );
-
-		if ( nlhs > curIdx )
-		{
-			/* exitflag */
-			double* status = mxGetPr( plhs[curIdx++] );
-			status[k] = (double)getSimpleStatus( returnvalue );
-
-			if ( nlhs > curIdx )
-			{
-				/* iter */
-				double* nWSRout = mxGetPr( plhs[curIdx++] );
-				nWSRout[k] = (double) _nWSRout;
-
-				if ( nlhs > curIdx )
-				{
-					/* lambda */
-					double* y = mxGetPr( plhs[curIdx++] );
-					qp->getDualSolution( &(y[k*(nV+nC)]) );
-
-					/* auxOutput */
-					if ( nlhs > curIdx )
-					{
-						QProblem* problemPointer;
-						problemPointer = dynamic_cast<QProblem*>(qp);
-
-						mxArray* auxOutput = plhs[curIdx];
-						mxArray* curField = 0;
-
-						/* working set bounds */
-						if ( nV > 0 )
-						{
-							curField = mxGetField( auxOutput,0,"workingSetB" );
-							double* workingSetB = mxGetPr(curField);
-
-							/* cast successful? */
-							if (problemPointer != NULL) {
-								problemPointer->getWorkingSetBounds( &(workingSetB[k*nV]) );
-							} else {
-								qp->getWorkingSetBounds( &(workingSetB[k*nV]) );
-							}
-						}
-
-						/* working set constraints */
-						if ( nC > 0 )
-						{
-							curField = mxGetField( auxOutput,0,"workingSetC" );
-							double* workingSetC = mxGetPr(curField);
-
-							/* cast successful? */
-							if (problemPointer != NULL) {
-								problemPointer->getWorkingSetConstraints( &(workingSetC[k*nC]) );
-							} else {
-								qp->getWorkingSetConstraints( &(workingSetC[k*nC]) );
-							}
-						}
-
-						/* cpu time */
-						curField = mxGetField( auxOutput,0,"cpuTime" );
-						double* cpuTime = mxGetPr(curField);
-						cpuTime[0] = (double) _cpuTime;
-					}
-				}
-			}
-		}
-	}
-	
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p H e s s i a n M a t r i x
- */
-returnValue setupHessianMatrix(	const mxArray* prhsH, int_t nV,
-								SymmetricMatrix** H, sparse_int_t** Hir, sparse_int_t** Hjc, real_t** Hv
-								)
-{
-	if ( prhsH == 0 )
-		return SUCCESSFUL_RETURN;
-
-	if ( mxIsSparse( prhsH ) != 0 )
-	{
-		mwIndex *mat_ir = mxGetIr( prhsH );
-		mwIndex *mat_jc = mxGetJc( prhsH );
-		double *v = (double*)mxGetPr( prhsH );
-		long nfill = 0;
-		mwIndex i, j;
-		BooleanType needInsertDiag;
-
-		/* copy indices to avoid 64/32-bit integer confusion */
-		/* also add explicit zeros on diagonal for regularization strategy */
-		/* copy values, too */
-		*Hir = new sparse_int_t[mat_jc[nV] + nV];
-		*Hjc = new sparse_int_t[nV+1];
-		*Hv = new real_t[mat_jc[nV] + nV];
-        for (j = 0; j < nV; j++) 
-		{
-            needInsertDiag = BT_TRUE;
-                
-            (*Hjc)[j] = (sparse_int_t)(mat_jc[j]) + nfill;
-            /* fill up to diagonal */
-            for (i = mat_jc[j]; i < mat_jc[j+1]; i++) 
-			{
-                if ( mat_ir[i] == j )
-                    needInsertDiag = BT_FALSE;
-                    
-                /* add zero diagonal element if not present */
-                if ( ( mat_ir[i] > j ) && ( needInsertDiag == BT_TRUE ) )
-                {
-                    (*Hir)[i + nfill] = (sparse_int_t)j;
-                    (*Hv)[i + nfill] = 0.0;
-                    nfill++;
-                    /* only add diag once */
-                    needInsertDiag = BT_FALSE;
-                }
-                        
-				(*Hir)[i + nfill] = (sparse_int_t)(mat_ir[i]);
-				(*Hv)[i + nfill] = (real_t)(v[i]);
-			}
-		}
-		(*Hjc)[nV] = (sparse_int_t)(mat_jc[nV]) + nfill;
-
-		SymSparseMat *sH;
-		*H = sH = new SymSparseMat(nV, nV, *Hir, *Hjc, *Hv);
-		sH->createDiagInfo();
-	}
-	else
-	{
-		/* make a deep-copy in order to avoid modifying input data when regularising */
-		real_t* H_for = (real_t*) mxGetPr( prhsH );
-		real_t* H_mem = new real_t[nV*nV];
-		memcpy( H_mem,H_for, nV*nV*sizeof(real_t) );
-
-		*H = new SymDenseMat( nV,nV,nV, H_mem );
-		(*H)->doFreeMemory( );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p C o n s t r a i n t M a t r i x
- */
-returnValue setupConstraintMatrix(	const mxArray* prhsA, int_t nV, int_t nC,
-									Matrix** A, sparse_int_t** Air, sparse_int_t** Ajc, real_t** Av
-									)
-{
-	if ( prhsA == 0 )
-		return SUCCESSFUL_RETURN;
-
-	if ( mxIsSparse( prhsA ) != 0 )
-	{
-		mwIndex i;
-		long j;
-
-		mwIndex *mat_ir = mxGetIr( prhsA );
-		mwIndex *mat_jc = mxGetJc( prhsA );
-		double *v = (double*)mxGetPr( prhsA );
-
-		/* copy indices to avoid 64/32-bit integer confusion */
-		*Air = new sparse_int_t[mat_jc[nV]];
-		*Ajc = new sparse_int_t[nV+1];
-		for (i = 0; i < mat_jc[nV]; i++)
-			(*Air)[i] = (sparse_int_t)(mat_ir[i]);
-		for (i = 0; i < nV + 1; i++)
-			(*Ajc)[i] = (sparse_int_t)(mat_jc[i]);
-		
-		/* copy values, too */
-		*Av = new real_t[(*Ajc)[nV]];
-		for (j = 0; j < (*Ajc)[nV]; j++)
-			(*Av)[j] = (real_t)(v[j]);
-
-		*A = new SparseMatrix(nC, nV, *Air, *Ajc, *Av);
-	}
-	else
-	{
-		/* Convert constraint matrix A from FORTRAN to C style
-		* (not necessary for H as it should be symmetric!). */
-		real_t* A_for = (real_t*) mxGetPr( prhsA );
-		real_t* A_mem = new real_t[nC*nV];
-		convertFortranToC( A_for,nV,nC, A_mem );
-		*A = new DenseMatrix(nC, nV, nV, A_mem );
-		(*A)->doFreeMemory();
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.hpp b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.hpp
deleted file mode 100644
index 610c902..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.hpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/octave/qpOASES_octave_utils.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Collects utility functions for Interface to octave that
- *	enables to call qpOASES as a MEX function.
- *
- */
-
-
-
-/* Work-around for settings where mexErrMsgTxt causes unexpected behaviour. */
-#ifdef __AVOID_MEXERRMSGTXT__
-	#define myMexErrMsgTxt( TEXT ) mexPrintf( "%s\n\n",(TEXT) );
-#else
-	#define myMexErrMsgTxt mexErrMsgTxt
-#endif
-
-
-#include "mex.h"
-/* #include "matrix.h" */
-#include "string.h"
-#include <vector>
-
-
-/*
- * QProblem instance class
- */
-class QPInstance
-{
-	private:
-		static int_t s_nexthandle;
-
-	public:
-		QPInstance(	uint_t _nV = 0,
-					uint_t _nC = 0,
-					HessianType _hessianType = HST_UNKNOWN,
-					BooleanType _isSimplyBounded = BT_FALSE
-					);
-
-		~QPInstance( );
-	
-		returnValue deleteQPMatrices();
-		
-		int_t getNV() const;
-		int_t getNC() const;
-
-		int_t handle;
-
-		SQProblem* sqp;
-		QProblemB* qpb;
-		BooleanType isSimplyBounded;
-
-		SymmetricMatrix* H;
-		Matrix* A;
-		sparse_int_t* Hir; 
-		sparse_int_t* Hjc; 
-		sparse_int_t* Air; 
-		sparse_int_t* Ajc;
-		real_t* Hv;
-		real_t* Av;
-};
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_options.m b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_options.m
deleted file mode 100644
index 0f37b97..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_options.m
+++ /dev/null
@@ -1,251 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%Returns a struct containing values for all options to be used within qpOASES.
-%
-%Call
-%    options = qpOASES_options( 'default' );
-%    options = qpOASES_options( 'reliable' );
-%    options = qpOASES_options( 'MPC' );
-%to obtain a set of default options or a pre-defined set of options tuned
-%for reliable or fast QP solution, respectively.
-%
-%Call
-%    options = qpOASES_options( 'option1',value1,'option2',value2,... )
-%to obtain a set of default options but with 'option1' set to value1 etc.
-%
-%Call
-%    options = qpOASES_options( oldOptions,'option1',value1,... )
-%to obtain a copy of the options struct oldOptions but with 'option1' set
-%to value1 etc.
-%
-%Call
-%    options = qpOASES_options( 'default', 'option1',value1,... )
-%    options = qpOASES_options( 'reliable','option1',value1,... )
-%    options = qpOASES_options( 'MPC',     'option1',value1,... )
-%to obtain a set of default options or a pre-defined set of options tuned
-%for reliable or fast QP solution, respectively, but with 'option1' set to 
-%value1 etc.
-%
-%
-%qpOASES features the following options:
-%  maxIter                    -  Maximum number of iterations (if set
-%                                to -1, a value is chosen heuristically)
-%  maxCpuTime                 -  Maximum CPU time in seconds (if set
-%                                to -1, only iteration limit is used)
-%  printLevel                 -  0: no printed output,
-%                                1: only error messages are printed,
-%                                2: iterations and error messages are printed,
-%                                3: all available messages are printed.
-%
-%  enableRamping              -  Enables (1) or disables (0) ramping.
-%  enableFarBounds            -  Enables (1) or disables (0) the use of 
-%                                far bounds.
-%  enableFlippingBounds       -  Enables (1) or disables (0) the use of 
-%                                flipping bounds.
-%  enableRegularisation       -  Enables (1) or disables (0) automatic 
-%                                Hessian regularisation.
-%  enableFullLITests          -  Enables (1) or disables (0) condition-hardened 
-%                                (but more expensive) LI test.
-%  enableNZCTests             -  Enables (1) or disables (0) nonzero curvature 
-%                                tests.
-%  enableDriftCorrection      -  Specifies the frequency of drift corrections:
-%                                0: turns them off, 
-%                                1: uses them at each iteration etc.
-%  enableCholeskyRefactorisation - Specifies the frequency of a full re-
-%                                factorisation of projected Hessian matrix:
-%                                0: turns them off, 
-%                                1: uses them at each iteration etc.
-%  enableEqualities           -  Specifies whether equalities should be treated 
-%                                as always active (1) or not (0)
-%
-%  terminationTolerance       -  Relative termination tolerance to stop homotopy.
-%  boundTolerance             -  If upper and lower bounds differ less than this
-%                                tolerance, they are regarded equal, i.e. as 
-%                                equality constraint.
-%  boundRelaxation            -  Initial relaxation of bounds to start homotopy 
-%                                and initial value for far bounds.
-%  epsNum                     -  Numerator tolerance for ratio tests.
-%  epsDen                     -  Denominator tolerance for ratio tests.
-%  maxPrimalJump              -  Maximum allowed jump in primal variables in 
-%                                nonzero curvature tests.
-%  maxDualJump                -  Maximum allowed jump in dual variables in 
-%                                linear independence tests.
-%
-%  initialRamping             -  Start value for ramping strategy.
-%  finalRamping               -  Final value for ramping strategy.
-%  initialFarBounds           -  Initial size for far bounds.
-%  growFarBounds              -  Factor to grow far bounds.
-%  initialStatusBounds        -  Initial status of bounds at first iteration:
-%                                 0: all bounds inactive,
-%                                -1: all bounds active at their lower bound,
-%                                +1: all bounds active at their upper bound.
-%  epsFlipping                -  Tolerance of squared Cholesky diagonal factor 
-%                                which triggers flipping bound.
-%  numRegularisationSteps     -  Maximum number of successive regularisation steps.
-%  epsRegularisation          -  Scaling factor of identity matrix used for 
-%                                Hessian regularisation.
-%  numRefinementSteps         -  Maximum number of iterative refinement steps.
-%  epsIterRef                 -  Early termination tolerance for iterative 
-%                                refinement.
-%  epsLITests                 -  Tolerance for linear independence tests.
-%  epsNZCTests                -  Tolerance for nonzero curvature tests.
-%
-%
-%See also QPOASES, QPOASES_SEQUENCE, QPOASES_AUXINPUT
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
-function [ options ] = qpOASES_options( varargin )
-
-	firstIsStructOrScheme = 0;
-
-	if ( nargin == 0 ) 
-		options = qpOASES_default_options();
-	else
-		if ( isstruct( varargin{1} ) )
-			if ( mod( nargin,2 ) ~= 1 )
-				error('ERROR (qpOASES_options): Options must be specified in pairs!');
-			end
-			options = varargin{1};
-			firstIsStructOrScheme = 1;
-		else
-			if ( ischar( varargin{1} ) )
-				if ( mod( nargin,2 ) == 0 )
-					options = qpOASES_default_options();
-				else
-					if ( ( nargin > 1 ) && ( ischar( varargin{nargin} ) ) )
-						error('ERROR (qpOASES_options): Options must be specified in pairs!');
-					end
-
-					switch ( varargin{1} )
-						case 'default'
-							options = qpOASES_default_options();
-						case 'reliable'
-							options = qpOASES_reliable_options();
-						case {'MPC','mpc','fast'}
-							options = qpOASES_MPC_options();
-						otherwise
-							error( ['ERROR (qpOASES_options): Only the following option schemes are defined: ''default'', ''reliable'', ''MPC''!'] );
-							
-					end
-					firstIsStructOrScheme = 1;
-				end
-			else
-				error('ERROR (qpOASES_options): First argument needs to be a string or an options struct!');
-			end
-		end
-	end
-
-	% set options to user-defined values  
-	for i=(1+firstIsStructOrScheme):2:nargin
-
-		argName  = varargin{i};
-		argValue = varargin{i+1};
-
-		if ( ( isempty( argName ) ) || ( ~ischar( argName ) ) )
-			error('ERROR (qpOASES_options): Argmument no. %d has to be a non-empty string!',i );
-        end
-			
-		if ( ( ischar(argValue) ) || ( ~isscalar( argValue ) ) )
-			error('ERROR (qpOASES_options): Argmument no. %d has to be a scalar constant!',i+1 );
-        end
-
-		if ( ~isfield( options,argName ) )
-			error('ERROR (qpOASES_options): Argmument no. %d is an invalid option!',i );
-		end
-
-		eval( ['options.',argName,' = ',num2str(argValue),';'] );
-
-	end
-
-end
-
-
-function [ options ] = qpOASES_default_options( )
-
-	% setup options struct with default values
-	options = struct(	'maxIter',                       -1, ...
-						'maxCpuTime',                    -1, ...
-						'printLevel',                     1, ...
-						...
-						'enableRamping',                  1, ...
-						'enableFarBounds',                1, ...
-						'enableFlippingBounds',           1, ...
-						'enableRegularisation',           0, ...
-						'enableFullLITests',              0, ...
-						'enableNZCTests',                 1, ...
-						'enableDriftCorrection',          1, ...
-						'enableCholeskyRefactorisation',  0, ...
-						'enableEqualities',               0, ...
-						...
-						'terminationTolerance',           5.0e6*eps, ...
-						'boundTolerance',                 1.0e6*eps, ...
-						'boundRelaxation',                1.0e4, ...
-						'epsNum',                        -1.0e3*eps, ...
-						'epsDen',                         1.0e3*eps, ...
-						'maxPrimalJump',                  1.0e8, ...
-						'maxDualJump',                    1.0e8, ...
-						...
-    					'initialRamping',                 0.5, ...
-						'finalRamping',                   1.0, ...
-						'initialFarBounds',               1.0e6, ...
-						'growFarBounds',                  1.0e3, ...
-						'initialStatusBounds',            -1, ...
-						'epsFlipping',                    1.0e3*eps, ...
-						'numRegularisationSteps',         0, ...
-						'epsRegularisation',              1.0e3*eps, ...
-						'numRefinementSteps',             1, ...
-						'epsIterRef',                     1.0e2*eps, ...
-						'epsLITests',                     1.0e5*eps, ...
-						'epsNZCTests',                    3.1e3*eps );
-
-end
-
-
-
-function [ options ] = qpOASES_reliable_options( )
-
-	% setup options struct with values for most reliable QP solution
-	options = qpOASES_default_options( );
-
-	options.enableFullLITests             =  1;
-	options.enableCholeskyRefactorisation =  1;
-
-	options.numRefinementSteps            =  2;
-
-end
-
-
-function [ options ] = qpOASES_MPC_options( )
-
-	% setup options struct with values for most reliable QP solution
-	options = qpOASES_default_options( );
-
-	options.enableRamping                 =  0;
-	options.enableFarBounds               =  1;
-	options.enableFlippingBounds          =  0;
-	options.enableRegularisation          =  1;
-	options.enableNZCTests                =  0;
-	options.enableDriftCorrection         =  0;
-	options.enableEqualities              =  1;
-
-	options.terminationTolerance          =  1.0e9*eps;
-	
-	options.initialStatusBounds           =  0;
-	options.numRegularisationSteps        =  1;
-	options.numRefinementSteps            =  0;
-
-end
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.cpp b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.cpp
deleted file mode 100644
index 48bf3d9..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.cpp
+++ /dev/null
@@ -1,1104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/octave/qpOASES_sequence.cpp
- *	\author Hans Joachim Ferreau, Christian Kirches, Andreas Potschka, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for octave that enables to call qpOASES as a MEX function
- *  (variant for solving QP sequences).
- *
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-
-#include "qpOASES_octave_utils.hpp"
-
-/** initialise handle counter of QPInstance class */
-int_t QPInstance::s_nexthandle = 1;
-
-/** global pointer to QP objects */
-static std::vector<QPInstance *> g_instances;
-
-#include "qpOASES_octave_utils.cpp"
-
-
-/*
- *	Q P r o b l e m B _ i n i t
- */
-int_t QProblemB_init(	int_t handle, 
-						SymmetricMatrix* H, real_t* g,
-						const real_t* const lb, const real_t* const ub,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds,
-						const double* const _R
-						)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	/* 1) setup initial QP. */
-	QProblemB* globalQPB = getQPInstance(handle)->qpb;
-
-	if ( globalQPB == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-		return -1;
-	}
-
-	globalQPB->setOptions( *options );
-	
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-	int_t nV = globalQPB->getNV();
-	
-	/* 3) Fill the working set. */
-	Bounds bounds(nV);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	returnvalue = globalQPB->init(	H,g,lb,ub,
-									nWSRout,&maxCpuTimeOut,
-									x0,0,
-									(guessedBounds != 0) ? &bounds : 0,
-									_R
-									);
-
-	/* 3) Assign lhs arguments. */
-	obtainOutputs(	0,globalQPB,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,0,handle );
-
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ i n i t
- */
-int_t SQProblem_init(	int_t handle, 
-						SymmetricMatrix* H, real_t* g, Matrix* A,
-						const real_t* const lb, const real_t* const ub,
-						const real_t* const lbA, const real_t* const ubA,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds, const double* const guessedConstraints,
-						const double* const _R
-						)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	/* 1) setup initial QP. */
-	SQProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-		return -1;
-	}
-
-	globalSQP->setOptions( *options );
-	
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-	
-	/* 3) Fill the working set. */
-	Bounds bounds(nV);
-	Constraints constraints(nC);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	if (guessedConstraints != 0) {
-		for (int_t i = 0; i < nC; i++) {
-			if ( isEqual(guessedConstraints[i],-1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_LOWER);
-			} else if ( isEqual(guessedConstraints[i],1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_UPPER);
-			} else if ( isEqual(guessedConstraints[i],0.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of constraints!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-	
-	returnvalue = globalSQP->init(	H,g,A,lb,ub,lbA,ubA,
-									nWSRout,&maxCpuTimeOut,
-									x0,0,
-									(guessedBounds != 0) ? &bounds : 0, (guessedConstraints != 0) ? &constraints : 0,
-									_R
-									);
-
-	/* 3) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC,handle );
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m B _ h o t s t a r t
- */
-int_t QProblemB_hotstart(	int_t handle,
-							const real_t* const g,
-							const real_t* const lb, const real_t* const ub,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	QProblemB* globalQPB = getQPInstance(handle)->qpb;
-
-	if ( globalQPB == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalQPB->getNV();
-
-	/* 1) Solve QP with given options. */
-	globalQPB->setOptions( *options );
-	returnValue returnvalue = globalQPB->hotstart( g,lb,ub, nWSRout,&maxCpuTimeOut );
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalQPB,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,0 );
-
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m _ h o t s t a r t
- */
-int_t QProblem_hotstart(	int_t handle,
-							const real_t* const g,
-							const real_t* const lb, const real_t* const ub,
-							const real_t* const lbA, const real_t* const ubA,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	QProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-
-	/* 1) Solve QP with given options. */
-	globalSQP->setOptions( *options );
-	returnValue returnvalue = globalSQP->hotstart( g,lb,ub,lbA,ubA, nWSRout,&maxCpuTimeOut );
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC );
-
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ h o t s t a r t
- */
-int_t SQProblem_hotstart(	int_t handle,
-							SymmetricMatrix* H, real_t* g, Matrix* A,
-							const real_t* const lb, const real_t* const ub, const real_t* const lbA, const real_t* const ubA,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	SQProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-
-	/* 1) Solve QP. */
-	globalSQP->setOptions( *options );
-	returnValue returnvalue = globalSQP->hotstart( H,g,A,lb,ub,lbA,ubA, nWSRout,&maxCpuTimeOut );
-
-	switch (returnvalue)
-	{
-		case SUCCESSFUL_RETURN:
-		case RET_QP_UNBOUNDED:
-		case RET_QP_INFEASIBLE:
-			break;
-
-		default:
-			myMexErrMsgTxt( "ERROR (qpOASES): Hotstart failed." );
-			return -1;
-	}
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC );
-
-	return 0;
-}
-
-
-
-/*
- *	m e x F u n c t i o n
- */
-void mexFunction( int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[] )
-{
-	/* inputs */
-	char typeString[2];
-
-	real_t *g=0, *lb=0, *ub=0, *lbA=0, *ubA=0;
-	HessianType hessianType = HST_UNKNOWN;
-	double *x0=0, *R=0, *R_for=0;
-	double *guessedBounds=0, *guessedConstraints=0;
-
-	int_t H_idx=-1, g_idx=-1, A_idx=-1, lb_idx=-1, ub_idx=-1, lbA_idx=-1, ubA_idx=-1;
-	int_t x0_idx=-1, auxInput_idx=-1;
-
-	BooleanType isSimplyBoundedQp = BT_FALSE;
-
-	Options options;
-	options.printLevel = PL_LOW;
-	#ifdef __DEBUG__
-	options.printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	options.printLevel = PL_NONE;
-	#endif
-
-	/* dimensions */
-	uint_t nV=0, nC=0, handle=0;
-	int_t nWSRin;
-	real_t maxCpuTimeIn = -1.0;
-	QPInstance* globalQP = 0;
-
-	/* I) CONSISTENCY CHECKS: */
-	/* 1) Ensure that qpOASES is called with a feasible number of input arguments. */
-	if ( ( nrhs < 5 ) || ( nrhs > 10 ) )
-	{
-		if ( nrhs != 2 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-	}
-	
-	/* 2) Ensure that first input is a string ... */
-	if ( mxIsChar( prhs[0] ) != 1 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): First input argument must be a string!" );
-		return;
-	}
-
-	mxGetString( prhs[0], typeString, 2 );
-
-	/*    ... and if so, check if it is an allowed one. */
-	if ( ( strcmp( typeString,"i" ) != 0 ) && ( strcmp( typeString,"I" ) != 0 ) &&
-		 ( strcmp( typeString,"h" ) != 0 ) && ( strcmp( typeString,"H" ) != 0 ) &&
-		 ( strcmp( typeString,"m" ) != 0 ) && ( strcmp( typeString,"M" ) != 0 ) &&
-		 ( strcmp( typeString,"e" ) != 0 ) && ( strcmp( typeString,"E" ) != 0 ) &&
-		 ( strcmp( typeString,"c" ) != 0 ) && ( strcmp( typeString,"C" ) != 0 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Undefined first input argument!\nType 'help qpOASES_sequence' for further information." );
-		return;
-	}
-
-
-	/* II) SELECT RESPECTIVE QPOASES FUNCTION CALL: */
-	/* 1) Init (without or with initial guess for primal solution). */
-	if ( ( strcmp( typeString,"i" ) == 0 ) || ( strcmp( typeString,"I" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 7 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 5 ) || ( nrhs > 10 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		g_idx = 2;
-
-		if ( mxIsEmpty(prhs[1]) == 1 )
-		{
-			H_idx = -1;
-			nV = (uint_t)mxGetM( prhs[ g_idx ] ); /* row number of Hessian matrix */
-		}
-		else
-		{
-			H_idx = 1;
-			nV = (uint_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-		}
-
-
-		/* ensure that data is given in double precision */
-		if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[ H_idx ] ) == 0 ) ) ||
-		     ( mxIsDouble( prhs[ g_idx ] ) == 0 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-			return;
-		}
-
-		if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Hessian matrix dimension mismatch!" );
-			return;
-		}
-
-
-		/* Check for 'Inf' and 'Nan' in Hessian */
-		if (containsNaNorInf( prhs,H_idx, 0 ) == BT_TRUE)
-			return;
-
-		/* Check for 'Inf' and 'Nan' in gradient */
-		if (containsNaNorInf(prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		/* determine whether is it a simply bounded QP */
-		if ( nrhs <= 7 )
-			isSimplyBoundedQp = BT_TRUE;
-		else
-			isSimplyBoundedQp = BT_FALSE;
-
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			lb_idx = 3;
-			ub_idx = 4;
-
-			if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-				return;
-
-			/* Check inputs dimensions and assign pointers to inputs. */
-			nC = 0; /* row number of constraint matrix */
-
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,2 ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,3 ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,4 ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*nV;
-
-			/* Check whether x0 and options are specified .*/
-			if ( nrhs >= 6 )
-			{
-				if ((!mxIsEmpty(prhs[5])) && (mxIsStruct(prhs[5])))
-					setupOptions( &options,prhs[5],nWSRin,maxCpuTimeIn );
-
-				if ( ( nrhs >= 7 ) && ( !mxIsEmpty(prhs[6]) ) )
-				{ 
-					/* auxInput specified */
-					if ( mxIsStruct(prhs[6]) )
-					{
-						auxInput_idx = 6;
-						x0_idx = -1;
-					}
-					else
-					{
-						auxInput_idx = -1;
-						x0_idx = 6;
-					}
-				}
-				else
-				{
-					auxInput_idx = -1;
-					x0_idx = -1;
-				}
-			}
-		}
-		else
-		{
-			A_idx = 3;
-
-			/* ensure that data is given in double precision */
-			if ( mxIsDouble( prhs[ A_idx ] ) == 0 )
-			{
-				myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-				return;
-			}
-		
-			/* Check inputs dimensions and assign pointers to inputs. */
-			nC = (uint_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-
-			lb_idx = 4;
-			ub_idx = 5;
-			lbA_idx = 6;
-			ubA_idx = 7;
-
-			if (containsNaNorInf( prhs,A_idx, 0 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if ( ( mxGetN( prhs[ A_idx ] ) != 0 ) && ( mxGetN( prhs[ A_idx ] ) != nV ) )
-			{
-				myMexErrMsgTxt( "ERROR (qpOASES): Constraint matrix dimension mismatch!" );
-				return;
-			}
-		
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-				return;
-			
-			if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*(nV+nC);
-
-			/* Check whether x0 and options are specified .*/
-			if ( nrhs >= 9 )
-			{
-				if ((!mxIsEmpty(prhs[8])) && (mxIsStruct(prhs[8])))
-					setupOptions( &options,prhs[8],nWSRin,maxCpuTimeIn );
-
-				if ( ( nrhs >= 10 ) && ( !mxIsEmpty(prhs[9]) ) )
-				{ 
-					/* auxInput specified */
-					if ( mxIsStruct(prhs[9]) )
-					{
-						auxInput_idx = 9;
-						x0_idx = -1;
-					}
-					else
-					{
-						auxInput_idx = -1;
-						x0_idx = 9;
-					}
-				}
-				else
-				{
-					auxInput_idx = -1;
-					x0_idx = -1;
-				}
-			}
-		}
-
-
-		/* check dimensions and copy auxInputs */
-		if ( smartDimensionCheck( &x0,nV,1, BT_TRUE,prhs,x0_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( auxInput_idx >= 0 )
-			setupAuxiliaryInputs( prhs[auxInput_idx],nV,nC, &hessianType,&x0,&guessedBounds,&guessedConstraints,&R_for );
-
-		/* convert Cholesky factor to C storage format */
-		if ( R_for != 0 )
-		{
-			R = new real_t[nV*nV];
-			convertFortranToC( R_for, nV,nV, R );
-		}
-		
-		/* allocate instance */
-		handle = allocateQPInstance( nV,nC,hessianType, isSimplyBoundedQp,&options );	
-		globalQP = getQPInstance( handle );
-
-		/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-		if ( H_idx >= 0 )
-			setupHessianMatrix(	prhs[H_idx],nV, &(globalQP->H),&(globalQP->Hir),&(globalQP->Hjc),&(globalQP->Hv) );
-		
-		/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-		if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-			setupConstraintMatrix( prhs[A_idx],nV,nC, &(globalQP->A),&(globalQP->Air),&(globalQP->Ajc),&(globalQP->Av) );
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC,1,handle );
-
-		/* Call qpOASES. */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			QProblemB_init(	handle,
-							globalQP->H,g,
-							lb,ub,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,R
-							);
-		}
-		else
-		{
-			SQProblem_init(	handle,
-							globalQP->H,g,globalQP->A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,guessedConstraints,R
-							);
-		}
-
-		if (R != 0) delete R;
-		return;
-	}
-
-	/* 2) Hotstart. */
-	if ( ( strcmp( typeString,"h" ) == 0 ) || ( strcmp( typeString,"H" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 6 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 5 ) || ( nrhs > 8 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* determine whether is it a simply bounded QP */
-		if ( nrhs < 7 )
-			isSimplyBoundedQp = BT_TRUE;
-		else
-			isSimplyBoundedQp = BT_FALSE;
-
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		nV = globalQP->getNV();
-
-		g_idx = 2;
-		lb_idx = 3;
-		ub_idx = 4;
-
-		if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			nC = 0;
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*nV;
-
-			/* Check whether options are specified .*/
-			if ( nrhs == 6 )
-				if ( ( !mxIsEmpty( prhs[5] ) ) && ( mxIsStruct( prhs[5] ) ) )
-					setupOptions( &options,prhs[5],nWSRin,maxCpuTimeIn );
-		}
-		else
-		{
-			nC = globalQP->getNC( );
-
-			lbA_idx = 5;
-			ubA_idx = 6;
-
-			if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*(nV+nC);
-
-			/* Check whether options are specified .*/
-			if ( nrhs == 8 )
-				if ( ( !mxIsEmpty( prhs[7] ) ) && ( mxIsStruct( prhs[7] ) ) )
-					setupOptions( &options,prhs[7],nWSRin,maxCpuTimeIn );
-		}
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC );
-
-		/* call qpOASES */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			QProblemB_hotstart(	handle, g,
-								lb,ub,
-								nWSRin,maxCpuTimeIn,
-								&options,
-								nlhs,plhs
-								);
-		}
-		else
-		{
-			QProblem_hotstart(	handle, g,
-								lb,ub,lbA,ubA,
-								nWSRin,maxCpuTimeIn,
-								&options,
-								nlhs,plhs
-								);
-		}
-
-		return;
-	}
-
-	/* 3) Modify matrices. */
-	if ( ( strcmp( typeString,"m" ) == 0 ) || ( strcmp( typeString,"M" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 6 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 9 ) || ( nrhs > 10 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		g_idx = 3;
-		
-		if ( mxIsEmpty(prhs[2]) == 1 )
-		{
-			H_idx = -1;
-			nV = (uint_t)mxGetM( prhs[ g_idx ] ); /* if Hessian is empty, row number of gradient vector */
-		}
-		else
-		{
-			H_idx = 2;
-			nV = (uint_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-		}
-		
-		A_idx = 4;
-		nC = (uint_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-				
-		lb_idx = 5;
-		ub_idx = 6;
-		lbA_idx = 7;
-		ubA_idx = 8;
-
-
-		/* ensure that data is given in double precision */
-		if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[H_idx] ) == 0 ) ) ||
-			 ( mxIsDouble( prhs[g_idx] ) == 0 ) ||
-			 ( mxIsDouble( prhs[A_idx] ) == 0 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in real_t precision!" );
-			return;
-		}
-
-		/* check if supplied data contains 'NaN' or 'Inf' */
-		if (containsNaNorInf(prhs,H_idx, 0) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,A_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-
-		/* Check that dimensions are consistent with existing QP instance */
-		if (nV != (uint_t) globalQP->getNV () || nC != (uint_t) globalQP->getNC ())
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): QP dimensions must be constant during a sequence! Try creating a new QP instance instead." );
-			return;
-		}
-
-		if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Hessian matrix dimension mismatch!" );
-			return;
-		}
-
-		if ( ( mxGetN( prhs[ A_idx ] ) != 0 ) && ( mxGetN( prhs[ A_idx ] ) != nV ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Constraint matrix dimension mismatch!" );
-			return;
-		}
-
-		if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		/* default value for nWSR */
-		nWSRin = 5*(nV+nC);
-
-		/* Check whether options are specified .*/
-		if ( nrhs > 9 )
-			if ( ( !mxIsEmpty( prhs[9] ) ) && ( mxIsStruct( prhs[9] ) ) )
-				setupOptions( &options,prhs[9],nWSRin,maxCpuTimeIn );
-
-		globalQP->deleteQPMatrices( );
-
-		/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-		if ( H_idx >= 0 )
-			setupHessianMatrix(	prhs[H_idx],nV, &(globalQP->H),&(globalQP->Hir),&(globalQP->Hjc),&(globalQP->Hv) );
-
-		/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-		if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-			setupConstraintMatrix( prhs[A_idx],nV,nC, &(globalQP->A),&(globalQP->Air),&(globalQP->Ajc),&(globalQP->Av) );
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC );
-
-		/* Call qpOASES */
-		SQProblem_hotstart(	handle, globalQP->H,g,globalQP->A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							&options,
-							nlhs,plhs
-							);
-
-		return;
-	}
-
-	/* 4) Solve current equality constrained QP. */
-	if ( ( strcmp( typeString,"e" ) == 0 ) || ( strcmp( typeString,"E" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 4 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 7 ) || ( nrhs > 8 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		int_t nRHS = (int_t)mxGetN(prhs[2]);
-		nV = globalQP->getNV( );
-		nC = globalQP->getNC( );
-		real_t *x_out, *y_out;
-
-		g_idx = 2;
-		lb_idx = 3;
-		ub_idx = 4;
-		lbA_idx = 5;
-		ubA_idx = 6;
-
-		/* check if supplied data contains 'NaN' or 'Inf' */
-		if (containsNaNorInf(prhs,g_idx, 0) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if ( smartDimensionCheck( &g,nV,nRHS, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lb,nV,nRHS, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ub,nV,nRHS, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lbA,nC,nRHS, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,nRHS, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		/* Check whether options are specified .*/
-		if ( ( nrhs == 8 ) && ( !mxIsEmpty( prhs[7] ) ) && ( mxIsStruct( prhs[7] ) ) )
-		{
-			nWSRin = 5*(nV+nC);
-			setupOptions( &options,prhs[7],nWSRin,maxCpuTimeIn );
-			globalQP->sqp->setOptions( options );
-		}
-
-		/* Create output vectors and assign pointers to them. */
-		plhs[0] = mxCreateDoubleMatrix( nV, nRHS, mxREAL );
-		x_out = mxGetPr(plhs[0]);
-		if (nlhs >= 2)
-		{
-			plhs[1] = mxCreateDoubleMatrix( nV+nC, nRHS, mxREAL );
-			y_out = mxGetPr(plhs[1]);
-
-			if (nlhs >= 3)
-			{
-				plhs[2] = mxCreateDoubleMatrix( nV, nRHS, mxREAL );
-				real_t* workingSetB = mxGetPr(plhs[2]);
-				globalQP->sqp->getWorkingSetBounds(workingSetB);
-
-				if ( nlhs >= 4 )
-				{
-					plhs[3] = mxCreateDoubleMatrix( nC, nRHS, mxREAL );
-					real_t* workingSetC = mxGetPr(plhs[3]);
-					globalQP->sqp->getWorkingSetConstraints(workingSetC);
-				}
-			}
-		}
-		else
-			y_out = new real_t[nV+nC];
-
-		/* Solve equality constrained QP */
-		returnValue returnvalue = globalQP->sqp->solveCurrentEQP( nRHS,g,lb,ub,lbA,ubA, x_out,y_out );
-
-		if (nlhs < 2)
-			delete[] y_out;
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-		{
-			char msg[MAX_STRING_LENGTH];
-			snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Couldn't solve current EQP (code %d)!", returnvalue);
-			myMexErrMsgTxt(msg);
-			return;
-		}
-
-		return;
-	}
-
-	/* 5) Cleanup. */
-	if ( ( strcmp( typeString,"c" ) == 0 ) || ( strcmp( typeString,"C" ) == 0 ) )
-	{		
-		/* consistency checks */
-		if ( nlhs != 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( nrhs != 2 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* Cleanup SQProblem instance. */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		deleteQPInstance( handle );
-		
-		return;
-	}
-
-}
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.m b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.m
deleted file mode 100644
index b02b7c0..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.m
+++ /dev/null
@@ -1,111 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%qpOASES_sequence is intended to solve a sequence of quadratic
-%programming (QP) problems of the following form:
-%
-%                min   1/2*x'Hx + x'g
-%                s.t.  lb  <=  x <= ub
-%                      lbA <= Ax <= ubA  {optional}
-%
-%I) Call
-%
-%    [QP,x,fval,exitflag,iter,lambda,auxOutput] = ...
-%               qpOASES_sequence( 'i',H,g,A,lb,ub,lbA,ubA{,options{,auxInput}} )
-%or 
-%    [QP,x,fval,exitflag,iter,lambda,auxOutput] = ...
-%               qpOASES_sequence( 'i',H,g,lb,ub{,options{,auxInput}} )
-%
-%for initialising and solving the first above-mentioned QP of the sequence
-%starting from an initial guess x0. H must be a symmetric (possibly indefinite) 
-%matrix and all vectors g, lb, ub, lbA, ubA have to be given as column vectors. 
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used. Optionally, further auxiliary inputs may be generated 
-%using qpOASES_auxInput command and passed to the solver.
-%Both matrices H or A may be passed in sparse matrix format.
-%
-%II) Call
-%
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                      qpOASES_sequence( 'h',QP,g,lb,ub,lbA,ubA{,options} )
-%or
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                      qpOASES_sequence( 'h',QP,g,lb,ub{,options} )
-%
-%for hotstarting from the previous QP solution to the one of the next QP
-%given by the vectors g, lb, ub, lbA, ubA. Options can be generated using the 
-%qpOASES_options command, otherwise default values are used.
-%
-%III) Call
-%
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                     qpOASES_sequence( 'm',QP,H,g,A,lb,ub,lbA,ubA{,options} )
-%
-%for hotstarting from the previous QP solution to the one of the next QP
-%given by the matrices H, A and the vectors g, lb, ub, lbA, ubA. The previous
-%active set serves as a starting guess. If the new projected Hessian matrix
-%turns out to be not positive definite, qpOASES recedes to a safe initial active
-%set guess automatically. This can result in a high number of iterations iter.
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used.
-%
-%IV) Call
-%
-%     [x,lambda,workingSetB,workingSetC] = ...
-%                     qpOASES_sequence( 'e',QP,g,lb,ub,lbA,ubA{,options} )
-%
-%for solving the equality constrained QP with constraints determined by the
-%current active set. All inequalities and bounds which were not active in the
-%previous solution might be violated. This command does not alter the internal
-%state of qpOASES. Instead of calling this command multiple times, it is
-%possible to supply several columns simultaneously in g, lb, ub, lbA, and ubA.
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used.
-%
-%V) Having solved the last QP of your sequence, call
-%
-%     qpOASES_sequence( 'c',QP )
-%
-%in order to cleanup the internal memory.
-%
-%
-%Optional outputs (only x is mandatory):
-%    x            -  Optimal primal solution vector (if exitflag==0).
-%    fval         -  Optimal objective function value (if exitflag==0).
-%    exitflag     -   0: QP solved,
-%                     1: QP could not be solved within given number of iterations,
-%                    -1: QP could not be solved due to an internal error,
-%                    -2: QP is infeasible (and thus could not be solved),
-%                    -3: QP is unbounded (and thus could not be solved).
-%    iter         -  Number of active set iterations actually performed.
-%    lambda       -  Optimal dual solution vector (if exitflag==0).
-%    auxOutput    -  Struct containing auxiliary outputs as described below.
-%
-%The auxOutput struct contains the following entries:
-%    workingSetB  -  Working set of bounds at point x.
-%    workingSetC  -  Working set of constraints at point x.
-%                    The working set is a subset of the active set (indices
-%                    of bounds/constraints that hold with equality) yielding
-%                    a set linearly independent of bounds/constraints.
-%                    The working sets are encoded as follows:
-%                     1: bound/constraint at its upper bound
-%                     0: bound/constraint not at any bound
-%                    -1: bound/constraint at its lower bound
-%    cpuTime      -  Internally measured CPU time for solving QP problem.
-%
-%See also QPOASES_OPTIONS, QPOASES_AUXINPUT, QPOASES
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/README.rst b/extlibs/qpOASES-3.2.0/interfaces/python/README.rst
deleted file mode 100644
index 64911d9..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/README.rst
+++ /dev/null
@@ -1,68 +0,0 @@
-pyqpOASES: a Python interface to qpOASES
-
-:Author: Sebastian F. Walter, Manuel Kudruss
-
-
-Installation
-------------
-
-
-Requirements:
-
-  You'll need numpy and cython. Install for instance with::
-
-      sudo pip install cython
-      sudo pip install numpy
-
-Method 1:
-
-  This is a local installation and creates `./interfaces/python/qpoases.so`::
-
-    make python
-
-  Then, you'll have to update your PYTHONPATH, e.g., on LINUX you have to add::
-
-    export PYTHONPATH=$PYTHONPATH:/home/swalter/projects/qpOASES/interfaces/python
-
-  to your ``~/.bashrc``.
-
-Method 2:
-
-  global installation::
-
-    sudo make pythoninstall
-
-Method 3::
-
-   cd ./interfaces/python/
-   python setup.py build_ext --inplace
-   # or python setup.py install
-
-
-Testing your installation
--------------------------
-
-For a quick test run::
-
-  cd ./interfaces/python
-  python example1.py
-
-
-To run a complete unit test you need ``nose``. Install for instance with::
-
-    sudo pip install nose
-
-Then::
-
-   cd ./interfaces/python/
-   nosestests ./tests
-
-The results of the tests can be found in `./interfaces/python/tests/results`.
-
-Tested setups
--------------
-
-The Python interface is known to work on
-
-* Windows, Python 3
-* Linux (Ubuntu 12.04) using Python 2.7.3, Python 3.2.3. NumPy 1.8, Cython 0.19
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/example1.pyx b/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/example1.pyx
deleted file mode 100644
index e562342..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/example1.pyx
+++ /dev/null
@@ -1,73 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-## Example adapted from examples/example1.cpp.
-## author of this file: Sebastian F. Walter
-
-import numpy as np
-from qpoases import PyQProblem as QProblem
-from qpoases import PyPrintLevel as PrintLevel
-from qpoases import PyOptions as Options
-cimport numpy as np
-
-def run():
-
-    #Setup data of QP.
-
-    cdef np.ndarray[np.double_t, ndim=2] H
-    cdef np.ndarray[np.double_t, ndim=2] A
-    cdef np.ndarray[np.double_t, ndim=1] g
-    cdef np.ndarray[np.double_t, ndim=1] lb
-    cdef np.ndarray[np.double_t, ndim=1] ub
-    cdef np.ndarray[np.double_t, ndim=1] lbA
-    cdef np.ndarray[np.double_t, ndim=1] ubA
-
-    H   = np.array([1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-    A   = np.array([1.0, 1.0 ]).reshape((2,1))
-    g   = np.array([1.5, 1.0 ])
-    lb  = np.array([0.5, -2.0])
-    ub  = np.array([5.0, 2.0 ])
-    lbA = np.array([-1.0 ])
-    ubA = np.array([2.0])
-
-    # Setting up QProblem object.
-
-    cdef example = QProblem(2, 1)
-    cdef options = Options()
-    options.printLevel = PrintLevel.NONE
-    example.setOptions(options)
-
-    # Solve first QP.
-
-    cdef int nWSR = 10
-    example.init(H, g, A, lb, ub, lbA, ubA, nWSR)
-
-    # Solve subsequent QPs
-
-    cdef int i,j
-    for i in range(100000):
-        for j in range(1, 100):
-            g[0] = i%j
-        example.hotstart(g, lb, ub, lbA, ubA, nWSR)
-
-run()
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/setup.py b/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/setup.py
deleted file mode 100644
index d605d2c..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/setup.py
+++ /dev/null
@@ -1,16 +0,0 @@
-from distutils.core import setup
-from distutils.extension import Extension
-from Cython.Distutils import build_ext
-
-ext_module = Extension(
-    "example1",
-    ["example1.pyx"],
-    extra_compile_args=['-fopenmp'],
-    extra_link_args=['-fopenmp'],
-)
-
-setup(
-    name = 'Hello world app',
-    cmdclass = {'build_ext': build_ext},
-    ext_modules = [ext_module],
-)
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1.py b/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1.py
deleted file mode 100644
index afa7c56..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1.py
+++ /dev/null
@@ -1,76 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-## Example adapted from examples/example1.cpp.
-## author of this file: Sebastian F. Walter
-
-import numpy as np
-from qpoases import PyQProblem as QProblem
-from qpoases import PyOptions as Options
-from qpoases import PyPrintLevel as PrintLevel
-
-#Setup data of first QP.
-
-H   = np.array([1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-A   = np.array([1.0, 1.0 ]).reshape((2,1))
-g   = np.array([1.5, 1.0 ])
-lb  = np.array([0.5, -2.0])
-ub  = np.array([5.0, 2.0 ])
-lbA = np.array([-1.0 ])
-ubA = np.array([2.0])
-
-
-# Setup data of second QP.
-
-g_new   = np.array([1.0, 1.5])
-lb_new  = np.array([0.0, -1.0])
-ub_new  = np.array([5.0, -0.5])
-lbA_new = np.array([-2.0])
-ubA_new = np.array([1.0])
-
-
-# Setting up QProblem object.
-
-example = QProblem(2, 1)
-options = Options()
-options.printLevel = PrintLevel.NONE
-example.setOptions(options)
-
-# Solve first QP.
-nWSR = np.array([10])
-example.init(H, g, A, lb, ub, lbA, ubA, nWSR)
-
-
-# Solve second QP.
-nWSR = np.array([10])
-
-for i in range(100000):
-    for j in range(1, 100):
-        g_new[0] = i%j
-    example.hotstart( g_new, lb_new, ub_new, lbA_new, ubA_new, nWSR)
-
-# Get and print solution of second QP.
-
-xOpt = np.zeros(2)
-example.getPrimalSolution(xOpt)
-print("\nxOpt = [ %e, %e ];  objVal = %e\n\n"%(xOpt[0],xOpt[1],example.getObjVal()))
-example.printOptions()
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1b.py b/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1b.py
deleted file mode 100644
index c450add..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1b.py
+++ /dev/null
@@ -1,72 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-## Example adapted from examples/example1b.cpp.
-## author of this file: Sebastian F. Walter
-
-import numpy as np
-from qpoases import PyQProblemB as QProblemB
-from qpoases import PyBooleanType as BooleanType
-from qpoases import PySubjectToStatus as SubjectToStatus
-from qpoases import PyOptions as Options
-
-# Example for qpOASES main function using the QProblemB class.
-
-#Setup data of first QP.
-
-H   = np.array([1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-g   = np.array([1.5, 1.0 ])
-lb  = np.array([0.5, -2.0])
-ub  = np.array([5.0, 2.0 ])
-
-# Setup data of second QP.
-
-g_new   = np.array([1.0, 1.5])
-lb_new  = np.array([0.0, -1.0])
-ub_new  = np.array([5.0, -0.5])
-
-
-# Setting up QProblemB object.
-example = QProblemB(2)
-
-options = Options()
-options.enableFlippingBounds = BooleanType.FALSE
-options.initialStatusBounds  = SubjectToStatus.INACTIVE
-options.numRefinementSteps   = 1
-
-example.setOptions(options)
-
-# Solve first QP.
-nWSR = np.array([10])
-example.init(H, g, lb, ub, nWSR)
-print("\nnWSR = %d\n\n"%nWSR)
-
-# Solve second QP.
-nWSR = np.array([10])
-example.hotstart(g_new, lb_new, ub_new, nWSR)
-print("\nnWSR = %d\n\n"% nWSR)
-
-# Get and print solution of second QP.
-xOpt = np.zeros(2)
-example.getPrimalSolution(xOpt)
-print("\nxOpt = [ %e, %e ];  objVal = %e\n\n" %(xOpt[0], xOpt[1],
-	                                            example.getObjVal()))
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example2.py b/extlibs/qpOASES-3.2.0/interfaces/python/examples/example2.py
deleted file mode 100644
index fff34d9..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example2.py
+++ /dev/null
@@ -1,92 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-## Example adapted from examples/example2.cpp.
-## author of this file: Sebastian F. Walter
-
-import numpy as np
-from qpoases import PySQProblem as SQProblem
-from qpoases import PySolutionAnalysis as SolutionAnalysis
-
-
-#  Setup data of first QP.
-H = np.array([ 1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-A = np.array([ 1.0, 1.0 ]).reshape((2,1))
-g = np.array([ 1.5, 1.0 ])
-lb = np.array([ 0.5, -2.0 ])
-ub = np.array([ 5.0, 2.0 ])
-lbA = np.array([ -1.0 ])
-ubA = np.array([ 2.0 ])
-
-#  Setup data of second QP.
-H_new = np.array([ 1.0, 0.5, 0.5, 0.5 ]).reshape((2,2))
-A_new = np.array([ 1.0, 5.0 ]).reshape((2,1))
-g_new = np.array([ 1.0, 1.5 ])
-lb_new = np.array([ 0.0, -1.0 ])
-ub_new = np.array([ 5.0, -0.5 ])
-lbA_new = np.array([ -2.0 ])
-ubA_new = np.array([ 1.0 ])
-
-#  Setting up SQProblem object and solution analyser.
-example = SQProblem(2, 1)
-analyser = SolutionAnalysis()
-
-#  Solve first QP ...
-nWSR = np.array([10])
-example.init(H, g, A, lb, ub, lbA, ubA, nWSR)
-
-#  ... and analyse it.
-maxStat = np.zeros(1)
-maxFeas = np.zeros(1)
-maxCmpl = np.zeros(1)
-
-analyser.getKktViolation(example, maxStat, maxFeas, maxCmpl)
-print("maxStat: %e, maxFeas:%e, maxCmpl: %e\n"%(maxStat, maxFeas, maxCmpl))
-
-#  Solve second QP ...
-nWSR = np.array([10])
-example.hotstart(H_new, g_new, A_new, lb_new, ub_new,
-                 lbA_new, ubA_new, nWSR)
-
-#  ... and analyse it.
-analyser.getKktViolation(example, maxStat, maxFeas, maxCmpl)
-print("maxStat: %e, maxFeas:%e, maxCmpl: %e\n"%(maxStat, maxFeas, maxCmpl))
-
-
-#  ------------ VARIANCE-COVARIANCE EVALUATION --------------------
-
-Var             = np.zeros(5*5)
-Primal_Dual_Var = np.zeros(5*5)
-
-Var.reshape((5,5))[0,0] = 1.
-Var.reshape((5,5))[1,1] = 1.
-
-#                  (  1   0   0   0   0   )
-#                  (  0   1   0   0   0   )
-#     Var     =    (  0   0   0   0   0   )
-#                  (  0   0   0   0   0   )
-#                  (  0   0   0   0   0   )
-
-
-analyser.getVarianceCovariance(example, Var, Primal_Dual_Var)
-print('Primal_Dual_Var=\n', Primal_Dual_Var.reshape((5,5)))
-print("maxStat: %e, maxFeas:%e, maxCmpl: %e\n"%(maxStat, maxFeas, maxCmpl))
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pxd b/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pxd
deleted file mode 100644
index 66f0b8f..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pxd
+++ /dev/null
@@ -1,487 +0,0 @@
-##
-##  This file is part of qpOASES.
-##
-##  qpOASES -- An Implementation of the Online Active Set Strategy.
-##  Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##  Christian Kirches et al. All rights reserved.
-##
-##  qpOASES is free software; you can redistribute it and/or
-##  modify it under the terms of the GNU Lesser General Public
-##  License as published by the Free Software Foundation; either
-##  version 2.1 of the License, or (at your option) any later version.
-##
-##  qpOASES is distributed in the hope that it will be useful,
-##  but WITHOUT ANY WARRANTY; without even the implied warranty of
-##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##  See the GNU Lesser General Public License for more details.
-##
-##  You should have received a copy of the GNU Lesser General Public
-##  License along with qpOASES; if not, write to the Free Software
-##  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-##
-##    Filename:  qpoases.pxd
-##    Author:    Sebastian F. Walter, Manuel Kudruss
-##    Version:   3.2
-##    Date:      2013-2015
-##
-
-cdef extern from "qpOASES.hpp" namespace "qpOASES":
-
-    ctypedef double real_t
-    ctypedef int int_t
-
-    cdef enum BooleanType:
-
-        BT_FALSE
-        BT_TRUE
-
-    cdef enum PrintLevel:
-
-        PL_DEBUG_ITER = -2
-        PL_TABULAR
-        PL_NONE
-        PL_LOW
-        PL_MEDIUM
-        PL_HIGH
-
-    cdef enum VisibilityStatus:
-
-        VS_HIDDEN
-        VS_VISIBLE
-
-    cdef enum QProblemStatus:
-
-        QPS_NOTINITIALISED
-        QPS_PREPARINGAUXILIARYQP
-
-        QPS_AUXILIARYQPSOLVED
-
-        QPS_PERFORMINGHOMOTOPY
-
-        QPS_HOMOTOPYQPSOLVED
-        QPS_SOLVED
-
-    cdef enum HessianType:
-        HST_ZERO
-        HST_IDENTITY
-        HST_POSDEF
-        HST_POSDEF_NULLSPACE
-        HST_SEMIDEF
-        HST_INDEF
-        HST_UNKNOWN
-
-    cdef enum SubjectToType:
-
-        ST_UNBOUNDED
-        ST_BOUNDED
-        ST_EQUALITY
-        ST_DISABLED
-        ST_UNKNOWN
-
-    cdef enum SubjectToStatus:
-
-        ST_LOWER = -1
-        ST_INACTIVE
-        ST_UPPER
-        ST_INFEASIBLE_LOWER
-        ST_INFEASIBLE_UPPER
-        ST_UNDEFINED
-
-    cdef enum  returnValue:
-        TERMINAL_LIST_ELEMENT = -1
-        SUCCESSFUL_RETURN = 0
-        RET_DIV_BY_ZERO
-        RET_INDEX_OUT_OF_BOUNDS
-        RET_INVALID_ARGUMENTS
-        RET_ERROR_UNDEFINED
-        RET_WARNING_UNDEFINED
-        RET_INFO_UNDEFINED
-        RET_EWI_UNDEFINED
-        RET_AVAILABLE_WITH_LINUX_ONLY
-        RET_UNKNOWN_BUG
-        RET_PRINTLEVEL_CHANGED
-        RET_NOT_YET_IMPLEMENTED
-        RET_INDEXLIST_MUST_BE_REORDERD
-        RET_INDEXLIST_EXCEEDS_MAX_LENGTH
-        RET_INDEXLIST_CORRUPTED
-        RET_INDEXLIST_OUTOFBOUNDS
-        RET_INDEXLIST_ADD_FAILED
-        RET_INDEXLIST_INTERSECT_FAILED
-        RET_INDEX_ALREADY_OF_DESIRED_STATUS
-        RET_ADDINDEX_FAILED
-        RET_REMOVEINDEX_FAILED
-        RET_SWAPINDEX_FAILED
-        RET_NOTHING_TO_DO
-        RET_SETUP_BOUND_FAILED
-        RET_SETUP_CONSTRAINT_FAILED
-        RET_MOVING_BOUND_FAILED
-        RET_MOVING_CONSTRAINT_FAILED
-        RET_SHIFTING_FAILED
-        RET_ROTATING_FAILED
-        RET_QPOBJECT_NOT_SETUP
-        RET_QP_ALREADY_INITIALISED
-        RET_NO_INIT_WITH_STANDARD_SOLVER
-        RET_RESET_FAILED
-        RET_INIT_FAILED
-        RET_INIT_FAILED_TQ
-        RET_INIT_FAILED_CHOLESKY
-        RET_INIT_FAILED_HOTSTART
-        RET_INIT_FAILED_INFEASIBILITY
-        RET_INIT_FAILED_UNBOUNDEDNESS
-        RET_INIT_FAILED_REGULARISATION
-        RET_INIT_SUCCESSFUL
-        RET_OBTAINING_WORKINGSET_FAILED
-        RET_SETUP_WORKINGSET_FAILED
-        RET_SETUP_AUXILIARYQP_FAILED
-        RET_NO_CHOLESKY_WITH_INITIAL_GUESS
-        RET_NO_EXTERN_SOLVER
-        RET_QP_UNBOUNDED
-        RET_QP_INFEASIBLE
-        RET_QP_NOT_SOLVED
-        RET_QP_SOLVED
-        RET_UNABLE_TO_SOLVE_QP
-        RET_INITIALISATION_STARTED
-        RET_HOTSTART_FAILED
-        RET_HOTSTART_FAILED_TO_INIT
-        RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED
-        RET_ITERATION_STARTED
-        RET_SHIFT_DETERMINATION_FAILED
-        RET_STEPDIRECTION_DETERMINATION_FAILED
-        RET_STEPLENGTH_DETERMINATION_FAILED
-        RET_OPTIMAL_SOLUTION_FOUND
-        RET_HOMOTOPY_STEP_FAILED
-        RET_HOTSTART_STOPPED_INFEASIBILITY
-        RET_HOTSTART_STOPPED_UNBOUNDEDNESS
-        RET_WORKINGSET_UPDATE_FAILED
-        RET_MAX_NWSR_REACHED
-        RET_CONSTRAINTS_NOT_SPECIFIED
-        RET_INVALID_FACTORISATION_FLAG
-        RET_UNABLE_TO_SAVE_QPDATA
-        RET_STEPDIRECTION_FAILED_TQ
-        RET_STEPDIRECTION_FAILED_CHOLESKY
-        RET_CYCLING_DETECTED
-        RET_CYCLING_NOT_RESOLVED
-        RET_CYCLING_RESOLVED
-        RET_STEPSIZE
-        RET_STEPSIZE_NONPOSITIVE
-        RET_SETUPSUBJECTTOTYPE_FAILED
-        RET_ADDCONSTRAINT_FAILED
-        RET_ADDCONSTRAINT_FAILED_INFEASIBILITY
-        RET_ADDBOUND_FAILED
-        RET_ADDBOUND_FAILED_INFEASIBILITY
-        RET_REMOVECONSTRAINT_FAILED
-        RET_REMOVEBOUND_FAILED
-        RET_REMOVE_FROM_ACTIVESET
-        RET_ADD_TO_ACTIVESET
-        RET_REMOVE_FROM_ACTIVESET_FAILED
-        RET_ADD_TO_ACTIVESET_FAILED
-        RET_CONSTRAINT_ALREADY_ACTIVE
-        RET_ALL_CONSTRAINTS_ACTIVE
-        RET_LINEARLY_DEPENDENT
-        RET_LINEARLY_INDEPENDENT
-        RET_LI_RESOLVED
-        RET_ENSURELI_FAILED
-        RET_ENSURELI_FAILED_TQ
-        RET_ENSURELI_FAILED_NOINDEX
-        RET_ENSURELI_FAILED_CYCLING
-        RET_BOUND_ALREADY_ACTIVE
-        RET_ALL_BOUNDS_ACTIVE
-        RET_CONSTRAINT_NOT_ACTIVE
-        RET_BOUND_NOT_ACTIVE
-        RET_HESSIAN_NOT_SPD
-        RET_HESSIAN_INDEFINITE
-        RET_MATRIX_SHIFT_FAILED
-        RET_MATRIX_FACTORISATION_FAILED
-        RET_PRINT_ITERATION_FAILED
-        RET_NO_GLOBAL_MESSAGE_OUTPUTFILE
-        RET_DISABLECONSTRAINTS_FAILED
-        RET_ENABLECONSTRAINTS_FAILED
-        RET_ALREADY_ENABLED
-        RET_ALREADY_DISABLED
-        RET_NO_HESSIAN_SPECIFIED
-        RET_USING_REGULARISATION
-        RET_EPS_MUST_BE_POSITVE
-        RET_REGSTEPS_MUST_BE_POSITVE
-        RET_HESSIAN_ALREADY_REGULARISED
-        RET_CANNOT_REGULARISE_IDENTITY
-        RET_CANNOT_REGULARISE_SPARSE
-        RET_NO_REGSTEP_NWSR
-        RET_FEWER_REGSTEPS_NWSR
-        RET_CHOLESKY_OF_ZERO_HESSIAN
-        RET_ZERO_HESSIAN_ASSUMED
-        RET_CONSTRAINTS_ARE_NOT_SCALED
-        RET_INITIAL_BOUNDS_STATUS_NYI
-        RET_ERROR_IN_CONSTRAINTPRODUCT
-        RET_FIX_BOUNDS_FOR_LP
-        RET_USE_REGULARISATION_FOR_LP
-        RET_UPDATEMATRICES_FAILED
-        RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED
-        RET_UNABLE_TO_OPEN_FILE
-        RET_UNABLE_TO_WRITE_FILE
-        RET_UNABLE_TO_READ_FILE
-        RET_FILEDATA_INCONSISTENT
-        RET_UNABLE_TO_ANALYSE_QPROBLEM
-        RET_OPTIONS_ADJUSTED
-        RET_NWSR_SET_TO_ONE
-        RET_UNABLE_TO_READ_BENCHMARK
-        RET_BENCHMARK_ABORTED
-        RET_INITIAL_QP_SOLVED
-        RET_QP_SOLUTION_STARTED
-        RET_BENCHMARK_SUCCESSFUL
-        RET_NO_DIAGONAL_AVAILABLE
-        RET_DIAGONAL_NOT_INITIALISED
-        RET_ENSURELI_DROPPED
-        RET_KKT_MATRIX_SINGULAR
-        RET_QR_FACTORISATION_FAILED
-        RET_INERTIA_CORRECTION_FAILED
-        RET_NO_SPARSE_SOLVER
-        RET_SIMPLE_STATUS_P1
-        RET_SIMPLE_STATUS_P0
-        RET_SIMPLE_STATUS_M1
-        RET_SIMPLE_STATUS_M2
-        RET_SIMPLE_STATUS_M3
-
-
-    cdef cppclass Options:
-
-        Options()
-        Options(const Options&)
-        # Options& operator=( const Options&)  # equality operator cannot be overloaded in Python
-        returnValue setToDefault()
-        returnValue setToReliable()
-        returnValue setToMPC()
-        returnValue setToFast()
-        returnValue ensureConsistency()
-        # returnValue print() # print is a reserved keyword in Python
-        returnValue copy(const Options& )
-
-        PrintLevel printLevel
-
-        BooleanType enableRamping
-        BooleanType enableFarBounds
-        BooleanType enableFlippingBounds
-        BooleanType enableRegularisation
-        BooleanType enableFullLITests
-        BooleanType enableNZCTests
-        int_t       enableDriftCorrection
-        int_t       enableCholeskyRefactorisation
-        BooleanType enableEqualities
-
-        real_t terminationTolerance
-        real_t boundTolerance
-        real_t boundRelaxation
-        real_t epsNum
-        real_t epsDen
-        real_t maxPrimalJump
-        real_t maxDualJump
-
-        real_t initialRamping
-        real_t finalRamping
-        real_t initialFarBounds
-        real_t growFarBounds
-        SubjectToStatus initialStatusBounds
-        real_t epsFlipping
-        int_t numRegularisationSteps
-        real_t epsRegularisation
-        int_t numRefinementSteps
-        real_t epsIterRef
-        real_t epsLITests
-        real_t epsNZCTests
-
-        real_t rcondSMin
-        BooleanType enableInertiaCorrection
-
-        BooleanType enableDropInfeasibles
-        int_t dropBoundPriority
-        int_t dropEqConPriority
-        int_t dropIneqConPriority
-
-    cdef cppclass QProblemB:
-        QProblemB()
-        QProblemB(int_t, HessianType)
-
-        QProblemB(const QProblemB&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&,
-                         real_t*)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&,
-                             real_t*)
-
-
-        returnValue getPrimalSolution(real_t*)
-        returnValue getDualSolution(real_t*)
-        returnValue printOptions()
-        real_t getObjVal()
-
-        Options getOptions()
-        returnValue setOptions(Options&)
-
-    cdef cppclass QProblem:
-        QProblem()
-        QProblem(int_t, int_t, HessianType)
-
-        QProblem(const QProblem&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&,
-                         real_t*)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&,
-                             real_t*)
-
-        returnValue getPrimalSolution(real_t*)
-        returnValue getDualSolution(real_t*)
-        returnValue printOptions()
-        real_t getObjVal()
-
-        Options getOptions()
-        returnValue setOptions(Options&)
-
-
-    cdef cppclass SQProblem:
-        SQProblem()
-        SQProblem(int_t, int_t, HessianType)
-
-        SQProblem(const QProblem&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&,
-                         real_t*)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&,
-                             real_t*)
-
-        returnValue getPrimalSolution(real_t*)
-        returnValue getDualSolution(real_t*)
-        returnValue printOptions()
-        real_t getObjVal()
-
-        Options getOptions()
-        returnValue setOptions(Options&)
-
-cdef extern from "qpOASES/extras/SolutionAnalysis.hpp" namespace "qpOASES":
-    cdef cppclass SolutionAnalysis:
-        SolutionAnalysis()
-        SolutionAnalysis(const SolutionAnalysis&)
-        # ~SolutionAnalysis()
-        # SolutionAnalysis& operator=(const SolutionAnalysis&)
-        returnValue getKktViolation(const QProblem*,  const real_t*, const real_t*, const real_t*)
-        returnValue getKktViolation(const QProblemB*, const real_t*, const real_t*, const real_t*)
-        returnValue getKktViolation(const SQProblem*, const real_t*, const real_t*, const real_t*)
-        returnValue getVarianceCovariance(QProblem*, real_t*, real_t*)
-        returnValue getVarianceCovariance(QProblemB*, real_t*, real_t*)
-        returnValue getVarianceCovariance(SQProblem*, real_t*, real_t*)
-
-
-cdef extern from "qpOASES/Utils.hpp" namespace "qpOASES":
-    pass
-    #void getKktViolation(int_t nV,                # Number of variables.
-    #                     int_t nC,                # Number of constraints.
-    #                     const real_t* const H,   # Hessian matrix.
-    #                     const real_t* const g,   # Sequence of gradient vectors.
-    #                     const real_t* const A,   # Constraint matrix.
-    #                     const real_t* const lb,  # Sequence of lower bound vectors (on variables).
-    #                     const real_t* const ub,  # Sequence of upper bound vectors (on variables).
-    #                     const real_t* const lbA, # Sequence of lower constraints' bound vectors.
-    #                     const real_t* const ubA, # Sequence of upper constraints' bound vectors.
-    #                     const real_t* const x,   # Sequence of primal trial vectors.
-    #                     const real_t* const y,   # Sequence of dual trial vectors.
-    #                     real_t& stat,            # Maximum value of stationarity condition residual.
-    #                     real_t& feas,            # Maximum value of primal feasibility violation.
-    #                     real_t& cmpl             # Maximum value of complementarity residual.
-    #                     )
-
-
-cdef extern from "qpOASES/extras/OQPinterface.hpp" namespace "qpOASES":
-    returnValue runOqpBenchmark(const char* path,           # Full path of the benchmark files (without trailing slash!).
-                                BooleanType isSparse,       # Shall convert matrices to sparse format before solution?
-                                BooleanType useHotstarts,   # Shall QP solution be hotstarted?
-                                const Options& options,     # QP solver options to be used while solving benchmark problems.
-                                int maxAllowedNWSR,         # Maximum number of working set recalculations to be performed.
-                                real_t& maxNWSR,            # Output: Maximum number of performed working set recalculations.
-                                real_t& avgNWSR,            # Output: Average number of performed working set recalculations.
-                                real_t& maxCPUtime,         # Output: Maximum CPU time required for solving each QP.
-                                real_t& avgCPUtime,         # Output: Average CPU time required for solving each QP.
-                                real_t& maxStationarity,    # Output: Maximum residual of stationarity condition.
-                                real_t& maxFeasibility,     # Output: Maximum residual of primal feasibility condition.
-                                real_t& maxComplementarity  # Output: Maximum residual of complementarity condition.
-                                )
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pyx b/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pyx
deleted file mode 100644
index b9883cc..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pyx
+++ /dev/null
@@ -1,929 +0,0 @@
-##
-##  This file is part of qpOASES.
-##
-##  qpOASES -- An Implementation of the Online Active Set Strategy.
-##  Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##  Christian Kirches et al. All rights reserved.
-##
-##  qpOASES is free software; you can redistribute it and/or
-##  modify it under the terms of the GNU Lesser General Public
-##  License as published by the Free Software Foundation; either
-##  version 2.1 of the License, or (at your option) any later version.
-##
-##  qpOASES is distributed in the hope that it will be useful,
-##  but WITHOUT ANY WARRANTY; without even the implied warranty of
-##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##  See the GNU Lesser General Public License for more details.
-##
-##  You should have received a copy of the GNU Lesser General Public
-##  License along with qpOASES; if not, write to the Free Software
-##  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-## author of this file: Sebastian F. Walter
-
-"""
-Python interface to qpOASES
-using Cython
-:author: Sebastian F. Walter, Manuel Kudruss
-"""
-
-import warnings
-warnings.simplefilter("once", DeprecationWarning)
-import numpy as np
-cimport numpy as np
-
-from cython.operator cimport dereference as deref
-
-cimport qpoases
-
-def deprecation_warning_nWSR():
-    warnings.warn("\nInteger nWSR will be deprecated in qpOASES 4.0.\nUse nWSR = numpy.array([10]) as input to qp.init() and qp.hotstart()", DeprecationWarning, stacklevel=2)
-
-def deprecation_warning_cputime():
-    warnings.warn("\nFloat cputime will be deprecated in qpOASES 4.0.\nUse cputime = numpy.array([2.0]) as input to qp.init() and qp.hotstart()", DeprecationWarning, stacklevel=2)
-
-
-cdef class PyBooleanType:
-    FALSE = BT_FALSE
-    TRUE  = BT_TRUE
-
-cdef class PyPrintLevel:
-    DEBUG_ITER = PL_DEBUG_ITER
-    TABULAR    = PL_TABULAR
-    NONE       = PL_NONE
-    LOW        = PL_LOW
-    MEDIUM     = PL_MEDIUM
-    HIGH       = PL_HIGH
-
-cdef class PyHessianType:
-    ZERO               = HST_ZERO
-    IDENTITY           = HST_IDENTITY
-    POSDEF             = HST_POSDEF
-    POSDEF_NULLSPACE   = HST_POSDEF_NULLSPACE
-    SEMIDEF            = HST_SEMIDEF
-    INDEF              = HST_INDEF
-    UNKNOWN            = HST_UNKNOWN
-
-cdef class PySubjectToStatus:
-    LOWER              = ST_LOWER
-    INACTIVE           = ST_INACTIVE
-    UPPER              = ST_UPPER
-    INFEASIBLE_LOWER   = ST_INFEASIBLE_LOWER
-    INFEASIBLE_UPPER   = ST_INFEASIBLE_UPPER
-    UNDEFINED          = ST_UNDEFINED
-
-cdef class PyReturnValue:
-    TERMINAL_LIST_ELEMENT                 = -1
-    SUCCESSFUL_RETURN                     = 0
-    DIV_BY_ZERO                           = RET_DIV_BY_ZERO
-    INDEX_OUT_OF_BOUNDS                   = RET_INDEX_OUT_OF_BOUNDS
-    INVALID_ARGUMENTS                     = RET_INVALID_ARGUMENTS
-    ERROR_UNDEFINED                       = RET_ERROR_UNDEFINED
-    WARNING_UNDEFINED                     = RET_WARNING_UNDEFINED
-    INFO_UNDEFINED                        = RET_INFO_UNDEFINED
-    EWI_UNDEFINED                         = RET_EWI_UNDEFINED
-    AVAILABLE_WITH_LINUX_ONLY             = RET_AVAILABLE_WITH_LINUX_ONLY
-    UNKNOWN_BUG                           = RET_UNKNOWN_BUG
-    PRINTLEVEL_CHANGED                    = RET_PRINTLEVEL_CHANGED
-    NOT_YET_IMPLEMENTED                   = RET_NOT_YET_IMPLEMENTED
-    INDEXLIST_MUST_BE_REORDERD            = RET_INDEXLIST_MUST_BE_REORDERD
-    INDEXLIST_EXCEEDS_MAX_LENGTH          = RET_INDEXLIST_EXCEEDS_MAX_LENGTH
-    INDEXLIST_CORRUPTED                   = RET_INDEXLIST_CORRUPTED
-    INDEXLIST_OUTOFBOUNDS                 = RET_INDEXLIST_OUTOFBOUNDS
-    INDEXLIST_ADD_FAILED                  = RET_INDEXLIST_ADD_FAILED
-    INDEXLIST_INTERSECT_FAILED            = RET_INDEXLIST_INTERSECT_FAILED
-    INDEX_ALREADY_OF_DESIRED_STATUS       = RET_INDEX_ALREADY_OF_DESIRED_STATUS
-    ADDINDEX_FAILED                       = RET_ADDINDEX_FAILED
-    REMOVEINDEX_FAILED                    = RET_REMOVEINDEX_FAILED
-    SWAPINDEX_FAILED                      = RET_SWAPINDEX_FAILED
-    NOTHING_TO_DO                         = RET_NOTHING_TO_DO
-    SETUP_BOUND_FAILED                    = RET_SETUP_BOUND_FAILED
-    SETUP_CONSTRAINT_FAILED               = RET_SETUP_CONSTRAINT_FAILED
-    MOVING_BOUND_FAILED                   = RET_MOVING_BOUND_FAILED
-    MOVING_CONSTRAINT_FAILED              = RET_MOVING_CONSTRAINT_FAILED
-    SHIFTING_FAILED                       = RET_SHIFTING_FAILED
-    ROTATING_FAILED                       = RET_ROTATING_FAILED
-    QPOBJECT_NOT_SETUP                    = RET_QPOBJECT_NOT_SETUP
-    QP_ALREADY_INITIALISED                = RET_QP_ALREADY_INITIALISED
-    NO_INIT_WITH_STANDARD_SOLVER          = RET_NO_INIT_WITH_STANDARD_SOLVER
-    RESET_FAILED                          = RET_RESET_FAILED
-    INIT_FAILED                           = RET_INIT_FAILED
-    INIT_FAILED_TQ                        = RET_INIT_FAILED_TQ
-    INIT_FAILED_CHOLESKY                  = RET_INIT_FAILED_CHOLESKY
-    INIT_FAILED_HOTSTART                  = RET_INIT_FAILED_HOTSTART
-    INIT_FAILED_INFEASIBILITY             = RET_INIT_FAILED_INFEASIBILITY
-    INIT_FAILED_UNBOUNDEDNESS             = RET_INIT_FAILED_UNBOUNDEDNESS
-    INIT_FAILED_REGULARISATION            = RET_INIT_FAILED_REGULARISATION
-    INIT_SUCCESSFUL                       = RET_INIT_SUCCESSFUL
-    OBTAINING_WORKINGSET_FAILED           = RET_OBTAINING_WORKINGSET_FAILED
-    SETUP_WORKINGSET_FAILED               = RET_SETUP_WORKINGSET_FAILED
-    SETUP_AUXILIARYQP_FAILED              = RET_SETUP_AUXILIARYQP_FAILED
-    NO_CHOLESKY_WITH_INITIAL_GUESS        = RET_NO_CHOLESKY_WITH_INITIAL_GUESS
-    NO_EXTERN_SOLVER                      = RET_NO_EXTERN_SOLVER
-    QP_UNBOUNDED                          = RET_QP_UNBOUNDED
-    QP_INFEASIBLE                         = RET_QP_INFEASIBLE
-    QP_NOT_SOLVED                         = RET_QP_NOT_SOLVED
-    QP_SOLVED                             = RET_QP_SOLVED
-    UNABLE_TO_SOLVE_QP                    = RET_UNABLE_TO_SOLVE_QP
-    INITIALISATION_STARTED                = RET_INITIALISATION_STARTED
-    HOTSTART_FAILED                       = RET_HOTSTART_FAILED
-    HOTSTART_FAILED_TO_INIT               = RET_HOTSTART_FAILED_TO_INIT
-    HOTSTART_FAILED_AS_QP_NOT_INITIALISED = RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED
-    ITERATION_STARTED                     = RET_ITERATION_STARTED
-    SHIFT_DETERMINATION_FAILED            = RET_SHIFT_DETERMINATION_FAILED
-    STEPDIRECTION_DETERMINATION_FAILED    = RET_STEPDIRECTION_DETERMINATION_FAILED
-    STEPLENGTH_DETERMINATION_FAILED       = RET_STEPLENGTH_DETERMINATION_FAILED
-    OPTIMAL_SOLUTION_FOUND                = RET_OPTIMAL_SOLUTION_FOUND
-    HOMOTOPY_STEP_FAILED                  = RET_HOMOTOPY_STEP_FAILED
-    HOTSTART_STOPPED_INFEASIBILITY        = RET_HOTSTART_STOPPED_INFEASIBILITY
-    HOTSTART_STOPPED_UNBOUNDEDNESS        = RET_HOTSTART_STOPPED_UNBOUNDEDNESS
-    WORKINGSET_UPDATE_FAILED              = RET_WORKINGSET_UPDATE_FAILED
-    MAX_NWSR_REACHED                      = RET_MAX_NWSR_REACHED
-    CONSTRAINTS_NOT_SPECIFIED             = RET_CONSTRAINTS_NOT_SPECIFIED
-    INVALID_FACTORISATION_FLAG            = RET_INVALID_FACTORISATION_FLAG
-    UNABLE_TO_SAVE_QPDATA                 = RET_UNABLE_TO_SAVE_QPDATA
-    STEPDIRECTION_FAILED_TQ               = RET_STEPDIRECTION_FAILED_TQ
-    STEPDIRECTION_FAILED_CHOLESKY         = RET_STEPDIRECTION_FAILED_CHOLESKY
-    CYCLING_DETECTED                      = RET_CYCLING_DETECTED
-    CYCLING_NOT_RESOLVED                  = RET_CYCLING_NOT_RESOLVED
-    CYCLING_RESOLVED                      = RET_CYCLING_RESOLVED
-    STEPSIZE                              = RET_STEPSIZE
-    STEPSIZE_NONPOSITIVE                  = RET_STEPSIZE_NONPOSITIVE
-    SETUPSUBJECTTOTYPE_FAILED             = RET_SETUPSUBJECTTOTYPE_FAILED
-    ADDCONSTRAINT_FAILED                  = RET_ADDCONSTRAINT_FAILED
-    ADDCONSTRAINT_FAILED_INFEASIBILITY    = RET_ADDCONSTRAINT_FAILED_INFEASIBILITY
-    ADDBOUND_FAILED                       = RET_ADDBOUND_FAILED
-    ADDBOUND_FAILED_INFEASIBILITY         = RET_ADDBOUND_FAILED_INFEASIBILITY
-    REMOVECONSTRAINT_FAILED               = RET_REMOVECONSTRAINT_FAILED
-    REMOVEBOUND_FAILED                    = RET_REMOVEBOUND_FAILED
-    REMOVE_FROM_ACTIVESET                 = RET_REMOVE_FROM_ACTIVESET
-    ADD_TO_ACTIVESET                      = RET_ADD_TO_ACTIVESET
-    REMOVE_FROM_ACTIVESET_FAILED          = RET_REMOVE_FROM_ACTIVESET_FAILED
-    ADD_TO_ACTIVESET_FAILED               = RET_ADD_TO_ACTIVESET_FAILED
-    CONSTRAINT_ALREADY_ACTIVE             = RET_CONSTRAINT_ALREADY_ACTIVE
-    ALL_CONSTRAINTS_ACTIVE                = RET_ALL_CONSTRAINTS_ACTIVE
-    LINEARLY_DEPENDENT                    = RET_LINEARLY_DEPENDENT
-    LINEARLY_INDEPENDENT                  = RET_LINEARLY_INDEPENDENT
-    LI_RESOLVED                           = RET_LI_RESOLVED
-    ENSURELI_FAILED                       = RET_ENSURELI_FAILED
-    ENSURELI_FAILED_TQ                    = RET_ENSURELI_FAILED_TQ
-    ENSURELI_FAILED_NOINDEX               = RET_ENSURELI_FAILED_NOINDEX
-    ENSURELI_FAILED_CYCLING               = RET_ENSURELI_FAILED_CYCLING
-    BOUND_ALREADY_ACTIVE                  = RET_BOUND_ALREADY_ACTIVE
-    ALL_BOUNDS_ACTIVE                     = RET_ALL_BOUNDS_ACTIVE
-    CONSTRAINT_NOT_ACTIVE                 = RET_CONSTRAINT_NOT_ACTIVE
-    BOUND_NOT_ACTIVE                      = RET_BOUND_NOT_ACTIVE
-    HESSIAN_NOT_SPD                       = RET_HESSIAN_NOT_SPD
-    HESSIAN_INDEFINITE                    = RET_HESSIAN_INDEFINITE
-    MATRIX_SHIFT_FAILED                   = RET_MATRIX_SHIFT_FAILED
-    MATRIX_FACTORISATION_FAILED           = RET_MATRIX_FACTORISATION_FAILED
-    PRINT_ITERATION_FAILED                = RET_PRINT_ITERATION_FAILED
-    NO_GLOBAL_MESSAGE_OUTPUTFILE          = RET_NO_GLOBAL_MESSAGE_OUTPUTFILE
-    DISABLECONSTRAINTS_FAILED             = RET_DISABLECONSTRAINTS_FAILED
-    ENABLECONSTRAINTS_FAILED              = RET_ENABLECONSTRAINTS_FAILED
-    ALREADY_ENABLED                       = RET_ALREADY_ENABLED
-    ALREADY_DISABLED                      = RET_ALREADY_DISABLED
-    NO_HESSIAN_SPECIFIED                  = RET_NO_HESSIAN_SPECIFIED
-    USING_REGULARISATION                  = RET_USING_REGULARISATION
-    EPS_MUST_BE_POSITVE                   = RET_EPS_MUST_BE_POSITVE
-    REGSTEPS_MUST_BE_POSITVE              = RET_REGSTEPS_MUST_BE_POSITVE
-    HESSIAN_ALREADY_REGULARISED           = RET_HESSIAN_ALREADY_REGULARISED
-    CANNOT_REGULARISE_IDENTITY            = RET_CANNOT_REGULARISE_IDENTITY
-    CANNOT_REGULARISE_SPARSE              = RET_CANNOT_REGULARISE_SPARSE
-    NO_REGSTEP_NWSR                       = RET_NO_REGSTEP_NWSR
-    FEWER_REGSTEPS_NWSR                   = RET_FEWER_REGSTEPS_NWSR
-    CHOLESKY_OF_ZERO_HESSIAN              = RET_CHOLESKY_OF_ZERO_HESSIAN
-    ZERO_HESSIAN_ASSUMED                  = RET_ZERO_HESSIAN_ASSUMED
-    CONSTRAINTS_ARE_NOT_SCALED            = RET_CONSTRAINTS_ARE_NOT_SCALED
-    INITIAL_BOUNDS_STATUS_NYI             = RET_INITIAL_BOUNDS_STATUS_NYI
-    ERROR_IN_CONSTRAINTPRODUCT            = RET_ERROR_IN_CONSTRAINTPRODUCT
-    FIX_BOUNDS_FOR_LP                     = RET_FIX_BOUNDS_FOR_LP
-    USE_REGULARISATION_FOR_LP             = RET_USE_REGULARISATION_FOR_LP
-    UPDATEMATRICES_FAILED                 = RET_UPDATEMATRICES_FAILED
-    UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED= RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED
-    UNABLE_TO_OPEN_FILE                   = RET_UNABLE_TO_OPEN_FILE
-    UNABLE_TO_WRITE_FILE                  = RET_UNABLE_TO_WRITE_FILE
-    UNABLE_TO_READ_FILE                   = RET_UNABLE_TO_READ_FILE
-    FILEDATA_INCONSISTENT                 = RET_FILEDATA_INCONSISTENT
-    UNABLE_TO_ANALYSE_QPROBLEM            = RET_UNABLE_TO_ANALYSE_QPROBLEM
-    OPTIONS_ADJUSTED                      = RET_OPTIONS_ADJUSTED
-    NWSR_SET_TO_ONE                       = RET_NWSR_SET_TO_ONE
-    UNABLE_TO_READ_BENCHMARK              = RET_UNABLE_TO_READ_BENCHMARK
-    BENCHMARK_ABORTED                     = RET_BENCHMARK_ABORTED
-    INITIAL_QP_SOLVED                     = RET_INITIAL_QP_SOLVED
-    QP_SOLUTION_STARTED                   = RET_QP_SOLUTION_STARTED
-    BENCHMARK_SUCCESSFUL                  = RET_BENCHMARK_SUCCESSFUL
-    NO_DIAGONAL_AVAILABLE                 = RET_NO_DIAGONAL_AVAILABLE
-    DIAGONAL_NOT_INITIALISED              = RET_DIAGONAL_NOT_INITIALISED
-    ENSURELI_DROPPED                      = RET_ENSURELI_DROPPED
-    KKT_MATRIX_SINGULAR                   = RET_KKT_MATRIX_SINGULAR
-    QR_FACTORISATION_FAILED               = RET_QR_FACTORISATION_FAILED
-    INERTIA_CORRECTION_FAILED             = RET_INERTIA_CORRECTION_FAILED
-    NO_SPARSE_SOLVER                      = RET_NO_SPARSE_SOLVER
-    SIMPLE_STATUS_P1                      = RET_SIMPLE_STATUS_P1
-    SIMPLE_STATUS_P0                      = RET_SIMPLE_STATUS_P0
-    SIMPLE_STATUS_M1                      = RET_SIMPLE_STATUS_M1
-    SIMPLE_STATUS_M2                      = RET_SIMPLE_STATUS_M2
-    SIMPLE_STATUS_M3                      = RET_SIMPLE_STATUS_M3
-
-
-
-cdef class PyOptions:
-    cdef Options *thisptr      # hold a C++ instance which we're wrapping
-    def __cinit__(self):
-        # FIXME: add support for the other constructors
-        self.thisptr = new Options()
-
-    def __dealloc__(self):
-        del self.thisptr
-
-    def setToDefault(self):
-        return self.thisptr.setToDefault()
-
-    def setToReliable(self):
-        return self.thisptr.setToReliable()
-
-    def setToMPC(self):
-        return self.thisptr.setToMPC()
-
-    def setToFast(self):
-        return self.thisptr.setToFast()
-
-    def ensureConsistency(self):
-        return self.thisptr.ensureConsistency()
-
-    property printLevel:
-        def __get__(self): return self.thisptr.printLevel
-        def __set__(self, printLevel): self.thisptr.printLevel = printLevel
-
-    property enableRamping:
-        def __get__(self): return self.thisptr.enableRamping
-        def __set__(self, enableRamping): self.thisptr.enableRamping = enableRamping
-
-    property enableFarBounds:
-        def __get__(self): return self.thisptr.enableFarBounds
-        def __set__(self, enableFarBounds): self.thisptr.enableFarBounds = enableFarBounds
-
-    property enableFlippingBounds:
-        def __get__(self): return self.thisptr.enableFlippingBounds
-        def __set__(self, enableFlippingBounds): self.thisptr.enableFlippingBounds = enableFlippingBounds
-
-    property enableRegularisation:
-        def __get__(self): return self.thisptr.enableRegularisation
-        def __set__(self, enableRegularisation): self.thisptr.enableRegularisation = enableRegularisation
-
-    property enableFullLITests:
-        def __get__(self): return self.thisptr.enableFullLITests
-        def __set__(self, enableFullLITests): self.thisptr.enableFullLITests = enableFullLITests
-
-    property enableNZCTests:
-        def __get__(self): return self.thisptr.enableNZCTests
-        def __set__(self, enableNZCTests): self.thisptr.enableNZCTests = enableNZCTests
-
-    property enableDriftCorrection:
-        def __get__(self): return self.thisptr.enableDriftCorrection
-        def __set__(self, enableDriftCorrection): self.thisptr.enableDriftCorrection = enableDriftCorrection
-
-    property enableCholeskyRefactorisation:
-        def __get__(self): return self.thisptr.enableCholeskyRefactorisation
-        def __set__(self, enableCholeskyRefactorisation): self.thisptr.enableCholeskyRefactorisation = enableCholeskyRefactorisation
-
-    property enableEqualities:
-        def __get__(self): return self.thisptr.enableEqualities
-        def __set__(self, enableEqualities): self.thisptr.enableEqualities = enableEqualities
-
-    property terminationTolerance:
-        def __get__(self): return self.thisptr.terminationTolerance
-        def __set__(self, terminationTolerance): self.thisptr.terminationTolerance = terminationTolerance
-
-    property boundTolerance:
-        def __get__(self): return self.thisptr.boundTolerance
-        def __set__(self, boundTolerance): self.thisptr.boundTolerance = boundTolerance
-
-    property boundRelaxation:
-        def __get__(self): return self.thisptr.boundRelaxation
-        def __set__(self, boundRelaxation): self.thisptr.boundRelaxation = boundRelaxation
-
-    property epsNum:
-        def __get__(self): return self.thisptr.epsNum
-        def __set__(self, epsNum): self.thisptr.epsNum = epsNum
-
-    property epsDen:
-        def __get__(self): return self.thisptr.epsDen
-        def __set__(self, epsDen): self.thisptr.epsDen = epsDen
-
-    property maxPrimalJump:
-        def __get__(self): return self.thisptr.maxPrimalJump
-        def __set__(self, maxPrimalJump): self.thisptr.maxPrimalJump = maxPrimalJump
-
-    property maxDualJump:
-        def __get__(self): return self.thisptr.maxDualJump
-        def __set__(self, maxDualJump): self.thisptr.maxDualJump = maxDualJump
-
-    property initialRamping:
-        def __get__(self): return self.thisptr.initialRamping
-        def __set__(self, initialRamping): self.thisptr.initialRamping = initialRamping
-
-    property finalRamping:
-        def __get__(self): return self.thisptr.finalRamping
-        def __set__(self, finalRamping): self.thisptr.finalRamping = finalRamping
-
-    property initialFarBounds:
-        def __get__(self): return self.thisptr.initialFarBounds
-        def __set__(self, initialFarBounds): self.thisptr.initialFarBounds = initialFarBounds
-
-    property growFarBounds:
-        def __get__(self): return self.thisptr.growFarBounds
-        def __set__(self, growFarBounds): self.thisptr.growFarBounds = growFarBounds
-
-    property initialStatusBounds:
-        def __get__(self): return self.thisptr.initialStatusBounds
-        def __set__(self, initialStatusBounds): self.thisptr.initialStatusBounds = initialStatusBounds
-
-    property epsFlipping:
-        def __get__(self): return self.thisptr.epsFlipping
-        def __set__(self, epsFlipping): self.thisptr.epsFlipping = epsFlipping
-
-    property numRegularisationSteps:
-        def __get__(self): return self.thisptr.numRegularisationSteps
-        def __set__(self, numRegularisationSteps): self.thisptr.numRegularisationSteps = numRegularisationSteps
-
-    property epsRegularisation:
-        def __get__(self): return self.thisptr.epsRegularisation
-        def __set__(self, epsRegularisation): self.thisptr.epsRegularisation = epsRegularisation
-
-    property numRefinementSteps:
-        def __get__(self): return self.thisptr.numRefinementSteps
-        def __set__(self, numRefinementSteps): self.thisptr.numRefinementSteps = numRefinementSteps
-
-    property epsIterRef:
-        def __get__(self): return self.thisptr.epsIterRef
-        def __set__(self, epsIterRef): self.thisptr.epsIterRef = epsIterRef
-
-    property epsLITests:
-        def __get__(self): return self.thisptr.epsLITests
-        def __set__(self, epsLITests): self.thisptr.epsLITests = epsLITests
-
-    property epsNZCTests:
-        def __get__(self): return self.thisptr.epsNZCTests
-        def __set__(self, epsNZCTests): self.thisptr.epsNZCTests = epsNZCTests
-
-    property dropBoundPriority:
-        def __get__(self): return self.thisptr.dropBoundPriority
-        def __set__(self, dropBoundPriority): self.thisptr.dropBoundPriority = dropBoundPriority
-
-    property dropEqConPriority:
-        def __get__(self): return self.thisptr.dropEqConPriority
-        def __set__(self, dropEqConPriority): self.thisptr.dropEqConPriority = dropEqConPriority
-
-    property dropIneqConPriority:
-        def __get__(self): return self.thisptr.dropIneqConPriority
-        def __set__(self, dropIneqConPriority): self.thisptr.dropIneqConPriority = dropIneqConPriority
-
-
-
-cdef class PyQProblemB:
-    cdef QProblemB *thisptr      # hold a C++ instance which we're wrapping
-    def __cinit__(self, int nV):
-        # FIXME: allow other HessianTypes!
-        self.thisptr = new QProblemB(nV, HST_UNKNOWN)
-    def __dealloc__(self):
-        del self.thisptr
-
-    def init(self,
-             np.ndarray[np.double_t, ndim=2] H,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             nWSR,
-             cputime = 0.0
-        ):
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = nWSR
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime
-
-            return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <int&>    nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
-                    )
-
-        return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <int&> nWSR_tmp.data[0]
-                    )
-
-    def hotstart(self,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             nWSR,
-             cputime = 0.0
-        ):
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = nWSR#np.asarray(nWSR, dtype=int)
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime#np.asarray(cputime, dtype=float)
-
-            return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <int&>    nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
-                )
-
-        return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <int&>    nWSR_tmp.data[0]
-            )
-
-    def getPrimalSolution(self, np.ndarray[np.double_t, ndim=1] xOpt):
-        return self.thisptr.getPrimalSolution(<double*> xOpt.data)
-
-    def getDualSolution(self, np.ndarray[np.double_t, ndim=1] yOpt):
-        return self.thisptr.getDualSolution(<double*> yOpt.data)
-
-    def getObjVal(self):
-        return self.thisptr.getObjVal()
-
-    def printOptions(self):
-        return self.thisptr.printOptions()
-
-    def getOptions(self):
-        # FIXME: memory management? who deallocates o
-        cdef Options *o = new Options(self.thisptr.getOptions())
-        retval = PyOptions()
-        retval.thisptr = o
-        return retval
-
-    def setOptions(self, PyOptions options):
-        self.thisptr.setOptions(deref(options.thisptr))
-
-
-cdef class PyQProblem:
-    cdef QProblem *thisptr      # hold a C++ instance which we're wrapping
-    def __cinit__(self, int nV, int nC):
-        self.thisptr = new QProblem(nV, nC, HST_UNKNOWN)
-    def __dealloc__(self):
-        del self.thisptr
-
-    cpdef init(self,
-             np.ndarray[np.double_t, ndim=2] H,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=2] A,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             np.ndarray[np.double_t, ndim=1] lbA,
-             np.ndarray[np.double_t, ndim=1] ubA,
-             nWSR,
-             cputime=0.0):
-
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = nWSR
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime
-
-            return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
-                )
-
-        return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0]
-                )
-
-    cpdef hotstart(self,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             np.ndarray[np.double_t, ndim=1] lbA,
-             np.ndarray[np.double_t, ndim=1] ubA,
-             nWSR,
-             cputime=0.0
-        ):
-
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = nWSR
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime
-
-            return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
-                )
-
-        return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0]
-                )
-
-    cpdef getPrimalSolution(self, np.ndarray[np.double_t, ndim=1] xOpt):
-        return self.thisptr.getPrimalSolution(<double*> xOpt.data)
-
-    cpdef getDualSolution(self, np.ndarray[np.double_t, ndim=1] yOpt):
-        return self.thisptr.getDualSolution(<double*> yOpt.data)
-
-    cpdef getObjVal(self):
-        return self.thisptr.getObjVal()
-
-    cpdef printOptions(self):
-        return self.thisptr.printOptions()
-
-    cpdef setOptions(self, PyOptions options):
-        self.thisptr.setOptions(deref(options.thisptr))
-
-cdef class PySQProblem:
-    cdef SQProblem *thisptr      # hold a C++ instance which we're wrapping
-    def __cinit__(self, int nV, int nC):
-        self.thisptr = new SQProblem(nV, nC, HST_UNKNOWN)
-    def __dealloc__(self):
-        del self.thisptr
-
-    cpdef init(self,
-             np.ndarray[np.double_t, ndim=2] H,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=2] A,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             np.ndarray[np.double_t, ndim=1] lbA,
-             np.ndarray[np.double_t, ndim=1] ubA,
-             nWSR,
-             cputime=0.0):
-
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = np.asarray(nWSR, dtype=int)
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime
-
-            return self.thisptr.init(
-                        <double*> H.data,
-                        <double*> g.data,
-                        <double*> A.data,
-                        <double*> lb.data,
-                        <double*> ub.data,
-                        <double*> lbA.data,
-                        <double*> ubA.data,
-                        <int&>    nWSR_tmp.data[0],
-                        <double*> &cput_tmp.data[0]
-                )
-
-        return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0],
-        )
-
-    cpdef hotstart(self,
-             np.ndarray[np.double_t, ndim=2] H,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=2] A,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             np.ndarray[np.double_t, ndim=1] lbA,
-             np.ndarray[np.double_t, ndim=1] ubA,
-             nWSR,
-             cputime=0.0):
-
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = nWSR
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime
-
-            return self.thisptr.hotstart(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
-            )
-
-        return self.thisptr.hotstart(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0],
-        )
-
-    cpdef getPrimalSolution(self, np.ndarray[np.double_t, ndim=1] xOpt):
-        return self.thisptr.getPrimalSolution(<double*> xOpt.data)
-
-    cpdef getDualSolution(self, np.ndarray[np.double_t, ndim=1] yOpt):
-        return self.thisptr.getDualSolution(<double*> yOpt.data)
-
-    cpdef getObjVal(self):
-        return self.thisptr.getObjVal()
-
-    cpdef printOptions(self):
-        return self.thisptr.printOptions()
-
-    cpdef setOptions(self, PyOptions options):
-        self.thisptr.setOptions(deref(options.thisptr))
-
-
-cdef class PySolutionAnalysis:
-    cdef SolutionAnalysis *thisptr      # hold a C++ instance which we're wrapping
-    def __cinit__(self):
-        self.thisptr = new SolutionAnalysis()
-    def __dealloc__(self):
-        del self.thisptr
-
-    cpdef getKktViolation(self, qp,
-        np.ndarray[np.double_t, ndim=1] maxStat,
-        np.ndarray[np.double_t, ndim=1] maxFeas,
-        np.ndarray[np.double_t, ndim=1] maxCmpl
-    ):
-        """ """
-        if isinstance(qp, PyQProblemB):
-            return self._getKktViolation_QProblemB(qp, maxStat, maxFeas, maxCmpl)
-
-        elif isinstance(qp, PyQProblem):
-            return self._getKktViolation_QProblem(qp, maxStat, maxFeas, maxCmpl)
-
-        elif isinstance(qp, PySQProblem):
-            return self._getKktViolation_SQProblem(qp, maxStat, maxFeas, maxCmpl)
-
-        else:
-            raise ValueError('argument 1 must be QProblemB, QProblem or SQProblem')
-
-    cpdef _getKktViolation_QProblemB(self,
-            PyQProblemB qp,
-            np.ndarray[np.double_t, ndim=1] maxStat,
-            np.ndarray[np.double_t, ndim=1] maxFeas,
-            np.ndarray[np.double_t, ndim=1] maxCmpl
-        ):
-        return self.thisptr.getKktViolation(
-                qp.thisptr,
-                <real_t*> maxStat.data[0],
-                <real_t*> maxFeas.data[0],
-                <real_t*> maxCmpl.data[0]
-            )
-
-    cpdef _getKktViolation_QProblem(self,
-            PyQProblem qp,
-            np.ndarray[np.double_t, ndim=1] maxStat,
-            np.ndarray[np.double_t, ndim=1] maxFeas,
-            np.ndarray[np.double_t, ndim=1] maxCmpl
-        ):
-        return self.thisptr.getKktViolation(
-                qp.thisptr,
-                <real_t*> maxStat.data[0],
-                <real_t*> maxFeas.data[0],
-                <real_t*> maxCmpl.data[0]
-            )
-
-
-    cpdef _getKktViolation_SQProblem(self,
-            PySQProblem qp,
-            np.ndarray[np.double_t, ndim=1] maxStat,
-            np.ndarray[np.double_t, ndim=1] maxFeas,
-            np.ndarray[np.double_t, ndim=1] maxCmpl
-        ):
-        return self.thisptr.getKktViolation(
-                qp.thisptr,
-                <real_t*> maxStat.data[0],
-                <real_t*> maxFeas.data[0],
-                <real_t*> maxCmpl.data[0]
-            )
-
-    cpdef getVarianceCovariance(self,
-                              qp,
-                              np.ndarray[np.double_t, ndim=1] g_b_bA_VAR,
-                              np.ndarray[np.double_t, ndim=1] Primal_Dual_VAR ):
-
-        if isinstance(qp, PyQProblemB):
-            return self._getVarianceCovariance_QProblemB(qp, g_b_bA_VAR, Primal_Dual_VAR)
-
-        elif isinstance(qp, PyQProblem):
-            return self._getVarianceCovariance_QProblem(qp, g_b_bA_VAR, Primal_Dual_VAR)
-
-        elif isinstance(qp, PySQProblem):
-            return self._getVarianceCovariance_SQProblem(qp, g_b_bA_VAR, Primal_Dual_VAR)
-
-        else:
-            raise ValueError('argument 1 must be QProblemB, QProblem or SQProblem')
-
-    cpdef _getVarianceCovariance_QProblemB(self,
-                              PyQProblemB qp,
-                              np.ndarray[np.double_t, ndim=1] g_b_bA_VAR,
-                              np.ndarray[np.double_t, ndim=1] Primal_Dual_VAR ):
-        return self.thisptr.getVarianceCovariance(qp.thisptr,
-                                                  <double*> g_b_bA_VAR.data,
-                                                  <double*> Primal_Dual_VAR.data)
-
-    cpdef _getVarianceCovariance_QProblem(self,
-                              PyQProblem qp,
-                              np.ndarray[np.double_t, ndim=1] g_b_bA_VAR,
-                              np.ndarray[np.double_t, ndim=1] Primal_Dual_VAR ):
-        return self.thisptr.getVarianceCovariance(qp.thisptr,
-                                                  <double*> g_b_bA_VAR.data,
-                                                  <double*> Primal_Dual_VAR.data)
-
-    cpdef _getVarianceCovariance_SQProblem(self,
-                              PySQProblem qp,
-                              np.ndarray[np.double_t, ndim=1] g_b_bA_VAR,
-                              np.ndarray[np.double_t, ndim=1] Primal_Dual_VAR ):
-        return self.thisptr.getVarianceCovariance(qp.thisptr,
-                                                  <double*> g_b_bA_VAR.data,
-                                                  <double*> Primal_Dual_VAR.data)
-
-# Wrapped some utility functions for unit testing
-cpdef py_runOqpBenchmark(path,               # Full path of the benchmark files (without trailing slash!).
-                         isSparse,           # Shall convert matrices to sparse format before solution?
-                         useHotstarts,       # Shall QP solution be hotstarted?
-                         PyOptions options,  # QP solver options to be used while solving benchmark problems.
-                         int maxAllowedNWSR, # Maximum number of working set recalculations to be performed.
-                         double maxCPUTime,  # Maximum allowed CPU time for qp solving.
-                         ):
-    """run a QP benchmark example"""
-    maxNWSR            = 0.0 # Output: Maximum number of performed working set recalculations.
-    avgNWSR            = 0.0 # Output: Average number of performed working set recalculations.
-    maxCPUtime         = 0.0 # Output: Maximum CPU time required for solving each QP.
-    avgCPUtime         = 0.0 # Output: Average CPU time required for solving each QP.
-    maxStationarity    = 0.0 # Output: Maximum residual of stationarity condition.
-    maxFeasibility     = 0.0 # Output: Maximum residual of primal feasibility condition.
-    maxComplementarity = 0.0 # Output: Maximum residual of complementarity condition.
-
-    maxCPUtime = maxCPUTime
-
-    p = path.encode()
-    returnValue = runOqpBenchmark(p,
-                                  isSparse,
-                                  useHotstarts,
-                                  deref(options.thisptr),
-                                  maxAllowedNWSR,
-                                  maxNWSR,
-                                  avgNWSR,
-                                  maxCPUtime,
-                                  avgCPUtime,
-                                  maxStationarity,
-                                  maxFeasibility,
-                                  maxComplementarity)
-
-    return returnValue, maxNWSR, avgNWSR, maxCPUtime, avgCPUtime, \
-           maxStationarity, maxFeasibility, maxComplementarity
-
-"""
-def py_getKktViolation(int nV,                              # Number of variables.
-                       int nC,                              # Number of constraints.
-                       np.ndarray[np.double_t, ndim=2] H,   # Hessian matrix.
-                       np.ndarray[np.double_t, ndim=1] g,   # Sequence of gradient vectors.
-                       np.ndarray[np.double_t, ndim=2] A,   # Constraint matrix.
-                       np.ndarray[np.double_t, ndim=1] lb,  # Sequence of lower bound vectors (on variables).
-                       np.ndarray[np.double_t, ndim=1] ub,  # Sequence of upper bound vectors (on variables).
-                       np.ndarray[np.double_t, ndim=1] lbA, # Sequence of lower constraints' bound vectors.
-                       np.ndarray[np.double_t, ndim=1] ubA, # Sequence of upper constraints' bound vectors.
-                       np.ndarray[np.double_t, ndim=1] x,   # Sequence of primal trial vectors.
-                       np.ndarray[np.double_t, ndim=1] y,   # Sequence of dual trial vectors.
-                       ):
-    stat = 0.0 # Maximum value of stationarity condition residual.
-    feas = 0.0 # Maximum value of primal feasibility violation.
-    cmpl = 0.0 # Maximum value of complementarity residual.
-    getKktViolation(nV,
-                    nC,
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <double*> x.data,
-                    <double*> y.data,
-                    stat,
-                    feas,
-                    cmpl
-                    )
-    return stat, feas, cmpl
-    """
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/setup.py b/extlibs/qpOASES-3.2.0/interfaces/python/setup.py
deleted file mode 100755
index a5ef489..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/setup.py
+++ /dev/null
@@ -1,71 +0,0 @@
-#!/usr/bin/env python
-"""qpOASES python distutils setup script."""
-
-#
-#  This file is part of qpOASES.
-#
-#  qpOASES -- An Implementation of the Online Active Set Strategy.
-#  Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-#  Christian Kirches et al. All rights reserved.
-#
-#  qpOASES is free software; you can redistribute it and/or
-#  modify it under the terms of the GNU Lesser General Public
-#  License as published by the Free Software Foundation; either
-#  version 2.1 of the License, or (at your option) any later version.
-#
-#  qpOASES is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-#  See the GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public
-#  License along with qpOASES; if not, write to the Free Software
-#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
-#
-
-#
-#   Filename:  setup.py
-#   Author:    Sebastian F. Walter, Manuel Kudruss
-#   Version:   3.2
-#   Date:      2013-2015
-#
-
-import os
-import numpy as np
-
-from distutils.core import setup
-from distutils.extension import Extension
-from Cython.Distutils import build_ext
-from Cython.Build import cythonize
-
-BASEDIR = os.path.dirname(os.path.abspath(__file__))
-BASEDIR = os.path.dirname(BASEDIR)
-BASEDIR = os.path.dirname(BASEDIR)
-
-extra_params = {}
-extra_params['include_dirs'] = [
-    '/usr/include',
-    os.path.join(BASEDIR, 'include'),
-    os.path.join(BASEDIR, 'include', 'qpOASES'),
-    np.get_include()]
-extra_params['extra_compile_args'] = ["-O2", "-Wno-unused-variable"]
-extra_params['extra_link_args'] = ["-Wl,-O1", "-Wl,--as-needed"]
-
-extra_params = extra_params.copy()
-extra_params['libraries'] = ['qpOASES']
-
-extra_params['library_dirs'] = ['/usr/lib', os.path.join(BASEDIR, 'bin')]
-extra_params['language'] = 'c++'
-
-if os.name == 'posix':
-    extra_params['runtime_library_dirs'] = extra_params['library_dirs']
-
-ext_modules = [
-    Extension("qpoases",  ["qpoases.pyx", "qpoases.pxd"],   **extra_params),
-]
-
-setup(
-    name='qpOASES interface',
-    cmdclass={'build_ext': build_ext},
-    ext_modules=cythonize(ext_modules),
-)
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/tests/__init__.py b/extlibs/qpOASES-3.2.0/interfaces/python/tests/__init__.py
deleted file mode 100644
index 8b13789..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/tests/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/tests/test_examples.py b/extlibs/qpOASES-3.2.0/interfaces/python/tests/test_examples.py
deleted file mode 100644
index ba69be6..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/tests/test_examples.py
+++ /dev/null
@@ -1,360 +0,0 @@
-"""
-This file is part of qpOASES.
-
-qpOASES -- An Implementation of the Online Active Set Strategy.
-Copyright (C) 2007-2015 by Hans Joachim Ferreau et al. All rights reserved.
-
-qpOASES is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-qpOASES is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-See the GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with qpOASES; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-author Manuel Kudruss
-version 3.2
-date 2013-2015
-"""
-
-import os
-import re
-import numpy as np
-from numpy.testing import *
-from subprocess import Popen, PIPE, STDOUT
-
-from qpoases import PyQProblem as QProblem
-from qpoases import PyQProblemB as QProblemB
-from qpoases import PySQProblem as SQProblem
-from qpoases import PySolutionAnalysis as SolutionAnalysis
-from qpoases import PyBooleanType as BooleanType
-from qpoases import PySubjectToStatus as SubjectToStatus
-from qpoases import PyOptions as Options
-from qpoases import PyPrintLevel as PrintLevel
-
-# get qpOASES path
-qpoases_path = os.path.dirname(os.path.abspath(__file__))
-qpoases_path = os.path.dirname(qpoases_path)
-qpoases_path = os.path.dirname(qpoases_path)
-qpoases_path = os.path.dirname(qpoases_path)
-
-# set qpOASES binary path
-bin_path = os.path.join(qpoases_path, "bin")
-
-class TestExamples(TestCase):
-
-    def test_example1(self):
-        return 0
-        # Example for qpOASES main function using the QProblem class.
-        #Setup data of first QP.
-
-        H   = np.array([1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-        A   = np.array([1.0, 1.0 ]).reshape((2,1))
-        g   = np.array([1.5, 1.0 ])
-        lb  = np.array([0.5, -2.0])
-        ub  = np.array([5.0, 2.0 ])
-        lbA = np.array([-1.0 ])
-        ubA = np.array([2.0])
-
-        # Setup data of second QP.
-
-        g_new   = np.array([1.0, 1.5])
-        lb_new  = np.array([0.0, -1.0])
-        ub_new  = np.array([5.0, -0.5])
-        lbA_new = np.array([-2.0])
-        ubA_new = np.array([1.0])
-
-        # Setting up QProblemB object.
-        qp = QProblem(2, 1)
-        options = Options()
-        options.printLevel = PrintLevel.NONE
-        qp.setOptions(options)
-
-        # Solve first QP.
-        nWSR = 10
-        qp.init(H, g, A, lb, ub, lbA, ubA, nWSR)
-
-        # Solve second QP.
-        nWSR = 10
-        qp.hotstart(g_new, lb_new, ub_new, lbA_new, ubA_new, nWSR)
-
-        # Get and print solution of second QP.
-        xOpt_actual = np.zeros(2)
-        qp.getPrimalSolution(xOpt_actual)
-        xOpt_actual = np.asarray(xOpt_actual, dtype=float)
-        objVal_actual = qp.getObjVal()
-        objVal_actual = np.asarray(objVal_actual, dtype=float)
-
-        cmd = os.path.join(bin_path, "example1")
-        p = Popen(cmd, shell=True, stdout=PIPE)
-        stdout, stderr = p.communicate()
-        stdout = str(stdout).replace('\\n', '\n')
-        stdout = stdout.replace("'", '')
-        print(stdout)
-
-        # get c++ solution from std
-        pattern = re.compile(r'xOpt\s*=\s*\[\s+(?P<xOpt>([0-9., e+-])*)\];')
-        match = pattern.search(stdout)
-        xOpt_expected = match.group('xOpt')
-        xOpt_expected = xOpt_expected.split(",")
-        xOpt_expected = np.asarray(xOpt_expected, dtype=float)
-
-        pattern = re.compile(r'objVal = (?P<objVal>[0-9-+e.]*)')
-        match = pattern.search(stdout)
-        objVal_expected = match.group('objVal')
-        objVal_expected = np.asarray(objVal_expected, dtype=float)
-
-        print("xOpt_actual =", xOpt_actual)
-        print("xOpt_expected =", xOpt_expected)
-        print("objVal_actual = ", objVal_actual)
-        print("objVal_expected = ", objVal_expected)
-
-        assert_almost_equal(xOpt_actual, xOpt_expected, decimal=7)
-        assert_almost_equal(objVal_actual, objVal_expected, decimal=7)
-
-    def test_example1b(self):
-        """Example for qpOASES main function using the QProblemB class."""
-        # Setup data of first QP.
-        H = np.array([1.0, 0.0, 0.0, 0.5]).reshape((2, 2))
-        g = np.array([1.5, 1.0])
-        lb = np.array([0.5, -2.0])
-        ub = np.array([5.0, 2.0])
-
-        # Setup data of second QP.
-
-        g_new = np.array([1.0, 1.5])
-        lb_new = np.array([0.0, -1.0])
-        ub_new = np.array([5.0, -0.5])
-
-        # Setting up QProblemB object.
-        qp = QProblemB(2)
-
-        options = Options()
-        # options.enableFlippingBounds = BooleanType.FALSE
-        options.initialStatusBounds = SubjectToStatus.INACTIVE
-        options.numRefinementSteps = 1
-        options.enableCholeskyRefactorisation = 1
-        options.printLevel = PrintLevel.NONE
-        qp.setOptions(options)
-
-        # Solve first QP.
-        nWSR = 10
-        qp.init(H, g, lb, ub, nWSR)
-
-        xOpt_actual = np.zeros(2)
-        qp.getPrimalSolution(xOpt_actual)
-        xOpt_actual = np.asarray(xOpt_actual, dtype=float)
-        objVal_actual = qp.getObjVal()
-        objVal_actual = np.asarray(objVal_actual, dtype=float)
-        print 'xOpt_actual:', xOpt_actual
-        print 'objVal_actual:', objVal_actual
-
-        # Solve second QP.
-        nWSR = 10
-        qp.hotstart(g_new, lb_new, ub_new, nWSR)
-
-        xOpt_actual = np.zeros(2)
-        qp.getPrimalSolution(xOpt_actual)
-        xOpt_actual = np.asarray(xOpt_actual, dtype=float)
-        objVal_actual = qp.getObjVal()
-        objVal_actual = np.asarray(objVal_actual, dtype=float)
-        print 'xOpt_actual:', xOpt_actual
-        print 'objVal_actual:', objVal_actual
-
-        # Get and print solution of second QP.
-        xOpt_actual = np.zeros(2)
-        qp.getPrimalSolution(xOpt_actual)
-        xOpt_actual = np.asarray(xOpt_actual, dtype=float)
-        objVal_actual = qp.getObjVal()
-        objVal_actual = np.asarray(objVal_actual, dtype=float)
-
-        cmd = os.path.join(bin_path, "example1b")
-        p = Popen(cmd, shell=True, stdout=PIPE)
-        stdout, stderr = p.communicate()
-        stdout = str(stdout).replace('\\n', '\n')
-        stdout = stdout.replace("'", '')
-
-        # get c++ solution from std
-        pattern = re.compile(r'xOpt\s*=\s*\[\s+(?P<xOpt>([0-9., e+-])*)\];')
-        match = pattern.findall(stdout)
-        xOpt_expected = match[-1][0]
-        xOpt_expected = xOpt_expected.split(",")
-        xOpt_expected = np.asarray(xOpt_expected, dtype=float)
-
-        pattern = re.compile(r'objVal = (?P<objVal>[0-9-+e.]*)')
-        match = pattern.findall(stdout)
-        print match
-        objVal_expected = match[-1]
-        objVal_expected = np.asarray(objVal_expected, dtype=float)
-
-        print("xOpt_actual =", xOpt_actual)
-        print("xOpt_expected =", xOpt_expected)
-        print("objVal_actual = ", objVal_actual)
-        print("objVal_expected = ", objVal_expected)
-
-        assert_almost_equal(xOpt_actual, xOpt_expected, decimal=7)
-        assert_almost_equal(objVal_actual, objVal_expected, decimal=7)
-
-
-    def test_example2(self):
-        # Example for qpOASES main function using the SQProblem class.
-        #  Setup data of first QP.
-        H = np.array([ 1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-        A = np.array([ 1.0, 1.0 ]).reshape((2,1))
-        g = np.array([ 1.5, 1.0 ])
-        lb = np.array([ 0.5, -2.0 ])
-        ub = np.array([ 5.0, 2.0 ])
-        lbA = np.array([ -1.0 ])
-        ubA = np.array([ 2.0 ])
-
-        #  Setup data of second QP.
-        H_new = np.array([ 1.0, 0.5, 0.5, 0.5 ]).reshape((2,2))
-        A_new = np.array([ 1.0, 5.0 ]).reshape((2,1))
-        g_new = np.array([ 1.0, 1.5 ])
-        lb_new = np.array([ 0.0, -1.0 ])
-        ub_new = np.array([ 5.0, -0.5 ])
-        lbA_new = np.array([ -2.0 ])
-        ubA_new = np.array([ 1.0 ])
-
-        #  Setting up SQProblem object and solution analyser.
-        qp = SQProblem(2, 1)
-        options = Options()
-        options.printLevel = PrintLevel.NONE
-        qp.setOptions(options)
-
-        analyser = SolutionAnalysis()
-
-        # get c++ solution from std
-        cmd = os.path.join(bin_path, "example2")
-        p = Popen(cmd, shell=True, stdout=PIPE)
-        stdout, stderr = p.communicate()
-        stdout = str(stdout).replace('\\n', '\n')
-        stdout = stdout.replace("'", '')
-        print(stdout)
-
-        #  Solve first QP ...
-        nWSR = 10
-        qp.init(H, g, A, lb, ub, lbA, ubA, nWSR)
-
-        #  ... and analyse it.
-        maxViol = np.zeros(1)
-        maxStat = np.zeros(1)
-        maxFeas = np.zeros(1)
-        maxCmpl = np.zeros(1)
-        maxViol[0] = analyser.getKktViolation(
-            qp, maxStat, maxFeas, maxCmpl
-        )
-        print("maxViol: %e\n" % maxViol)
-        actual = np.asarray(maxViol)
-
-        pattern = re.compile(
-            r'maxKktViolation: (?P<KktViolation>[0-9+-e.]*)'
-        )
-
-        match = pattern.findall(stdout)
-        expected = np.asarray(match[0], dtype=float)
-
-        assert_almost_equal(actual, expected, decimal=7)
-
-        #  Solve second QP ...
-        nWSR = 10
-        qp.hotstart(
-            H_new, g_new, A_new,
-            lb_new, ub_new,
-            lbA_new, ubA_new,
-            nWSR
-        )
-
-        #  ... and analyse it.
-        maxViol = np.zeros(1)
-        maxStat = np.zeros(1)
-        maxFeas = np.zeros(1)
-        maxCmpl = np.zeros(1)
-        maxViol[0] = analyser.getKktViolation(
-            qp, maxStat, maxFeas, maxCmpl
-        )
-        print("maxViol: %e\n" % maxViol)
-        actual = np.asarray(maxViol)
-
-        expected = np.asarray(match[1], dtype=float)
-
-        assert_almost_equal(actual, expected, decimal=7)
-
-        # ------------ VARIANCE-COVARIANCE EVALUATION --------------------
-
-        Var = np.zeros(5*5)
-        Primal_Dual_Var = np.zeros(5*5)
-
-        Var.reshape((5, 5))[0, 0] = 1.
-        Var.reshape((5, 5))[1, 1] = 1.
-
-        #                  (  1   0   0   0   0   )
-        #                  (  0   1   0   0   0   )
-        #     Var     =    (  0   0   0   0   0   )
-        #                  (  0   0   0   0   0   )
-        #                  (  0   0   0   0   0   )
-
-        analyser.getVarianceCovariance(qp, Var, Primal_Dual_Var)
-        print('Primal_Dual_Var=\n', Primal_Dual_Var.reshape((5, 5)))
-        actual = Primal_Dual_Var.reshape((5, 5))
-
-        pattern = re.compile(
-            r'Primal_Dual_VAR = (?P<VAR>.*)',
-            re.DOTALL
-        )
-
-        print(stdout)
-        match = pattern.search(stdout)
-        expected = match.group('VAR').strip().split("\n")
-        expected = [x.strip().split() for x in expected]
-        print(expected)
-        expected = np.asarray(expected, dtype=float)
-
-        assert_almost_equal(actual, expected, decimal=7)
-
-    def test_example7(self):
-        H   = np.array([
-            0.8514828085899353, -0.15739890933036804, -0.081726007163524628, -0.530426025390625, 0.16773293912410736,
-           -0.15739890933036804, 1.1552412509918213, 0.57780224084854126, -0.0072606131434440613, 0.010559185408055782,
-           -0.081726007163524628, 0.57780224084854126, 0.28925251960754395, 5.324830453901086e-006, -3.0256599075073609e-006,
-           -0.530426025390625, -0.0072606131434440613, 5.324830453901086e-006, 0.35609596967697144, -0.15124998986721039,
-            0.16773293912410736, 0.010559185408055782, -3.0256599075073609e-006, -0.15124998986721039, 0.15129712224006653
-            ], dtype=float
-        ).reshape((5, 5))
-        g   = np.array([0.30908384919166565, 0.99325823783874512, 0.49822014570236206, -0.26309865713119507, 0.024296050891280174], dtype=float).reshape((5,))
-        A   = np.array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], dtype=float).reshape((5, 5))
-        lb  = np.array([-0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359938621520996], dtype=float).reshape((5,))
-        ub  = np.array([ 0.052359879016876221, 0.052359879016876221, 0.052359879016876221, 0, 0], dtype=float).reshape((5,))
-        lbA = np.array([-0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359938621520996], dtype=float).reshape((5,))
-        ubA = np.array([0.052359879016876221, 0.052359879016876221, 0.052359879016876221, 0, 0], dtype=float).reshape((5,))
-
-        # Setting up QProblem object.
-        qp = QProblem(5, 5)
-        options = Options()
-        options.printLevel = PrintLevel.NONE
-        qp.setOptions(options)
-
-        # Solve first QP.
-        nWSR = 100
-        qp.init(H, g, A, lb, ub, lbA, ubA,  nWSR)
-
-        result = np.zeros((5,))
-        qp.getPrimalSolution(result)
-
-        # TODO check against what?
-        # Where can I find solution?
-
-if __name__=="__main__":
-    try:
-        import nose
-        nose.runmodule()
-
-    except ImportError:
-        sys.stderr.write("Please install nosestests for python unittesting.\n")
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/scilab/Makefile b/extlibs/qpOASES-3.2.0/interfaces/scilab/Makefile
deleted file mode 100644
index 4618962..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/scilab/Makefile
+++ /dev/null
@@ -1,93 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  interfaces/scilab/Makefile
-##	Author:    Holger Diedam, Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-
-
-PATH_LIB = .
-PATH_SRC = .
-PATH_OBJ = .
-PATH_QPOASES_INC = ../../include
-PATH_QPOASES_SRC = ../../src
-PATH_QPOASES_OBJ = ../../src
-
-
-##
-##	bins
-##
-
-CC       = gcc
-CPP      = g++
-LD       = g++
-CP       = cp
-
-
-
-##
-##	flags
-##
-
-CFLAGS   = -I$(PATH_QPOASES_INC) -I$(PATH_QPOASES_SRC) -Wall -pedantic -Wshadow -O3 -finline-functions -fPIC
-CPPFLAGS = -I$(PATH_QPOASES_INC) -I$(PATH_QPOASES_SRC) -Wall -pedantic -Wshadow -O3 -finline-functions -fPIC -DLINUX -D__SCILAB__ -D__SINGLE_OBJECT__ 
-LDFLAGS  = -shared
-LIBEXT   = .so
-
-
-LIB = libqpOASESinterface$(LIBEXT)
-
-OBJ = \
-	qpOASESroutines.o \
-	qpOASESinterface.o
-
-
-
-##
-##	targets
-##
-
-all: $(PATH_LIB)/$(LIB)
-
-$(PATH_OBJ)/%.o: $(PATH_SRC)/%.c
-	$(CC) -c -o $(@) $(CFLAGS) $<
-
-$(PATH_OBJ)/%.o: $(PATH_SRC)/%.cpp
-	$(CPP) -c -o $(@) $(CPPFLAGS) $<
-
-$(PATH_LIB)/$(LIB) : $(addprefix $(PATH_OBJ)/, $(OBJ))
-	$(LD) $(LDFLAGS) $^ -o $@
-
-clean:
-	$(RM) $(PATH_OBJ)/*.o $(PATH_LIB)/$(LIB)
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/interfaces/scilab/example1.dat b/extlibs/qpOASES-3.2.0/interfaces/scilab/example1.dat
deleted file mode 100644
index 1c9e594b6da775ef2a23e6db6ce75a676f91f100..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 656
zcmb7AK?;O05bJss77vOy5mvCjnEqU!(jPb{@wiiH&_WOz7}7&C$>dl)#m70<<T1)n
z!K>sb9o^zR_9VV><vl9ri$Aot4*n`b%MGC^{UUPjQ<bg{**gp^Pnvu%kDS|7_1}eV
o8NV|*iQj`BF6)5{xef`{^3~|jL)@%~A4`f35<g&l*Zf!c0|-Py!2kdN

diff --git a/extlibs/qpOASES-3.2.0/interfaces/scilab/example1a.dat b/extlibs/qpOASES-3.2.0/interfaces/scilab/example1a.dat
deleted file mode 100644
index 4e67850dc07986750160308909887ba9fd3a9eef..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 784
zcmb7>O$x*y427N97KSb=-AQ2z^%n8wouhaIvnpLq1Rst}5DbL4@VzfT>F{bij4{uW
zQc5u4)z(O}>f$|oa;<R}AEv9rhqmg#XR?zHgr?<1^!;%|x+N5Lu#?_t<{*FiJl)WL
z6ViKqZOTZPC*Pt5_JFx+o%g;^yBGM}banXX;h(?AUUVQdEe{SX`x(*U4)K&bsGVjG
M5)`R&?~(sZUuq^%egFUf

diff --git a/extlibs/qpOASES-3.2.0/interfaces/scilab/example1b.dat b/extlibs/qpOASES-3.2.0/interfaces/scilab/example1b.dat
deleted file mode 100644
index b591a7ddcf2ea8854c8bfdf5ba1193068bc1cce2..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 408
zcmaE_u7MRWGB7YOK{1emf)DmE7ApO~UI42p8X7QjKr{mUfSU8cUX&ZVM(p|?!0bOD
tN0L4f2dLc+0xIHs3RtYfZXe9QKY;GUt`WOFm`^|Kmm^6Z%$*PR0|49CCeQ!?

diff --git a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.c b/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.c
deleted file mode 100644
index 469041c..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.c
+++ /dev/null
@@ -1,893 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/scilab/qpOASESinterface.c
- *	\author Holger Diedam, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface that enables to call qpOASES from scilab.
- *  (Please excuse a lot of copy and paste...)
- *
- */
-
-
-#include <stdio.h>
-#include <string.h>
-
-#include <scilab/stack-c.h>
-#include <scilab/Scierror.h>
-
-#include "../c/qpOASES_wrapper.h"
-
-
-
-extern int interface_qpOASES( char* fname );
-
-extern int interface_QProblem_init(  char* fname );
-extern int interface_QProblemB_init( char* fname );
-extern int interface_SQProblem_init( char* fname );
-
-extern int interface_QProblem_hotstart(  char* fname );
-extern int interface_QProblemB_hotstart( char* fname );
-extern int interface_SQProblem_hotstart( char* fname );
-
-extern int interface_QProblem_cleanup(  char* fname );
-extern int interface_QProblemB_cleanup( char* fname );
-extern int interface_SQProblem_cleanup( char* fname );
-
-
-typedef int (*gate_function) ( char* );
-extern int sci_gateway( char* name, gate_function f );
-extern int C2F(qpOASESgateway)();
-
-
-/* forward declaration of C++ routines */
-void sci_qpOASES(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-					int_t *nV, int_t* nC, int_t* nWSR,
-					real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-					);
-
-void sci_QProblem_init( real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-						int_t *nV, int_t* nC, int_t* nWSR,
-						real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-						);
-void sci_QProblemB_init(	real_t* H, real_t* g, real_t* lb, real_t* ub,
-							int_t *nV, int_t* nWSR,
-							real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-							);
-void sci_SQProblem_init(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-							int_t *nV, int_t* nC, int_t* nWSR,
-							real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-							);
-
-void sci_QProblem_hotstart(		real_t* g, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-void sci_QProblemB_hotstart(	real_t* g, real_t* lb, real_t* ub,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-void sci_SQProblem_hotstart(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-
-void sci_QProblem_cleanup( );
-void sci_QProblemB_cleanup( );
-void sci_SQProblem_cleanup( );
-
-
-/* global variables containing dimensions of matrices
- * (also used to check whether qpOASES object were initialised) */
-static int_t qp_rowsH = -1;
-static int_t qp_rowsA = -1;
-static int_t qpb_rowsH = -1;
-static int_t sqp_rowsH = -1;
-static int_t sqp_rowsA = -1;
-
-
-/*
- *	i n t e r f a c e _ q p O A S E S
- */
-int interface_qpOASES( char* fname )
-{
-	int_t H, H_rows, H_cols;
-	int_t g, g_rows, g_cols;
-	int_t A, A_rows, A_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t lbA, lbA_rows, lbA_cols;
-	int_t ubA, ubA_rows, ubA_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 8, maxrhs = 8, one = 1, y_size;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &H_rows,&H_cols,&H );
-	if ( ( H_rows != H_cols ) || ( H_rows < 1 ) )
-	{
-		Scierror( 111,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == H_rows ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == H_rows ) ) ) )
-	{
-		Scierror( 112,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &A_rows,&A_cols,&A );
-	if ( ( A_cols != H_rows ) || ( A_rows < 1 ) )
-	{
-		Scierror( 113,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &lb_rows,&lb_cols,&lb);
-	if ( !( ( ( lb_rows == H_rows ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 114,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"d", &ub_rows,&ub_cols,&ub);
-	if ( !( ( ( ub_rows == H_rows ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 115,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 6,"d", &lbA_rows,&lbA_cols,&lbA);
-	if ( !( ( ( lbA_rows == A_rows ) && ( lbA_cols == 1 ) ) || ( ( lbA_rows == 0 ) && ( lbA_cols == 0 ) ) ) )
-	{
-		Scierror( 116,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 7,"d", &ubA_rows,&ubA_cols,&ubA);
-	if ( !( ( ( ubA_rows == A_rows ) && ( ubA_cols == 1 ) ) || ( ( ubA_rows == 0 ) && ( ubA_cols == 0 ) ) ) )
-	{
-		Scierror( 117,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 8,"i", &nWSR_rows,&nWSR_cols,&nWSR);
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 118,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	y_size = H_rows + A_rows;
-
-	CreateVar(  9,"d", &H_rows,&one,&x );
-	CreateVar( 10,"d", &one,&one,&obj );
-	CreateVar( 11,"i", &one,&one,&status );
-	CreateVar( 12,"i", &one,&one,&nWSRout );
-	CreateVar( 13,"d", &y_size,&one,&y );
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_qpOASES(	stk(H),stk(g),stk(A), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0, (lbA_rows!=0) ? stk(lbA) : 0, (ubA_rows!=0) ? stk(ubA) : 0,
-					&H_rows,&A_rows,istk(nWSR),
-					stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-					);
-
-	LhsVar(1) = 9;
-	LhsVar(2) = 10;
-	LhsVar(3) = 11;
-	LhsVar(4) = 12;
-	LhsVar(5) = 13;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m _ i n i t
- */
-int interface_QProblem_init( char* fname )
-{
-	int_t H, H_rows, H_cols;
-	int_t g, g_rows, g_cols;
-	int_t A, A_rows, A_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t lbA, lbA_rows, lbA_cols;
-	int_t ubA, ubA_rows, ubA_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 8, maxrhs = 8, one = 1, y_size;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &H_rows,&H_cols,&H );
-	if ( ( H_rows != H_cols ) || ( H_rows < 1 ) )
-	{
-		Scierror( 211,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == H_rows ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == H_rows ) ) ) )
-	{
-		Scierror( 212,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &A_rows,&A_cols,&A );
-	if ( ( A_cols != H_rows ) || ( A_rows < 1 ) )
-	{
-		Scierror( 213,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &lb_rows,&lb_cols,&lb);
-	if ( !( ( ( lb_rows == H_rows ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 214,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"d", &ub_rows,&ub_cols,&ub);
-	if ( !( ( ( ub_rows == H_rows ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 215,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 6,"d", &lbA_rows,&lbA_cols,&lbA);
-	if ( !( ( ( lbA_rows == A_rows ) && ( lbA_cols == 1 ) ) || ( ( lbA_rows == 0 ) && ( lbA_cols == 0 ) ) ) )
-	{
-		Scierror( 216,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 7,"d", &ubA_rows,&ubA_cols,&ubA);
-	if ( !( ( ( ubA_rows == A_rows ) && ( ubA_cols == 1 ) ) || ( ( ubA_rows == 0 ) && ( ubA_cols == 0 ) ) ) )
-	{
-		Scierror( 217,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 8,"i", &nWSR_rows,&nWSR_cols,&nWSR);
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 218,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	y_size = H_rows + A_rows;
-
-	CreateVar(  9,"d", &H_rows,&one,&x );
-	CreateVar( 10,"d", &one,&one,&obj );
-	CreateVar( 11,"i", &one,&one,&status );
-	CreateVar( 12,"i", &one,&one,&nWSRout );
-	CreateVar( 13,"d", &y_size,&one,&y );
-
-
-	qp_rowsH = H_rows;
-	qp_rowsA = A_rows;
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_QProblem_init(	stk(H),stk(g),stk(A), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0, (lbA_rows!=0) ? stk(lbA) : 0, (ubA_rows!=0) ? stk(ubA) : 0,
-						&H_rows,&A_rows,istk(nWSR),
-						stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-						);
-
-	LhsVar(1) = 9;
-	LhsVar(2) = 10;
-	LhsVar(3) = 11;
-	LhsVar(4) = 12;
-	LhsVar(5) = 13;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m B _ i n i t
- */
-int interface_QProblemB_init( char* fname )
-{
-	int_t H, H_rows, H_cols;
-	int_t g, g_rows, g_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 5, maxrhs = 5, one = 1;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &H_rows,&H_cols,&H );
-	if ( ( H_rows != H_cols ) || ( H_rows < 1 ) )
-	{
-		Scierror( 221,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == H_rows ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == H_rows ) ) ) )
-	{
-		Scierror( 222,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &lb_rows,&lb_cols,&lb);
-	if ( !( ( ( lb_rows == H_rows ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 223,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &ub_rows,&ub_cols,&ub);
-	if ( !( ( ( ub_rows == H_rows ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 224,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"i", &nWSR_rows,&nWSR_cols,&nWSR);
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 225,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	CreateVar(  9,"d", &H_rows,&one,&x );
-	CreateVar( 10,"d", &one,&one,&obj );
-	CreateVar( 11,"i", &one,&one,&status );
-	CreateVar( 12,"i", &one,&one,&nWSRout );
-	CreateVar( 13,"d", &H_rows,&one,&y );
-
-
-	qpb_rowsH = H_rows;
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_QProblemB_init( 	stk(H),stk(g), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0,
-							&H_rows,istk(nWSR),
-							stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-							);
-
-	LhsVar(1) = 9;
-	LhsVar(2) = 10;
-	LhsVar(3) = 11;
-	LhsVar(4) = 12;
-	LhsVar(5) = 13;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ S Q P r o b l e m _ i n i t
- */
-int interface_SQProblem_init( char* fname )
-{
-	int_t H, H_rows, H_cols;
-	int_t g, g_rows, g_cols;
-	int_t A, A_rows, A_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t lbA, lbA_rows, lbA_cols;
-	int_t ubA, ubA_rows, ubA_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 8, maxrhs = 8, one = 1, y_size;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &H_rows,&H_cols,&H );
-	if ( ( H_rows != H_cols ) || ( H_rows < 1 ) )
-	{
-		Scierror( 231,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == H_rows ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == H_rows ) ) ) )
-	{
-		Scierror( 232,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &A_rows,&A_cols,&A );
-	if ( ( A_cols != H_rows ) || ( A_rows < 1 ) )
-	{
-		Scierror( 233,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &lb_rows,&lb_cols,&lb );
-	if ( !( ( ( lb_rows == H_rows ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 234,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"d", &ub_rows,&ub_cols,&ub );
-	if ( !( ( ( ub_rows == H_rows ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 235,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 6,"d", &lbA_rows,&lbA_cols,&lbA );
-	if ( !( ( ( lbA_rows == A_rows ) && ( lbA_cols == 1 ) ) || ( ( lbA_rows == 0 ) && ( lbA_cols == 0 ) ) ) )
-	{
-		Scierror( 236,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 7,"d", &ubA_rows,&ubA_cols,&ubA );
-	if ( !( ( ( ubA_rows == A_rows ) && ( ubA_cols == 1 ) ) || ( ( ubA_rows == 0 ) && ( ubA_cols == 0 ) ) ) )
-	{
-		Scierror( 237,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 8,"i", &nWSR_rows,&nWSR_cols,&nWSR) ;
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 238,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	y_size = H_rows + A_rows;
-
-	CreateVar(  9,"d", &H_rows,&one,&x );
-	CreateVar( 10,"d", &one,&one,&obj );
-	CreateVar( 11,"i", &one,&one,&status );
-	CreateVar( 12,"i", &one,&one,&nWSRout );
-	CreateVar( 13,"d", &y_size,&one,&y );
-
-
-	sqp_rowsH = H_rows;
-	sqp_rowsA = A_rows;
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_SQProblem_init( 	stk(H),stk(g),stk(A), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0, (lbA_rows!=0) ? stk(lbA) : 0, (ubA_rows!=0) ? stk(ubA) : 0,
-							&H_rows,&A_rows,istk(nWSR),
-							stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-							);
-	
-	LhsVar(1) = 9;
-	LhsVar(2) = 10;
-	LhsVar(3) = 11;
-	LhsVar(4) = 12;
-	LhsVar(5) = 13;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m _ h o t s t a r t
- */
-int interface_QProblem_hotstart( char* fname )
-{
-	int_t g, g_rows, g_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t lbA, lbA_rows, lbA_cols;
-	int_t ubA, ubA_rows, ubA_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 6, maxrhs = 6, one = 1, y_size;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	if ( ( qp_rowsH == -1 ) || ( qp_rowsA == -1 ) )
-	{
-		Scierror( 311,"ERROR (qpOASES): Need to call qpOASES_init first!\n" );
-		return 0;
-	}
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == qp_rowsH ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == qp_rowsH ) ) ) )
-	{
-		Scierror( 312,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &lb_rows,&lb_cols,&lb );
-	if ( !( ( ( lb_rows == qp_rowsH ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 313,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &ub_rows,&ub_cols,&ub );
-	if ( !( ( ( ub_rows == qp_rowsH ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 314,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &lbA_rows,&lbA_cols,&lbA );
-	if ( !( ( ( lbA_rows == qp_rowsA ) && ( lbA_cols == 1 ) ) || ( ( lbA_rows == 0 ) && ( lbA_cols == 0 ) ) ) )
-	{
-		Scierror( 315,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"d", &ubA_rows,&ubA_cols,&ubA );
-	if ( !( ( ( ubA_rows == qp_rowsA ) && ( ubA_cols == 1 ) ) || ( ( ubA_rows == 0 ) && ( ubA_cols == 0 ) ) ) )
-	{
-		Scierror( 316,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 6,"i", &nWSR_rows,&nWSR_cols,&nWSR );
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 317,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	y_size = qp_rowsH + qp_rowsA;
-
-	CreateVar(  7,"d", &qp_rowsH,&one,&x );
-	CreateVar(  8,"d", &one,&one,&obj );
-	CreateVar(  9,"i", &one,&one,&status );
-	CreateVar( 10,"i", &one,&one,&nWSRout );
-	CreateVar( 11,"d", &y_size,&one,&y );
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_QProblem_hotstart( 	stk(g), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0, (lbA_rows!=0) ? stk(lbA) : 0, (ubA_rows!=0) ? stk(ubA) : 0,
-							istk(nWSR),
-							stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-							);
-	
-	LhsVar(1) = 7;
-	LhsVar(2) = 8;
-	LhsVar(3) = 9;
-	LhsVar(4) = 10;
-	LhsVar(5) = 11;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m B _ h o t s t a r t
- */
-int interface_QProblemB_hotstart( char* fname )
-{
-	int_t g, g_rows, g_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 4, maxrhs = 4, one = 1;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	if ( qpb_rowsH == -1 )
-	{
-		Scierror( 321,"ERROR (qpOASES): Need to call qpOASES_initSB first!\n" );
-		return 0;
-	}
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == qpb_rowsH ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == qpb_rowsH ) ) ) )
-	{
-		Scierror( 322,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &lb_rows,&lb_cols,&lb );
-	if ( !( ( ( lb_rows == qpb_rowsH ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 323,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &ub_rows,&ub_cols,&ub );
-	if ( !( ( ( ub_rows == qpb_rowsH ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 324,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"i", &nWSR_rows,&nWSR_cols,&nWSR );
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 325,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	CreateVar( 5,"d", &qpb_rowsH,&one,&x );
-	CreateVar( 6,"d", &one,&one,&obj );
-	CreateVar( 7,"i", &one,&one,&status );
-	CreateVar( 8,"i", &one,&one,&nWSRout );
-	CreateVar( 9,"d", &qpb_rowsH,&one,&y );
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_QProblemB_hotstart( 	stk(g), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0,
-								istk(nWSR),
-								stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-								);
-
-	LhsVar(1) = 5;
-	LhsVar(2) = 6;
-	LhsVar(3) = 7;
-	LhsVar(4) = 8;
-	LhsVar(5) = 9;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ S Q P r o b l e m _ h o t s t a r t
- */
-int interface_SQProblem_hotstart( char* fname )
-{
-	int_t H, H_rows, H_cols;
-	int_t g, g_rows, g_cols;
-	int_t A, A_rows, A_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t lbA, lbA_rows, lbA_cols;
-	int_t ubA, ubA_rows, ubA_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t obj, x, y, status, nWSRout;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 8, maxrhs = 8, one = 1, y_size;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	if ( ( sqp_rowsH == -1 ) || ( sqp_rowsA == -1 ) )
-	{
-		Scierror( 331,"ERROR (qpOASES): Need to call qpOASES_initVM first!\n" );
-		return 0;
-	}
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &H_rows,&H_cols,&H );
-	if ( ( H_rows != H_cols ) || ( H_rows < 1 ) )
-	{
-		Scierror( 332,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == H_rows ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == H_rows ) ) ) )
-	{
-		Scierror( 333,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &A_rows,&A_cols,&A );
-	if ( ( A_cols != H_rows ) || ( A_rows < 1 ) )
-	{
-		Scierror( 334,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &lb_rows,&lb_cols,&lb);
-	if ( !( ( ( lb_rows == H_rows ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 335,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"d", &ub_rows,&ub_cols,&ub);
-	if ( !( ( ( ub_rows == H_rows ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 399,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 6,"d", &lbA_rows,&lbA_cols,&lbA);
-	if ( !( ( ( lbA_rows == A_rows ) && ( lbA_cols == 1 ) ) || ( ( lbA_rows == 0 ) && ( lbA_cols == 0 ) ) ) )
-	{
-		Scierror( 336,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 7,"d", &ubA_rows,&ubA_cols,&ubA);
-	if ( !( ( ( ubA_rows == A_rows ) && ( ubA_cols == 1 ) ) || ( ( ubA_rows == 0 ) && ( ubA_cols == 0 ) ) ) )
-	{
-		Scierror( 337,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 8,"i", &nWSR_rows,&nWSR_cols,&nWSR);
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 338,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	/* have matrices same dimension as last QP? */
-	if ( ( sqp_rowsH != H_rows ) || ( sqp_rowsA != A_rows ) )
-	{
-		Scierror( 339,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	y_size = H_rows + A_rows;
-
-	CreateVar(  9,"d", &H_rows,&one,&x );
-	CreateVar( 10,"d", &one,&one,&obj );
-	CreateVar( 11,"i", &one,&one,&status );
-	CreateVar( 12,"i", &one,&one,&nWSRout );
-	CreateVar( 13,"d", &y_size,&one,&y );
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_SQProblem_hotstart( 	stk(H),stk(g),stk(A), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0, (lbA_rows!=0) ? stk(lbA) : 0, (ubA_rows!=0) ? stk(ubA) : 0,
-								istk(nWSR),
-								stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-								);
-
-	LhsVar(1) = 9;
-	LhsVar(2) = 10;
-	LhsVar(3) = 11;
-	LhsVar(4) = 12;
-	LhsVar(5) = 13;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m _ c l e a n u p
- */
-int interface_QProblem_cleanup( char* fname )
-{
-	const int minlhs = 0, maxlhs = 1, minrhs = 0, maxrhs = 0;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-	sci_QProblem_cleanup( );
-	qp_rowsH = -1;
-	qp_rowsA = -1;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m B _ c l e a n u p
- */
-int interface_QProblemB_cleanup( char* fname )
-{
-	const int minlhs = 0, maxlhs = 1, minrhs = 0, maxrhs = 0;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-	sci_QProblemB_cleanup( );
-	qpb_rowsH = -1;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ S Q P r o b l e m _ c l e a n u p
- */
-int interface_SQProblem_cleanup( char* fname )
-{
-	const int minlhs = 0, maxlhs = 1, minrhs = 0, maxrhs = 0;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-	sci_SQProblem_cleanup( );
-	sqp_rowsH = -1;
-	sqp_rowsA = -1;
-
-	return 0;
-}
-
-
-/*
- *	q p O A S E S g a t e w a y
- */
-int C2F(qpOASESgateway)( )
-{
-	gate_function function[] = {	interface_qpOASES,
-									interface_QProblem_init,     interface_QProblemB_init,     interface_SQProblem_init,
-									interface_QProblem_hotstart, interface_QProblemB_hotstart, interface_SQProblem_hotstart,
-									interface_QProblem_cleanup,  interface_QProblemB_cleanup,  interface_SQProblem_cleanup
-									};
-	char* name[] = {	"qpOASES",
-						"qpOASES_init",     "qpOASES_initSB",     "qpOASES_initVM",
-						"qpOASES_hotstart", "qpOASES_hotstartSB", "qpOASES_hotstartVM",
-						"qpOASES_cleanup",  "qpOASES_cleanupSB",  "qpOASES_cleanupVM"
-						};
-
-	Rhs = Max( 0,Rhs );
-	sci_gateway( name[Fin-1],function[Fin-1] );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.sce b/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.sce
deleted file mode 100644
index a12b615..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.sce
+++ /dev/null
@@ -1,41 +0,0 @@
-//
-//	This file is part of qpOASES.
-//
-//	qpOASES -- An Implementation of the Online Active Set Strategy.
-//	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-//	Christian Kirches et al. All rights reserved.
-//
-//	qpOASES is free software; you can redistribute it and/or
-//	modify it under the terms of the GNU Lesser General Public
-//	License as published by the Free Software Foundation; either
-//	version 2.1 of the License, or (at your option) any later version.
-//
-//	qpOASES is distributed in the hope that it will be useful,
-//	but WITHOUT ANY WARRANTY; without even the implied warranty of
-//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-//	Lesser General Public License for more details.
-//
-//	You should have received a copy of the GNU Lesser General Public
-//	License along with qpOASES; if not, write to the Free Software
-//	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-//
-
-
-
-//
-//	Filename:  interfaces/scilab/qpOASESinterface.sci
-//	Author:    Holger Diedam, Hans Joachim Ferreau
-//	Version:   3.2
-//	Date:      2007-2015
-//
-
-
-
-sharedlib = link( './libqpOASESinterface.so' );
-addinter( './libqpOASESinterface.so', 'qpOASESgateway', ["qpOASES", "qpOASES_init","qpOASES_initSB","qpOASES_initVM", "qpOASES_hotstart","qpOASES_hotstartSB","qpOASES_hotstartVM", "qpOASES_cleanup","qpOASES_cleanupSB","qpOASES_cleanupVM"] );
-
-
-
-//
-//	end of file
-//
diff --git a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESroutines.cpp b/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESroutines.cpp
deleted file mode 100644
index bb487c8..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESroutines.cpp
+++ /dev/null
@@ -1,369 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/scilab/qpOASESroutines.cpp
- *	\author Holger Diedam, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface that enables to call qpOASES from scilab
- *  (C++ file to provide an interface between the files that
- *  have to be compiled with gcc and the qpOASES library).
- *
- */
-
-
-#include <scilab/Scierror.h>
-
-#include <qpOASES.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-/*extern "C" {
-#include "../c/qpOASES_wrapper.h"
-}*/
-
-
-/* global pointers to qpOASES objects */
-static QProblem*  qp  = 0;
-static QProblemB* qpb = 0;
-static SQProblem* sqp = 0;
-
-
-extern "C"
-{
-	void sci_qpOASES(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-						int_t *nV, int_t* nC, int_t* nWSR,
-						real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-						);
-
-	void sci_QProblem_init( 	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nV, int_t* nC, int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-	void sci_QProblemB_init(	real_t* H, real_t* g, real_t* lb, real_t* ub,
-								int_t* nV, int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-	void sci_SQProblem_init(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nV, int_t* nC, int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-
-	void sci_QProblem_hotstart( 	real_t* g, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-									int_t* nWSR,
-									real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-									);
-	void sci_QProblemB_hotstart(	real_t* g, real_t* lb, real_t* ub,
-									int_t* nWSR,
-									real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-									);
-	void sci_SQProblem_hotstart(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-									int_t* nWSR,
-									real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-									);
-
-	void sci_QProblem_cleanup( );
-	void sci_QProblemB_cleanup( );
-	void sci_SQProblem_cleanup( );
-} /* extern "C" */
-
-
-
-/*
- *	t r a n s f o r m A
- */
-void transformA( real_t* A, int_t nV, int_t nC )
-{
-	int_t i, j;
-
-	real_t* A_tmp = new real_t[nC*nV];
-
-	for( i=0; i<nV*nC; ++i )
-		A_tmp[i] = A[i];
-
-	for( i=0; i<nC; ++i )
-		for( j=0; j<nV; ++j )
-			A[i*nV + j] = A_tmp[j*nC + i];
-
-	delete[] A_tmp;
-
-	return;
-}
-
-
-/*
- *	q p O A S E S
- */
-void sci_qpOASES(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-					int_t *nV, int_t* nC, int_t* nWSR,
-					real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-					)
-{
-	/* transform A into C style matrix */
-	transformA( A, *nV,*nC );
-	
-	/* setup and solve initial QP */
-	QProblem single_qp( *nV,*nC );
-	single_qp.setPrintLevel( PL_LOW );
-	returnValue returnvalue = single_qp.init( H,g,A,lb,ub,lbA,ubA, *nWSR,0 );
-
-	/* assign lhs arguments */
-	single_qp.getPrimalSolution( x );
-	*obj = single_qp.getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	single_qp.getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m _ i n i t
- */
-void sci_QProblem_init( 	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-							int_t* nV, int_t* nC, int_t* nWSR,
-							real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-							)
-{
-	sci_QProblem_cleanup( );
-
-	/* transform A into C style matrix */
-	transformA( A, *nV,*nC );
-
-	/* setup and solve initial QP */
-	qp = new QProblem( *nV,*nC );
-	qp->setPrintLevel( PL_LOW );
-	returnValue returnvalue = qp->init( H,g,A,lb,ub,lbA,ubA, *nWSR,0 );
-
-	/* assign lhs arguments */
-	qp->getPrimalSolution( x );
-	*obj = qp->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	qp->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m B _ i n i t
- */
-void sci_QProblemB_init(	real_t* H, real_t* g, real_t* lb, real_t* ub,
-							int_t* nV, int_t* nWSR,
-							real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-							)
-{
-	sci_QProblemB_cleanup( );
-
-	/* setup and solve initial QP */
-	qpb = new QProblemB( *nV );
-	qpb->setPrintLevel( PL_LOW );
-	returnValue returnvalue = qpb->init( H,g,lb,ub, *nWSR,0 );
-
-	/* assign lhs arguments */
-	qpb->getPrimalSolution( x );
-	*obj = qpb->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	qpb->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	S Q P r o b l e m _ i n i t
- */
-void sci_SQProblem_init(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-							int_t* nV, int_t* nC, int_t* nWSR,
-							real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-							)
-{
-	sci_SQProblem_cleanup( );
-
-	/* transform A into C style matrix */
-	transformA( A, *nV,*nC );
-
-	/* setup and solve initial QP */
-	sqp = new SQProblem( *nV,*nC );
-	sqp->setPrintLevel( PL_LOW );
-	returnValue returnvalue = sqp->init( H,g,A,lb,ub,lbA,ubA, *nWSR,0 );
-
-	/* assign lhs arguments */
-	sqp->getPrimalSolution( x );
-	*obj = sqp->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	sqp->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m _ h o t s t a r t
- */
-void sci_QProblem_hotstart( 	real_t* g, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								)
-{
-	/* has QP been initialised? */
-	if ( qp == 0 )
-	{
-		*status = -1;
-		Scierror( 999,"ERROR (qpOASES): Need to call qpOASES_init first!\n" );
-		return;
-	}
-
-	/* solve QP */
-	returnValue returnvalue = qp->hotstart( g,lb,ub,lbA,ubA, *nWSR,0 );
-
-	/* assign lhs arguments */
-	qp->getPrimalSolution( x );
-	*obj = qp->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	qp->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m B _ h o t s t a r t
- */
-void sci_QProblemB_hotstart(	real_t* g, real_t* lb, real_t* ub,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								)
-{
-	/* has QP been initialised? */
-	if ( qpb == 0 )
-	{
-		*status = -1;
-		Scierror( 999,"ERROR (qpOASES): Need to call qpOASES_initSB first!\n" );
-		return;
-	}
-
-	/* solve QP */
-	returnValue returnvalue = qpb->hotstart( g,lb,ub, *nWSR,0 );
-
-	/* assign lhs arguments */
-	qpb->getPrimalSolution( x );
-	*obj = qpb->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	qpb->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	S Q P r o b l e m _ h o t s t a r t
- */
-void sci_SQProblem_hotstart(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								)
-{
-	/* has QP been initialised? */
-	if ( sqp == 0 )
-	{
-		*status = -1;
-		Scierror( 999,"ERROR (qpOASES): Need to call qpOASES_initVM first!\n" );
-		return;
-	}
-
-	/* transform A into C style matrix */
-	transformA( A, sqp->getNV( ),sqp->getNC( ) );
-
-	/* solve QP */
-	returnValue returnvalue = sqp->hotstart( H,g,A,lb,ub,lbA,ubA, *nWSR,0 );
-
-	/* assign lhs arguments */
-	sqp->getPrimalSolution( x );
-	*obj = sqp->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	sqp->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m _ c l e a n u p
- */
-void sci_QProblem_cleanup( )
-{
-	if ( qp != 0 )
-	{
-		delete qp;
-		qp = 0;
-	}
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m B _ c l e a n u p
- */
-void sci_QProblemB_cleanup( )
-{
-	if ( qpb != 0 )
-	{
-		delete qpb;
-		qpb = 0;
-	}
-
-	return;
-}
-
-
-/*
- *	S Q P r o b l e m _ c l e a n u p
- */
-void sci_SQProblem_cleanup( )
-{
-	if ( sqp != 0 )
-	{
-		delete sqp;
-		sqp = 0;
-	}
-
-	return;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblem.mdl b/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblem.mdl
deleted file mode 100644
index 028dd40..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblem.mdl
+++ /dev/null
@@ -1,762 +0,0 @@
-Model {
-  Name			  "example_QProblem"
-  Version		  7.4
-  MdlSubVersion		  0
-  GraphicalInterface {
-    NumRootInports	    0
-    NumRootOutports	    0
-    ParameterArgumentNames  ""
-    ComputedModelVersion    "1.69"
-    NumModelReferences	    0
-    NumTestPointedSignals   0
-  }
-  SavedCharacterEncoding  "UTF-8"
-  SaveDefaultBlockParams  on
-  ScopeRefreshTime	  0.035000
-  OverrideScopeRefreshTime on
-  DisableAllScopes	  off
-  DataTypeOverride	  "UseLocalSettings"
-  MinMaxOverflowLogging	  "UseLocalSettings"
-  MinMaxOverflowArchiveMode "Overwrite"
-  MaxMDLFileLineLength	  120
-  Created		  "Fri Apr 13 11:08:51 2007"
-  Creator		  "jferreau"
-  UpdateHistory		  "UpdateHistoryNever"
-  ModifiedByFormat	  "%<Auto>"
-  LastModifiedBy	  "chjofer2"
-  ModifiedDateFormat	  "%<Auto>"
-  LastModifiedDate	  "Tue Jan 06 16:16:07 2015"
-  RTWModifiedTimeStamp	  342461745
-  ModelVersionFormat	  "1.%<AutoIncrement:69>"
-  ConfigurationManager	  "None"
-  SampleTimeColors	  off
-  SampleTimeAnnotations	  off
-  LibraryLinkDisplay	  "none"
-  WideLines		  off
-  ShowLineDimensions	  off
-  ShowPortDataTypes	  off
-  ShowLoopsOnError	  on
-  IgnoreBidirectionalLines off
-  ShowStorageClass	  off
-  ShowTestPointIcons	  on
-  ShowSignalResolutionIcons on
-  ShowViewerIcons	  on
-  SortedOrder		  off
-  ExecutionContextIcon	  off
-  ShowLinearizationAnnotations on
-  BlockNameDataTip	  off
-  BlockParametersDataTip  off
-  BlockDescriptionStringDataTip	off
-  ToolBar		  on
-  StatusBar		  on
-  BrowserShowLibraryLinks off
-  BrowserLookUnderMasks	  off
-  SimulationMode	  "normal"
-  LinearizationMsg	  "none"
-  Profile		  off
-  ParamWorkspaceSource	  "MATLABWorkspace"
-  AccelSystemTargetFile	  "accel.tlc"
-  AccelTemplateMakefile	  "accel_default_tmf"
-  AccelMakeCommand	  "make_rtw"
-  TryForcingSFcnDF	  off
-  RecordCoverage	  off
-  CovPath		  "/"
-  CovSaveName		  "covdata"
-  CovMetricSettings	  "dw"
-  CovNameIncrementing	  off
-  CovHtmlReporting	  on
-  CovForceBlockReductionOff on
-  covSaveCumulativeToWorkspaceVar on
-  CovSaveSingleToWorkspaceVar on
-  CovCumulativeVarName	  "covCumulativeData"
-  CovCumulativeReport	  off
-  CovReportOnPause	  on
-  CovModelRefEnable	  "Off"
-  CovExternalEMLEnable	  off
-  ExtModeBatchMode	  off
-  ExtModeEnableFloating	  on
-  ExtModeTrigType	  "manual"
-  ExtModeTrigMode	  "normal"
-  ExtModeTrigPort	  "1"
-  ExtModeTrigElement	  "any"
-  ExtModeTrigDuration	  1000
-  ExtModeTrigDurationFloating "auto"
-  ExtModeTrigHoldOff	  0
-  ExtModeTrigDelay	  0
-  ExtModeTrigDirection	  "rising"
-  ExtModeTrigLevel	  0
-  ExtModeArchiveMode	  "off"
-  ExtModeAutoIncOneShot	  off
-  ExtModeIncDirWhenArm	  off
-  ExtModeAddSuffixToVar	  off
-  ExtModeWriteAllDataToWs off
-  ExtModeArmWhenConnect	  on
-  ExtModeSkipDownloadWhenConnect off
-  ExtModeLogAll		  on
-  ExtModeAutoUpdateStatusClock off
-  BufferReuse		  on
-  ShowModelReferenceBlockVersion off
-  ShowModelReferenceBlockIO off
-  Array {
-    Type		    "Handle"
-    Dimension		    1
-    Simulink.ConfigSet {
-      $ObjectID		      1
-      Version		      "1.6.0"
-      Array {
-	Type			"Handle"
-	Dimension		8
-	Simulink.SolverCC {
-	  $ObjectID		  2
-	  Version		  "1.6.0"
-	  StartTime		  "0.0"
-	  StopTime		  "0.5"
-	  AbsTol		  "auto"
-	  FixedStep		  "auto"
-	  InitialStep		  "auto"
-	  MaxNumMinSteps	  "-1"
-	  MaxOrder		  5
-	  ZcThreshold		  "auto"
-	  ConsecutiveZCsStepRelTol "10*128*eps"
-	  MaxConsecutiveZCs	  "1000"
-	  ExtrapolationOrder	  4
-	  NumberNewtonIterations  1
-	  MaxStep		  "auto"
-	  MinStep		  "auto"
-	  MaxConsecutiveMinStep	  "1"
-	  RelTol		  "1e-3"
-	  SolverMode		  "Auto"
-	  Solver		  "FixedStepDiscrete"
-	  SolverName		  "FixedStepDiscrete"
-	  ShapePreserveControl	  "DisableAll"
-	  ZeroCrossControl	  "UseLocalSettings"
-	  ZeroCrossAlgorithm	  "Nonadaptive"
-	  AlgebraicLoopSolver	  "TrustRegion"
-	  SolverResetMethod	  "Fast"
-	  PositivePriorityOrder	  off
-	  AutoInsertRateTranBlk	  off
-	  SampleTimeConstraint	  "Unconstrained"
-	  InsertRTBMode		  "Whenever possible"
-	}
-	Simulink.DataIOCC {
-	  $ObjectID		  3
-	  Version		  "1.6.0"
-	  Decimation		  "1"
-	  ExternalInput		  "[t, u]"
-	  FinalStateName	  "xFinal"
-	  InitialState		  "xInitial"
-	  LimitDataPoints	  on
-	  MaxDataPoints		  "1000"
-	  LoadExternalInput	  off
-	  LoadInitialState	  off
-	  SaveFinalState	  off
-	  SaveCompleteFinalSimState off
-	  SaveFormat		  "Array"
-	  SaveOutput		  on
-	  SaveState		  off
-	  SignalLogging		  on
-	  InspectSignalLogs	  off
-	  SaveTime		  on
-	  ReturnWorkspaceOutputs  off
-	  StateSaveName		  "xout"
-	  TimeSaveName		  "tout"
-	  OutputSaveName	  "yout"
-	  SignalLoggingName	  "logsout"
-	  OutputOption		  "RefineOutputTimes"
-	  OutputTimes		  "[]"
-	  ReturnWorkspaceOutputsName "out"
-	  Refine		  "1"
-	}
-	Simulink.OptimizationCC {
-	  $ObjectID		  4
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    4
-	    Cell		    "ZeroExternalMemoryAtStartup"
-	    Cell		    "ZeroInternalMemoryAtStartup"
-	    Cell		    "NoFixptDivByZeroProtection"
-	    Cell		    "OptimizeModelRefInitCode"
-	    PropName		    "DisabledProps"
-	  }
-	  BlockReduction	  on
-	  BooleanDataType	  on
-	  ConditionallyExecuteInputs on
-	  InlineParams		  off
-	  UseIntDivNetSlope	  off
-	  InlineInvariantSignals  off
-	  OptimizeBlockIOStorage  on
-	  BufferReuse		  on
-	  EnhancedBackFolding	  off
-	  StrengthReduction	  off
-	  EnforceIntegerDowncast  on
-	  ExpressionFolding	  on
-	  BooleansAsBitfields	  off
-	  EnableMemcpy		  on
-	  MemcpyThreshold	  64
-	  PassReuseOutputArgsAs	  "Structure reference"
-	  ExpressionDepthLimit	  2147483647
-	  FoldNonRolledExpr	  on
-	  LocalBlockOutputs	  on
-	  RollThreshold		  5
-	  SystemCodeInlineAuto	  off
-	  StateBitsets		  off
-	  DataBitsets		  off
-	  UseTempVars		  off
-	  ZeroExternalMemoryAtStartup on
-	  ZeroInternalMemoryAtStartup on
-	  InitFltsAndDblsToZero	  on
-	  NoFixptDivByZeroProtection off
-	  EfficientFloat2IntCast  off
-	  EfficientMapNaN2IntZero on
-	  OptimizeModelRefInitCode off
-	  LifeSpan		  "inf"
-	  BufferReusableBoundary  on
-	  SimCompilerOptimization "Off"
-	  AccelVerboseBuild	  off
-	}
-	Simulink.DebuggingCC {
-	  $ObjectID		  5
-	  Version		  "1.6.0"
-	  RTPrefix		  "error"
-	  ConsistencyChecking	  "none"
-	  ArrayBoundsChecking	  "none"
-	  SignalInfNanChecking	  "none"
-	  SignalRangeChecking	  "none"
-	  ReadBeforeWriteMsg	  "UseLocalSettings"
-	  WriteAfterWriteMsg	  "UseLocalSettings"
-	  WriteAfterReadMsg	  "UseLocalSettings"
-	  AlgebraicLoopMsg	  "warning"
-	  ArtificialAlgebraicLoopMsg "warning"
-	  SaveWithDisabledLinksMsg "warning"
-	  SaveWithParameterizedLinksMsg	"none"
-	  CheckSSInitialOutputMsg on
-	  UnderspecifiedInitializationDetection	"Classic"
-	  MergeDetectMultiDrivingBlocksExec "none"
-	  CheckExecutionContextPreStartOutputMsg off
-	  CheckExecutionContextRuntimeOutputMsg	off
-	  SignalResolutionControl "TryResolveAllWithWarning"
-	  BlockPriorityViolationMsg "warning"
-	  MinStepSizeMsg	  "warning"
-	  TimeAdjustmentMsg	  "none"
-	  MaxConsecutiveZCsMsg	  "error"
-	  SolverPrmCheckMsg	  "warning"
-	  InheritedTsInSrcMsg	  "warning"
-	  DiscreteInheritContinuousMsg "warning"
-	  MultiTaskDSMMsg	  "error"
-	  MultiTaskCondExecSysMsg "error"
-	  MultiTaskRateTransMsg	  "error"
-	  SingleTaskRateTransMsg  "none"
-	  TasksWithSamePriorityMsg "warning"
-	  SigSpecEnsureSampleTimeMsg "warning"
-	  CheckMatrixSingularityMsg "none"
-	  IntegerOverflowMsg	  "warning"
-	  Int32ToFloatConvMsg	  "warning"
-	  ParameterDowncastMsg	  "error"
-	  ParameterOverflowMsg	  "error"
-	  ParameterUnderflowMsg	  "none"
-	  ParameterPrecisionLossMsg "warning"
-	  ParameterTunabilityLossMsg "warning"
-	  FixptConstUnderflowMsg  "none"
-	  FixptConstOverflowMsg	  "none"
-	  FixptConstPrecisionLossMsg "none"
-	  UnderSpecifiedDataTypeMsg "none"
-	  UnnecessaryDatatypeConvMsg "none"
-	  VectorMatrixConversionMsg "none"
-	  InvalidFcnCallConnMsg	  "error"
-	  FcnCallInpInsideContextMsg "Use local settings"
-	  SignalLabelMismatchMsg  "none"
-	  UnconnectedInputMsg	  "warning"
-	  UnconnectedOutputMsg	  "warning"
-	  UnconnectedLineMsg	  "warning"
-	  SFcnCompatibilityMsg	  "none"
-	  UniqueDataStoreMsg	  "none"
-	  BusObjectLabelMismatch  "warning"
-	  RootOutportRequireBusObject "warning"
-	  AssertControl		  "UseLocalSettings"
-	  EnableOverflowDetection off
-	  ModelReferenceIOMsg	  "none"
-	  ModelReferenceVersionMismatchMessage "none"
-	  ModelReferenceIOMismatchMessage "none"
-	  ModelReferenceCSMismatchMessage "none"
-	  UnknownTsInhSupMsg	  "warning"
-	  ModelReferenceDataLoggingMessage "warning"
-	  ModelReferenceSymbolNameMessage "warning"
-	  ModelReferenceExtraNoncontSigs "error"
-	  StateNameClashWarn	  "warning"
-	  SimStateInterfaceChecksumMismatchMsg "warning"
-	  StrictBusMsg		  "Warning"
-	  LoggingUnavailableSignals "error"
-	  BlockIODiagnostic	  "none"
-	}
-	Simulink.HardwareCC {
-	  $ObjectID		  6
-	  Version		  "1.6.0"
-	  ProdBitPerChar	  8
-	  ProdBitPerShort	  16
-	  ProdBitPerInt		  32
-	  ProdBitPerLong	  32
-	  ProdIntDivRoundTo	  "Undefined"
-	  ProdEndianess		  "Unspecified"
-	  ProdWordSize		  32
-	  ProdShiftRightIntArith  on
-	  ProdHWDeviceType	  "32-bit Generic"
-	  TargetBitPerChar	  8
-	  TargetBitPerShort	  16
-	  TargetBitPerInt	  32
-	  TargetBitPerLong	  32
-	  TargetShiftRightIntArith on
-	  TargetIntDivRoundTo	  "Undefined"
-	  TargetEndianess	  "Unspecified"
-	  TargetWordSize	  32
-	  TargetTypeEmulationWarnSuppressLevel 0
-	  TargetPreprocMaxBitsSint 32
-	  TargetPreprocMaxBitsUint 32
-	  TargetHWDeviceType	  "Specified"
-	  TargetUnknown		  off
-	  ProdEqTarget		  on
-	}
-	Simulink.ModelReferenceCC {
-	  $ObjectID		  7
-	  Version		  "1.6.0"
-	  UpdateModelReferenceTargets "IfOutOfDateOrStructuralChange"
-	  CheckModelReferenceTargetMessage "error"
-	  ModelReferenceNumInstancesAllowed "Multi"
-	  ModelReferencePassRootInputsByReference on
-	  ModelReferenceMinAlgLoopOccurrences off
-	}
-	Simulink.SFSimCC {
-	  $ObjectID		  8
-	  Version		  "1.6.0"
-	  SFSimEnableDebug	  on
-	  SFSimOverflowDetection  on
-	  SFSimEcho		  on
-	  SimBlas		  on
-	  SimCtrlC		  on
-	  SimExtrinsic		  on
-	  SimIntegrity		  on
-	  SimUseLocalCustomCode	  off
-	  SimBuildMode		  "sf_incremental_build"
-	}
-	Simulink.RTWCC {
-	  $BackupClass		  "Simulink.RTWCC"
-	  $ObjectID		  9
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    1
-	    Cell		    "IncludeHyperlinkInReport"
-	    PropName		    "DisabledProps"
-	  }
-	  SystemTargetFile	  "grt.tlc"
-	  GenCodeOnly		  off
-	  MakeCommand		  "make_rtw"
-	  GenerateMakefile	  on
-	  TemplateMakefile	  "grt_default_tmf"
-	  GenerateReport	  off
-	  SaveLog		  off
-	  RTWVerbose		  on
-	  RetainRTWFile		  off
-	  ProfileTLC		  off
-	  TLCDebug		  off
-	  TLCCoverage		  off
-	  TLCAssert		  off
-	  ProcessScriptMode	  "Default"
-	  ConfigurationMode	  "Optimized"
-	  ConfigAtBuild		  off
-	  RTWUseLocalCustomCode	  off
-	  RTWUseSimCustomCode	  off
-	  IncludeHyperlinkInReport off
-	  LaunchReport		  off
-	  TargetLang		  "C"
-	  IncludeBusHierarchyInRTWFileBlockHierarchyMap	off
-	  IncludeERTFirstTime	  off
-	  GenerateTraceInfo	  off
-	  GenerateTraceReport	  off
-	  GenerateTraceReportSl	  off
-	  GenerateTraceReportSf	  off
-	  GenerateTraceReportEml  off
-	  GenerateCodeInfo	  off
-	  RTWCompilerOptimization "Off"
-	  CheckMdlBeforeBuild	  "Off"
-	  Array {
-	    Type		    "Handle"
-	    Dimension		    2
-	    Simulink.CodeAppCC {
-	      $ObjectID		      10
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		16
-		Cell			"IgnoreCustomStorageClasses"
-		Cell			"InsertBlockDesc"
-		Cell			"SFDataObjDesc"
-		Cell			"SimulinkDataObjDesc"
-		Cell			"DefineNamingRule"
-		Cell			"SignalNamingRule"
-		Cell			"ParamNamingRule"
-		Cell			"InlinedPrmAccess"
-		Cell			"CustomSymbolStr"
-		Cell			"CustomSymbolStrGlobalVar"
-		Cell			"CustomSymbolStrType"
-		Cell			"CustomSymbolStrField"
-		Cell			"CustomSymbolStrFcn"
-		Cell			"CustomSymbolStrBlkIO"
-		Cell			"CustomSymbolStrTmpVar"
-		Cell			"CustomSymbolStrMacro"
-		PropName		"DisabledProps"
-	      }
-	      ForceParamTrailComments off
-	      GenerateComments	      on
-	      IgnoreCustomStorageClasses on
-	      IgnoreTestpoints	      off
-	      IncHierarchyInIds	      off
-	      MaxIdLength	      31
-	      PreserveName	      off
-	      PreserveNameWithParent  off
-	      ShowEliminatedStatement off
-	      IncAutoGenComments      off
-	      SimulinkDataObjDesc     off
-	      SFDataObjDesc	      off
-	      IncDataTypeInIds	      off
-	      MangleLength	      1
-	      CustomSymbolStrGlobalVar "$R$N$M"
-	      CustomSymbolStrType     "$N$R$M"
-	      CustomSymbolStrField    "$N$M"
-	      CustomSymbolStrFcn      "$R$N$M$F"
-	      CustomSymbolStrFcnArg   "rt$I$N$M"
-	      CustomSymbolStrBlkIO    "rtb_$N$M"
-	      CustomSymbolStrTmpVar   "$N$M"
-	      CustomSymbolStrMacro    "$R$N$M"
-	      DefineNamingRule	      "None"
-	      ParamNamingRule	      "None"
-	      SignalNamingRule	      "None"
-	      InsertBlockDesc	      off
-	      SimulinkBlockComments   on
-	      EnableCustomComments    off
-	      InlinedPrmAccess	      "Literals"
-	      ReqsInCode	      off
-	      UseSimReservedNames     off
-	    }
-	    Simulink.GRTTargetCC {
-	      $BackupClass	      "Simulink.TargetCC"
-	      $ObjectID		      11
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		13
-		Cell			"IncludeMdlTerminateFcn"
-		Cell			"CombineOutputUpdateFcns"
-		Cell			"SuppressErrorStatus"
-		Cell			"ERTCustomFileBanners"
-		Cell			"GenerateSampleERTMain"
-		Cell			"GenerateTestInterfaces"
-		Cell			"MultiInstanceERTCode"
-		Cell			"PurelyIntegerCode"
-		Cell			"SupportNonFinite"
-		Cell			"SupportComplex"
-		Cell			"SupportAbsoluteTime"
-		Cell			"SupportContinuousTime"
-		Cell			"SupportNonInlinedSFcns"
-		PropName		"DisabledProps"
-	      }
-	      TargetFcnLib	      "ansi_tfl_tmw.mat"
-	      TargetLibSuffix	      ""
-	      TargetPreCompLibLocation ""
-	      TargetFunctionLibrary   "ANSI_C"
-	      UtilityFuncGeneration   "Auto"
-	      ERTMultiwordTypeDef     "System defined"
-	      ERTMultiwordLength      256
-	      MultiwordLength	      2048
-	      GenerateFullHeader      on
-	      GenerateSampleERTMain   off
-	      GenerateTestInterfaces  off
-	      IsPILTarget	      off
-	      ModelReferenceCompliant on
-	      ParMdlRefBuildCompliant on
-	      CompOptLevelCompliant   on
-	      IncludeMdlTerminateFcn  on
-	      GeneratePreprocessorConditionals "Disable all"
-	      CombineOutputUpdateFcns off
-	      SuppressErrorStatus     off
-	      ERTFirstTimeCompliant   off
-	      IncludeFileDelimiter    "Auto"
-	      ERTCustomFileBanners    off
-	      SupportAbsoluteTime     on
-	      LogVarNameModifier      "rt_"
-	      MatFileLogging	      on
-	      MultiInstanceERTCode    off
-	      SupportNonFinite	      on
-	      SupportComplex	      on
-	      PurelyIntegerCode	      off
-	      SupportContinuousTime   on
-	      SupportNonInlinedSFcns  on
-	      SupportVariableSizeSignals off
-	      EnableShiftOperators    on
-	      ParenthesesLevel	      "Nominal"
-	      PortableWordSizes	      off
-	      ModelStepFunctionPrototypeControlCompliant off
-	      CPPClassGenCompliant    off
-	      AutosarCompliant	      off
-	      UseMalloc		      off
-	      ExtMode		      off
-	      ExtModeStaticAlloc      off
-	      ExtModeTesting	      off
-	      ExtModeStaticAllocSize  1000000
-	      ExtModeTransport	      0
-	      ExtModeMexFile	      "ext_comm"
-	      ExtModeIntrfLevel	      "Level1"
-	      RTWCAPISignals	      off
-	      RTWCAPIParams	      off
-	      RTWCAPIStates	      off
-	      GenerateASAP2	      off
-	    }
-	    PropName		    "Components"
-	  }
-	}
-	PropName		"Components"
-      }
-      Name		      "Configuration"
-      CurrentDlgPage	      "Solver"
-      ConfigPrmDlgPosition    " [ 200, 197, 1080, 827 ] "
-    }
-    PropName		    "ConfigurationSets"
-  }
-  Simulink.ConfigSet {
-    $PropName		    "ActiveConfigurationSet"
-    $ObjectID		    1
-  }
-  BlockDefaults {
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    NamePlacement	    "normal"
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    ShowName		    on
-    BlockRotation	    0
-    BlockMirror		    off
-  }
-  AnnotationDefaults {
-    HorizontalAlignment	    "center"
-    VerticalAlignment	    "middle"
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    UseDisplayTextAsClickCallback off
-  }
-  LineDefaults {
-    FontName		    "Courier"
-    FontSize		    9
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-  }
-  BlockParameterDefaults {
-    Block {
-      BlockType		      FromWorkspace
-      VariableName	      "simulink_input"
-      SampleTime	      "-1"
-      Interpolate	      on
-      ZeroCross		      off
-      OutputAfterFinalValue   "Extrapolation"
-    }
-    Block {
-      BlockType		      "S-Function"
-      FunctionName	      "system"
-      SFunctionModules	      "''"
-      PortCounts	      "[]"
-      SFunctionDeploymentMode off
-    }
-    Block {
-      BlockType		      Scope
-      ModelBased	      off
-      TickLabels	      "OneTimeTick"
-      ZoomMode		      "on"
-      Grid		      "on"
-      TimeRange		      "auto"
-      YMin		      "-5"
-      YMax		      "5"
-      SaveToWorkspace	      off
-      SaveName		      "ScopeData"
-      LimitDataPoints	      on
-      MaxDataPoints	      "5000"
-      Decimation	      "1"
-      SampleInput	      off
-      SampleTime	      "-1"
-    }
-  }
-  System {
-    Name		    "example_QProblem"
-    Location		    [2, 74, 1918, 1139]
-    Open		    on
-    ModelBrowserVisibility  off
-    ModelBrowserWidth	    200
-    ScreenColor		    "white"
-    PaperOrientation	    "landscape"
-    PaperPositionMode	    "auto"
-    PaperType		    "usletter"
-    PaperUnits		    "inches"
-    TiledPaperMargins	    [0.500000, 0.500000, 0.500000, 0.500000]
-    TiledPageScale	    1
-    ShowPageBoundaries	    off
-    ZoomFactor		    "125"
-    ReportName		    "simulink-default.rpt"
-    SIDHighWatermark	    9
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "g"
-      SID		      2
-      Position		      [200, 158, 265, 182]
-      VariableName	      "g"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "lb"
-      SID		      4
-      Position		      [200, 203, 265, 227]
-      VariableName	      "lb"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "lbA"
-      SID		      6
-      Position		      [200, 293, 265, 317]
-      VariableName	      "lbA"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      "S-Function"
-      Name		      "qpOASES"
-      SID		      9
-      Ports		      [5, 4]
-      Position		      [595, 222, 795, 298]
-      BackgroundColor	      "[1.000000, 0.915850, 0.439000]"
-      FunctionName	      "qpOASES_QProblem"
-      Parameters	      "H,A"
-      EnableBusSupport	      off
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "ub"
-      SID		      5
-      Position		      [200, 248, 265, 272]
-      VariableName	      "ub"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "ubA"
-      SID		      7
-      Position		      [200, 338, 265, 362]
-      VariableName	      "ubA"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      Scope
-      Name		      "x,\nfval,\nexitflag,\niter"
-      SID		      8
-      Ports		      [4]
-      Position		      [945, 222, 1000, 298]
-      Floating		      off
-      Location		      [6, 78, 1276, 993]
-      Open		      off
-      NumInputPorts	      "4"
-      List {
-	ListType		AxesTitles
-	axes1			"%<SignalLabel>"
-	axes2			"%<SignalLabel>"
-	axes3			"%<SignalLabel>"
-	axes4			"%<SignalLabel>"
-      }
-      YMin		      "-5~-5~-5~-5"
-      YMax		      "5~5~5~5"
-      SaveName		      "ScopeData1"
-      DataFormat	      "StructureWithTime"
-      SampleTime	      "0"
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      1
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      2
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      2
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      3
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      3
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      4
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      4
-    }
-    Line {
-      SrcBlock		      "ub"
-      SrcPort		      1
-      DstBlock		      "qpOASES"
-      DstPort		      3
-    }
-    Line {
-      SrcBlock		      "lb"
-      SrcPort		      1
-      Points		      [55, 0; 0, 30]
-      DstBlock		      "qpOASES"
-      DstPort		      2
-    }
-    Line {
-      SrcBlock		      "g"
-      SrcPort		      1
-      Points		      [80, 0; 0, 60]
-      DstBlock		      "qpOASES"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "lbA"
-      SrcPort		      1
-      Points		      [55, 0; 0, -30]
-      DstBlock		      "qpOASES"
-      DstPort		      4
-    }
-    Line {
-      SrcBlock		      "ubA"
-      SrcPort		      1
-      Points		      [80, 0; 0, -60]
-      DstBlock		      "qpOASES"
-      DstPort		      5
-    }
-    Annotation {
-      Position		      [335, 96]
-    }
-    Annotation {
-      Name		      "This file is part of qpOASES.\n\nqpOASES -- An Implementation of the Online Active Set Strategy.\nC"
-      "opyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka, Christian Kirches et al.\nAll rights reserved."
-      Position		      [693, 128]
-    }
-  }
-}
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblemB.mdl b/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblemB.mdl
deleted file mode 100644
index 727602d..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblemB.mdl
+++ /dev/null
@@ -1,728 +0,0 @@
-Model {
-  Name			  "example_QProblemB"
-  Version		  7.4
-  MdlSubVersion		  0
-  GraphicalInterface {
-    NumRootInports	    0
-    NumRootOutports	    0
-    ParameterArgumentNames  ""
-    ComputedModelVersion    "1.67"
-    NumModelReferences	    0
-    NumTestPointedSignals   0
-  }
-  SavedCharacterEncoding  "UTF-8"
-  SaveDefaultBlockParams  on
-  ScopeRefreshTime	  0.035000
-  OverrideScopeRefreshTime on
-  DisableAllScopes	  off
-  DataTypeOverride	  "UseLocalSettings"
-  MinMaxOverflowLogging	  "UseLocalSettings"
-  MinMaxOverflowArchiveMode "Overwrite"
-  MaxMDLFileLineLength	  120
-  Created		  "Fri Apr 13 11:08:51 2007"
-  Creator		  "jferreau"
-  UpdateHistory		  "UpdateHistoryNever"
-  ModifiedByFormat	  "%<Auto>"
-  LastModifiedBy	  "chjofer2"
-  ModifiedDateFormat	  "%<Auto>"
-  LastModifiedDate	  "Tue Jan 06 16:15:23 2015"
-  RTWModifiedTimeStamp	  342461721
-  ModelVersionFormat	  "1.%<AutoIncrement:67>"
-  ConfigurationManager	  "None"
-  SampleTimeColors	  off
-  SampleTimeAnnotations	  off
-  LibraryLinkDisplay	  "none"
-  WideLines		  off
-  ShowLineDimensions	  off
-  ShowPortDataTypes	  off
-  ShowLoopsOnError	  on
-  IgnoreBidirectionalLines off
-  ShowStorageClass	  off
-  ShowTestPointIcons	  on
-  ShowSignalResolutionIcons on
-  ShowViewerIcons	  on
-  SortedOrder		  off
-  ExecutionContextIcon	  off
-  ShowLinearizationAnnotations on
-  BlockNameDataTip	  off
-  BlockParametersDataTip  off
-  BlockDescriptionStringDataTip	off
-  ToolBar		  on
-  StatusBar		  on
-  BrowserShowLibraryLinks off
-  BrowserLookUnderMasks	  off
-  SimulationMode	  "normal"
-  LinearizationMsg	  "none"
-  Profile		  off
-  ParamWorkspaceSource	  "MATLABWorkspace"
-  AccelSystemTargetFile	  "accel.tlc"
-  AccelTemplateMakefile	  "accel_default_tmf"
-  AccelMakeCommand	  "make_rtw"
-  TryForcingSFcnDF	  off
-  RecordCoverage	  off
-  CovPath		  "/"
-  CovSaveName		  "covdata"
-  CovMetricSettings	  "dw"
-  CovNameIncrementing	  off
-  CovHtmlReporting	  on
-  CovForceBlockReductionOff on
-  covSaveCumulativeToWorkspaceVar on
-  CovSaveSingleToWorkspaceVar on
-  CovCumulativeVarName	  "covCumulativeData"
-  CovCumulativeReport	  off
-  CovReportOnPause	  on
-  CovModelRefEnable	  "Off"
-  CovExternalEMLEnable	  off
-  ExtModeBatchMode	  off
-  ExtModeEnableFloating	  on
-  ExtModeTrigType	  "manual"
-  ExtModeTrigMode	  "normal"
-  ExtModeTrigPort	  "1"
-  ExtModeTrigElement	  "any"
-  ExtModeTrigDuration	  1000
-  ExtModeTrigDurationFloating "auto"
-  ExtModeTrigHoldOff	  0
-  ExtModeTrigDelay	  0
-  ExtModeTrigDirection	  "rising"
-  ExtModeTrigLevel	  0
-  ExtModeArchiveMode	  "off"
-  ExtModeAutoIncOneShot	  off
-  ExtModeIncDirWhenArm	  off
-  ExtModeAddSuffixToVar	  off
-  ExtModeWriteAllDataToWs off
-  ExtModeArmWhenConnect	  on
-  ExtModeSkipDownloadWhenConnect off
-  ExtModeLogAll		  on
-  ExtModeAutoUpdateStatusClock off
-  BufferReuse		  on
-  ShowModelReferenceBlockVersion off
-  ShowModelReferenceBlockIO off
-  Array {
-    Type		    "Handle"
-    Dimension		    1
-    Simulink.ConfigSet {
-      $ObjectID		      1
-      Version		      "1.6.0"
-      Array {
-	Type			"Handle"
-	Dimension		8
-	Simulink.SolverCC {
-	  $ObjectID		  2
-	  Version		  "1.6.0"
-	  StartTime		  "0.0"
-	  StopTime		  "0.5"
-	  AbsTol		  "auto"
-	  FixedStep		  "auto"
-	  InitialStep		  "auto"
-	  MaxNumMinSteps	  "-1"
-	  MaxOrder		  5
-	  ZcThreshold		  "auto"
-	  ConsecutiveZCsStepRelTol "10*128*eps"
-	  MaxConsecutiveZCs	  "1000"
-	  ExtrapolationOrder	  4
-	  NumberNewtonIterations  1
-	  MaxStep		  "auto"
-	  MinStep		  "auto"
-	  MaxConsecutiveMinStep	  "1"
-	  RelTol		  "1e-3"
-	  SolverMode		  "Auto"
-	  Solver		  "VariableStepDiscrete"
-	  SolverName		  "VariableStepDiscrete"
-	  ShapePreserveControl	  "DisableAll"
-	  ZeroCrossControl	  "UseLocalSettings"
-	  ZeroCrossAlgorithm	  "Nonadaptive"
-	  AlgebraicLoopSolver	  "TrustRegion"
-	  SolverResetMethod	  "Fast"
-	  PositivePriorityOrder	  off
-	  AutoInsertRateTranBlk	  off
-	  SampleTimeConstraint	  "Unconstrained"
-	  InsertRTBMode		  "Whenever possible"
-	}
-	Simulink.DataIOCC {
-	  $ObjectID		  3
-	  Version		  "1.6.0"
-	  Decimation		  "1"
-	  ExternalInput		  "[t, u]"
-	  FinalStateName	  "xFinal"
-	  InitialState		  "xInitial"
-	  LimitDataPoints	  on
-	  MaxDataPoints		  "1000"
-	  LoadExternalInput	  off
-	  LoadInitialState	  off
-	  SaveFinalState	  off
-	  SaveCompleteFinalSimState off
-	  SaveFormat		  "Array"
-	  SaveOutput		  on
-	  SaveState		  off
-	  SignalLogging		  on
-	  InspectSignalLogs	  off
-	  SaveTime		  on
-	  ReturnWorkspaceOutputs  off
-	  StateSaveName		  "xout"
-	  TimeSaveName		  "tout"
-	  OutputSaveName	  "yout"
-	  SignalLoggingName	  "logsout"
-	  OutputOption		  "RefineOutputTimes"
-	  OutputTimes		  "[]"
-	  ReturnWorkspaceOutputsName "out"
-	  Refine		  "1"
-	}
-	Simulink.OptimizationCC {
-	  $ObjectID		  4
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    4
-	    Cell		    "ZeroExternalMemoryAtStartup"
-	    Cell		    "ZeroInternalMemoryAtStartup"
-	    Cell		    "NoFixptDivByZeroProtection"
-	    Cell		    "OptimizeModelRefInitCode"
-	    PropName		    "DisabledProps"
-	  }
-	  BlockReduction	  on
-	  BooleanDataType	  on
-	  ConditionallyExecuteInputs on
-	  InlineParams		  off
-	  UseIntDivNetSlope	  off
-	  InlineInvariantSignals  off
-	  OptimizeBlockIOStorage  on
-	  BufferReuse		  on
-	  EnhancedBackFolding	  off
-	  StrengthReduction	  off
-	  EnforceIntegerDowncast  on
-	  ExpressionFolding	  on
-	  BooleansAsBitfields	  off
-	  EnableMemcpy		  on
-	  MemcpyThreshold	  64
-	  PassReuseOutputArgsAs	  "Structure reference"
-	  ExpressionDepthLimit	  2147483647
-	  FoldNonRolledExpr	  on
-	  LocalBlockOutputs	  on
-	  RollThreshold		  5
-	  SystemCodeInlineAuto	  off
-	  StateBitsets		  off
-	  DataBitsets		  off
-	  UseTempVars		  off
-	  ZeroExternalMemoryAtStartup on
-	  ZeroInternalMemoryAtStartup on
-	  InitFltsAndDblsToZero	  on
-	  NoFixptDivByZeroProtection off
-	  EfficientFloat2IntCast  off
-	  EfficientMapNaN2IntZero on
-	  OptimizeModelRefInitCode off
-	  LifeSpan		  "inf"
-	  BufferReusableBoundary  on
-	  SimCompilerOptimization "Off"
-	  AccelVerboseBuild	  off
-	}
-	Simulink.DebuggingCC {
-	  $ObjectID		  5
-	  Version		  "1.6.0"
-	  RTPrefix		  "error"
-	  ConsistencyChecking	  "none"
-	  ArrayBoundsChecking	  "none"
-	  SignalInfNanChecking	  "none"
-	  SignalRangeChecking	  "none"
-	  ReadBeforeWriteMsg	  "UseLocalSettings"
-	  WriteAfterWriteMsg	  "UseLocalSettings"
-	  WriteAfterReadMsg	  "UseLocalSettings"
-	  AlgebraicLoopMsg	  "warning"
-	  ArtificialAlgebraicLoopMsg "warning"
-	  SaveWithDisabledLinksMsg "warning"
-	  SaveWithParameterizedLinksMsg	"none"
-	  CheckSSInitialOutputMsg on
-	  UnderspecifiedInitializationDetection	"Classic"
-	  MergeDetectMultiDrivingBlocksExec "none"
-	  CheckExecutionContextPreStartOutputMsg off
-	  CheckExecutionContextRuntimeOutputMsg	off
-	  SignalResolutionControl "TryResolveAllWithWarning"
-	  BlockPriorityViolationMsg "warning"
-	  MinStepSizeMsg	  "warning"
-	  TimeAdjustmentMsg	  "none"
-	  MaxConsecutiveZCsMsg	  "error"
-	  SolverPrmCheckMsg	  "warning"
-	  InheritedTsInSrcMsg	  "warning"
-	  DiscreteInheritContinuousMsg "warning"
-	  MultiTaskDSMMsg	  "error"
-	  MultiTaskCondExecSysMsg "error"
-	  MultiTaskRateTransMsg	  "error"
-	  SingleTaskRateTransMsg  "none"
-	  TasksWithSamePriorityMsg "warning"
-	  SigSpecEnsureSampleTimeMsg "warning"
-	  CheckMatrixSingularityMsg "none"
-	  IntegerOverflowMsg	  "warning"
-	  Int32ToFloatConvMsg	  "warning"
-	  ParameterDowncastMsg	  "error"
-	  ParameterOverflowMsg	  "error"
-	  ParameterUnderflowMsg	  "none"
-	  ParameterPrecisionLossMsg "warning"
-	  ParameterTunabilityLossMsg "warning"
-	  FixptConstUnderflowMsg  "none"
-	  FixptConstOverflowMsg	  "none"
-	  FixptConstPrecisionLossMsg "none"
-	  UnderSpecifiedDataTypeMsg "none"
-	  UnnecessaryDatatypeConvMsg "none"
-	  VectorMatrixConversionMsg "none"
-	  InvalidFcnCallConnMsg	  "error"
-	  FcnCallInpInsideContextMsg "Use local settings"
-	  SignalLabelMismatchMsg  "none"
-	  UnconnectedInputMsg	  "warning"
-	  UnconnectedOutputMsg	  "warning"
-	  UnconnectedLineMsg	  "warning"
-	  SFcnCompatibilityMsg	  "none"
-	  UniqueDataStoreMsg	  "none"
-	  BusObjectLabelMismatch  "warning"
-	  RootOutportRequireBusObject "warning"
-	  AssertControl		  "UseLocalSettings"
-	  EnableOverflowDetection off
-	  ModelReferenceIOMsg	  "none"
-	  ModelReferenceVersionMismatchMessage "none"
-	  ModelReferenceIOMismatchMessage "none"
-	  ModelReferenceCSMismatchMessage "none"
-	  UnknownTsInhSupMsg	  "warning"
-	  ModelReferenceDataLoggingMessage "warning"
-	  ModelReferenceSymbolNameMessage "warning"
-	  ModelReferenceExtraNoncontSigs "error"
-	  StateNameClashWarn	  "warning"
-	  SimStateInterfaceChecksumMismatchMsg "warning"
-	  StrictBusMsg		  "Warning"
-	  LoggingUnavailableSignals "error"
-	  BlockIODiagnostic	  "none"
-	}
-	Simulink.HardwareCC {
-	  $ObjectID		  6
-	  Version		  "1.6.0"
-	  ProdBitPerChar	  8
-	  ProdBitPerShort	  16
-	  ProdBitPerInt		  32
-	  ProdBitPerLong	  32
-	  ProdIntDivRoundTo	  "Undefined"
-	  ProdEndianess		  "Unspecified"
-	  ProdWordSize		  32
-	  ProdShiftRightIntArith  on
-	  ProdHWDeviceType	  "32-bit Generic"
-	  TargetBitPerChar	  8
-	  TargetBitPerShort	  16
-	  TargetBitPerInt	  32
-	  TargetBitPerLong	  32
-	  TargetShiftRightIntArith on
-	  TargetIntDivRoundTo	  "Undefined"
-	  TargetEndianess	  "Unspecified"
-	  TargetWordSize	  32
-	  TargetTypeEmulationWarnSuppressLevel 0
-	  TargetPreprocMaxBitsSint 32
-	  TargetPreprocMaxBitsUint 32
-	  TargetHWDeviceType	  "Specified"
-	  TargetUnknown		  off
-	  ProdEqTarget		  on
-	}
-	Simulink.ModelReferenceCC {
-	  $ObjectID		  7
-	  Version		  "1.6.0"
-	  UpdateModelReferenceTargets "IfOutOfDateOrStructuralChange"
-	  CheckModelReferenceTargetMessage "error"
-	  ModelReferenceNumInstancesAllowed "Multi"
-	  ModelReferencePassRootInputsByReference on
-	  ModelReferenceMinAlgLoopOccurrences off
-	}
-	Simulink.SFSimCC {
-	  $ObjectID		  8
-	  Version		  "1.6.0"
-	  SFSimEnableDebug	  on
-	  SFSimOverflowDetection  on
-	  SFSimEcho		  on
-	  SimBlas		  on
-	  SimCtrlC		  on
-	  SimExtrinsic		  on
-	  SimIntegrity		  on
-	  SimUseLocalCustomCode	  off
-	  SimBuildMode		  "sf_incremental_build"
-	}
-	Simulink.RTWCC {
-	  $BackupClass		  "Simulink.RTWCC"
-	  $ObjectID		  9
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    1
-	    Cell		    "IncludeHyperlinkInReport"
-	    PropName		    "DisabledProps"
-	  }
-	  SystemTargetFile	  "grt.tlc"
-	  GenCodeOnly		  off
-	  MakeCommand		  "make_rtw"
-	  GenerateMakefile	  on
-	  TemplateMakefile	  "grt_default_tmf"
-	  GenerateReport	  off
-	  SaveLog		  off
-	  RTWVerbose		  on
-	  RetainRTWFile		  off
-	  ProfileTLC		  off
-	  TLCDebug		  off
-	  TLCCoverage		  off
-	  TLCAssert		  off
-	  ProcessScriptMode	  "Default"
-	  ConfigurationMode	  "Optimized"
-	  ConfigAtBuild		  off
-	  RTWUseLocalCustomCode	  off
-	  RTWUseSimCustomCode	  off
-	  IncludeHyperlinkInReport off
-	  LaunchReport		  off
-	  TargetLang		  "C"
-	  IncludeBusHierarchyInRTWFileBlockHierarchyMap	off
-	  IncludeERTFirstTime	  off
-	  GenerateTraceInfo	  off
-	  GenerateTraceReport	  off
-	  GenerateTraceReportSl	  off
-	  GenerateTraceReportSf	  off
-	  GenerateTraceReportEml  off
-	  GenerateCodeInfo	  off
-	  RTWCompilerOptimization "Off"
-	  CheckMdlBeforeBuild	  "Off"
-	  Array {
-	    Type		    "Handle"
-	    Dimension		    2
-	    Simulink.CodeAppCC {
-	      $ObjectID		      10
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		16
-		Cell			"IgnoreCustomStorageClasses"
-		Cell			"InsertBlockDesc"
-		Cell			"SFDataObjDesc"
-		Cell			"SimulinkDataObjDesc"
-		Cell			"DefineNamingRule"
-		Cell			"SignalNamingRule"
-		Cell			"ParamNamingRule"
-		Cell			"InlinedPrmAccess"
-		Cell			"CustomSymbolStr"
-		Cell			"CustomSymbolStrGlobalVar"
-		Cell			"CustomSymbolStrType"
-		Cell			"CustomSymbolStrField"
-		Cell			"CustomSymbolStrFcn"
-		Cell			"CustomSymbolStrBlkIO"
-		Cell			"CustomSymbolStrTmpVar"
-		Cell			"CustomSymbolStrMacro"
-		PropName		"DisabledProps"
-	      }
-	      ForceParamTrailComments off
-	      GenerateComments	      on
-	      IgnoreCustomStorageClasses on
-	      IgnoreTestpoints	      off
-	      IncHierarchyInIds	      off
-	      MaxIdLength	      31
-	      PreserveName	      off
-	      PreserveNameWithParent  off
-	      ShowEliminatedStatement off
-	      IncAutoGenComments      off
-	      SimulinkDataObjDesc     off
-	      SFDataObjDesc	      off
-	      IncDataTypeInIds	      off
-	      MangleLength	      1
-	      CustomSymbolStrGlobalVar "$R$N$M"
-	      CustomSymbolStrType     "$N$R$M"
-	      CustomSymbolStrField    "$N$M"
-	      CustomSymbolStrFcn      "$R$N$M$F"
-	      CustomSymbolStrFcnArg   "rt$I$N$M"
-	      CustomSymbolStrBlkIO    "rtb_$N$M"
-	      CustomSymbolStrTmpVar   "$N$M"
-	      CustomSymbolStrMacro    "$R$N$M"
-	      DefineNamingRule	      "None"
-	      ParamNamingRule	      "None"
-	      SignalNamingRule	      "None"
-	      InsertBlockDesc	      off
-	      SimulinkBlockComments   on
-	      EnableCustomComments    off
-	      InlinedPrmAccess	      "Literals"
-	      ReqsInCode	      off
-	      UseSimReservedNames     off
-	    }
-	    Simulink.GRTTargetCC {
-	      $BackupClass	      "Simulink.TargetCC"
-	      $ObjectID		      11
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		13
-		Cell			"IncludeMdlTerminateFcn"
-		Cell			"CombineOutputUpdateFcns"
-		Cell			"SuppressErrorStatus"
-		Cell			"ERTCustomFileBanners"
-		Cell			"GenerateSampleERTMain"
-		Cell			"GenerateTestInterfaces"
-		Cell			"MultiInstanceERTCode"
-		Cell			"PurelyIntegerCode"
-		Cell			"SupportNonFinite"
-		Cell			"SupportComplex"
-		Cell			"SupportAbsoluteTime"
-		Cell			"SupportContinuousTime"
-		Cell			"SupportNonInlinedSFcns"
-		PropName		"DisabledProps"
-	      }
-	      TargetFcnLib	      "ansi_tfl_tmw.mat"
-	      TargetLibSuffix	      ""
-	      TargetPreCompLibLocation ""
-	      TargetFunctionLibrary   "ANSI_C"
-	      UtilityFuncGeneration   "Auto"
-	      ERTMultiwordTypeDef     "System defined"
-	      ERTMultiwordLength      256
-	      MultiwordLength	      2048
-	      GenerateFullHeader      on
-	      GenerateSampleERTMain   off
-	      GenerateTestInterfaces  off
-	      IsPILTarget	      off
-	      ModelReferenceCompliant on
-	      ParMdlRefBuildCompliant on
-	      CompOptLevelCompliant   on
-	      IncludeMdlTerminateFcn  on
-	      GeneratePreprocessorConditionals "Disable all"
-	      CombineOutputUpdateFcns off
-	      SuppressErrorStatus     off
-	      ERTFirstTimeCompliant   off
-	      IncludeFileDelimiter    "Auto"
-	      ERTCustomFileBanners    off
-	      SupportAbsoluteTime     on
-	      LogVarNameModifier      "rt_"
-	      MatFileLogging	      on
-	      MultiInstanceERTCode    off
-	      SupportNonFinite	      on
-	      SupportComplex	      on
-	      PurelyIntegerCode	      off
-	      SupportContinuousTime   on
-	      SupportNonInlinedSFcns  on
-	      SupportVariableSizeSignals off
-	      EnableShiftOperators    on
-	      ParenthesesLevel	      "Nominal"
-	      PortableWordSizes	      off
-	      ModelStepFunctionPrototypeControlCompliant off
-	      CPPClassGenCompliant    off
-	      AutosarCompliant	      off
-	      UseMalloc		      off
-	      ExtMode		      off
-	      ExtModeStaticAlloc      off
-	      ExtModeTesting	      off
-	      ExtModeStaticAllocSize  1000000
-	      ExtModeTransport	      0
-	      ExtModeMexFile	      "ext_comm"
-	      ExtModeIntrfLevel	      "Level1"
-	      RTWCAPISignals	      off
-	      RTWCAPIParams	      off
-	      RTWCAPIStates	      off
-	      GenerateASAP2	      off
-	    }
-	    PropName		    "Components"
-	  }
-	}
-	PropName		"Components"
-      }
-      Name		      "Configuration"
-      CurrentDlgPage	      "Solver"
-      ConfigPrmDlgPosition    " [ 200, 197, 1080, 827 ] "
-    }
-    PropName		    "ConfigurationSets"
-  }
-  Simulink.ConfigSet {
-    $PropName		    "ActiveConfigurationSet"
-    $ObjectID		    1
-  }
-  BlockDefaults {
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    NamePlacement	    "normal"
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    ShowName		    on
-    BlockRotation	    0
-    BlockMirror		    off
-  }
-  AnnotationDefaults {
-    HorizontalAlignment	    "center"
-    VerticalAlignment	    "middle"
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    UseDisplayTextAsClickCallback off
-  }
-  LineDefaults {
-    FontName		    "Courier"
-    FontSize		    9
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-  }
-  BlockParameterDefaults {
-    Block {
-      BlockType		      FromWorkspace
-      VariableName	      "simulink_input"
-      SampleTime	      "-1"
-      Interpolate	      on
-      ZeroCross		      off
-      OutputAfterFinalValue   "Extrapolation"
-    }
-    Block {
-      BlockType		      "S-Function"
-      FunctionName	      "system"
-      SFunctionModules	      "''"
-      PortCounts	      "[]"
-      SFunctionDeploymentMode off
-    }
-    Block {
-      BlockType		      Scope
-      ModelBased	      off
-      TickLabels	      "OneTimeTick"
-      ZoomMode		      "on"
-      Grid		      "on"
-      TimeRange		      "auto"
-      YMin		      "-5"
-      YMax		      "5"
-      SaveToWorkspace	      off
-      SaveName		      "ScopeData"
-      LimitDataPoints	      on
-      MaxDataPoints	      "5000"
-      Decimation	      "1"
-      SampleInput	      off
-      SampleTime	      "-1"
-    }
-  }
-  System {
-    Name		    "example_QProblemB"
-    Location		    [1922, 224, 3598, 1179]
-    Open		    on
-    ModelBrowserVisibility  off
-    ModelBrowserWidth	    200
-    ScreenColor		    "white"
-    PaperOrientation	    "landscape"
-    PaperPositionMode	    "auto"
-    PaperType		    "usletter"
-    PaperUnits		    "inches"
-    TiledPaperMargins	    [0.500000, 0.500000, 0.500000, 0.500000]
-    TiledPageScale	    1
-    ShowPageBoundaries	    off
-    ZoomFactor		    "125"
-    ReportName		    "simulink-default.rpt"
-    SIDHighWatermark	    6
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "g"
-      SID		      2
-      Position		      [170, 153, 235, 177]
-      VariableName	      "g"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "lb"
-      SID		      3
-      Position		      [170, 203, 235, 227]
-      VariableName	      "lb"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      "S-Function"
-      Name		      "qpOASES"
-      SID		      6
-      Ports		      [3, 4]
-      Position		      [505, 180, 700, 245]
-      BackgroundColor	      "yellow"
-      FunctionName	      "qpOASES_QProblemB"
-      Parameters	      "H"
-      EnableBusSupport	      off
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "ub"
-      SID		      4
-      Position		      [170, 253, 235, 277]
-      VariableName	      "ub"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      Scope
-      Name		      "x,\nfval,\nexitflag,\niter"
-      SID		      5
-      Ports		      [4]
-      Position		      [855, 185, 905, 240]
-      Floating		      off
-      Location		      [6, 78, 1276, 993]
-      Open		      off
-      NumInputPorts	      "4"
-      List {
-	ListType		AxesTitles
-	axes1			"%<SignalLabel>"
-	axes2			"%<SignalLabel>"
-	axes3			"%<SignalLabel>"
-	axes4			"%<SignalLabel>"
-      }
-      YMin		      "-5~-5~-5~-5"
-      YMax		      "5~5~5~5"
-      SaveName		      "ScopeData1"
-      DataFormat	      "StructureWithTime"
-      SampleTime	      "0"
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      1
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      2
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      2
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      3
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      3
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      4
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      4
-    }
-    Line {
-      SrcBlock		      "g"
-      SrcPort		      1
-      Points		      [50, 0; 0, 30]
-      DstBlock		      "qpOASES"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "lb"
-      SrcPort		      1
-      DstBlock		      "qpOASES"
-      DstPort		      2
-    }
-    Line {
-      SrcBlock		      "ub"
-      SrcPort		      1
-      Points		      [50, 0; 0, -30]
-      DstBlock		      "qpOASES"
-      DstPort		      3
-    }
-    Annotation {
-      Position		      [335, 96]
-    }
-    Annotation {
-      Name		      "This file is part of qpOASES.\n\nqpOASES -- An Implementation of the Online Active Set Strategy.\nC"
-      "opyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka, Christian Kirches et al.\nAll rights reserved."
-      Position		      [608, 108]
-    }
-  }
-}
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_SQProblem.mdl b/extlibs/qpOASES-3.2.0/interfaces/simulink/example_SQProblem.mdl
deleted file mode 100644
index 1f7a9f3..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_SQProblem.mdl
+++ /dev/null
@@ -1,797 +0,0 @@
-Model {
-  Name			  "example_SQProblem"
-  Version		  7.4
-  MdlSubVersion		  0
-  GraphicalInterface {
-    NumRootInports	    0
-    NumRootOutports	    0
-    ParameterArgumentNames  ""
-    ComputedModelVersion    "1.67"
-    NumModelReferences	    0
-    NumTestPointedSignals   0
-  }
-  SavedCharacterEncoding  "UTF-8"
-  SaveDefaultBlockParams  on
-  ScopeRefreshTime	  0.035000
-  OverrideScopeRefreshTime on
-  DisableAllScopes	  off
-  DataTypeOverride	  "UseLocalSettings"
-  MinMaxOverflowLogging	  "UseLocalSettings"
-  MinMaxOverflowArchiveMode "Overwrite"
-  MaxMDLFileLineLength	  120
-  Created		  "Fri Apr 13 11:08:51 2007"
-  Creator		  "jferreau"
-  UpdateHistory		  "UpdateHistoryNever"
-  ModifiedByFormat	  "%<Auto>"
-  LastModifiedBy	  "chjofer2"
-  ModifiedDateFormat	  "%<Auto>"
-  LastModifiedDate	  "Wed Jan 07 09:31:42 2015"
-  RTWModifiedTimeStamp	  342523898
-  ModelVersionFormat	  "1.%<AutoIncrement:67>"
-  ConfigurationManager	  "None"
-  SampleTimeColors	  off
-  SampleTimeAnnotations	  off
-  LibraryLinkDisplay	  "none"
-  WideLines		  off
-  ShowLineDimensions	  off
-  ShowPortDataTypes	  off
-  ShowLoopsOnError	  on
-  IgnoreBidirectionalLines off
-  ShowStorageClass	  off
-  ShowTestPointIcons	  on
-  ShowSignalResolutionIcons on
-  ShowViewerIcons	  on
-  SortedOrder		  off
-  ExecutionContextIcon	  off
-  ShowLinearizationAnnotations on
-  BlockNameDataTip	  off
-  BlockParametersDataTip  off
-  BlockDescriptionStringDataTip	off
-  ToolBar		  on
-  StatusBar		  on
-  BrowserShowLibraryLinks off
-  BrowserLookUnderMasks	  off
-  SimulationMode	  "normal"
-  LinearizationMsg	  "none"
-  Profile		  off
-  ParamWorkspaceSource	  "MATLABWorkspace"
-  AccelSystemTargetFile	  "accel.tlc"
-  AccelTemplateMakefile	  "accel_default_tmf"
-  AccelMakeCommand	  "make_rtw"
-  TryForcingSFcnDF	  off
-  RecordCoverage	  off
-  CovPath		  "/"
-  CovSaveName		  "covdata"
-  CovMetricSettings	  "dw"
-  CovNameIncrementing	  off
-  CovHtmlReporting	  on
-  CovForceBlockReductionOff on
-  covSaveCumulativeToWorkspaceVar on
-  CovSaveSingleToWorkspaceVar on
-  CovCumulativeVarName	  "covCumulativeData"
-  CovCumulativeReport	  off
-  CovReportOnPause	  on
-  CovModelRefEnable	  "Off"
-  CovExternalEMLEnable	  off
-  ExtModeBatchMode	  off
-  ExtModeEnableFloating	  on
-  ExtModeTrigType	  "manual"
-  ExtModeTrigMode	  "normal"
-  ExtModeTrigPort	  "1"
-  ExtModeTrigElement	  "any"
-  ExtModeTrigDuration	  1000
-  ExtModeTrigDurationFloating "auto"
-  ExtModeTrigHoldOff	  0
-  ExtModeTrigDelay	  0
-  ExtModeTrigDirection	  "rising"
-  ExtModeTrigLevel	  0
-  ExtModeArchiveMode	  "off"
-  ExtModeAutoIncOneShot	  off
-  ExtModeIncDirWhenArm	  off
-  ExtModeAddSuffixToVar	  off
-  ExtModeWriteAllDataToWs off
-  ExtModeArmWhenConnect	  on
-  ExtModeSkipDownloadWhenConnect off
-  ExtModeLogAll		  on
-  ExtModeAutoUpdateStatusClock off
-  BufferReuse		  on
-  ShowModelReferenceBlockVersion off
-  ShowModelReferenceBlockIO off
-  Array {
-    Type		    "Handle"
-    Dimension		    1
-    Simulink.ConfigSet {
-      $ObjectID		      1
-      Version		      "1.6.0"
-      Array {
-	Type			"Handle"
-	Dimension		8
-	Simulink.SolverCC {
-	  $ObjectID		  2
-	  Version		  "1.6.0"
-	  StartTime		  "0.0"
-	  StopTime		  "0.5"
-	  AbsTol		  "auto"
-	  FixedStep		  "auto"
-	  InitialStep		  "auto"
-	  MaxNumMinSteps	  "-1"
-	  MaxOrder		  5
-	  ZcThreshold		  "auto"
-	  ConsecutiveZCsStepRelTol "10*128*eps"
-	  MaxConsecutiveZCs	  "1000"
-	  ExtrapolationOrder	  4
-	  NumberNewtonIterations  1
-	  MaxStep		  "auto"
-	  MinStep		  "auto"
-	  MaxConsecutiveMinStep	  "1"
-	  RelTol		  "1e-3"
-	  SolverMode		  "Auto"
-	  Solver		  "VariableStepDiscrete"
-	  SolverName		  "VariableStepDiscrete"
-	  ShapePreserveControl	  "DisableAll"
-	  ZeroCrossControl	  "UseLocalSettings"
-	  ZeroCrossAlgorithm	  "Nonadaptive"
-	  AlgebraicLoopSolver	  "TrustRegion"
-	  SolverResetMethod	  "Fast"
-	  PositivePriorityOrder	  off
-	  AutoInsertRateTranBlk	  off
-	  SampleTimeConstraint	  "Unconstrained"
-	  InsertRTBMode		  "Whenever possible"
-	}
-	Simulink.DataIOCC {
-	  $ObjectID		  3
-	  Version		  "1.6.0"
-	  Decimation		  "1"
-	  ExternalInput		  "[t, u]"
-	  FinalStateName	  "xFinal"
-	  InitialState		  "xInitial"
-	  LimitDataPoints	  on
-	  MaxDataPoints		  "1000"
-	  LoadExternalInput	  off
-	  LoadInitialState	  off
-	  SaveFinalState	  off
-	  SaveCompleteFinalSimState off
-	  SaveFormat		  "Array"
-	  SaveOutput		  on
-	  SaveState		  off
-	  SignalLogging		  on
-	  InspectSignalLogs	  off
-	  SaveTime		  on
-	  ReturnWorkspaceOutputs  off
-	  StateSaveName		  "xout"
-	  TimeSaveName		  "tout"
-	  OutputSaveName	  "yout"
-	  SignalLoggingName	  "logsout"
-	  OutputOption		  "RefineOutputTimes"
-	  OutputTimes		  "[]"
-	  ReturnWorkspaceOutputsName "out"
-	  Refine		  "1"
-	}
-	Simulink.OptimizationCC {
-	  $ObjectID		  4
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    4
-	    Cell		    "ZeroExternalMemoryAtStartup"
-	    Cell		    "ZeroInternalMemoryAtStartup"
-	    Cell		    "NoFixptDivByZeroProtection"
-	    Cell		    "OptimizeModelRefInitCode"
-	    PropName		    "DisabledProps"
-	  }
-	  BlockReduction	  on
-	  BooleanDataType	  on
-	  ConditionallyExecuteInputs on
-	  InlineParams		  off
-	  UseIntDivNetSlope	  off
-	  InlineInvariantSignals  off
-	  OptimizeBlockIOStorage  on
-	  BufferReuse		  on
-	  EnhancedBackFolding	  off
-	  StrengthReduction	  off
-	  EnforceIntegerDowncast  on
-	  ExpressionFolding	  on
-	  BooleansAsBitfields	  off
-	  EnableMemcpy		  on
-	  MemcpyThreshold	  64
-	  PassReuseOutputArgsAs	  "Structure reference"
-	  ExpressionDepthLimit	  2147483647
-	  FoldNonRolledExpr	  on
-	  LocalBlockOutputs	  on
-	  RollThreshold		  5
-	  SystemCodeInlineAuto	  off
-	  StateBitsets		  off
-	  DataBitsets		  off
-	  UseTempVars		  off
-	  ZeroExternalMemoryAtStartup on
-	  ZeroInternalMemoryAtStartup on
-	  InitFltsAndDblsToZero	  on
-	  NoFixptDivByZeroProtection off
-	  EfficientFloat2IntCast  off
-	  EfficientMapNaN2IntZero on
-	  OptimizeModelRefInitCode off
-	  LifeSpan		  "inf"
-	  BufferReusableBoundary  on
-	  SimCompilerOptimization "Off"
-	  AccelVerboseBuild	  off
-	}
-	Simulink.DebuggingCC {
-	  $ObjectID		  5
-	  Version		  "1.6.0"
-	  RTPrefix		  "error"
-	  ConsistencyChecking	  "none"
-	  ArrayBoundsChecking	  "none"
-	  SignalInfNanChecking	  "none"
-	  SignalRangeChecking	  "none"
-	  ReadBeforeWriteMsg	  "UseLocalSettings"
-	  WriteAfterWriteMsg	  "UseLocalSettings"
-	  WriteAfterReadMsg	  "UseLocalSettings"
-	  AlgebraicLoopMsg	  "warning"
-	  ArtificialAlgebraicLoopMsg "warning"
-	  SaveWithDisabledLinksMsg "warning"
-	  SaveWithParameterizedLinksMsg	"none"
-	  CheckSSInitialOutputMsg on
-	  UnderspecifiedInitializationDetection	"Classic"
-	  MergeDetectMultiDrivingBlocksExec "none"
-	  CheckExecutionContextPreStartOutputMsg off
-	  CheckExecutionContextRuntimeOutputMsg	off
-	  SignalResolutionControl "TryResolveAllWithWarning"
-	  BlockPriorityViolationMsg "warning"
-	  MinStepSizeMsg	  "warning"
-	  TimeAdjustmentMsg	  "none"
-	  MaxConsecutiveZCsMsg	  "error"
-	  SolverPrmCheckMsg	  "warning"
-	  InheritedTsInSrcMsg	  "warning"
-	  DiscreteInheritContinuousMsg "warning"
-	  MultiTaskDSMMsg	  "error"
-	  MultiTaskCondExecSysMsg "error"
-	  MultiTaskRateTransMsg	  "error"
-	  SingleTaskRateTransMsg  "none"
-	  TasksWithSamePriorityMsg "warning"
-	  SigSpecEnsureSampleTimeMsg "warning"
-	  CheckMatrixSingularityMsg "none"
-	  IntegerOverflowMsg	  "warning"
-	  Int32ToFloatConvMsg	  "warning"
-	  ParameterDowncastMsg	  "error"
-	  ParameterOverflowMsg	  "error"
-	  ParameterUnderflowMsg	  "none"
-	  ParameterPrecisionLossMsg "warning"
-	  ParameterTunabilityLossMsg "warning"
-	  FixptConstUnderflowMsg  "none"
-	  FixptConstOverflowMsg	  "none"
-	  FixptConstPrecisionLossMsg "none"
-	  UnderSpecifiedDataTypeMsg "none"
-	  UnnecessaryDatatypeConvMsg "none"
-	  VectorMatrixConversionMsg "none"
-	  InvalidFcnCallConnMsg	  "error"
-	  FcnCallInpInsideContextMsg "Use local settings"
-	  SignalLabelMismatchMsg  "none"
-	  UnconnectedInputMsg	  "warning"
-	  UnconnectedOutputMsg	  "warning"
-	  UnconnectedLineMsg	  "warning"
-	  SFcnCompatibilityMsg	  "none"
-	  UniqueDataStoreMsg	  "none"
-	  BusObjectLabelMismatch  "warning"
-	  RootOutportRequireBusObject "warning"
-	  AssertControl		  "UseLocalSettings"
-	  EnableOverflowDetection off
-	  ModelReferenceIOMsg	  "none"
-	  ModelReferenceVersionMismatchMessage "none"
-	  ModelReferenceIOMismatchMessage "none"
-	  ModelReferenceCSMismatchMessage "none"
-	  UnknownTsInhSupMsg	  "warning"
-	  ModelReferenceDataLoggingMessage "warning"
-	  ModelReferenceSymbolNameMessage "warning"
-	  ModelReferenceExtraNoncontSigs "error"
-	  StateNameClashWarn	  "warning"
-	  SimStateInterfaceChecksumMismatchMsg "warning"
-	  StrictBusMsg		  "Warning"
-	  LoggingUnavailableSignals "error"
-	  BlockIODiagnostic	  "none"
-	}
-	Simulink.HardwareCC {
-	  $ObjectID		  6
-	  Version		  "1.6.0"
-	  ProdBitPerChar	  8
-	  ProdBitPerShort	  16
-	  ProdBitPerInt		  32
-	  ProdBitPerLong	  32
-	  ProdIntDivRoundTo	  "Undefined"
-	  ProdEndianess		  "Unspecified"
-	  ProdWordSize		  32
-	  ProdShiftRightIntArith  on
-	  ProdHWDeviceType	  "32-bit Generic"
-	  TargetBitPerChar	  8
-	  TargetBitPerShort	  16
-	  TargetBitPerInt	  32
-	  TargetBitPerLong	  32
-	  TargetShiftRightIntArith on
-	  TargetIntDivRoundTo	  "Undefined"
-	  TargetEndianess	  "Unspecified"
-	  TargetWordSize	  32
-	  TargetTypeEmulationWarnSuppressLevel 0
-	  TargetPreprocMaxBitsSint 32
-	  TargetPreprocMaxBitsUint 32
-	  TargetHWDeviceType	  "Specified"
-	  TargetUnknown		  off
-	  ProdEqTarget		  on
-	}
-	Simulink.ModelReferenceCC {
-	  $ObjectID		  7
-	  Version		  "1.6.0"
-	  UpdateModelReferenceTargets "IfOutOfDateOrStructuralChange"
-	  CheckModelReferenceTargetMessage "error"
-	  ModelReferenceNumInstancesAllowed "Multi"
-	  ModelReferencePassRootInputsByReference on
-	  ModelReferenceMinAlgLoopOccurrences off
-	}
-	Simulink.SFSimCC {
-	  $ObjectID		  8
-	  Version		  "1.6.0"
-	  SFSimEnableDebug	  on
-	  SFSimOverflowDetection  on
-	  SFSimEcho		  on
-	  SimBlas		  on
-	  SimCtrlC		  on
-	  SimExtrinsic		  on
-	  SimIntegrity		  on
-	  SimUseLocalCustomCode	  off
-	  SimBuildMode		  "sf_incremental_build"
-	}
-	Simulink.RTWCC {
-	  $BackupClass		  "Simulink.RTWCC"
-	  $ObjectID		  9
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    1
-	    Cell		    "IncludeHyperlinkInReport"
-	    PropName		    "DisabledProps"
-	  }
-	  SystemTargetFile	  "grt.tlc"
-	  GenCodeOnly		  off
-	  MakeCommand		  "make_rtw"
-	  GenerateMakefile	  on
-	  TemplateMakefile	  "grt_default_tmf"
-	  GenerateReport	  off
-	  SaveLog		  off
-	  RTWVerbose		  on
-	  RetainRTWFile		  off
-	  ProfileTLC		  off
-	  TLCDebug		  off
-	  TLCCoverage		  off
-	  TLCAssert		  off
-	  ProcessScriptMode	  "Default"
-	  ConfigurationMode	  "Optimized"
-	  ConfigAtBuild		  off
-	  RTWUseLocalCustomCode	  off
-	  RTWUseSimCustomCode	  off
-	  IncludeHyperlinkInReport off
-	  LaunchReport		  off
-	  TargetLang		  "C"
-	  IncludeBusHierarchyInRTWFileBlockHierarchyMap	off
-	  IncludeERTFirstTime	  off
-	  GenerateTraceInfo	  off
-	  GenerateTraceReport	  off
-	  GenerateTraceReportSl	  off
-	  GenerateTraceReportSf	  off
-	  GenerateTraceReportEml  off
-	  GenerateCodeInfo	  off
-	  RTWCompilerOptimization "Off"
-	  CheckMdlBeforeBuild	  "Off"
-	  Array {
-	    Type		    "Handle"
-	    Dimension		    2
-	    Simulink.CodeAppCC {
-	      $ObjectID		      10
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		16
-		Cell			"IgnoreCustomStorageClasses"
-		Cell			"InsertBlockDesc"
-		Cell			"SFDataObjDesc"
-		Cell			"SimulinkDataObjDesc"
-		Cell			"DefineNamingRule"
-		Cell			"SignalNamingRule"
-		Cell			"ParamNamingRule"
-		Cell			"InlinedPrmAccess"
-		Cell			"CustomSymbolStr"
-		Cell			"CustomSymbolStrGlobalVar"
-		Cell			"CustomSymbolStrType"
-		Cell			"CustomSymbolStrField"
-		Cell			"CustomSymbolStrFcn"
-		Cell			"CustomSymbolStrBlkIO"
-		Cell			"CustomSymbolStrTmpVar"
-		Cell			"CustomSymbolStrMacro"
-		PropName		"DisabledProps"
-	      }
-	      ForceParamTrailComments off
-	      GenerateComments	      on
-	      IgnoreCustomStorageClasses on
-	      IgnoreTestpoints	      off
-	      IncHierarchyInIds	      off
-	      MaxIdLength	      31
-	      PreserveName	      off
-	      PreserveNameWithParent  off
-	      ShowEliminatedStatement off
-	      IncAutoGenComments      off
-	      SimulinkDataObjDesc     off
-	      SFDataObjDesc	      off
-	      IncDataTypeInIds	      off
-	      MangleLength	      1
-	      CustomSymbolStrGlobalVar "$R$N$M"
-	      CustomSymbolStrType     "$N$R$M"
-	      CustomSymbolStrField    "$N$M"
-	      CustomSymbolStrFcn      "$R$N$M$F"
-	      CustomSymbolStrFcnArg   "rt$I$N$M"
-	      CustomSymbolStrBlkIO    "rtb_$N$M"
-	      CustomSymbolStrTmpVar   "$N$M"
-	      CustomSymbolStrMacro    "$R$N$M"
-	      DefineNamingRule	      "None"
-	      ParamNamingRule	      "None"
-	      SignalNamingRule	      "None"
-	      InsertBlockDesc	      off
-	      SimulinkBlockComments   on
-	      EnableCustomComments    off
-	      InlinedPrmAccess	      "Literals"
-	      ReqsInCode	      off
-	      UseSimReservedNames     off
-	    }
-	    Simulink.GRTTargetCC {
-	      $BackupClass	      "Simulink.TargetCC"
-	      $ObjectID		      11
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		13
-		Cell			"IncludeMdlTerminateFcn"
-		Cell			"CombineOutputUpdateFcns"
-		Cell			"SuppressErrorStatus"
-		Cell			"ERTCustomFileBanners"
-		Cell			"GenerateSampleERTMain"
-		Cell			"GenerateTestInterfaces"
-		Cell			"MultiInstanceERTCode"
-		Cell			"PurelyIntegerCode"
-		Cell			"SupportNonFinite"
-		Cell			"SupportComplex"
-		Cell			"SupportAbsoluteTime"
-		Cell			"SupportContinuousTime"
-		Cell			"SupportNonInlinedSFcns"
-		PropName		"DisabledProps"
-	      }
-	      TargetFcnLib	      "ansi_tfl_tmw.mat"
-	      TargetLibSuffix	      ""
-	      TargetPreCompLibLocation ""
-	      TargetFunctionLibrary   "ANSI_C"
-	      UtilityFuncGeneration   "Auto"
-	      ERTMultiwordTypeDef     "System defined"
-	      ERTMultiwordLength      256
-	      MultiwordLength	      2048
-	      GenerateFullHeader      on
-	      GenerateSampleERTMain   off
-	      GenerateTestInterfaces  off
-	      IsPILTarget	      off
-	      ModelReferenceCompliant on
-	      ParMdlRefBuildCompliant on
-	      CompOptLevelCompliant   on
-	      IncludeMdlTerminateFcn  on
-	      GeneratePreprocessorConditionals "Disable all"
-	      CombineOutputUpdateFcns off
-	      SuppressErrorStatus     off
-	      ERTFirstTimeCompliant   off
-	      IncludeFileDelimiter    "Auto"
-	      ERTCustomFileBanners    off
-	      SupportAbsoluteTime     on
-	      LogVarNameModifier      "rt_"
-	      MatFileLogging	      on
-	      MultiInstanceERTCode    off
-	      SupportNonFinite	      on
-	      SupportComplex	      on
-	      PurelyIntegerCode	      off
-	      SupportContinuousTime   on
-	      SupportNonInlinedSFcns  on
-	      SupportVariableSizeSignals off
-	      EnableShiftOperators    on
-	      ParenthesesLevel	      "Nominal"
-	      PortableWordSizes	      off
-	      ModelStepFunctionPrototypeControlCompliant off
-	      CPPClassGenCompliant    off
-	      AutosarCompliant	      off
-	      UseMalloc		      off
-	      ExtMode		      off
-	      ExtModeStaticAlloc      off
-	      ExtModeTesting	      off
-	      ExtModeStaticAllocSize  1000000
-	      ExtModeTransport	      0
-	      ExtModeMexFile	      "ext_comm"
-	      ExtModeIntrfLevel	      "Level1"
-	      RTWCAPISignals	      off
-	      RTWCAPIParams	      off
-	      RTWCAPIStates	      off
-	      GenerateASAP2	      off
-	    }
-	    PropName		    "Components"
-	  }
-	}
-	PropName		"Components"
-      }
-      Name		      "Configuration"
-      CurrentDlgPage	      "Solver"
-      ConfigPrmDlgPosition    " [ 200, 197, 1080, 827 ] "
-    }
-    PropName		    "ConfigurationSets"
-  }
-  Simulink.ConfigSet {
-    $PropName		    "ActiveConfigurationSet"
-    $ObjectID		    1
-  }
-  BlockDefaults {
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    NamePlacement	    "normal"
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    ShowName		    on
-    BlockRotation	    0
-    BlockMirror		    off
-  }
-  AnnotationDefaults {
-    HorizontalAlignment	    "center"
-    VerticalAlignment	    "middle"
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    UseDisplayTextAsClickCallback off
-  }
-  LineDefaults {
-    FontName		    "Courier"
-    FontSize		    9
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-  }
-  BlockParameterDefaults {
-    Block {
-      BlockType		      FromWorkspace
-      VariableName	      "simulink_input"
-      SampleTime	      "-1"
-      Interpolate	      on
-      ZeroCross		      off
-      OutputAfterFinalValue   "Extrapolation"
-    }
-    Block {
-      BlockType		      "S-Function"
-      FunctionName	      "system"
-      SFunctionModules	      "''"
-      PortCounts	      "[]"
-      SFunctionDeploymentMode off
-    }
-    Block {
-      BlockType		      Scope
-      ModelBased	      off
-      TickLabels	      "OneTimeTick"
-      ZoomMode		      "on"
-      Grid		      "on"
-      TimeRange		      "auto"
-      YMin		      "-5"
-      YMax		      "5"
-      SaveToWorkspace	      off
-      SaveName		      "ScopeData"
-      LimitDataPoints	      on
-      MaxDataPoints	      "5000"
-      Decimation	      "1"
-      SampleInput	      off
-      SampleTime	      "-1"
-    }
-  }
-  System {
-    Name		    "example_SQProblem"
-    Location		    [122, 122, 1798, 1077]
-    Open		    on
-    ModelBrowserVisibility  off
-    ModelBrowserWidth	    200
-    ScreenColor		    "white"
-    PaperOrientation	    "landscape"
-    PaperPositionMode	    "auto"
-    PaperType		    "usletter"
-    PaperUnits		    "inches"
-    TiledPaperMargins	    [0.500000, 0.500000, 0.500000, 0.500000]
-    TiledPageScale	    1
-    ShowPageBoundaries	    off
-    ZoomFactor		    "125"
-    ReportName		    "simulink-default.rpt"
-    SIDHighWatermark	    14
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "A"
-      SID		      3
-      Position		      [100, 198, 165, 222]
-      VariableName	      "A"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "H"
-      SID		      1
-      Position		      [100, 98, 165, 122]
-      VariableName	      "H"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "g"
-      SID		      2
-      Position		      [100, 148, 165, 172]
-      VariableName	      "g"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "lb"
-      SID		      4
-      Position		      [100, 248, 165, 272]
-      VariableName	      "lb"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "lbA"
-      SID		      6
-      Position		      [100, 348, 165, 372]
-      VariableName	      "lbA"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      "S-Function"
-      Name		      "qpOASES"
-      SID		      9
-      Ports		      [7, 4]
-      Position		      [590, 224, 790, 296]
-      BackgroundColor	      "yellow"
-      FunctionName	      "qpOASES_SQProblem"
-      EnableBusSupport	      off
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "ub"
-      SID		      5
-      Position		      [100, 298, 165, 322]
-      VariableName	      "ub"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "ubA"
-      SID		      7
-      Position		      [100, 398, 165, 422]
-      VariableName	      "ubA"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      Scope
-      Name		      "x,\nfval,\nexitflag,\niter"
-      SID		      8
-      Ports		      [4]
-      Position		      [950, 223, 1005, 297]
-      Floating		      off
-      Location		      [6, 78, 1276, 993]
-      Open		      off
-      NumInputPorts	      "4"
-      List {
-	ListType		AxesTitles
-	axes1			"%<SignalLabel>"
-	axes2			"%<SignalLabel>"
-	axes3			"%<SignalLabel>"
-	axes4			"%<SignalLabel>"
-      }
-      YMin		      "-5~-5~-5~-5"
-      YMax		      "5~5~5~5"
-      SaveName		      "ScopeData1"
-      DataFormat	      "StructureWithTime"
-      SampleTime	      "0"
-    }
-    Line {
-      SrcBlock		      "H"
-      SrcPort		      1
-      Points		      [155, 0; 0, 120]
-      DstBlock		      "qpOASES"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "g"
-      SrcPort		      1
-      Points		      [115, 0; 0, 80]
-      DstBlock		      "qpOASES"
-      DstPort		      2
-    }
-    Line {
-      Labels		      [3, 0]
-      SrcBlock		      "ubA"
-      SrcPort		      1
-      Points		      [160, 0; 0, -120]
-      DstBlock		      "qpOASES"
-      DstPort		      7
-    }
-    Line {
-      SrcBlock		      "ub"
-      SrcPort		      1
-      Points		      [80, 0; 0, -40]
-      DstBlock		      "qpOASES"
-      DstPort		      5
-    }
-    Line {
-      SrcBlock		      "lb"
-      SrcPort		      1
-      DstBlock		      "qpOASES"
-      DstPort		      4
-    }
-    Line {
-      SrcBlock		      "A"
-      SrcPort		      1
-      Points		      [80, 0; 0, 40]
-      DstBlock		      "qpOASES"
-      DstPort		      3
-    }
-    Line {
-      Labels		      [3, 0]
-      SrcBlock		      "lbA"
-      SrcPort		      1
-      Points		      [115, 0; 0, -80]
-      DstBlock		      "qpOASES"
-      DstPort		      6
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      1
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      2
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      2
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      3
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      3
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      4
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      4
-    }
-    Annotation {
-      Position		      [350, 96]
-    }
-    Annotation {
-      Name		      "This file is part of qpOASES.\n\nqpOASES -- An Implementation of the Online Active Set Strategy.\nC"
-      "opyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka, Christian Kirches et al.\nAll rights reserved."
-      Position		      [683, 128]
-    }
-  }
-}
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblem.m b/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblem.m
deleted file mode 100644
index f1d8eab..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblem.m
+++ /dev/null
@@ -1,86 +0,0 @@
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-
-
-%%
-%%	Filename:  interfaces/simulink/load_example_QProblem.m
-%%	Author:    Hans Joachim Ferreau (thanks to Aude Perrin)
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-
-
-clear all;
-
-
-%% setup QP data
-simulationTime = [0;0.1];
-
-H = [ 1.0,0.0; ...
-      0.0,0.5 ];
-
-A = [ 1.0,1.0 ];
-
-g.time = simulationTime;
-data1 = [ 1.5,1.0 ];
-data2 = [ 1.0,1.5 ];
-g.signals.values = [data1; data2];
-g.signals.dimensions = numel(data1);
-
-lb.time = simulationTime;
-data1 = [ 0.5,-2.0 ];
-data2 = [ 0.0,-1.0 ];
-lb.signals.values = [data1; data2];
-lb.signals.dimensions = numel(data1);
-
-ub.time = simulationTime;
-data1 = [ 5.0,2.0 ];
-data2 = [ 5.0,-0.5 ];
-ub.signals.values = [data1; data2];
-ub.signals.dimensions = numel(data1);
-
-lbA.time = simulationTime;
-data1 = [ -1.0 ];
-data2 = [ -2.0 ];
-lbA.signals.values = [data1; data2];
-lbA.signals.dimensions = numel(data1);
-
-ubA.time = simulationTime;
-data1 = [ 2.0 ];
-data2 = [ 1.0 ];
-ubA.signals.values = [data1; data2];
-ubA.signals.dimensions = numel(data1);
-
-
-clear simulationTime data1 data2
-
-
-%% open corresponding simulink example
-open( 'example_QProblem.mdl' );
-
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblemB.m b/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblemB.m
deleted file mode 100644
index d0bbd1b..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblemB.m
+++ /dev/null
@@ -1,72 +0,0 @@
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-
-
-%%
-%%	Filename:  interfaces/simulink/load_example_QProblemB.m
-%%	Author:    Hans Joachim Ferreau (thanks to Aude Perrin)
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-
-
-clear all;
-
-
-%% setup QP data
-simulationTime = [0;0.1];
-
-H = [ 1.0,0.0; ...
-      0.0,0.5 ];
-
-g.time = simulationTime;
-data1 = [ 1.5,1.0 ];
-data2 = [ 1.0,1.5 ];
-g.signals.values = [data1; data2];
-g.signals.dimensions = numel(data1);
-
-lb.time = simulationTime;
-data1 = [ 0.5,-2.0 ];
-data2 = [ 0.0,-1.0 ];
-lb.signals.values = [data1; data2];
-lb.signals.dimensions = numel(data1);
-
-ub.time = simulationTime;
-data1 = [ 5.0,2.0 ];
-data2 = [ 5.0,-0.5 ];
-ub.signals.values = [data1; data2];
-ub.signals.dimensions = numel(data1);
-
-
-clear simulationTime data1 data2
-
-
-%% open corresponding simulink example
-open( 'example_QProblemB.mdl' );
-
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_SQProblem.m b/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_SQProblem.m
deleted file mode 100644
index 16c0f16..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_SQProblem.m
+++ /dev/null
@@ -1,95 +0,0 @@
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-
-
-%%
-%%	Filename:  interfaces/simulink/load_example_SQProblem.m
-%%	Author:    Hans Joachim Ferreau (thanks to Aude Perrin)
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-
-
-clear all;
-
-
-%% setup QP data
-simulationTime = [0;0.1];
-
-H.time = simulationTime;
-data1 = [ 1.0,0.0; ...
-          0.0,0.5 ];
-data2 = [ 1.0,0.5; ...
-          0.5,0.5 ];
-H.signals.values = [ data1(:)'; data2(:)' ];
-H.signals.dimensions = numel(data1);
-
-g.time = simulationTime;
-data1 = [ 1.5,1.0 ];
-data2 = [ 1.0,1.5 ];
-g.signals.values = [data1; data2];
-g.signals.dimensions = numel(data1);
-
-A.time = simulationTime;
-data1 = [ 1.0,1.0 ];
-data2 = [ 1.0,5.0 ];
-A.signals.values = [ data1(:)'; data2(:)' ];
-A.signals.dimensions = numel(data1);
-
-lb.time = simulationTime;
-data1 = [ 0.5,-2.0 ];
-data2 = [ 0.0,-1.0 ];
-lb.signals.values = [data1; data2];
-lb.signals.dimensions = numel(data1);
-
-ub.time = simulationTime;
-data1 = [ 5.0,2.0 ];
-data2 = [ 5.0,-0.5 ];
-ub.signals.values = [data1; data2];
-ub.signals.dimensions = numel(data1);
-
-lbA.time = simulationTime;
-data1 = [ -1.0 ];
-data2 = [ -2.0 ];
-lbA.signals.values = [data1; data2];
-lbA.signals.dimensions = numel(data1);
-
-ubA.time = simulationTime;
-data1 = [ 2.0 ];
-data2 = [ 1.0 ];
-ubA.signals.values = [data1; data2];
-ubA.signals.dimensions = numel(data1);
-
-
-clear simulationTime data1 data2
-
-
-%% open corresponding simulink example
-open( 'example_SQProblem.mdl' );
-
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/make.m b/extlibs/qpOASES-3.2.0/interfaces/simulink/make.m
deleted file mode 100644
index 7a2aa1f..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/make.m
+++ /dev/null
@@ -1,239 +0,0 @@
-function [] = make( varargin )
-%MAKE Compiles the Simulink interface of qpOASES.
-%
-%Type  make            to compile all interfaces that 
-%                      have been modified,
-%type  make clean      to delete all compiled interfaces,
-%type  make clean all  to first delete and then compile 
-%                      all interfaces,
-%type  make 'name'     to compile only the interface with
-%                      the given name (if it has been modified),
-%type  make 'opt'      to compile all interfaces using the 
-%                      given compiler options.
-%
-%Copyright (C) 2013-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-%%
-%%	Filename:  interfaces/simulink/make.m
-%%	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-       
-    %% consistency check
-    if ( exist( [pwd, '/make.m'],'file' ) == 0 )
-        error( ['ERROR (',mfilename '.m): Run this make script directly within the directory', ...
-                '<qpOASES-inst-dir>/interfaces/simulink, please.'] );
-    end
-
-
-    if ( nargin > 2 )
-        error( ['ERROR (',mfilename '.m): At most two make arguments supported!'] );
-    else
-        [ doClean,fcnNames,userFlags ] = analyseMakeArguments( nargin,varargin );
-    end
-
-    
-    %% define compiler settings
-    QPOASESPATH = '../../';
-    
-    DEBUGFLAGS = ' ';
-    %DEBUGFLAGS = ' -g CXXDEBUGFLAGS=''$CXXDEBUGFLAGS -Wall -pedantic -Wshadow'' ';
-
-    IFLAGS = [ '-I. -I',QPOASESPATH,'include',' -I',QPOASESPATH,'src',' ' ];
-    CPPFLAGS = [ IFLAGS, DEBUGFLAGS, '-largeArrayDims -D__cpluplus -D__MATLAB__ -D__SINGLE_OBJECT__',' ' ];
-    defaultFlags = '-O '; %% -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__
-
-    if ( ispc == 0 )
-        CPPFLAGS  = [ CPPFLAGS, '-DLINUX ',' ' ]; 
-    else
-        CPPFLAGS  = [ CPPFLAGS, '-DWIN32 ',' ' ];
-    end
-
-    if ( isempty(userFlags) > 0 )
-        CPPFLAGS = [ CPPFLAGS, defaultFlags,' ' ];
-    else
-        CPPFLAGS = [ CPPFLAGS, userFlags,' ' ];
-    end
-
-    mexExt = eval('mexext');
-    
-    
-    %% ensure copyright notice is displayed
-    if ~isempty( strfind( CPPFLAGS,'-D__NO_COPYRIGHT__' ) )
-        printCopyrightNotice( );
-    end
-    
-    
-    %% clean if desired
-    if ( doClean > 0 )
-        
-        eval( 'delete *.o;' );
-        eval( ['delete *.',mexExt,'*;'] );
-        disp( [ 'INFO (',mfilename '.m): Cleaned all compiled files.'] );
-        pause( 0.2 );
-        
-    end
-    
-    
-    if ( ~isempty(userFlags) )
-        disp( [ 'INFO (',mfilename '.m): Compiling all files with user-defined compiler flags (''',userFlags,''')...'] );
-    end
-    
-
-    %% call mex compiler
-    for ii=1:length(fcnNames)
-        
-        cmd = [ 'mex -output ', fcnNames{ii}, ' ', CPPFLAGS, [fcnNames{ii},'.cpp'] ];
-        
-        if ( exist( [fcnNames{ii},'.',mexExt],'file' ) == 0 )
-            
-            eval( cmd );
-            disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            
-        else
-            
-            % check modification time of source/Make files and compiled mex file
-            cppFile = dir( [pwd,'/',fcnNames{ii},'.cpp'] );
-            cppFileTimestamp = getTimestamp( cppFile );
-
-            makeFile = dir( [pwd,'/make.m'] );
-            makeFileTimestamp = getTimestamp( makeFile );
-            
-            mexFile = dir( [pwd,'/',fcnNames{ii},'.',mexExt] );
-            if ( isempty(mexFile) == 0 )
-                mexFileTimestamp = getTimestamp( mexFile );
-            else
-                mexFileTimestamp = 0;
-            end
-            
-            if ( ( cppFileTimestamp   >= mexFileTimestamp ) || ...
-                 ( makeFileTimestamp  >= mexFileTimestamp ) )
-                eval( cmd );
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            else            
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' already exists.'] );
-            end
-            
-        end
-        
-    end
-
-    %% add qpOASES directory to path
-    path( path,pwd );
-
-end
-
-
-function [ doClean,fcnNames,userIFlags ] = analyseMakeArguments( nArgs,args )
-
-    doClean = 0;
-    fcnNames = [];
-    userIFlags = [];
-
-    switch ( nArgs )
-        
-        case 1
-            if ( strcmp( args{1},'all' ) > 0 )
-                fcnNames = { 'qpOASES_QProblemB','qpOASES_QProblem','qpOASES_SQProblem' };
-            elseif ( strcmp( args{1},'qpOASES_QProblemB' ) > 0 )
-                fcnNames = { 'qpOASES_QProblemB' };
-            elseif ( strcmp( args{1},'qpOASES_QProblem' ) > 0 )
-                fcnNames = { 'qpOASES_QProblem' };
-            elseif ( strcmp( args{1},'qpOASES_SQProblem' ) > 0 )
-                fcnNames = { 'qpOASES_SQProblem' };
-            elseif ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            elseif ( strcmp( args{1}(1),'-' ) > 0 )
-                % make clean all with user-specified compiler flags
-                userIFlags = args{1};
-                doClean = 1;
-                fcnNames = { 'qpOASES_QProblemB','qpOASES_QProblem','qpOASES_SQProblem' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid first argument (''',args{1},''')!'] );
-            end
-
-        case 2
-            if ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            else
-                error( ['ERROR (',mfilename '.m): First argument must be ''clean'' if two arguments are provided!'] );
-            end
-            
-            if ( strcmp( args{2},'all' ) > 0 )
-                fcnNames = { 'qpOASES_QProblemB','qpOASES_QProblem','qpOASES_SQProblem' };
-            elseif ( strcmp( args{2},'qpOASES_QProblemB' ) > 0 )
-                fcnNames = { 'qpOASES_QProblemB' };
-            elseif ( strcmp( args{2},'qpOASES_QProblem' ) > 0 )
-                fcnNames = { 'qpOASES_QProblem' };
-            elseif ( strcmp( args{2},'qpOASES_SQProblem' ) > 0 )
-                fcnNames = { 'qpOASES_SQProblem' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid second argument (''',args{2},''')!'] );
-            end
-            
-        otherwise
-            doClean = 0;
-            fcnNames = { 'qpOASES_QProblemB','qpOASES_QProblem','qpOASES_SQProblem' };
-            userIFlags = [];            
-    end
-    
-end
-
-
-function [ timestamp ] = getTimestamp( dateString )
-
-    try 
-        timestamp = dateString.datenum;
-    catch
-        timestamp = Inf;
-    end
-
-end
-
-
-function [ ] = printCopyrightNotice( )
-
-    disp( ' ' );
-    disp( 'qpOASES -- An Implementation of the Online Active Set Strategy.' );
-    disp( 'Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,' );
-    disp( 'Christian Kirches et al. All rights reserved.' );
-    disp( ' ' );
-    disp( 'qpOASES is distributed under the terms of the' );
-    disp( 'GNU Lesser General Public License 2.1 in the hope that it will be' );
-    disp( 'useful, but WITHOUT ANY WARRANTY; without even the implied warranty' );
-    disp( 'of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.' );
-    disp( 'See the GNU Lesser General Public License for more details.' );
-    disp( ' ' );
-    disp( ' ' );
-
-end
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblem.cpp b/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblem.cpp
deleted file mode 100644
index 735d755..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblem.cpp
+++ /dev/null
@@ -1,506 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/simulink/qpOASES_QProblem.cpp
- *	\author Hans Joachim Ferreau (thanks to Aude Perrin)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Simulink(R) that enables to call qpOASES as a S function
- *  (variant for QPs with fixed matrices).
- *
- */
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "qpOASES_simulink_utils.cpp"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define S_FUNCTION_NAME   qpOASES_QProblem		/**< Name of the S function. */
-#define S_FUNCTION_LEVEL  2						/**< S function level. */
-
-#define MDL_START								/**< Activate call to mdlStart. */
-
-#include "simstruc.h"
-
-
-/* SETTINGS: */
-#define SAMPLINGTIME   -1						/**< Sampling time. */
-#define NCONTROLINPUTS  2						/**< Number of control inputs. */
-#define MAXITER         100						/**< Maximum number of iterations. */
-#define HESSIANTYPE     HST_UNKNOWN				/**< Hessian type, see documentation of QProblem class constructor. */
-
-
-static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
-{
-	int nU = NCONTROLINPUTS;
-
-	/* Specify the number of continuous and discrete states */
-	ssSetNumContStates(S, 0);
-	ssSetNumDiscStates(S, 0);
-
-	/* Specify the number of parameters */
-	ssSetNumSFcnParams(S, 2); /* H, A */
-	if ( ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S) )
-		return;
-
-	/* Specify the number of intput ports */
-	if ( !ssSetNumInputPorts(S, 5) )
-		return;
-
-	/* Specify the number of output ports */
-	if ( !ssSetNumOutputPorts(S, 4) )
-		return;
-
-	/* Specify dimension information for the input ports */
-	ssSetInputPortVectorDimension(S, 0, DYNAMICALLY_SIZED); /* g */
-	ssSetInputPortVectorDimension(S, 1, DYNAMICALLY_SIZED); /* lb */
-	ssSetInputPortVectorDimension(S, 2, DYNAMICALLY_SIZED); /* ub */
-	ssSetInputPortVectorDimension(S, 3, DYNAMICALLY_SIZED); /* lbA */
-	ssSetInputPortVectorDimension(S, 4, DYNAMICALLY_SIZED); /* ubA */
-
-	/* Specify dimension information for the output ports */
-	ssSetOutputPortVectorDimension(S, 0, nU );  /* uOpt */
-	ssSetOutputPortVectorDimension(S, 1, 1 );   /* fval */
-	ssSetOutputPortVectorDimension(S, 2, 1 );   /* exitflag */
-	ssSetOutputPortVectorDimension(S, 3, 1 );   /* iter */
-
-	/* Specify the direct feedthrough status */
-	ssSetInputPortDirectFeedThrough(S, 0, 1);
-	ssSetInputPortDirectFeedThrough(S, 1, 1);
-	ssSetInputPortDirectFeedThrough(S, 2, 1);
-	ssSetInputPortDirectFeedThrough(S, 3, 1);
-	ssSetInputPortDirectFeedThrough(S, 4, 1);
-
-	/* One sample time */
-	ssSetNumSampleTimes(S, 1);
-
-	/* global variables:
-     * 0: problem
-     * 1: H
-     * 2: g
-     * 3: A
-     * 4: lb
-     * 5: ub
-     * 6: lbA
-     * 7: ubA
-     */
-
-	/* Specify the size of the block's pointer work vector */
-    ssSetNumPWork(S, 8);
-}
-
-
-#if defined(MATLAB_MEX_FILE)
-
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-
-static void mdlSetInputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetInputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-static void mdlSetOutputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetOutputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-#endif
-
-
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-	ssSetSampleTime(S, 0, SAMPLINGTIME);
-	ssSetOffsetTime(S, 0, 0.0);
-}
-
-
-static void mdlStart(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int nU = NCONTROLINPUTS;
-	int size_g, size_lb, size_ub, size_lbA, size_ubA;
-	int size_H, nRows_H, nCols_H, size_A, nRows_A, nCols_A;
-	int nV, nC;
-
-	QProblem* problem;
-
-
-	/* get block inputs dimensions */
-	const mxArray* in_H = ssGetSFcnParam(S, 0);
-	const mxArray* in_A = ssGetSFcnParam(S, 1);
-
-	if ( mxIsEmpty(in_H) == 1 )
-	{
-		if ( ( HESSIANTYPE != HST_ZERO ) && ( HESSIANTYPE != HST_IDENTITY ) )
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			mexErrMsgTxt( "ERROR (qpOASES): Hessian can only be empty if type is set to HST_ZERO or HST_IDENTITY!" );
-			#endif
-			return;
-		}
-		
-	    nRows_H = 0;
-		nCols_H = 0;
-		size_H  = 0;
-	}
-	else
-	{
-	    nRows_H = (int)mxGetM(in_H);
-		nCols_H = (int)mxGetN(in_H);
-		size_H  = nRows_H * nCols_H;
-	}
-
-	if ( mxIsEmpty(in_A) == 1 )
-	{
-	    nRows_A = 0;
-		nCols_A = 0;
-		size_A  = 0;
-	}
-	else
-	{
-	    nRows_A = (int)mxGetM(in_A);
-		nCols_A = (int)mxGetN(in_A);
-		size_A  = nRows_A * nCols_A;
-	}
-
-	size_g   = ssGetInputPortWidth(S, 0);
-	size_lb  = ssGetInputPortWidth(S, 1);
-	size_ub  = ssGetInputPortWidth(S, 2);
-	size_lbA = ssGetInputPortWidth(S, 3);
-	size_ubA = ssGetInputPortWidth(S, 4);
-
-
-	/* dimension checks */
-	nV = size_g;
-	nC = nRows_A;
-
-
-	if ( MAXITER < 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Maximum number of iterations must not be negative!" );
-		#endif
-		return;
-	}
-
-	if ( nV <= 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_H != nV*nV ) && ( size_H != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in H!" );
-		#endif
-		return;
-	}
-
-	if ( nRows_H != nCols_H )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Hessian matrix must be square matrix!" );
-		#endif
-		return;
-	}
-
-	if ( ( nU < 1 ) || ( nU > nV ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Invalid number of control inputs!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_lb != nV ) && ( size_lb != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in lb!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_ub != nV ) && ( size_lb != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in ub!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_lbA != nC ) && ( size_lbA != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in lbA!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_ubA != nC ) && ( size_ubA != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in ubA!" );
-		#endif
-		return;
-	}
-
-
-	/* allocate QProblem object */
-	problem = new QProblem( nV,nC,HESSIANTYPE );
-	if ( problem == 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Unable to create QProblem object!" );
-		#endif
-		return;
-	}
-	
-	Options problemOptions;
-	problemOptions.setToMPC();
-	problem->setOptions( problemOptions );
-
-	#ifndef __DEBUG__
-	problem->setPrintLevel( PL_LOW );
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	problem->setPrintLevel( PL_NONE );
-	#endif
-
-	ssGetPWork(S)[0] = (void *) problem;
-
-	/* allocate memory for QP data ... */
-	if ( size_H > 0 )
-		ssGetPWork(S)[1] = (void *) calloc( size_H, sizeof(real_t) );	/* H */
-	else
-		ssGetPWork(S)[1] = 0;
-
-	ssGetPWork(S)[2] = (void *) calloc( size_g, sizeof(real_t) );		/* g */
-	ssGetPWork(S)[3] = (void *) calloc( size_A, sizeof(real_t) );		/* A */
-
-	if ( size_lb > 0 )
-		ssGetPWork(S)[4] = (void *) calloc( size_lb, sizeof(real_t) );	/* lb */
-	else
-		ssGetPWork(S)[4] = 0;
-
-	if ( size_ub > 0 )
-		ssGetPWork(S)[5] = (void *) calloc( size_ub, sizeof(real_t) );	/* ub */
-	else
-		ssGetPWork(S)[5] = 0;
-	
-	if ( size_lbA > 0 )
-		ssGetPWork(S)[6] = (void *) calloc( size_lbA, sizeof(real_t) );	/* lbA */
-	else
-		ssGetPWork(S)[6] = 0;
-
-	if ( size_ubA > 0 )
-		ssGetPWork(S)[7] = (void *) calloc( size_ubA, sizeof(real_t) );	/* ubA */
-	else
-		ssGetPWork(S)[7] = 0;
-}
-
-
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-	int nV, nC;
-	returnValue status;
-
-	int_t nWSR = MAXITER;
-	int nU     = NCONTROLINPUTS;
-
-	InputRealPtrsType in_g, in_lb, in_ub, in_lbA, in_ubA;
-
-	QProblem* problem;
-	real_t *H, *g, *A, *lb, *ub, *lbA, *ubA;
-
-	real_t *xOpt;
-
-	real_T *out_uOpt, *out_objVal, *out_status, *out_nWSR;
-
-
-	/* get pointers to block inputs ... */
-	const mxArray* in_H = ssGetSFcnParam(S, 0);
-	const mxArray* in_A = ssGetSFcnParam(S, 1);
-	in_g   = ssGetInputPortRealSignalPtrs(S, 0);
-	in_lb  = ssGetInputPortRealSignalPtrs(S, 1);
-	in_ub  = ssGetInputPortRealSignalPtrs(S, 2);
-	in_lbA = ssGetInputPortRealSignalPtrs(S, 3);
-	in_ubA = ssGetInputPortRealSignalPtrs(S, 4);
-
-
-	/* ... and to the QP data */
-	problem = (QProblem*)(ssGetPWork(S)[0]);
-
-	H   = (real_t *) ssGetPWork(S)[1];
-	g   = (real_t *) ssGetPWork(S)[2];
-	A   = (real_t *) ssGetPWork(S)[3];
-	lb  = (real_t *) ssGetPWork(S)[4];
-	ub  = (real_t *) ssGetPWork(S)[5];
-	lbA = (real_t *) ssGetPWork(S)[6];
-	ubA = (real_t *) ssGetPWork(S)[7];
-
-
-	/* setup QP data */
-	nV = ssGetInputPortWidth(S, 0); /* nV = size_g */
-	nC = (int)mxGetM(in_A);			/* nC = nRows_A*/
-
-	if ( H != 0 )
-	{
-		/* no conversion from FORTRAN to C as Hessian is symmetric! */
-		for ( i=0; i<nV*nV; ++i )
-			H[i] = (mxGetPr(in_H))[i];
-	}
-
-	convertFortranToC( mxGetPr(in_A),nV,nC, A );
-
-	for ( i=0; i<nV; ++i )
-		g[i] = (*in_g)[i];
-
-	if ( lb != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			lb[i] = (*in_lb)[i];
-	}
-
-	if ( ub != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			ub[i] = (*in_ub)[i];
-	}
-
-	if ( lbA != 0 )
-	{
-		for ( i=0; i<nC; ++i )
-			lbA[i] = (*in_lbA)[i];
-	}
-
-	if ( ubA != 0 )
-	{
-		for ( i=0; i<nC; ++i )
-			ubA[i] = (*in_ubA)[i];
-	}
-
-	xOpt = new real_t[nV];
-
-	if ( problem->getCount() == 0 )
-	{
-		/* initialise and solve first QP */
-		status = problem->init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-		problem->getPrimalSolution( xOpt );
-	}
-	else
-	{
-		/* solve neighbouring QP using hotstart technique */
-		status = problem->hotstart( g,lb,ub,lbA,ubA, nWSR,0 );
-		if ( ( status != SUCCESSFUL_RETURN ) && ( status != RET_MAX_NWSR_REACHED ) )
-		{
-			/* if an error occurs, reset problem data structures ... */
-			problem->reset( );
-            
-            /* ... and initialise/solve again with remaining number of iterations. */
-            int_t nWSR_retry = MAXITER - nWSR;
-			status = problem->init( H,g,A,lb,ub,lbA,ubA, nWSR_retry,0 );
-			nWSR += nWSR_retry;
-			
-		}
-
-		/* obtain optimal solution */
-		problem->getPrimalSolution( xOpt );
-	}
-
-	/* generate block output: status information ... */
-	out_uOpt   = ssGetOutputPortRealSignal(S, 0);
-	out_objVal = ssGetOutputPortRealSignal(S, 1);
-	out_status = ssGetOutputPortRealSignal(S, 2);
-	out_nWSR   = ssGetOutputPortRealSignal(S, 3);
-
-	for ( i=0; i<nU; ++i )
-		out_uOpt[i] = (real_T)(xOpt[i]);
-
-	out_objVal[0] = (real_T)(problem->getObjVal());
-	out_status[0] = (real_t)(getSimpleStatus( status ));
-	out_nWSR[0]   = (real_T)(nWSR);
-
-	removeNaNs( out_uOpt,nU );
-	removeInfs( out_uOpt,nU );
-	removeNaNs( out_objVal,1 );
-	removeInfs( out_objVal,1 );
-
-	delete[] xOpt;
-}
-
-
-static void mdlTerminate(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-	
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-
-	if ( ssGetPWork(S)[0] != 0 )
-		delete ((QProblem*)(ssGetPWork(S)[0]));
-
-	for ( i=1; i<8; ++i )
-	{
-		if ( ssGetPWork(S)[i] != 0 )
-			free( ssGetPWork(S)[i] );
-	}
-}
-
-
-#ifdef  MATLAB_MEX_FILE
-#include "simulink.c"
-#else
-#include "cg_sfun.h"
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblemB.cpp b/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblemB.cpp
deleted file mode 100644
index 5de0a5b..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblemB.cpp
+++ /dev/null
@@ -1,431 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/simulink/qpOASES_QProblemB.cpp
- *	\author Hans Joachim Ferreau (thanks to Aude Perrin)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Simulink(R) that enables to call qpOASES as a S function
- *  (variant for simply bounded QPs with fixed matrices).
- *
- */
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "qpOASES_simulink_utils.cpp"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define S_FUNCTION_NAME   qpOASES_QProblemB		/**< Name of the S function. */
-#define S_FUNCTION_LEVEL  2						/**< S function level. */
-
-#define MDL_START								/**< Activate call to mdlStart. */
-
-#include "simstruc.h"
-
-
-/* SETTINGS */
-#define SAMPLINGTIME   -1						/**< Sampling time. */
-#define NCONTROLINPUTS  2						/**< Number of control inputs. */
-#define MAXITER         100						/**< Maximum number of iteration. */
-#define HESSIANTYPE     HST_UNKNOWN				/**< Hessian type, see documentation of QProblemB class constructor. */
-
-
-static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
-{
-	int nU = NCONTROLINPUTS;
-
-	/* Specify the number of continuous and discrete states */
-	ssSetNumContStates(S, 0);
-	ssSetNumDiscStates(S, 0);
-
-	/* Specify the number of parameters */
-	ssSetNumSFcnParams(S, 1); /* H */
-	if ( ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S) )
-		return;
-
-	/* Specify the number of intput ports */
-	if ( !ssSetNumInputPorts(S, 3) )
-		return;
-
-	/* Specify the number of output ports */
-	if ( !ssSetNumOutputPorts(S, 4) )
-		return;
-
-	/* Specify dimension information for the input ports */
-	ssSetInputPortVectorDimension(S, 0, DYNAMICALLY_SIZED);	/* g */
-	ssSetInputPortVectorDimension(S, 1, DYNAMICALLY_SIZED);	/* lb */
-	ssSetInputPortVectorDimension(S, 2, DYNAMICALLY_SIZED);	/* ub */
-
-	/* Specify dimension information for the output ports */
-	ssSetOutputPortVectorDimension(S, 0, nU );  /* uOpt */
-    ssSetOutputPortVectorDimension(S, 1, 1 );   /* fval */
-	ssSetOutputPortVectorDimension(S, 2, 1 );   /* exitflag */
-	ssSetOutputPortVectorDimension(S, 3, 1 );   /* iter */
-
-	/* Specify the direct feedthrough status */
-	ssSetInputPortDirectFeedThrough(S, 0, 1);
-	ssSetInputPortDirectFeedThrough(S, 1, 1);
-	ssSetInputPortDirectFeedThrough(S, 2, 1);
-
-	/* One sample time */
-	ssSetNumSampleTimes(S, 1);
-
-	/* global variables:
-     * 0: problem
-     * 1: H
-     * 2: g
-     * 3: lb
-     * 4: ub
-     */
-
-	/* Specify the size of the block's pointer work vector */
-    ssSetNumPWork(S, 5);
-}
-
-
-#if defined(MATLAB_MEX_FILE)
-
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-
-static void mdlSetInputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetInputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-static void mdlSetOutputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetOutputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-#endif
-
-
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-	ssSetSampleTime(S, 0, SAMPLINGTIME);
-	ssSetOffsetTime(S, 0, 0.0);
-}
-
-
-static void mdlStart(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int nU = NCONTROLINPUTS;
-	int size_g, size_lb, size_ub;
-	int size_H, nRows_H, nCols_H;
-	int nV;
-
-	QProblemB* problem;
-
-
-	/* get block inputs dimensions */
-	const mxArray* in_H = ssGetSFcnParam(S, 0);
-
-	if ( mxIsEmpty(in_H) == 1 )
-	{
-		if ( ( HESSIANTYPE != HST_ZERO ) && ( HESSIANTYPE != HST_IDENTITY ) )
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			mexErrMsgTxt( "ERROR (qpOASES): Hessian can only be empty if type is set to HST_ZERO or HST_IDENTITY!" );
-			#endif
-			return;
-		}
-		
-	    nRows_H = 0;
-		nCols_H = 0;
-		size_H  = 0;
-	}
-	else
-	{
-	    nRows_H = (int)mxGetM(in_H);
-		nCols_H = (int)mxGetN(in_H);
-		size_H  = nRows_H * nCols_H;
-	}
-
-	size_g   = ssGetInputPortWidth(S, 0);
-	size_lb  = ssGetInputPortWidth(S, 1);
-	size_ub  = ssGetInputPortWidth(S, 2);
-
-
-	/* dimension checks */
-	nV = size_g;
-
-	if ( MAXITER < 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Maximum number of iterations must not be negative!" );
-		#endif
-		return;
-	}
-
-	if ( nV <= 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_H != nV*nV ) && ( size_H != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in H!" );
-		#endif
-		return;
-	}
-
-	if ( nRows_H != nCols_H )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Hessian matrix must be square matrix!" );
-		#endif
-		return;
-	}
-
-	if ( ( nU < 1 ) || ( nU > nV ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Invalid number of control inputs!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_lb != nV ) && ( size_lb != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in lb!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_ub != nV ) && ( size_ub != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in ub!" );
-		#endif
-		return;
-	}
-
-
-	/* allocate QProblemB object */
-	problem = new QProblemB( nV,HESSIANTYPE );
-	if ( problem == 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Unable to create QProblemB object!" );
-		#endif
-		return;
-	}
-
-	Options problemOptions;
-	problemOptions.setToMPC();
-	problem->setOptions( problemOptions );
-	
-	#ifndef __DEBUG__
-	problem->setPrintLevel( PL_LOW );
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	problem->setPrintLevel( PL_NONE );
-	#endif
-
-	ssGetPWork(S)[0] = (void *) problem;
-
-	/* allocate memory for QP data ... */
-	if ( size_H > 0 )
-		ssGetPWork(S)[1] = (void *) calloc( size_H, sizeof(real_t) );	/* H */
-	else
-		ssGetPWork(S)[1] = 0;
-
-	ssGetPWork(S)[2] = (void *) calloc( size_g, sizeof(real_t) );		/* g */
-
-	if ( size_lb > 0 )
-		ssGetPWork(S)[3] = (void *) calloc( size_lb, sizeof(real_t) );	/* lb */
-	else
-		ssGetPWork(S)[3] = 0;
-
-	if ( size_ub > 0 )
-		ssGetPWork(S)[4] = (void *) calloc( size_ub, sizeof(real_t) );	/* ub */
-	else
-		ssGetPWork(S)[4] = 0;
-}
-
-
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-	int nV;
-	returnValue status;
-
-	int_t nWSR = MAXITER;
-	int nU     = NCONTROLINPUTS;
-
-	InputRealPtrsType in_g, in_lb, in_ub;
-
-	QProblemB* problem;
-	real_t *H, *g, *lb, *ub;
-
-	real_t *xOpt;
-
-	real_T *out_uOpt, *out_objVal, *out_status, *out_nWSR;
-
-
-	/* get pointers to block inputs ... */
-	const mxArray* in_H = ssGetSFcnParam(S, 0);
-	in_g  = ssGetInputPortRealSignalPtrs(S, 0);
-	in_lb = ssGetInputPortRealSignalPtrs(S, 1);
-	in_ub = ssGetInputPortRealSignalPtrs(S, 2);
-
-	/* ... and to the QP data */
-	problem = (QProblemB*) ssGetPWork(S)[0];
-
-	H  = (real_t *) ssGetPWork(S)[1];
-	g  = (real_t *) ssGetPWork(S)[2];
-	lb = (real_t *) ssGetPWork(S)[3];
-	ub = (real_t *) ssGetPWork(S)[4];
-
-
-	/* setup QP data */
-	nV = ssGetInputPortWidth(S, 1); /* nV = size_g */
-
-	if ( H != 0 )
-	{
-		/* no conversion from FORTRAN to C as Hessian is symmetric! */
-		for ( i=0; i<nV*nV; ++i )
-			H[i] = (mxGetPr(in_H))[i];
-	}
-
-	for ( i=0; i<nV; ++i )
-		g[i] = (*in_g)[i];
-
-	if ( lb != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			lb[i] = (*in_lb)[i];
-	}
-
-	if ( ub != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			ub[i] = (*in_ub)[i];
-	}
-
-	xOpt = new real_t[nV];
-
-	if ( problem->getCount() == 0 )
-	{
-		/* initialise and solve first QP */
-		status = problem->init( H,g,lb,ub, nWSR,0 );
-		problem->getPrimalSolution( xOpt );
-	}
-	else
-	{
-		/* solve neighbouring QP using hotstart technique */
-		status = problem->hotstart( g,lb,ub, nWSR,0 );
-		if ( ( status != SUCCESSFUL_RETURN ) && ( status != RET_MAX_NWSR_REACHED ) )
-		{
-			/* if an error occurs, reset problem data structures ... */
-			problem->reset( );
-            
-            /* ... and initialise/solve again with remaining number of iterations. */
-            int_t nWSR_retry = MAXITER - nWSR;
-			status = problem->init( H,g,lb,ub, nWSR_retry,0 );
-            nWSR += nWSR_retry;
-		}
-
-		/* obtain optimal solution */
-		problem->getPrimalSolution( xOpt );
-	}
-
-	/* generate block output: status information ... */
-	out_uOpt   = ssGetOutputPortRealSignal(S, 0);
-	out_objVal = ssGetOutputPortRealSignal(S, 1);
-	out_status = ssGetOutputPortRealSignal(S, 2);
-	out_nWSR   = ssGetOutputPortRealSignal(S, 3);
-
-	for ( i=0; i<nU; ++i )
-		out_uOpt[i] = (real_T)(xOpt[i]);
-    
-    out_objVal[0] = (real_T)(problem->getObjVal());
-	out_status[0] = (real_t)(getSimpleStatus( status ));
-	out_nWSR[0]   = (real_T)(nWSR);
-
-	removeNaNs( out_uOpt,nU );
-	removeInfs( out_uOpt,nU );
-	removeNaNs( out_objVal,1 );
-	removeInfs( out_objVal,1 );
-
-	delete[] xOpt;
-}
-
-
-static void mdlTerminate(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-
-	if ( ssGetPWork(S)[0] != 0 )
-		delete ((QProblemB*)(ssGetPWork(S)[0]));
-
-	for ( i=1; i<5; ++i )
-	{
-		if ( ssGetPWork(S)[i] != 0 )
-			free( ssGetPWork(S)[i] );
-	}
-}
-
-
-#ifdef  MATLAB_MEX_FILE
-#include "simulink.c"
-#else
-#include "cg_sfun.h"
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_SQProblem.cpp b/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_SQProblem.cpp
deleted file mode 100644
index b720508..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_SQProblem.cpp
+++ /dev/null
@@ -1,475 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/simulink/qpOASES_SQProblem.cpp
- *	\author Hans Joachim Ferreau (thanks to Aude Perrin)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Simulink(R) that enables to call qpOASES as a S function
- *  (variant for QPs with varying matrices).
- *
- */
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "qpOASES_simulink_utils.cpp"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define S_FUNCTION_NAME   qpOASES_SQProblem		/**< Name of the S function. */
-#define S_FUNCTION_LEVEL  2						/**< S function level. */
-
-#define MDL_START								/**< Activate call to mdlStart. */
-
-#include "simstruc.h"
-
-
-/* SETTINGS */
-#define SAMPLINGTIME   -1						/**< Sampling time. */
-#define NCONTROLINPUTS  2						/**< Number of control inputs. */
-#define MAXITER         100	    				/**< Maximum number of iterations. */
-#define HESSIANTYPE     HST_UNKNOWN				/**< Hessian type, see documentation of SQProblem class constructor. */
-
-
-static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
-{
-	int nU = NCONTROLINPUTS;
-
-	/* Specify the number of continuous and discrete states */
-	ssSetNumContStates(S, 0);
-	ssSetNumDiscStates(S, 0);
-
-	/* Specify the number of parameters */
-	ssSetNumSFcnParams(S, 0);
-	if ( ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S) )
-		return;
-
-	/* Specify the number of intput ports */
-	if ( !ssSetNumInputPorts(S, 7) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Invalid number of input ports!" );
-		#endif
-		return;
-	}
-
-	/* Specify the number of output ports */
-	if ( !ssSetNumOutputPorts(S, 4) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Invalid number of output ports!" );
-		#endif
-		return;
-	}
-
-	/* Specify dimension information for the input ports */
-	ssSetInputPortVectorDimension(S, 0, DYNAMICALLY_SIZED);	/* H */
-	ssSetInputPortVectorDimension(S, 1, DYNAMICALLY_SIZED); /* g */
-	ssSetInputPortVectorDimension(S, 2, DYNAMICALLY_SIZED); /* A */
-	ssSetInputPortVectorDimension(S, 3, DYNAMICALLY_SIZED); /* lb */
-	ssSetInputPortVectorDimension(S, 4, DYNAMICALLY_SIZED); /* ub */
-	ssSetInputPortVectorDimension(S, 5, DYNAMICALLY_SIZED); /* lbA */
-	ssSetInputPortVectorDimension(S, 6, DYNAMICALLY_SIZED); /* ubA */
-
-	/* Specify dimension information for the output ports */
-	ssSetOutputPortVectorDimension(S, 0, nU );  /* uOpt */
-	ssSetOutputPortVectorDimension(S, 1, 1 );   /* fval */
-	ssSetOutputPortVectorDimension(S, 2, 1 );   /* exitflag */
-	ssSetOutputPortVectorDimension(S, 3, 1 );   /* iter */
-
-	/* Specify the direct feedthrough status */
-	ssSetInputPortDirectFeedThrough(S, 0, 1);
-	ssSetInputPortDirectFeedThrough(S, 1, 1);
-	ssSetInputPortDirectFeedThrough(S, 2, 1);
-	ssSetInputPortDirectFeedThrough(S, 3, 1);
-	ssSetInputPortDirectFeedThrough(S, 4, 1);
-	ssSetInputPortDirectFeedThrough(S, 5, 1);
-	ssSetInputPortDirectFeedThrough(S, 6, 1);
-
-	/* One sample time */
-	ssSetNumSampleTimes(S, 1);
-
-	/* global variables:
-     * 0: problem
-     * 1: H
-     * 2: g
-     * 3: A
-     * 4: lb
-     * 5: ub
-     * 6: lbA
-     * 7: ubA
-     */
-
-	/* Specify the size of the block's pointer work vector */
-    ssSetNumPWork(S, 8);
-}
-
-
-#if defined(MATLAB_MEX_FILE)
-
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-
-static void mdlSetInputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetInputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-static void mdlSetOutputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetOutputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-#endif
-
-
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-	ssSetSampleTime(S, 0, SAMPLINGTIME);
-	ssSetOffsetTime(S, 0, 0.0);
-}
-
-
-static void mdlStart(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int nU = NCONTROLINPUTS;
-	int size_H, size_g, size_A, size_lb, size_ub, size_lbA, size_ubA;
-	int nV, nC;
-
-	SQProblem* problem;
-
-
-	/* get block inputs dimensions */
-	size_H   = ssGetInputPortWidth(S, 0);
-	size_g   = ssGetInputPortWidth(S, 1);
-	size_A   = ssGetInputPortWidth(S, 2);
-	size_lb  = ssGetInputPortWidth(S, 3);
-	size_ub  = ssGetInputPortWidth(S, 4);
-	size_lbA = ssGetInputPortWidth(S, 5);
-	size_ubA = ssGetInputPortWidth(S, 6);
-
-
-	/* dimension checks */
-	nV = size_g;
-	nC = (int) ( ((real_t) size_A) / ((real_t) nV) );
-
-	if ( MAXITER < 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Maximum number of iterations must not be negative!" );
-		#endif
-		return;
-	}
-
-	if ( nV <= 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_H != nV*nV ) && ( size_H != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in H!" );
-		#endif
-		return;
-	}
-
-	if ( ( nU < 1 ) || ( nU > nV ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Invalid number of control inputs!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_lb != nV ) && ( size_lb != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in lb!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_ub != nV ) && ( size_ub != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in ub!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_lbA != nC ) && ( size_lbA != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in lbA!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_ubA != nC ) && ( size_ubA != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in ubA!" );
-		#endif
-		return;
-	}
-
-
-	/* allocate QProblem object */
-	problem = new SQProblem( nV,nC,HESSIANTYPE );
-	if ( problem == 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Unable to create SQProblem object!" );
-		#endif
-		return;
-	}
-
-	Options problemOptions;
-	problemOptions.setToMPC();
-	problem->setOptions( problemOptions );
-
-	#ifndef __DEBUG__
-	problem->setPrintLevel( PL_LOW );
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	problem->setPrintLevel( PL_NONE );
-	#endif
-
-	ssGetPWork(S)[0] = (void *) problem;
-
-	/* allocate memory for QP data ... */
-	if ( size_H > 0 )
-		ssGetPWork(S)[1] = (void *) calloc( size_H, sizeof(real_t) );	/* H */
-	else
-		ssGetPWork(S)[1] = 0;
-
-	ssGetPWork(S)[2] = (void *) calloc( size_g, sizeof(real_t) );		/* g */
-	ssGetPWork(S)[3] = (void *) calloc( size_A, sizeof(real_t) );		/* A */
-
-	if ( size_lb > 0 )
-		ssGetPWork(S)[4] = (void *) calloc( size_lb, sizeof(real_t) );	/* lb */
-	else
-		ssGetPWork(S)[4] = 0;
-
-	if ( size_ub > 0 )
-		ssGetPWork(S)[5] = (void *) calloc( size_ub, sizeof(real_t) );	/* ub */
-	else
-		ssGetPWork(S)[5] = 0;
-	
-	if ( size_lbA > 0 )
-		ssGetPWork(S)[6] = (void *) calloc( size_lbA, sizeof(real_t) );	/* lbA */
-	else
-		ssGetPWork(S)[6] = 0;
-
-	if ( size_ubA > 0 )
-		ssGetPWork(S)[7] = (void *) calloc( size_ubA, sizeof(real_t) );	/* ubA */
-	else
-		ssGetPWork(S)[7] = 0;
-}
-
-
-
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-	int nV, nC;
-	returnValue status;
-
-	int_t nWSR = MAXITER;
-	int nU     = NCONTROLINPUTS;
-
-	InputRealPtrsType in_H, in_g, in_A, in_lb, in_ub, in_lbA, in_ubA;
-
-	SQProblem* problem;
-	real_t *H, *g, *A, *lb, *ub, *lbA, *ubA;
-
-	real_t *xOpt;
-
-	real_T *out_uOpt, *out_objVal, *out_status, *out_nWSR;
-
-
-	/* get pointers to block inputs ... */
-	in_H   = ssGetInputPortRealSignalPtrs(S, 0);
-	in_g   = ssGetInputPortRealSignalPtrs(S, 1);
-	in_A   = ssGetInputPortRealSignalPtrs(S, 2);
-	in_lb  = ssGetInputPortRealSignalPtrs(S, 3);
-	in_ub  = ssGetInputPortRealSignalPtrs(S, 4);
-	in_lbA = ssGetInputPortRealSignalPtrs(S, 5);
-	in_ubA = ssGetInputPortRealSignalPtrs(S, 6);
-
-
-	/* ... and to the QP data */
-	problem = (SQProblem*) ssGetPWork(S)[0];
-
-	H   = (real_t *) ssGetPWork(S)[1];
-	g   = (real_t *) ssGetPWork(S)[2];
-	A   = (real_t *) ssGetPWork(S)[3];
-	lb  = (real_t *) ssGetPWork(S)[4];
-	ub  = (real_t *) ssGetPWork(S)[5];
-	lbA = (real_t *) ssGetPWork(S)[6];
-	ubA = (real_t *) ssGetPWork(S)[7];
-
-
-	/* setup QP data */
-	nV = ssGetInputPortWidth(S, 1); /* nV = size_g */
-	nC = (int) ( ((real_t) ssGetInputPortWidth(S, 2)) / ((real_t) nV) ); /* nC = size_A / size_g */
-
-	if ( H != 0 )
-	{
-		/* no conversion from FORTRAN to C as Hessian is symmetric! */
-		for ( i=0; i<nV*nV; ++i )
-			H[i] = (*in_H)[i];
-	}
-
-	convertFortranToC( *in_A,nV,nC, A );
-
-	for ( i=0; i<nV; ++i )
-		g[i] = (*in_g)[i];
-
-	if ( lb != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			lb[i] = (*in_lb)[i];
-	}
-
-	if ( ub != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			ub[i] = (*in_ub)[i];
-	}
-
-	if ( lbA != 0 )
-	{
-		for ( i=0; i<nC; ++i )
-			lbA[i] = (*in_lbA)[i];
-	}
-
-	if ( ubA != 0 )
-	{
-		for ( i=0; i<nC; ++i )
-			ubA[i] = (*in_ubA)[i];
-	}
-
-	xOpt = new real_t[nV];
-
-	if ( problem->getCount() == 0 )
-	{
-		/* initialise and solve first QP */
-		status = problem->init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-		problem->getPrimalSolution( xOpt );
-	}
-	else
-	{
-		/* solve neighbouring QP using hotstart technique */
-		status = problem->hotstart( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-		if ( ( status != SUCCESSFUL_RETURN ) && ( status != RET_MAX_NWSR_REACHED ) )
-		{
-			/* if an error occurs, reset problem data structures ... */
-			problem->reset( );
-            
-            /* ... and initialise/solve again with remaining number of iterations. */
-            int_t nWSR_retry = MAXITER - nWSR;
-			status = problem->init( H,g,A,lb,ub,lbA,ubA, nWSR_retry,0 );
-            nWSR += nWSR_retry;
-		}
-	        
-        /* obtain optimal solution */
-        problem->getPrimalSolution( xOpt );
-	}
-
-	/* generate block output: status information ... */
-	out_uOpt   = ssGetOutputPortRealSignal(S, 0);
-	out_objVal = ssGetOutputPortRealSignal(S, 1);
-	out_status = ssGetOutputPortRealSignal(S, 2);
-	out_nWSR   = ssGetOutputPortRealSignal(S, 3);
-
-	for ( i=0; i<nU; ++i )
-		out_uOpt[i] = (real_T)(xOpt[i]);
-
-	out_objVal[0] = (real_T)(problem->getObjVal( ));
-	out_status[0] = (real_t)(getSimpleStatus( status ));
-	out_nWSR[0]   = (real_T)(nWSR);
-
-	removeNaNs( out_uOpt,nU );
-	removeInfs( out_uOpt,nU );
-	removeNaNs( out_objVal,1 );
-	removeInfs( out_objVal,1 );
-
-	delete[] xOpt;
-}
-
-
-static void mdlTerminate(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-
-	if ( ssGetPWork(S)[0] != 0 )
-		delete ((SQProblem*)(ssGetPWork(S)[0]));
-
-	for ( i=1; i<8; ++i )
-	{
-		if ( ssGetPWork(S)[i] != 0 )
-			free( ssGetPWork(S)[i] );
-	}
-}
-
-
-#ifdef  MATLAB_MEX_FILE
-#include "simulink.c"
-#else
-#include "cg_sfun.h"
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_simulink_utils.cpp b/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_simulink_utils.cpp
deleted file mode 100644
index 59c4158..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_simulink_utils.cpp
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/simulink/qpOASES_simulink_utils.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Collects utility functions for Interface to Simulink(R) that
- *	enables to call qpOASES as a C S function.
- *
- */
-
-#ifndef __SINGLE_OBJECT__
-#include <qpOASES.hpp>
-#endif
-
-
-USING_NAMESPACE_QPOASES
-
-
-/*
- *	i s N a N
- */
-BooleanType isNaN( real_t val )
-{
-	if ( (( val <= 0.0 ) || ( val >= 0.0 )) == 0 )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *	r e m o v e N a N s
- */
-returnValue removeNaNs( real_t* const data, unsigned int dim )
-{
-	unsigned int i;
-
-	if ( data == 0 )
-		return RET_INVALID_ARGUMENTS;
-
-	for ( i=0; i<dim; ++i )
-		if ( isNaN(data[i]) == BT_TRUE )
-			data[i] = INFTY;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e I n f s
- */
-returnValue removeInfs( real_t* const data, unsigned int dim )
-{
-	unsigned int i;
-
-	if ( data == 0 )
-		return RET_INVALID_ARGUMENTS;
-
-	for ( i=0; i<dim; ++i )
-	{
-		if ( data[i] < -INFTY )
-			data[i] = -INFTY;
-
-		if ( data[i] > INFTY )
-			data[i] = INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	c o n v e r t F o r t r a n T o C
- */
-returnValue convertFortranToC( const real_t* const M_for, int nV, int nC, real_t* const M )
-{
-	int i,j;
-
-	if ( ( M_for == 0 ) || ( M == 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	if ( ( nV < 0 ) || ( nC < 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	for ( i=0; i<nC; ++i )
-		for ( j=0; j<nV; ++j )
-			M[i*nV + j] = M_for[j*nC + i];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/libqpOASESConfig.cmake.in b/extlibs/qpOASES-3.2.0/libqpOASESConfig.cmake.in
deleted file mode 100644
index 28ed2f6..0000000
--- a/extlibs/qpOASES-3.2.0/libqpOASESConfig.cmake.in
+++ /dev/null
@@ -1,13 +0,0 @@
-# CMake package configuration file for the plugin '@PROJECT_NAME@'
-
-@PACKAGE_INIT@
-
-if(NOT TARGET @PROJECT_NAME@)
-    include("${CMAKE_CURRENT_LIST_DIR}/@PROJECT_NAME@Targets.cmake")
-endif()
-
-check_required_components(@PROJECT_NAME@)
-
-set(@PROJECT_NAME@_LIBRARY @PROJECT_NAME@)
-set(@PROJECT_NAME@_LIBRARIES @PROJECT_NAME@)
-set(@PROJECT_NAME@_INCLUDE_DIRS @PROJECT_SOURCE_DIR@/include)
\ No newline at end of file
diff --git a/extlibs/qpOASES-3.2.0/make.mk b/extlibs/qpOASES-3.2.0/make.mk
deleted file mode 100644
index 5dcbf66..0000000
--- a/extlibs/qpOASES-3.2.0/make.mk
+++ /dev/null
@@ -1,38 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  make.mk
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-
-TOP = $(realpath $(dir $(lastword $(MAKEFILE_LIST))))
-
-include ${TOP}/make_linux.mk
-#include ${TOP}/make_cygwin.mk
-#include ${TOP}/make_windows.mk
-#include ${TOP}/make_osx.mk
diff --git a/extlibs/qpOASES-3.2.0/make_cygwin.mk b/extlibs/qpOASES-3.2.0/make_cygwin.mk
deleted file mode 100644
index 0279293..0000000
--- a/extlibs/qpOASES-3.2.0/make_cygwin.mk
+++ /dev/null
@@ -1,119 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  make_cygwin.mk
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-################################################################################
-# user configuration
-
-# include directories, relative
-IDIR =   ${TOP}/include
-SRCDIR = ${TOP}/src
-BINDIR = ${TOP}/bin
-
-# Matlab include directory (ADAPT TO YOUR LOCAL SETTINGS!)
-MATLAB_IDIR   = /cygdrive/c/progra~2/matlab/r2009b/extern/include/
-MATLAB_LIBDIR = /cygdrive/c/progra~2/matlab/r2009b/extern/lib/win32/microsoft
-
-# system or replacement BLAS/LAPACK
-REPLACE_LINALG = 1
-
-ifeq ($(REPLACE_LINALG), 1)
-	LIB_BLAS =   ${SRCDIR}/BLASReplacement.o
-	LIB_LAPACK = ${SRCDIR}/LAPACKReplacement.o
-else
-	LIB_BLAS =   /usr/lib/lapack/cygblas-0.dll
-	LIB_LAPACK = /usr/lib/lapack/cyglapack-0.dll
-endif
-
-# choice of sparse solver: NONE, MA27, or MA57
-# If choice is not 'NONE', BLAS and LAPACK replacements must not be used
-USE_SOLVER = NONE
-
-ifeq ($(USE_SOLVER), MA57)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma57.a /usr/local/lib/libfakemetis.a
-	DEF_SOLVER = SOLVER_MA57
-else ifeq ($(USE_SOLVER), MA27)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma27.a
-	DEF_SOLVER = SOLVER_MA27
-else
-	LIB_SOLVER =
-	DEF_SOLVER = SOLVER_NONE
-endif
-
-################################################################################
-# do not touch this
-
-CPP = g++
-CC  = gcc
-AR  = ar
-RM  = rm
-F77 = gfortran
-ECHO = echo
-CD = cd
-CP = cp
-
-# file extensions
-OBJEXT = o
-LIBEXT = a
-DLLEXT = so
-EXE = .exe
-MEXOCTEXT = mex
-DEF_TARGET = -o $@
-SHARED = -shared
-
-# 32 or 64 depending on target platform
-BITS = $(shell getconf LONG_BIT)
-
-# decide on MEX interface extension
-ifeq ($(BITS), 32)
-	MEXEXT = mexw32
-else
-	MEXEXT = mexw64
-endif
-
-CPPFLAGS = -Wall -pedantic -Wshadow -Wfloat-equal -O3 -Wconversion -Wsign-conversion -finline-functions -DWIN32 -D${DEF_SOLVER} -D__NO_COPYRIGHT__ 
-#          -g -D__DEBUG__ -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__ -D__USE_SINGLE_PRECISION__
-
-# libraries to link against when building qpOASES .so files
-LINK_LIBRARIES = ${LIB_LAPACK} ${LIB_BLAS} -lm ${LIB_SOLVER}
-LINK_LIBRARIES_WRAPPER = -lm ${LIB_SOLVER} -lstdc++
-
-# how to link against the qpOASES shared library
-QPOASES_LINK = -L${BINDIR} -Wl,-rpath=${BINDIR} -lqpOASES
-QPOASES_LINK_WRAPPER = -L${BINDIR} -Wl,-rpath=${BINDIR} -lqpOASES_wrapper
-
-# link dependencies when creating executables
-LINK_DEPENDS = ${LIB_LAPACK} ${LIB_BLAS} ${BINDIR}/libqpOASES.${LIBEXT} ${BINDIR}/libqpOASES.${DLLEXT}
-LINK_DEPENDS_WRAPPER = ${BINDIR}/libqpOASES_wrapper.${LIBEXT} ${BINDIR}/libqpOASES_wrapper.${DLLEXT}
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/make_linux.mk b/extlibs/qpOASES-3.2.0/make_linux.mk
deleted file mode 100644
index 0670f11..0000000
--- a/extlibs/qpOASES-3.2.0/make_linux.mk
+++ /dev/null
@@ -1,122 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  make_linux.mk
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-################################################################################
-# user configuration
-
-# include directories, relative
-IDIR =   ${TOP}/include
-SRCDIR = ${TOP}/src
-BINDIR = ${TOP}/bin
-
-# Matlab include directory (ADAPT TO YOUR LOCAL SETTINGS!)
-#MATLAB_IDIR   = ${HOME}/Programs/matlab/extern/include/
-MATLAB_IDIR   = /usr/local/matlab/extern/include/
-MATLAB_LIBDIR = /usr/local/matlab/bin/glnxa64/
-
-# system or replacement BLAS/LAPACK
-REPLACE_LINALG = 1
-
-ifeq ($(REPLACE_LINALG), 1)
-	LIB_BLAS =   ${SRCDIR}/BLASReplacement.o
-	LIB_LAPACK = ${SRCDIR}/LAPACKReplacement.o
-else
-	LIB_BLAS =   /usr/lib/libblas.so
-	LIB_LAPACK = /usr/lib/liblapack.so
-endif
-
-# choice of sparse solver: NONE, MA27, or MA57
-# If choice is not 'NONE', BLAS and LAPACK replacements must not be used
-USE_SOLVER = NONE
-
-ifeq ($(USE_SOLVER), MA57)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma57.a /usr/local/lib/libfakemetis.a
-	DEF_SOLVER = SOLVER_MA57
-else ifeq ($(USE_SOLVER), MA27)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma27.a
-	DEF_SOLVER = SOLVER_MA27
-else
-	LIB_SOLVER =
-	DEF_SOLVER = SOLVER_NONE
-endif
-
-################################################################################
-# do not touch this
-
-CPP = g++
-CC  = gcc
-AR  = ar
-RM  = rm
-F77 = gfortran
-ECHO = echo
-CD = cd
-CP = cp
-
-# file extensions
-OBJEXT = o
-LIBEXT = a
-DLLEXT = so
-EXE =
-MEXOCTEXT = mex
-DEF_TARGET = -o $@
-SHARED = -shared
-
-# 32 or 64 depending on target platform
-BITS = $(shell getconf LONG_BIT)
-
-# decide on MEX interface extension
-ifeq ($(BITS), 32)
-	MEXEXT = mexglx
-else
-	MEXEXT = mexa64
-endif
-
-
-
-CPPFLAGS = -Wall -pedantic -Wshadow -Wfloat-equal -O3 -Wconversion -Wsign-conversion -finline-functions -fPIC -DLINUX -D${DEF_SOLVER} -D__NO_COPYRIGHT__
-#          -g -D__DEBUG__ -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__ -D__USE_SINGLE_PRECISION__
-
-# libraries to link against when building qpOASES .so files
-LINK_LIBRARIES = ${LIB_LAPACK} ${LIB_BLAS} -lm ${LIB_SOLVER}
-LINK_LIBRARIES_WRAPPER = -lm ${LIB_SOLVER} -lstdc++
-
-# how to link against the qpOASES shared library
-QPOASES_LINK = -L${BINDIR} -Wl,-rpath=${BINDIR} -lqpOASES
-QPOASES_LINK_WRAPPER = -L${BINDIR} -Wl,-rpath=${BINDIR} -lqpOASES_wrapper
-
-# link dependencies when creating executables
-LINK_DEPENDS = ${LIB_LAPACK} ${LIB_BLAS} ${BINDIR}/libqpOASES.${LIBEXT} ${BINDIR}/libqpOASES.${DLLEXT}
-LINK_DEPENDS_WRAPPER = ${BINDIR}/libqpOASES_wrapper.${LIBEXT} ${BINDIR}/libqpOASES_wrapper.${DLLEXT}
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/make_osx.mk b/extlibs/qpOASES-3.2.0/make_osx.mk
deleted file mode 100644
index 4f77386..0000000
--- a/extlibs/qpOASES-3.2.0/make_osx.mk
+++ /dev/null
@@ -1,124 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  make_osx.mk
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-################################################################################
-# user configuration
-
-# include directories, relative
-IDIR =   ${TOP}/include
-SRCDIR = ${TOP}/src
-BINDIR = ${TOP}/bin
-
-# MacOSX SDK
-SYSROOT = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.8.sdk
-SDK = -isysroot ${SYSROOT} -stdlib=libc++ -I/usr/include -L/usr/lib/
-
-# Matlab include directory (ADAPT TO YOUR LOCAL SETTINGS!)
-MATLAB_IDIR   = /Applications/MATLAB_R2013a.app/extern/include/
-MATLAB_LIBDIR =
-
-# system or replacement BLAS/LAPACK
-REPLACE_LINALG = 1
-
-ifeq ($(REPLACE_LINALG), 1)
-	LIB_BLAS =   ${SRCDIR}/BLASReplacement.o
-	LIB_LAPACK = ${SRCDIR}/LAPACKReplacement.o
-	LA_DEPENDS = ${LIB_LAPACK} ${LIB_BLAS}
-else
-	LIB_BLAS =   -framework Accelerate
-	LIB_LAPACK =
-	LA_DEPENDS =
-endif
-
-# choice of sparse solver: NONE, MA27, or MA57
-# If choice is not 'NONE', BLAS and LAPACK replacements must not be used
-USE_SOLVER = NONE
-
-ifeq ($(USE_SOLVER), MA57)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma57.a /usr/local/lib/libfakemetis.a
-	DEF_SOLVER = SOLVER_MA57
-else ifeq ($(USE_SOLVER), MA27)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma27.a
-	DEF_SOLVER = SOLVER_MA27
-else
-	LIB_SOLVER =
-	DEF_SOLVER = SOLVER_NONE
-endif
-
-################################################################################
-# do not touch this
-
-CPP = clang++
-CC  = clang
-AR  = ar
-RM  = rm
-F77 = gfortran
-ECHO = echo
-CD = cd
-
-# file extensions
-OBJEXT = o
-LIBEXT = a
-DLLEXT = dylib
-EXE =
-MEXOCTEXT = mex
-DEF_TARGET = -o $@
-SHARED = -dynamiclib ${SDK} -lgcc_s.10.5 -ldylib1.o
-
-# 32 or 64 depending on target platform
-BITS = $(shell getconf LONG_BIT)
-
-# decide on MEX interface extension
-ifeq ($(BITS), 32)
-	MEXEXT = mexglx
-else
-	MEXEXT = mexa64
-endif
-
-CPPFLAGS = ${SDK} -Wall -pedantic -Wshadow -Wfloat-equal -Wconversion -Wsign-conversion -O3 -finline-functions -fPIC -DLINUX
-#          -g -D__DEBUG__ -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__ -D__USE_SINGLE_PRECISION__
-
-# libraries to link against when building qpOASES .so files
-LINK_LIBRARIES = ${LIB_LAPACK} ${LIB_BLAS} -lm ${LIB_SOLVER}
-LINK_LIBRARIES_WRAPPER = -lm ${LIB_SOLVER}
-
-# how to link against the qpOASES shared library
-QPOASES_LINK = -L${BINDIR}  -lqpOASES -L${SYSROOT}/usr/lib/System -lgcc_s.10.5 -lcrt1.o
-QPOASES_LINK_WRAPPER = -L${BINDIR} -lqpOASES_wrapper
-
-# link dependencies when creating executables
-LINK_DEPENDS = ${LA_DEPENDS} ${BINDIR}/libqpOASES.${LIBEXT} ${BINDIR}/libqpOASES.${DLLEXT}
-LINK_DEPENDS_WRAPPER = ${BINDIR}/libqpOASES_wrapper.${LIBEXT} ${BINDIR}/libqpOASES_wrapper.${DLLEXT}
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/make_windows.mk b/extlibs/qpOASES-3.2.0/make_windows.mk
deleted file mode 100644
index 8debc8c..0000000
--- a/extlibs/qpOASES-3.2.0/make_windows.mk
+++ /dev/null
@@ -1,126 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  make_windows.mk
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-
-##
-##	definitions for compiling with Visual Studio under Windows
-##
-
-
-################################################################################
-# user configuration
-
-# include directories, relative
-IDIR =   ${TOP}/include
-SRCDIR = ${TOP}/src
-BINDIR = ${TOP}/bin
-
-# Matlab include directory (ADAPT TO YOUR LOCAL SETTINGS!)
-#MATLAB_IDIR   = ${HOME}/Programs/matlab/extern/include/
-MATLAB_IDIR = /usr/local/matlab/extern/include/
-MATLAB_LIBDIR = /usr/local/matlab/bin/glnxa64/
-
-# system or replacement BLAS/LAPACK
-REPLACE_LINALG = 1
-
-ifeq ($(REPLACE_LINALG), 1)
-	LIB_BLAS =   ${SRCDIR}/BLASReplacement.o
-	LIB_LAPACK = ${SRCDIR}/LAPACKReplacement.o
-else
-	LIB_BLAS =   /usr/lib/libblas.so
-	LIB_LAPACK = /usr/lib/liblapack.so
-endif
-
-# choice of sparse solver: NONE, MA27, or MA57
-# If choice is not 'NONE', BLAS and LAPACK replacements must not be used
-USE_SOLVER = NONE
-
-ifeq ($(USE_SOLVER), MA57)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma57.a /usr/local/lib/libfakemetis.a
-	DEF_SOLVER = SOLVER_MA57
-else ifeq ($(USE_SOLVER), MA27)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma27.a
-	DEF_SOLVER = SOLVER_MA27
-else
-	LIB_SOLVER =
-	DEF_SOLVER = SOLVER_NONE
-endif
-
-################################################################################
-# do not touch this
-
-CPP = cl
-CC  = cl
-AR  = ar
-RM  = rm
-F77 = gfortran
-ECHO = echo
-CD = cd
-CP = copy
-
-# file extensions
-OBJEXT = obj
-LIBEXT = lib
-DLLEXT = so
-EXE = .exe
-MEXOCTEXT = mex
-DEF_TARGET =
-SHARED = /LD
-
-# 32 or 64 depending on target platform
-BITS = $(shell getconf LONG_BIT)
-
-# decide on MEX interface extension
-ifeq ($(BITS), 32)
-	MEXEXT = mexglx
-else
-	MEXEXT = mexa64
-endif
-
-CPPFLAGS = -nologo -EHsc -DWIN32 -Dsnprintf=_snprintf
-#-g -D__DEBUG__ -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__
-
-# libraries to link against when building qpOASES .so files
-LINK_LIBRARIES = ${LIB_LAPACK} ${LIB_BLAS} -lm ${LIB_SOLVER}
-LINK_LIBRARIES_WRAPPER = -lm ${LIB_SOLVER}
-
-# how to link against the qpOASES shared library
-QPOASES_LINK = /I${BINDIR} /WL /link ${BINDIR}/libqpOASES.lib
-QPOASES_LINK_WRAPPER = /I${BINDIR} /WL /link ${BINDIR}/libqpOASES_wrapper.lib
-
-# link dependencies when creating executables
-LINK_DEPENDS = ${LIB_LAPACK} ${LIB_BLAS} ${BINDIR}/libqpOASES.${LIBEXT} ${BINDIR}/libqpOASES.${DLLEXT}
-LINK_DEPENDS_WRAPPER = ${BINDIR}/libqpOASES_wrapper.${LIBEXT} ${BINDIR}/libqpOASES_wrapper.${DLLEXT}
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/src/BLASReplacement.cpp b/extlibs/qpOASES-3.2.0/src/BLASReplacement.cpp
deleted file mode 100644
index 745fd55..0000000
--- a/extlibs/qpOASES-3.2.0/src/BLASReplacement.cpp
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/BLASReplacement.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	BLAS Level 3 replacement routines.
- */
-
-
-#include <qpOASES/Utils.hpp>
-
-
-extern "C" void dgemm_(	const char *TRANSA, const char *TRANSB,
-						const unsigned long *M, const unsigned long *N, const unsigned long *K,
-						const double *ALPHA, const double *A, const unsigned long *LDA, const double *B, const unsigned long *LDB,
-						const double *BETA, double *C, const unsigned long *LDC
-						)
-{
-	unsigned long i, j, k;
-
-	if ( REFER_NAMESPACE_QPOASES isZero(*BETA) == REFER_NAMESPACE_QPOASES BT_TRUE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] = 0.0;
-	else if ( REFER_NAMESPACE_QPOASES isEqual(*BETA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] = -C[j+(*LDC)*k];
-	else if ( REFER_NAMESPACE_QPOASES isEqual(*BETA,1.0) == REFER_NAMESPACE_QPOASES BT_FALSE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] *= *BETA;
-
-	if (TRANSA[0] == 'N')
-		if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += A[j+(*LDA)*i] * B[i+(*LDB)*k];
-		else if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] -= A[j+(*LDA)*i] * B[i+(*LDB)*k];
-		else
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += *ALPHA * A[j+(*LDA)*i] * B[i+(*LDB)*k];
-	else
-		if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += A[i+(*LDA)*j] * B[i+(*LDB)*k];
-		else if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] -= A[i+(*LDA)*j] * B[i+(*LDB)*k];
-		else
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += *ALPHA * A[i+(*LDA)*j] * B[i+(*LDB)*k];
-}
-
-extern "C" void sgemm_(	const char *TRANSA, const char *TRANSB,
-						const unsigned long *M, const unsigned long *N, const unsigned long *K,
-						const float *ALPHA, const float *A, const unsigned long *LDA, const float *B, const unsigned long *LDB,
-						const float *BETA, float *C, const unsigned long *LDC
-						)
-{
-	unsigned long i, j, k;
-
-	if ( REFER_NAMESPACE_QPOASES isZero(*BETA) == REFER_NAMESPACE_QPOASES BT_TRUE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] = 0.0;
-	else if ( REFER_NAMESPACE_QPOASES isEqual(*BETA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] = -C[j+(*LDC)*k];
-	else if ( REFER_NAMESPACE_QPOASES isEqual(*BETA,1.0) == REFER_NAMESPACE_QPOASES BT_FALSE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] *= *BETA;
-
-	if (TRANSA[0] == 'N')
-		if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += A[j+(*LDA)*i] * B[i+(*LDB)*k];
-		else if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] -= A[j+(*LDA)*i] * B[i+(*LDB)*k];
-		else
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += *ALPHA * A[j+(*LDA)*i] * B[i+(*LDB)*k];
-	else
-		if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += A[i+(*LDA)*j] * B[i+(*LDB)*k];
-		else if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] -= A[i+(*LDA)*j] * B[i+(*LDB)*k];
-		else
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += *ALPHA * A[i+(*LDA)*j] * B[i+(*LDB)*k];
-}
diff --git a/extlibs/qpOASES-3.2.0/src/Bounds.cpp b/extlibs/qpOASES-3.2.0/src/Bounds.cpp
deleted file mode 100644
index 64081a1..0000000
--- a/extlibs/qpOASES-3.2.0/src/Bounds.cpp
+++ /dev/null
@@ -1,514 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Bounds.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the Bounds class designed to manage working sets of
- *	bounds within a QProblem.
- */
-
-
-#include <qpOASES/Bounds.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	B o u n d s
- */
-Bounds::Bounds( ) : SubjectTo( )
-{
-}
-
-
-/*
- *	B o u n d s
- */
-Bounds::Bounds( int_t _n ) : SubjectTo( _n )
-{
-	init( _n );
-}
-
-
-/*
- *	B o u n d s
- */
-Bounds::Bounds( const Bounds& rhs ) : SubjectTo( rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ B o u n d s
- */
-Bounds::~Bounds( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Bounds& Bounds::operator=( const Bounds& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		SubjectTo::operator=( rhs );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-
-/*
- *	i n i t
- */
-returnValue Bounds::init(	int_t _n
-							)
-{
-	if ( _n < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	clear( );
-
-	if ( _n >= 0 )
-	{
-		freee.init( _n );
-		fixed.init( _n );
-	}
-
-	return SubjectTo::init( _n );
-}
-
-
-
-/*
- *	s e t u p B o u n d
- */
-returnValue Bounds::setupBound(	int_t number, SubjectToStatus _status
-								)
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Add bound index to respective index list. */
-	switch ( _status )
-	{
-		case ST_INACTIVE:
-			if ( this->addIndex( this->getFree( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-			break;
-
-		case ST_LOWER:
-			if ( this->addIndex( this->getFixed( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-			break;
-
-		case ST_UPPER:
-			if ( this->addIndex( this->getFixed( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-			break;
-
-		default:
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A l l F r e e
- */
-returnValue Bounds::setupAllFree( )
-{
-	return setupAll( ST_INACTIVE );
-}
-
-
-/*
- *	s e t u p A l l L o w e r
- */
-returnValue Bounds::setupAllLower( )
-{
-	return setupAll( ST_LOWER );
-}
-
-
-/*
- *	s e t u p A l l U p p e r
- */
-returnValue Bounds::setupAllUpper( )
-{
-	return setupAll( ST_UPPER );
-}
-
-
-/*
- *	m o v e F i x e d T o F r e e
- */
-returnValue Bounds::moveFixedToFree( int_t number )
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Move index from indexlist of fixed variables to that of free ones. */
-	if ( this->removeIndex( this->getFixed( ),number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	if ( this->addIndex( this->getFree( ),number,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	m o v e F r e e T o F i x e d
- */
-returnValue Bounds::moveFreeToFixed(	int_t number, SubjectToStatus _status
-										)
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Move index from indexlist of free variables to that of fixed ones. */
-	if ( this->removeIndex( this->getFree( ),number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	if ( this->addIndex( this->getFixed( ),number,_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	f l i p F i x e d
- */
-returnValue Bounds::flipFixed( int_t number )
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	if ( status != 0 )
-		switch (status[number])
-		{
-			case ST_LOWER: status[number] = ST_UPPER; break;
-			case ST_UPPER: status[number] = ST_LOWER; break;
-			default: return THROWERROR( RET_MOVING_BOUND_FAILED );
-		}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s w a p F r e e
- */
-returnValue Bounds::swapFree(	int_t number1, int_t number2
-								)
-{
-	/* consistency check */
-	if ( ( number1 < 0 ) || ( number1 >= n ) || ( number2 < 0 ) || ( number2 >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Swap index within indexlist of free variables. */
-	return this->swapIndex( this->getFree( ),number1,number2 );
-}
-
-
-/*
- *	s h i f t
- */
-returnValue Bounds::shift(	int_t offset )
-{
-	int_t i;
-
-	/* consistency check */
-	if ( ( offset == 0 ) || ( n <= 1 ) )
-		return SUCCESSFUL_RETURN;
-
-	if ( ( offset < 0 ) || ( offset > n/2 ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	if ( ( n % offset ) != 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Shift types and status. */
-	for( i=0; i<n-offset; ++i )
-	{
-		setType( i,getType( i+offset ) );
-		setStatus( i,getStatus( i+offset ) );
-	}
-
-	/* 2) Construct shifted index lists of free and fixed variables. */
-	Indexlist shiftedFreee( n );
-	Indexlist shiftedFixed( n );
-
-	for( i=0; i<n; ++i )
-	{
-		switch ( getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( shiftedFreee.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			case ST_LOWER:
-				if ( shiftedFixed.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			case ST_UPPER:
-				if ( shiftedFixed.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			default:
-				return THROWERROR( RET_SHIFTING_FAILED );
-		}
-	}
-
-	/* 3) Assign shifted index list. */
-	freee = shiftedFreee;
-	fixed = shiftedFixed;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r o t a t e
- */
-returnValue Bounds::rotate( int_t offset )
-{
-	int_t i;
-
-	/* consistency check */
-	if ( ( offset == 0 ) || ( offset == n ) || ( n <= 1 ) )
-		return SUCCESSFUL_RETURN;
-
-	if ( ( offset < 0 ) || ( offset > n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-
-	/* 1) Rotate types and status. */
-	SubjectToType*   typeTmp   = new SubjectToType[offset];
-	SubjectToStatus* statusTmp = new SubjectToStatus[offset];
-
-	for( i=0; i<offset; ++i )
-	{
-		typeTmp[i] = getType( i );
-		statusTmp[i] = getStatus( i );
-	}
-
-	for( i=0; i<n-offset; ++i )
-	{
-		setType( i,getType( i+offset ) );
-		setStatus( i,getStatus( i+offset ) );
-	}
-
-	for( i=n-offset; i<n; ++i )
-	{
-		setType( i,typeTmp[i-n+offset] );
-		setStatus( i,statusTmp[i-n+offset] );
-	}
-
-	delete[] statusTmp; delete[] typeTmp;
-
-	/* 2) Construct shifted index lists of free and fixed variables. */
-	Indexlist rotatedFreee( n );
-	Indexlist rotatedFixed( n );
-
-	for( i=0; i<n; ++i )
-	{
-		switch ( getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( rotatedFreee.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			case ST_LOWER:
-				if ( rotatedFixed.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			case ST_UPPER:
-				if ( rotatedFixed.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			default:
-				return THROWERROR( RET_ROTATING_FAILED );
-		}
-	}
-
-	/* 3) Assign shifted index list. */
-	freee = rotatedFreee;
-	fixed = rotatedFixed;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue Bounds::print( )
-{
-	if ( n == 0 )
-		return SUCCESSFUL_RETURN;
-
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-
-	int_t* FR_idx;
-	getFree( )->getNumberArray( &FR_idx );
-
-	int_t* FX_idx;
-	getFixed( )->getNumberArray( &FX_idx );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"Bounds object comprising %d variables (%d free, %d fixed):\n",(int)n,(int)nFR,(int)nFX );
-	myPrintf( myPrintfString );
-
-	REFER_NAMESPACE_QPOASES print( FR_idx,nFR,"free " );
-	REFER_NAMESPACE_QPOASES print( FX_idx,nFX,"fixed" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Bounds::clear( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Bounds::copy(	const Bounds& rhs
-							)
-{
-	freee = rhs.freee;
-	fixed = rhs.fixed;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p A l l
- */
-returnValue Bounds::setupAll( SubjectToStatus _status )
-{
-	int_t i;
-
-	/* 1) Place unbounded variables at the beginning of the index list of free variables. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_UNBOUNDED )
-		{
-			if ( setupBound( i,_status ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_BOUND_FAILED );
-		}
-	}
-
-	/* 2) Add remaining (i.e. bounded but possibly free) variables to the index list of free variables. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_BOUNDED )
-		{
-			if ( setupBound( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-		}
-	}
-
-	/* 3) Place implicitly fixed variables at the end of the index list of free variables. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_EQUALITY )
-		{
-			if ( setupBound( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-		}
-	}
-
-	/* 4) Moreover, add all bounds of unknown type. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_UNKNOWN || getType( i ) == ST_DISABLED )
-		{
-			if ( setupBound( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/Constraints.cpp b/extlibs/qpOASES-3.2.0/src/Constraints.cpp
deleted file mode 100644
index 9b024aa..0000000
--- a/extlibs/qpOASES-3.2.0/src/Constraints.cpp
+++ /dev/null
@@ -1,499 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Constraints.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the Constraints class designed to manage working sets of
- *	constraints within a QProblem.
- */
-
-
-#include <qpOASES/Constraints.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	C o n s t r a i n t s
- */
-Constraints::Constraints( ) : SubjectTo( )
-{
-}
-
-
-/*
- *	C o n s t r a i n t s
- */
-Constraints::Constraints( int_t _n ) : SubjectTo( _n )
-{
-	init( _n );
-}
-
-
-/*
- *	C o n s t r a i n t s
- */
-Constraints::Constraints( const Constraints& rhs ) : SubjectTo( rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ C o n s t r a i n t s
- */
-Constraints::~Constraints( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Constraints& Constraints::operator=( const Constraints& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		SubjectTo::operator=( rhs );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-/*
- *	i n i t
- */
-returnValue Constraints::init(	int_t _n
-								)
-{
-	if ( _n < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	clear( );
-
-	if ( _n >= 0 )
-	{
-		active.init(   _n );
-		inactive.init( _n );
-	}
-
-	return SubjectTo::init( _n );
-}
-
-
-
-/*
- *	s e t u p C o n s t r a i n t
- */
-returnValue Constraints::setupConstraint(	int_t number, SubjectToStatus _status
-											)
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Add constraint index to respective index list. */
-	switch ( _status )
-	{
-		case ST_INACTIVE:
-			if ( this->addIndex( this->getInactive( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-			break;
-
-		case ST_LOWER:
-			if ( this->addIndex( this->getActive( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-			break;
-
-		case ST_UPPER:
-			if ( this->addIndex( this->getActive( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-			break;
-
-		default:
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A l l I n a c t i v e
- */
-returnValue Constraints::setupAllInactive( )
-{
-	return setupAll( ST_INACTIVE );
-}
-
-
-/*
- *	s e t u p A l l L o w e r
- */
-returnValue Constraints::setupAllLower( )
-{
-	return setupAll( ST_LOWER );
-}
-
-
-/*
- *	s e t u p A l l U p p e r
- */
-returnValue Constraints::setupAllUpper( )
-{
-	return setupAll( ST_UPPER );
-}
-
-
-/*
- *	m o v e A c t i v e T o I n a c t i v e
- */
-returnValue Constraints::moveActiveToInactive( int_t number )
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Move index from indexlist of active constraints to that of inactive ones. */
-	if ( this->removeIndex( this->getActive( ),number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	if ( this->addIndex( this->getInactive( ),number,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	m o v e I n a c t i v e T o A c t i v e
- */
-returnValue Constraints::moveInactiveToActive(	int_t number, SubjectToStatus _status
-												)
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Move index from indexlist of inactive constraints to that of active ones. */
-	if ( this->removeIndex( this->getInactive( ),number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	if ( this->addIndex( this->getActive( ),number,_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	f l i p F i x e d
- */
-returnValue Constraints::flipFixed( int_t number )
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	if ( status != 0 )
-		switch (status[number])
-		{
-			case ST_LOWER: status[number] = ST_UPPER; break;
-			case ST_UPPER: status[number] = ST_LOWER; break;
-			default: return THROWERROR( RET_MOVING_CONSTRAINT_FAILED );
-		}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s h i f t
- */
-returnValue Constraints::shift( int_t offset )
-{
-	int_t i;
-
-	/* consistency check */
-	if ( ( offset == 0 ) || ( n <= 1 ) )
-		return SUCCESSFUL_RETURN;
-
-	if ( ( offset < 0 ) || ( offset > n/2 ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	if ( ( n % offset ) != 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Shift types and status. */
-	for( i=0; i<n-offset; ++i )
-	{
-		setType( i,getType( i+offset ) );
-		setStatus( i,getStatus( i+offset ) );
-	}
-
-	/* 2) Construct shifted index lists of free and fixed variables. */
-	Indexlist shiftedActive( n );
-	Indexlist shiftedInactive( n );
-
-	for( i=0; i<n; ++i )
-	{
-		switch ( getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( shiftedInactive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			case ST_LOWER:
-				if ( shiftedActive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			case ST_UPPER:
-				if ( shiftedActive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			default:
-				return THROWERROR( RET_SHIFTING_FAILED );
-		}
-	}
-
-	/* 3) Assign shifted index list. */
-	active = shiftedActive;
-	inactive = shiftedInactive;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r o t a t e
- */
-returnValue Constraints::rotate( int_t offset )
-{
-	int_t i;
-
-	/* consistency check */
-	if ( ( offset == 0 ) || ( offset == n ) || ( n <= 1 ) )
-		return SUCCESSFUL_RETURN;
-
-	if ( ( offset < 0 ) || ( offset > n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-
-	/* 1) Rotate types and status. */
-	SubjectToType*   typeTmp   = new SubjectToType[offset];
-	SubjectToStatus* statusTmp = new SubjectToStatus[offset];
-
-	for( i=0; i<offset; ++i )
-	{
-		typeTmp[i] = getType( i );
-		statusTmp[i] = getStatus( i );
-	}
-
-	for( i=0; i<n-offset; ++i )
-	{
-		setType( i,getType( i+offset ) );
-		setStatus( i,getStatus( i+offset ) );
-	}
-
-	for( i=n-offset; i<n; ++i )
-	{
-		setType( i,typeTmp[i-n+offset] );
-		setStatus( i,statusTmp[i-n+offset] );
-	}
-
-	delete[] statusTmp; delete[] typeTmp;
-
-	/* 2) Construct shifted index lists of free and fixed variables. */
-	Indexlist rotatedActive( n );
-	Indexlist rotatedInactive( n );
-
-	for( i=0; i<n; ++i )
-	{
-		switch ( getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( rotatedInactive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			case ST_LOWER:
-				if ( rotatedActive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			case ST_UPPER:
-				if ( rotatedActive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			default:
-				return THROWERROR( RET_ROTATING_FAILED );
-		}
-	}
-
-	/* 3) Assign shifted index list. */
-	active = rotatedActive;
-	inactive = rotatedInactive;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue Constraints::print( )
-{
-	if ( n == 0 )
-		return SUCCESSFUL_RETURN;
-
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	int_t nIAC = getNIAC( );
-	int_t nAC  = getNAC( );
-
-	int_t* IAC_idx;
-	getInactive( )->getNumberArray( &IAC_idx );
-
-	int_t* AC_idx;
-	getActive( )->getNumberArray( &AC_idx );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"Constraints object comprising %d constraints (%d inactive, %d active):\n",(int)n,(int)nIAC,(int)nAC );
-	myPrintf( myPrintfString );
-
-	REFER_NAMESPACE_QPOASES print( IAC_idx,nIAC,"inactive" );
-	REFER_NAMESPACE_QPOASES print( AC_idx, nAC, "active  " );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Constraints::clear( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Constraints::copy(	const Constraints& rhs
-								)
-{
-	active   = rhs.active;
-	inactive = rhs.inactive;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p A l l
- */
-returnValue Constraints::setupAll( SubjectToStatus _status )
-{
-	int_t i;
-
-	/* 1) Place unbounded constraints at the beginning of the index list of inactive constraints. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_UNBOUNDED )
-		{
-			if ( setupConstraint( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-		}
-	}
-
-	/* 2) Add remaining (i.e. "real" inequality) constraints to the index list of inactive constraints. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_BOUNDED )
-		{
-			if ( setupConstraint( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-		}
-	}
-
-	/* 3) Place implicit equality constraints at the end of the index list of inactive constraints. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_EQUALITY )
-		{
-			if ( setupConstraint( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-		}
-	}
-
-	/* 4) Moreover, add all constraints of unknown type. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_UNKNOWN || getType( i ) == ST_DISABLED )
-		{
-			if ( setupConstraint( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-		}
-	}
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/Flipper.cpp b/extlibs/qpOASES-3.2.0/src/Flipper.cpp
deleted file mode 100644
index 14ca0bd..0000000
--- a/extlibs/qpOASES-3.2.0/src/Flipper.cpp
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Flipper.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the Flipper class designed to manage working sets of
- *	constraints and bounds within a QProblem.
- */
-
-
-#include <qpOASES/Flipper.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	F l i p p e r
- */
-Flipper::Flipper( )
-{
-	R = 0;
-	Q = 0;
-	T = 0;
-	
-	init( );
-}
-
-
-/*
- *	F l i p p e r
- */
-Flipper::Flipper(	uint_t _nV,
-					uint_t _nC
-					)
-{
-	R = 0;
-	Q = 0;
-	T = 0;
-	
-	init( _nV,_nC );
-}
-
-
-/*
- *	F l i p p e r
- */
-Flipper::Flipper( const Flipper& rhs )
-{
-	R = 0;
-	Q = 0;
-	T = 0;
-
-	copy( rhs );
-}
-
-
-/*
- *	~ F l i p p e r
- */
-Flipper::~Flipper( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Flipper& Flipper::operator=( const Flipper& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-
-/*
- *	i n i t
- */
-returnValue Flipper::init(	uint_t _nV,
-							uint_t _nC
-							)
-{
-	clear( );
-
-	nV = _nV;
-	nC = _nC;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	g e t
- */
-returnValue Flipper::get(	Bounds* const _bounds,
-							real_t* const _R,
-							Constraints* const _constraints,
-							real_t* const _Q,
-							real_t* const _T 
-							) const
-{
-	if ( _bounds != 0 )
-		*_bounds = bounds;
-
-	if ( _constraints != 0 )
-		*_constraints = constraints;
-
-	if ( ( _R != 0 ) && ( R != 0 ) )
-		memcpy( _R,R, nV*nV*sizeof(real_t) );
-
-	if ( ( _Q != 0 ) && ( Q != 0 ) )
-		memcpy( _Q,Q, nV*nV*sizeof(real_t) );
-
-	if ( ( _T != 0 ) && ( T != 0 ) )
-		memcpy( _T,T, getDimT()*sizeof(real_t) );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t
- */
-returnValue Flipper::set(	const Bounds* const _bounds,
-							const real_t* const _R,
-							const Constraints* const _constraints,
-							const real_t* const _Q,
-							const real_t* const _T
-							)
-{
-	if ( _bounds != 0 )
-		bounds = *_bounds;
-
-	if ( _constraints != 0 )
-		constraints = *_constraints;
-
-	if ( _R != 0 )
-	{
-		if ( R == 0 )
-			R = new real_t[nV*nV];
-
-		memcpy( R,_R, nV*nV*sizeof(real_t) );
-	}
-
-	if ( _Q != 0 )
-	{
-		if ( Q == 0 )
-			Q = new real_t[nV*nV];
-
-		memcpy( Q,_Q, nV*nV*sizeof(real_t) );
-	}
-
-	if ( _T != 0 )
-	{
-		if ( T == 0 )
-			T = new real_t[getDimT()];
-
-		memcpy( T,_T, getDimT()*sizeof(real_t) );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Flipper::clear( )
-{
-	if ( R != 0 )
-	{
-		delete[] R;
-		R = 0;
-	}
-	
-	if ( Q != 0 )
-	{
-		delete[] Q;
-		Q = 0;
-	}
-	
-	if ( T != 0 )
-	{
-		delete[] T;
-		T = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Flipper::copy(	const Flipper& rhs
-							)
-{
-	return set( &(rhs.bounds),rhs.R, &(rhs.constraints),rhs.Q,rhs.T );
-}
-
-
-uint_t Flipper::getDimT( ) const
-{
-	if ( nV > nC )
-		return nC*nC;
-	else
-		return nV*nV;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/Indexlist.cpp b/extlibs/qpOASES-3.2.0/src/Indexlist.cpp
deleted file mode 100644
index 53dec11..0000000
--- a/extlibs/qpOASES-3.2.0/src/Indexlist.cpp
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Indexlist.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the Indexlist class designed to manage index lists of
- *	constraints and bounds within a QProblem_SubjectTo.
- */
-
-
-#include <qpOASES/Indexlist.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	I n d e x l i s t
- */
-Indexlist::Indexlist( )
-{
-	number = 0;
-	iSort  = 0;
-
-	init( );
-}
-
-
-/*
- *	I n d e x l i s t
- */
-Indexlist::Indexlist( int_t n )
-{
-	number = 0;
-	iSort  = 0;
-
-	init( n );
-}
-
-
-/*
- *	I n d e x l i s t
- */
-Indexlist::Indexlist( const Indexlist& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ I n d e x l i s t
- */
-Indexlist::~Indexlist( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Indexlist& Indexlist::operator=( const Indexlist& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-
-/*
- *	i n i t
- */
-returnValue Indexlist::init(	int_t n
-								)
-{
-	if ( n < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	clear( );
-
-	length = 0;
-	physicallength = n;
-
-	if ( n > 0 )
-	{
-		number = new int_t[n];
-		iSort  = new int_t[n];
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t N u m b e r A r r a y
- */
-returnValue Indexlist::getNumberArray( int_t** const numberarray ) const
-{
-	if (numberarray == 0)
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	*numberarray = number;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t I S o r t A r r a y
- */
-returnValue Indexlist::getISortArray( int_t** const iSortArray ) const
-{
-	*iSortArray = iSort;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t I n d e x
- */
-int_t Indexlist::getIndex( int_t givennumber ) const
-{
-	int_t index = findInsert(givennumber);
-	return number[iSort[index]] == givennumber ? iSort[index] : -1;
-}
-
-
-/*
- *	a d d N u m b e r
- */
-returnValue Indexlist::addNumber( int_t addnumber )
-{
-	if ( length >= physicallength )
-		return THROWERROR( RET_INDEXLIST_EXCEEDS_MAX_LENGTH );
-
-	int_t i, j;
-	number[length] = addnumber;
-	j = findInsert(addnumber);
-	for (i = length; i > j+1; i--)
-		iSort[i] = iSort[i-1];
-	iSort[j+1] = length;
-	++length;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e N u m b e r
- */
-returnValue Indexlist::removeNumber( int_t removenumber )
-{
-	int_t i;
-	int_t idx = findInsert( removenumber );
-	int_t iSidx = iSort[idx];
-
-	/* nothing to be done if number is not contained in index set */
-	if ( number[iSidx] != removenumber )
-		return SUCCESSFUL_RETURN;
-
-	/* update sorted indices iSort first */
-	for (i = 0; i < length; i++)
-		if (iSort[i] > iSidx) iSort[i]--;
-	for (i = idx+1; i < length; i++)
-		iSort[i-1] = iSort[i];
-
-	/* remove from numbers list */
-	for( i=iSidx; i<length-1; ++i )
-		number[i] = number[i+1];
-	number[length-1] = -1;
-
-	--length;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s w a p N u m b e r s
- */
-returnValue Indexlist::swapNumbers( int_t number1, int_t number2 )
-{
-	int_t index1 = findInsert( number1 );
-	int_t index2 = findInsert( number2 );
-
-	/* consistency check */
-	if ( ( number[iSort[index1]] != number1 ) || ( number[iSort[index2]] != number2 ) )
-		return THROWERROR( RET_INDEXLIST_CORRUPTED );
-
-	int_t tmp;
-	/* swap numbers */
-	tmp = number[iSort[index1]];
-	number[iSort[index1]] = number[iSort[index2]];
-	number[iSort[index2]] = tmp;
-	/* swap sorting indices */
-	tmp = iSort[index1];
-	iSort[index1] = iSort[index2];
-	iSort[index2] = tmp;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Indexlist::clear( )
-{
-	if ( iSort != 0 )
-	{
-		delete[] iSort;
-		iSort = 0;
-	}
-
-	if ( number != 0 )
-	{
-		delete[] number;
-		number = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Indexlist::copy(	const Indexlist& rhs
-								)
-{
-	int_t i;
-
-	length = rhs.length;
-	physicallength = rhs.physicallength;
-
-	if ( rhs.number != 0 )
-	{
-		number = new int_t[physicallength];
-		for( i=0; i<physicallength; ++i )
-			number[i] = rhs.number[i];
-		iSort = new int_t[physicallength];
-		for( i=0; i<physicallength; ++i )
-			iSort[i] = rhs.iSort[i];
-	}
-	else
-	{
-		number = 0;
-		iSort = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-int_t Indexlist::findInsert(int_t i) const
-{
-	/* quick check if index can be appended */
-	if (length == 0 || i < number[iSort[0]]) return -1;
-	if (i >= number[iSort[length-1]]) return length-1;
-
-	/* otherwise, perform bisection search */
-	int_t fst = 0, lst = length-1, mid;
-
-	while (fst < lst - 1)
-	{
-		mid = (fst + lst) / 2;
-		if (i >= number[iSort[mid]]) fst = mid;
-		else lst = mid;
-	}
-
-	return fst;
-}
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/LAPACKReplacement.cpp b/extlibs/qpOASES-3.2.0/src/LAPACKReplacement.cpp
deleted file mode 100644
index 61a4a98..0000000
--- a/extlibs/qpOASES-3.2.0/src/LAPACKReplacement.cpp
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/LAPACKReplacement.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *  LAPACK replacement routines.
- */
-
-
-#include <qpOASES/Utils.hpp>
-
-
-extern "C" void dpotrf_(	const char *uplo, const unsigned long *_n, double *a,
-							const unsigned long *_lda, long *info
-							)
-{
-	double sum;
-	long i, j, k;
-	long n = (long)(*_n);
-	long lda = (long)(*_lda);
-
-	for( i=0; i<n; ++i )
-	{
-		/* j == i */
-		sum = a[i + lda*i];
-
-		for( k=(i-1); k>=0; --k )
-			sum -= a[k+lda*i] * a[k+lda*i];
-
-		if ( sum > 0.0 )
-			a[i+lda*i] = REFER_NAMESPACE_QPOASES getSqrt( sum );
-		else
-		{
-			a[0] = sum; /* tunnel negative diagonal element to caller */
-			if (info != 0)
-				*info = (long)i+1;
-			return;
-		}
-
-		for( j=(i+1); j<n; ++j )
-		{
-			sum = a[j*lda + i];
-
-			for( k=(i-1); k>=0; --k )
-				sum -= a[k+lda*i] * a[k+lda*j];
-
-			a[i+lda*j] = sum / a[i+lda*i];
-		}
-	}
-	if (info != 0)
-		*info = 0;
-}
-
-
-extern "C" void spotrf_(	const char *uplo, const unsigned long *_n, float *a,
-							const unsigned long *_lda, long *info
-							)
-{
-	float sum;
-	long i, j, k;
-	long n = (long)(*_n);
-	long lda = (long)(*_lda);
-
-	for( i=0; i<n; ++i )
-	{
-		/* j == i */
-		sum = a[i + lda*i];
-
-		for( k=(i-1); k>=0; --k )
-			sum -= a[k+lda*i] * a[k+lda*i];
-
-		if ( sum > 0.0 )
-			a[i+lda*i] = (float)(REFER_NAMESPACE_QPOASES getSqrt( sum ));
-		else
-		{
-			a[0] = sum; /* tunnel negative diagonal element to caller */
-			if (info != 0)
-				*info = (long)i+1;
-			return;
-		}
-
-		for( j=(i+1); j<n; ++j )
-		{
-			sum = a[j*lda + i];
-
-			for( k=(i-1); k>=0; --k )
-				sum -= a[k+lda*i] * a[k+lda*j];
-
-			a[i+lda*j] = sum / a[i+lda*i];
-		}
-	}
-	if (info != 0)
-		*info = 0;
-}
-
-extern "C" void dtrtrs_(	const char *UPLO, const char *TRANS, const char *DIAG,
-							const unsigned long *N, const unsigned long *NRHS,
-							double *A, const unsigned long *LDA, double *B, const unsigned long *LDB, long *INFO
-							)
-{
-	; /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
-}
-
-extern "C" void strtrs_(	const char *UPLO, const char *TRANS, const char *DIAG,
-							const unsigned long *N, const unsigned long *NRHS,
-							float *A, const unsigned long *LDA, float *B, const unsigned long *LDB, long *INFO
-							)
-{
-	; /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
-}
-
-extern "C" void dtrcon_(	const char *NORM, const char *UPLO, const char *DIAG,
-							const unsigned long *N, double *A, const unsigned long *LDA,
-							double *RCOND, double *WORK, const unsigned long *IWORK, long *INFO
-							)
-{
-	; /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
-}
-
-extern "C" void strcon_(	const char *NORM, const char *UPLO, const char *DIAG,
-							const unsigned long *N, float *A, const unsigned long *LDA,
-							float *RCOND, float *WORK, const unsigned long *IWORK, long *INFO
-							)
-{
-	; /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
-}
diff --git a/extlibs/qpOASES-3.2.0/src/Makefile b/extlibs/qpOASES-3.2.0/src/Makefile
deleted file mode 100644
index bcad734..0000000
--- a/extlibs/qpOASES-3.2.0/src/Makefile
+++ /dev/null
@@ -1,110 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  src/Makefile
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-include ../make.mk
-
-##
-##	flags
-##
-
-IFLAGS      =  -I. \
-               -I${IDIR}
-
-QPOASES_OBJECTS = \
-	SQProblem.${OBJEXT} \
-	QProblem.${OBJEXT} \
-	QProblemB.${OBJEXT} \
-	SQProblemSchur.${OBJEXT} \
-	Bounds.${OBJEXT} \
-	Constraints.${OBJEXT} \
-	SubjectTo.${OBJEXT} \
-	Indexlist.${OBJEXT} \
-	Flipper.${OBJEXT} \
-	Utils.${OBJEXT} \
-	Options.${OBJEXT} \
-	Matrices.${OBJEXT} \
-	MessageHandling.${OBJEXT} \
-	SparseSolver.${OBJEXT}
-
-
-QPOASES_EXTRAS_OBJECTS = \
-	SolutionAnalysis.${OBJEXT} \
-	OQPinterface.${OBJEXT}
-
-QPOASES_DEPENDS = \
-	${IDIR}/qpOASES.hpp \
-	${IDIR}/qpOASES/SQProblem.hpp \
-	${IDIR}/qpOASES/QProblem.hpp \
-	${IDIR}/qpOASES/Flipper.hpp \
-	${IDIR}/qpOASES/QProblemB.hpp \
-	${IDIR}/qpOASES/Bounds.hpp \
-	${IDIR}/qpOASES/Constraints.hpp \
-	${IDIR}/qpOASES/SubjectTo.hpp \
-	${IDIR}/qpOASES/Indexlist.hpp \
-	${IDIR}/qpOASES/Utils.hpp \
-	${IDIR}/qpOASES/Constants.hpp \
-	${IDIR}/qpOASES/Types.hpp \
-	${IDIR}/qpOASES/Options.hpp \
-	${IDIR}/qpOASES/Matrices.hpp \
-	${IDIR}/qpOASES/MessageHandling.hpp \
-	${IDIR}/qpOASES/UnitTesting.hpp
-
-
-##
-##	targets
-##
-
-all: ${LINK_DEPENDS}
-
-
-${BINDIR}/libqpOASES.${LIBEXT}: ${QPOASES_OBJECTS} ${QPOASES_EXTRAS_OBJECTS}
-	@${ECHO} "Creating static lib" $@
-	@${AR} r $@ $^
-
-${BINDIR}/libqpOASES.${DLLEXT}: ${QPOASES_OBJECTS} ${QPOASES_EXTRAS_OBJECTS}
-	@${ECHO} "Creating shared lib" $@
-	@${CPP} ${DEF_TARGET} ${SHARED} $^ ${LINK_LIBRARIES}
-
-clean:
-	@${ECHO} "Cleaning up (src)"
-	@${RM} -f *.${OBJEXT} *.${LIBEXT} *.${DLLEXT}
-
-clobber: clean
-
-
-%.${OBJEXT}: %.cpp ${QPOASES_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/src/Matrices.cpp b/extlibs/qpOASES-3.2.0/src/Matrices.cpp
deleted file mode 100644
index 1249a7b..0000000
--- a/extlibs/qpOASES-3.2.0/src/Matrices.cpp
+++ /dev/null
@@ -1,2141 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Matrices.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the matrix classes.
- */
-
-
-#include <qpOASES/Matrices.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-returnValue Matrix::getSparseSubmatrix(
-				const Indexlist* const irows,
-				const Indexlist* const icols,
-				int_t rowoffset,
-				int_t coloffset,
-				int_t& numNonzeros,
-				int_t* irn,
-				int_t* jcn,
-				real_t* avals,
-				BooleanType only_lower_triangular) const
-{
-	int_t* rowsNumbers;
-	irows->getNumberArray( &rowsNumbers );
-	int_t* colsNumbers;
-	icols->getNumberArray( &colsNumbers );
-
-	return getSparseSubmatrix(irows->getLength(), rowsNumbers, icols->getLength(), colsNumbers, rowoffset, coloffset, numNonzeros, irn, jcn, avals, only_lower_triangular);
-}
-
-returnValue Matrix::getSparseSubmatrix(
-				const Indexlist* const irows,
-				int_t idx_icol,
-				int_t rowoffset,
-				int_t coloffset,
-				int_t& numNonzeros,
-				int_t* irn,
-				int_t* jcn,
-				real_t* avals,
-				BooleanType only_lower_triangular) const
-{
-	int_t* rowsNumbers;
-	irows->getNumberArray( &rowsNumbers );
-
-	return getSparseSubmatrix(irows->getLength(), rowsNumbers, 1, &idx_icol, rowoffset, coloffset, numNonzeros, irn, jcn, avals, only_lower_triangular);
-}
-
-returnValue Matrix::getSparseSubmatrix(
-				int_t idx_row,
-				const Indexlist* const icols,
-				int_t rowoffset,
-				int_t coloffset,
-				int_t& numNonzeros,
-				int_t* irn,
-				int_t* jcn,
-				real_t* avals,
-				BooleanType only_lower_triangular) const
-{
-	int_t* colsNumbers;
-	icols->getNumberArray( &colsNumbers );
-
-	return getSparseSubmatrix(1, &idx_row, icols->getLength(), colsNumbers, rowoffset, coloffset, numNonzeros, irn, jcn, avals, only_lower_triangular);
-}
-
-
-DenseMatrix::~DenseMatrix()
-{
-	if ( needToFreeMemory( ) == BT_TRUE )
-		free( );
-}
-
-void DenseMatrix::free( )
-{
-	if (val != 0)
-		delete[] val;
-	val = 0;
-}
-
-Matrix *DenseMatrix::duplicate( ) const
-{
-	DenseMatrix *dupl = 0;
-
-	if ( needToFreeMemory( ) == BT_TRUE )
-	{
-		real_t* val_new = new real_t[nRows*nCols];
-		memcpy( val_new,val, ((uint_t)(nRows*nCols))*sizeof(real_t) );
-		dupl = new DenseMatrix(nRows, nCols, nCols, val_new);
-		dupl->doFreeMemory( );
-	}
-	else
-	{
-		dupl = new DenseMatrix(nRows, nCols, nCols, val);
-	}
-
-	return dupl;
-}
-
-real_t DenseMatrix::diag(	int_t i
-							) const
-{
-	return val[i*(leaDim+1)];
-}
-
-BooleanType DenseMatrix::isDiag( ) const
-{
-	int_t i, j;
-
-	if (nRows != nCols)
-		return BT_FALSE;
-
-	for ( i=0; i<nRows; ++i )
-		for ( j=0; j<i; ++j )
-			if ( ( getAbs( val[i*leaDim+j] ) > EPS ) || ( getAbs( val[j*leaDim+i] ) > EPS ) )
-				return BT_FALSE;
-
-	return BT_TRUE;
-}
-
-
-real_t DenseMatrix::getNorm(	int_t type
-								) const
-{
-	return REFER_NAMESPACE_QPOASES getNorm( val,nCols*nRows,type );
-}
-
-
-real_t DenseMatrix::getRowNorm( int_t rNum, int_t type ) const
-{
-	return REFER_NAMESPACE_QPOASES getNorm( &(val[rNum*leaDim]),nCols,type );
-}
-
-returnValue DenseMatrix::getRow(int_t rNum, const Indexlist* const icols, real_t alpha, real_t *row) const
-{
-	int_t i;
-    if (icols != 0)
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (i = 0; i < icols->length; i++)
-			    row[i] = val[rNum*leaDim+icols->number[i]];
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (i = 0; i < icols->length; i++)
-			    row[i] = -val[rNum*leaDim+icols->number[i]];
-	    else
-		    for (i = 0; i < icols->length; i++)
-			    row[i] = alpha*val[rNum*leaDim+icols->number[i]];
-    }
-    else
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (i = 0; i < nCols; i++)
-			    row[i] = val[rNum*leaDim+i];
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (i = 0; i < nCols; i++)
-			    row[i] = -val[rNum*leaDim+i];
-	    else
-		    for (i = 0; i < nCols; i++)
-			    row[i] = alpha*val[rNum*leaDim+i];
-    }
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue DenseMatrix::getCol(int_t cNum, const Indexlist* const irows, real_t alpha, real_t *col) const
-{
-	int_t i;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (i = 0; i < irows->length; i++)
-			col[i] = val[irows->number[i]*leaDim+cNum];
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (i = 0; i < irows->length; i++)
-			col[i] = -val[irows->number[i]*leaDim+cNum];
-	else
-		for (i = 0; i < irows->length; i++)
-			col[i] = alpha*val[irows->number[i]*leaDim+cNum];
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue DenseMatrix::getSparseSubmatrix (int_t irowsLength, const int_t* const irowsNumber,
-											 int_t icolsLength, const int_t* const icolsNumber,
-											 int_t rowoffset, int_t coloffset, int_t& numNonzeros,	int_t* irn,
-											 int_t* jcn, real_t* avals,
-											 BooleanType only_lower_triangular /*= BT_FALSE */) const
-{
-	int_t i, j, irA;
-	real_t v;
-	numNonzeros = 0;
-	if ( only_lower_triangular == BT_FALSE )
-	{
-		if (irn == 0)
-		{
-			if (jcn != 0 || avals != 0)
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			for (j = 0; j<irowsLength; j++)
-			{
-				irA = irowsNumber[j] * leaDim;
-				for (i = 0; i<icolsLength; i++)
-					if (isZero( val[irA+icolsNumber[i]] ) == BT_FALSE)
-						numNonzeros++;
-			}
-		}
-		else
-		{
-			for (j = 0; j<irowsLength; j++)
-			{
-				irA = irowsNumber[j] * leaDim;
-				for (i = 0; i<icolsLength; i++)
-				{
-					v = val[irA+icolsNumber[i]];
-					if (isZero( v ) == BT_FALSE)
-					{
-						irn[numNonzeros] = j+rowoffset;
-						jcn[numNonzeros] = i+coloffset;
-						avals[numNonzeros] = v;
-						numNonzeros++;
-					}
-				}
-			}
-		}
-	}
-	else
-	{
-		if (irn == 0)
-		{
-			if (jcn != 0 || avals != 0)
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			for (j = 0; j<irowsLength; j++)
-			{
-				irA = irowsNumber[j] * leaDim;
-				for (i = 0; i<=j; i++)
-					if (isZero( val[irA+irowsNumber[i]] ) == BT_FALSE)
-						numNonzeros++;
-			}
-		}
-		else
-		{
-			for (j = 0; j<irowsLength; j++)
-			{
-				irA = irowsNumber[j] * leaDim;
-				for (i = 0; i<=j; i++)
-				{
-					v = val[irA+irowsNumber[i]];
-					if (isZero( v ) == BT_FALSE)
-					{
-						irn[numNonzeros] = j+rowoffset;
-						jcn[numNonzeros] = i+coloffset;
-						avals[numNonzeros] = v;
-						numNonzeros++;
-					}
-				}
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue DenseMatrix::times(	int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD) const
-{
-	unsigned long _xN     = (unsigned long)xN;
-	unsigned long _nRows  = (unsigned long)nRows;
-	unsigned long _nCols  = (unsigned long)nCols;
-	unsigned long _leaDim = (unsigned long)getMax(1,nCols);
-	unsigned long _xLD    = (unsigned long)getMax(1,xLD);
-	unsigned long _yLD    = (unsigned long)getMax(1,yLD);
-
-	/* Call BLAS. Mind row major format! */
-	GEMM("TRANS", "NOTRANS", &_nRows, &_xN, &_nCols, &alpha, val, &_leaDim, x, &_xLD, &beta, y, &_yLD);
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue DenseMatrix::transTimes( int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD) const
-{
-	unsigned long _xN     = (unsigned long)xN;
-	unsigned long _nRows  = (unsigned long)nRows;
-	unsigned long _nCols  = (unsigned long)nCols;
-	unsigned long _leaDim = (unsigned long)getMax(1,nCols);
-	unsigned long _xLD    = (unsigned long)getMax(1,xLD);
-	unsigned long _yLD    = (unsigned long)getMax(1,yLD);
-
-	/* Call BLAS. Mind row major format! */
-	GEMM("NOTRANS", "NOTRANS", &_nCols, &_xN, &_nRows, &alpha, val, &_leaDim, x, &_xLD, &beta, y, &_yLD);
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue DenseMatrix::times(	const Indexlist* const irows, const Indexlist* const icols,
-								int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD,
-								BooleanType yCompr) const
-{
-	int_t i, j, k, row, col, iy, irA;
-
-	if (yCompr == BT_TRUE)
-	{
-		if ( isZero(beta) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = 0.0;
-		else if ( isEqual(beta,-1.0) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = -y[j+k*yLD];
-		else if ( isEqual(beta,1.0) == BT_FALSE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] *= beta;
-
-		if (icols == 0)
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] += val[irA+i] * x[k*xLD+i];
-					}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] -= val[irA+i] * x[k*xLD+i];
-					}
-			else
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] += alpha * val[irA+i] * x[k*xLD+i];
-					}
-		else /* icols != 0 */
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] += val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] -= val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-			else
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] += alpha * val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-	}
-	else /* y not compressed */
-	{
-		if ( isZero(beta) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = 0.0;
-		else if ( isEqual(beta,-1.0) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = -y[j+k*yLD];
-		else if ( isEqual(beta,1.0) == BT_FALSE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] *= beta;
-
-		if (icols == 0)
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] += val[irA+i] * x[k*xLD+i];
-					}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] -= val[irA+i] * x[k*xLD+i];
-					}
-			else
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] += alpha * val[irA+i] * x[k*xLD+i];
-					}
-		else /* icols != 0 */
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] += val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] -= val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-			else
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] += alpha * val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue DenseMatrix::transTimes(	const Indexlist* const irows, const Indexlist* const icols,
-										int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD) const
-{
-	int_t i, j, k, row, col;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < irows->length; j++)
-			{
-				row = irows->iSort[j];
-				for (i = 0; i < icols->length; i++)
-				{
-					col = icols->iSort[i];
-					y[col+k*yLD] += val[irows->number[row]*leaDim+icols->number[col]] * x[row+k*xLD];
-				}
-			}
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < irows->length; j++)
-			{
-				row = irows->iSort[j];
-				for (i = 0; i < icols->length; i++)
-				{
-					col = icols->iSort[i];
-					y[col+k*yLD] -= val[irows->number[row]*leaDim+icols->number[col]] * x[row+k*xLD];
-				}
-			}
-	else
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < irows->length; j++)
-			{
-				row = irows->iSort[j];
-				for (i = 0; i < icols->length; i++)
-				{
-					col = icols->iSort[i];
-					y[col+k*yLD] += alpha * val[irows->number[row]*leaDim+icols->number[col]] * x[row+k*xLD];
-				}
-			}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue DenseMatrix::addToDiag( real_t alpha )
-{
-	int_t i;
-	for (i = 0; i < nRows && i < nCols; i++)
-		val[i*(leaDim+1)] += alpha;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue DenseMatrix::writeToFile( FILE* output_file, const char* prefix ) const
-{
-	return THROWERROR( RET_NOT_YET_IMPLEMENTED );
-}
-
-
-real_t* DenseMatrix::full() const
-{
-	real_t* v = new real_t[nRows*nCols];
-	memcpy( v,val, ((uint_t)(nRows*nCols))*sizeof(real_t) );
-	return v;
-}
-
-
-returnValue DenseMatrix::print( const char* name ) const
-{
-	return REFER_NAMESPACE_QPOASES print( val,nRows,nCols,name );
-}
-
-
-
-Matrix *SymDenseMat::duplicate( ) const
-{
-	return duplicateSym();
-}
-
-
-SymmetricMatrix *SymDenseMat::duplicateSym( ) const
-{
-	/* "same" as duplicate() in DenseMatrix */
-	SymDenseMat *dupl = 0;
-
-	if ( needToFreeMemory( ) == BT_TRUE )
-	{
-		real_t* val_new = new real_t[nRows*nCols];
-		memcpy( val_new,val, ((uint_t)(nRows*nCols))*sizeof(real_t) );
-		dupl = new SymDenseMat(nRows, nCols, nCols, val_new);
-		dupl->doFreeMemory( );
-	}
-	else
-	{
-		dupl = new SymDenseMat(nRows, nCols, nCols, val);
-	}
-
-	return dupl;
-}
-
-
-returnValue SymDenseMat::bilinear(	const Indexlist* const icols,
-									int_t xN, const real_t *x, int_t xLD, real_t *y, int_t yLD) const
-{
-	int_t ii, jj, kk, col;
-	int_t i,j,k,irA;
-
-	for (ii = 0; ii < xN; ii++)
-		for (jj = 0; jj < xN; jj++)
-			y[ii*yLD+jj] = 0.0;
-
-	real_t *Ax = new real_t[icols->length * xN];
-
-	for (i=0;i<icols->length * xN;++i)
-		Ax[i]=0.0;
-
-	/* exploit symmetry of A ! */
-	for (j = 0; j < icols->length; j++) {
-		irA = icols->number[j] * leaDim;
-		for (i = 0; i < icols->length; i++)
-		{
-			real_t h = val[irA+icols->number[i]];
-			for (k = 0; k < xN; k++)
-				Ax[j + k * icols->length] += h * x[k*xLD+icols->number[i]];
-		}
-	}
-
-	for (ii = 0; ii < icols->length; ++ii) {
-		col = icols->number[ii];
-		for (jj = 0; jj < xN; ++jj) {
-			for (kk = 0; kk < xN; ++kk) {
-				y[kk + jj*yLD] += x[col + jj*xLD] * Ax[ii + kk*icols->length];
-			}
-		}
-	}
-	delete[] Ax;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-SparseMatrix::SparseMatrix() : nRows(0), nCols(0), ir(0), jc(0), jd(0), val(0) {}
-
-SparseMatrix::SparseMatrix(	int_t nr, int_t nc, sparse_int_t *r, sparse_int_t *c, real_t *v)
-								: nRows(nr), nCols(nc), ir(r), jc(c), jd(0), val(v) { doNotFreeMemory(); }
-
-SparseMatrix::SparseMatrix(	int_t nr, int_t nc, int_t ld, const real_t * const v)
-								: nRows(nr), nCols(nc), jd(0)
-{
-	int_t i, j, nnz;
-
-	jc = new sparse_int_t[nc+1];
-	ir = new sparse_int_t[nr*nc];
-	val = new real_t[nr*nc];
-
-	nnz = 0;
-	for (j = 0; j < nCols; j++)
-	{
-		jc[j] = nnz;
-		for (i = 0; i < nRows; i++)
-			if ( ( isZero( v[i*ld+j],0.0 ) == BT_FALSE ) || ( i == j ) ) /* also include zero diagonal elemets! */
-			{
-				ir[nnz] = i;
-				val[nnz++] = v[i*ld+j];
-			}
-	}
-	jc[nCols] = nnz;
-
-	doFreeMemory( );
-}
-
-
-SparseMatrix::~SparseMatrix()
-{
-	if (jd != 0)
-	{
-		delete[] jd;
-		jd = 0;
-	}
-
-	if ( needToFreeMemory() == BT_TRUE )
-		free( );
-}
-
-
-void SparseMatrix::free( )
-{
-	if (ir != 0) delete[] ir;
-	ir = 0;
-	if (jc != 0) delete[] jc;
-	jc = 0;
-	if (val != 0) delete[] val;
-	val = 0;
-
-	doNotFreeMemory( );
-}
-
-Matrix *SparseMatrix::duplicate() const
-{
-	long i, length = jc[nCols];
-	SparseMatrix *dupl = new SparseMatrix;
-
-	dupl->nRows = nRows;
-	dupl->nCols = nCols;
-	dupl->ir = new sparse_int_t[length];
-	dupl->jc = new sparse_int_t[nCols+1];
-	dupl->val = new real_t[length];
-
-	for (i = 0; i < length; i++) dupl->ir[i] = ir[i];
-	for (i = 0; i <= nCols; i++) dupl->jc[i] = jc[i];
-	for (i = 0; i < length; i++) dupl->val[i] = val[i];
-
-	if ( jd != 0 )
-	{
-		dupl->jd = new sparse_int_t[nCols];
-		for (i = 0; i < nCols; i++) dupl->jd[i] = jd[i];
-	}
-	else
-		dupl->jd = 0;
-
-	dupl->doFreeMemory( );
-
-	return dupl;
-}
-
-
-
-real_t SparseMatrix::diag(int_t i) const
-{
-	if ( jd == 0 )
-	{
-		THROWERROR( RET_DIAGONAL_NOT_INITIALISED );
-		return INFTY;
-	}
-
-	int_t entry = jd[i];
-	return (entry < jc[i+1] && ir[entry] == i) ? val[entry] : 0.0;
-}
-
-
-BooleanType SparseMatrix::isDiag() const
-{
-	int_t j;
-
-	if ( nCols != nRows )
-		return BT_FALSE;
-
-	for (j = 0; j < nCols; ++j)
-	{
-		if ( jc[j+1] > jc[j]+1 )
-			return BT_FALSE;
-
-		if ( ( jc[j+1] == jc[j]+1 ) && ( ir[jc[j]] != j ) )
-			return BT_FALSE;
-	}
-
-	return BT_TRUE;
-}
-
-
-
-real_t SparseMatrix::getNorm(	int_t type
-								) const
-{
-	int_t length = jc[nCols];
-	return REFER_NAMESPACE_QPOASES getNorm( val,length,type );
-}
-
-
-real_t SparseMatrix::getRowNorm( int_t rNum, int_t type ) const
-{
-    int_t i,j;
-    real_t norm = 0.0;
-
-	switch( type )
-	{
-		case 2:
-			for ( j=0; j < nCols; ++j ) {
-				for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++) {};
-				norm += (i < jc[j+1] && ir[i] == rNum) ? val[i]*val[i] : 0.0;
-			}
-			return getSqrt(norm);
-
-		case 1:
-			for ( j=0; j < nCols; ++j ) {
-				for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++) {};
-				norm += (i < jc[j+1] && ir[i] == rNum) ? REFER_NAMESPACE_QPOASES getAbs( val[i] ) : 0.0;
-			}
-			return norm;
-
-		default:
-			THROWERROR( RET_INVALID_ARGUMENTS );
-			return -INFTY;
-	}
-}
-
-
-returnValue SparseMatrix::getRow(int_t rNum, const Indexlist* const icols, real_t alpha, real_t *row) const
-{
-	long i, j, k;
-
-    if (icols != 0)
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (k = 0; k < icols->length; k++)
-		    {
-			    j = icols->number[icols->iSort[k]];
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[icols->iSort[k]] = (i < jc[j+1] && ir[i] == rNum) ? val[i] : 0.0;
-		    }
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (k = 0; k < icols->length; k++)
-		    {
-			    j = icols->number[icols->iSort[k]];
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[icols->iSort[k]] = (i < jc[j+1] && ir[i] == rNum) ? -val[i] : 0.0;
-		    }
-	    else
-		    for (k = 0; k < icols->length; k++)
-		    {
-			    j = icols->number[icols->iSort[k]];
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[icols->iSort[k]] = (i < jc[j+1] && ir[i] == rNum) ? alpha*val[i] : 0.0;
-		    }
-    }
-    else
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (j = 0; j < nCols; j++)
-		    {
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[j] = (i < jc[j+1] && ir[i] == rNum) ? val[i] : 0.0;
-		    }
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (j = 0; j < icols->length; j++)
-		    {
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[j] = (i < jc[j+1] && ir[i] == rNum) ? -val[i] : 0.0;
-		    }
-	    else
-		    for (j = 0; j < icols->length; j++)
-		    {
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[j] = (i < jc[j+1] && ir[i] == rNum) ? alpha*val[i] : 0.0;
-		    }
-    }
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrix::getCol(int_t cNum, const Indexlist* const irows, real_t alpha, real_t *col) const
-{
-	long i, j;
-
-	i = jc[cNum];
-	j = 0;
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		while (i < jc[cNum+1] && j < irows->length)
-			if (ir[i] == irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = val[i++];
-			else if (ir[i] > irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = 0.0;
-			else
-				i++;
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		while (i < jc[cNum+1] && j < irows->length)
-			if (ir[i] == irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = -val[i++];
-			else if (ir[i] > irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = 0.0;
-			else
-				i++;
-	else
-		while (i < jc[cNum+1] && j < irows->length)
-			if (ir[i] == irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = alpha * val[i++];
-			else if (ir[i] > irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = 0.0;
-			else
-				i++;
-
-	/* fill in remaining zeros */
-	while (j < irows->length)
-		col[irows->iSort[j++]] = 0.0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SparseMatrix::getSparseSubmatrix (int_t irowsLength, const int_t* const irowsNumber,
-											  int_t icolsLength, const int_t* const icolsNumber,
-											  int_t rowoffset, int_t coloffset, int_t& numNonzeros,	int_t* irn,
-											  int_t* jcn, real_t* avals,
-											  BooleanType only_lower_triangular /*= BT_FALSE */) const
-{
-	int_t i, j, k, l;
-
-	// Compute the "inverse" of the irows->number array
-	// TODO: Ideally this should be a part of Indexlist
-	int_t* rowNumberInv = new int_t[nRows];
-	for (i=0; i<nRows; i++)
-		rowNumberInv[i] = -1;
-	for (i=0; i<irowsLength; i++)
-		rowNumberInv[irowsNumber[i]] = i;
-
-	numNonzeros = 0;
-	if ( only_lower_triangular == BT_FALSE )
-	{
-		if (irn == 0)
-		{
-			if (jcn != 0 || avals != 0)
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			for (k = 0; k < icolsLength; k++)
-			{
-				j = icolsNumber[k];
-				for (i = jc[j]; i < jc[j+1]; i++)
-				{
-					l = rowNumberInv[ir[i]];
-					if (l >= 0)
-						numNonzeros++;
-				}
-			}
-		}
-		else
-		{
-			for (k = 0; k < icolsLength; k++)
-			{
-				j = icolsNumber[k];
-				for (i = jc[j]; i < jc[j+1]; i++)
-				{
-					l = rowNumberInv[ir[i]];
-					if (l >= 0)
-					{
-						irn[numNonzeros] = l+rowoffset;
-						jcn[numNonzeros] = k+coloffset;
-						avals[numNonzeros] = val[i];
-						numNonzeros++;
-					}
-				}
-			}
-		}
-	}
-	else
-	{
-		if (irn == 0)
-		{
-			if (jcn != 0 || avals != 0)
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			for (k = 0; k < icolsLength; k++)
-			{
-				j = icolsNumber[k];
-				for (i = jc[j]; i < jc[j+1]; i++)
-				{
-					l = rowNumberInv[ir[i]];
-					if (l >= k)
-						numNonzeros++;
-				}
-			}
-		}
-		else
-		{
-			for (k = 0; k < icolsLength; k++)
-			{
-				j = icolsNumber[k];
-				for (i = jc[j]; i < jc[j+1]; i++)
-				{
-					l = rowNumberInv[ir[i]];
-					if (l >= k)
-					{
-						irn[numNonzeros] = l+rowoffset;
-						jcn[numNonzeros] = k+coloffset;
-						avals[numNonzeros] = val[i];
-						numNonzeros++;
-					}
-				}
-			}
-		}
-	}
-	delete [] rowNumberInv;
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SparseMatrix::times(int_t xN, real_t alpha, const real_t *x, int_t xLD,
-		real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[ir[i]+k*yLD] += val[i] * x[j+k*xLD];
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[ir[i]+k*yLD] -= val[i] * x[j+k*xLD];
-	else
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[ir[i]+k*yLD] += alpha * val[i] * x[j+k*xLD];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrix::transTimes(int_t xN, real_t alpha, const real_t *x, int_t xLD,
-		real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[j+k*yLD] += val[i] * x[ir[i]+k*xLD];
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[j+k*yLD] -= val[i] * x[ir[i]+k*xLD];
-	else
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[j+k*yLD] += alpha * val[i] * x[ir[i]+k*xLD];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrix::times(const Indexlist* const irows, const Indexlist* const icols,
-		int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD,
-		BooleanType yCompr) const
-{
-	long i, j, k, l, col;
-	real_t xcol;
-
-	if ( isEqual(alpha,0.0) == BT_TRUE )
-	{
-		if (yCompr == BT_TRUE)
-		{
-			if ( isZero(beta) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[j+k*yLD] = 0.0;
-			else if ( isEqual(beta,-1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[j+k*yLD] = -y[j+k*yLD];
-			else if ( isEqual(beta,1.0) == BT_FALSE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[j+k*yLD] *= beta;
-		}
-		else
-		{
-			if (isZero( beta ) == BT_TRUE)
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[irows->number[j]+k*yLD] = 0.0;
-			else if (isEqual( beta, -1.0 ) == BT_TRUE)
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[irows->number[j]+k*yLD] = -y[irows->number[j]+k*yLD];
-			else if (isEqual( beta, 1.0 ) == BT_FALSE)
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[irows->number[j]+k*yLD] *= beta;
-		}
-		return SUCCESSFUL_RETURN;
-	}
-
-	// First, work with full, unordered copy of y and store matrix times x in there
-	const int_t yfullLength = nRows;
-	real_t* ytmp = new real_t[xN*yfullLength];
-	for (k = 0; k < xN*yfullLength; k++)
-		ytmp[k] = 0.0;
-
-	if (icols!=0)
-	{
-		if (xN==1)
-		{
-			for (l = 0; l < icols->length; l++)
-			{
-				col = icols->iSort[l];
-				xcol = x[col];
-				if (isZero( xcol ) == BT_FALSE)
-				{
-					j = icols->number[col];
-					for (i = jc[j]; i < jc[j+1]; i++)
-						ytmp[ir[i]] += val[i] * xcol;
-				}
-			}
-		}
-		else
-		{
-			// AW: I didn't test the case xN>1, but I hope it is working
-			real_t* xcols = new real_t[xN];
-			for (l = 0; l < icols->length; l++)
-			{
-				col = icols->iSort[l];
-				real_t xmax = 0.0;
-				for (k=0; k<xN; k++)
-				{
-					xcols[k] = x[k*xLD+col];
-					xmax = getMax(xmax,getAbs(xcols[k]));
-				}
-				if (isZero( xmax ) == BT_FALSE)
-				{
-					j = icols->number[col];
-					for (i = jc[j]; i < jc[j+1]; i++)
-						for (k=0; k<xN; k++)
-						  // AW: Maybe it makes more sense to order ytmp by vectors, not vector entries, for better cache peformance?
-							ytmp[k*yfullLength+ir[i]] += val[i] * xcols[k];
-				}
-			}
-			delete [] xcols;
-		}
-	}
-	else /* icols == 0 */
-	{
-		if (xN==1)
-		{
-			for (col = 0; col < nCols; col++)
-			{
-				xcol = x[col];
-				if (isZero( xcol ) == BT_FALSE)
-					for (i = jc[col]; i < jc[col+1]; i++)
-						ytmp[ir[i]] += val[i] * xcol;
-			}
-		}
-		else
-		{
-			// AW: I didn't test the case xN>1, but I hope it is working
-			real_t* xcols = new real_t[xN];
-			for (col = 0; col < nCols; col++)
-			{
-				real_t xmax = 0.0;
-				for (k=0; k<xN; k++)
-				{
-					xcols[k] = x[k*xLD+col];
-					xmax = getMax(xmax,getAbs(xcols[k]));
-				}
-				if (isZero( xmax ) == BT_FALSE)
-					for (i = jc[col]; i < jc[col+1]; i++)
-						for (k=0; k<xN; k++)
-							ytmp[k*yfullLength+ir[i]] += val[i] * xcols[k];
-				delete [] xcols;
-			}
-		}
-	}
-
-	if (yCompr == BT_TRUE)
-	{
-		if ( isZero(beta) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength];
-		else if (isEqual( beta, 1.0 ) == BT_TRUE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] += alpha*ytmp[irows->number[j]+k*yfullLength];
-		else if (isEqual( beta, -1.0 ) == BT_TRUE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength]-y[j+k*yLD];
-		else if (isEqual( beta, 1.0 ) == BT_FALSE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength]+beta*y[j+k*yLD];
-	}
-	else
-	{
-		if (isZero( beta ) == BT_TRUE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength];
-		else if (isEqual( beta, 1.0 ) == BT_TRUE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength]+y[j+k*yLD];
-		else if (isEqual( beta, -1.0 ) == BT_TRUE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength]-y[j+k*yLD];
-		else if (isEqual( beta, 1.0 ) == BT_FALSE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength]+beta*y[j+k*yLD];
-	}
-
-	delete [] ytmp;
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrix::transTimes(const Indexlist* const irows, const Indexlist* const icols,
-		int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k, l, col;
-	real_t yadd;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] *= beta;
-	if ( isEqual(alpha,0.0) == BT_TRUE )
-		return SUCCESSFUL_RETURN;
-
-	// work with full, unordered copy of x
-	const int_t xfullLength = nRows;
-	real_t* xtmp = new real_t[xfullLength];
-	for (k = 0; k < xN; k++)
-	{
-		for (i = 0; i < xfullLength; i++)
-			xtmp[i] = 0.0;
-		for (i = 0; i < irows->length; i++)
-			xtmp[irows->number[i]] = x[k*xLD+i];
-		for (l = 0; l < icols->length; l++)
-		{
-			col = icols->iSort[l];
-			yadd = 0.0;
-			j = icols->number[col];
-			for (i = jc[j]; i < jc[j+1]; i++)
-				yadd += val[i] * xtmp[ir[i]];
-			y[col] += alpha*yadd;
-		}
-		y += yLD; // move on to next RHS
-	}
-
-	delete [] xtmp;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-returnValue SparseMatrix::addToDiag(real_t alpha)
-{
-	long i;
-
-	if ( jd == 0 )
-		return THROWERROR( RET_DIAGONAL_NOT_INITIALISED );
-
-	if ( isZero( alpha ) == BT_FALSE )
-	{
-		for (i = 0; i < nRows && i < nCols; i++)
-		{
-			if (ir[jd[i]] == i)
-				val[jd[i]] += alpha;
-			else
-				return RET_NO_DIAGONAL_AVAILABLE;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-sparse_int_t *SparseMatrix::createDiagInfo()
-{
-	sparse_int_t i, j;
-
-	if (jd == 0) {
-		jd = new sparse_int_t[nCols];
-
-		for (j = 0; j < nCols; j++)
-		{
-			for (i = jc[j]; i < jc[j+1] && ir[i] < j; i++);
-			jd[j] = i;
-		}
-	}
-
-	return jd;
-}
-
-
-
-real_t *SparseMatrix::full() const
-{
-	sparse_int_t i, j;
-	real_t *v = new real_t[nRows*nCols];
-
-	for (i = 0; i < nCols*nRows; i++)
-		v[i] = 0.0;
-
-	for (j = 0; j < nCols; j++)
-		for (i = jc[j]; i < jc[j+1]; i++)
-			v[ir[i] * nCols + j] = val[i];
-
-	return v;
-}
-
-
-returnValue SparseMatrix::print( const char* name ) const
-{
-	real_t* tmp = this->full();
-	returnValue retVal = REFER_NAMESPACE_QPOASES print( tmp,nRows,nCols,name );
-	delete[] tmp;
-
-	return retVal;
-}
-
-returnValue SparseMatrix::writeToFile( FILE* output_file, const char* prefix ) const
-{
-	for (int_t i=0; i<=nCols; i++) {
-		fprintf( output_file,"%sjc[%d] = %d\n",prefix,(int)i,(int)(jc[i]) );
-	}
-	for (int_t i=0; i<jc[nCols]; i++) {
-		fprintf( output_file,"%sir[%d] = %d\n",prefix,(int)i,(int)(ir[i]) );
-	}
-	for (int_t i=0; i<jc[nCols]; i++) {
-		fprintf( output_file,"%sval[%d] = %23.16e\n",prefix,(int)i,val[i] );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-SparseMatrixRow::SparseMatrixRow() : nRows(0), nCols(0), jr(0), ic(0), jd(0), val(0) {}
-
-SparseMatrixRow::SparseMatrixRow(int_t nr, int_t nc, sparse_int_t *r, sparse_int_t *c, real_t *v)
-	: nRows(nr), nCols(nc), jr(r), ic(c), jd(0), val(v) { doNotFreeMemory(); }
-
-SparseMatrixRow::SparseMatrixRow(int_t nr, int_t nc, int_t ld, const real_t * const v) : nRows(nr), nCols(nc), jd(0)
-{
-	int_t i, j, nnz;
-
-	jr = new sparse_int_t[nr+1];
-	ic = new sparse_int_t[nr*nc];
-	val = new real_t[nr*nc];
-
-	nnz = 0;
-	for (j = 0; j < nRows; j++)
-	{
-		jr[j] = nnz;
-		for (i = 0; i < nCols; i++)
-			if ( ( isZero( v[j*ld+i],0.0 ) == BT_FALSE ) || ( j == i ) )
-			{
-				ic[nnz] = i;
-				val[nnz++] = v[j*ld+i];
-			}
-	}
-	jr[nRows] = nnz;
-
-	doFreeMemory( );
-}
-
-
-SparseMatrixRow::~SparseMatrixRow()
-{
-	if (jd != 0)
-	{
-		delete[] jd;
-		jd = 0;
-	}
-
-	if ( needToFreeMemory() == BT_TRUE )
-		free( );
-}
-
-
-void SparseMatrixRow::free( )
-{
-	if (jr != 0) delete[] jr;
-	jr = 0;
-	if (ic != 0) delete[] ic;
-	ic = 0;
-	if (val != 0) delete[] val;
-	val = 0;
-
-	doNotFreeMemory( );
-}
-
-
-Matrix *SparseMatrixRow::duplicate() const
-{
-	long i, length = jr[nRows];
-	SparseMatrixRow *dupl = new SparseMatrixRow;
-
-	dupl->nRows = nRows;
-	dupl->nCols = nCols;
-	dupl->jr = new sparse_int_t[nRows+1];
-	dupl->ic = new sparse_int_t[length];
-	dupl->val = new real_t[length];
-
-	for (i = 0; i < length; i++) dupl->jr[i] = jr[i];
-	for (i = 0; i <= nCols; i++) dupl->ic[i] = ic[i];
-	for (i = 0; i < length; i++) dupl->val[i] = val[i];
-
-	if ( jd != 0 )
-	{
-		dupl->jd = new sparse_int_t[nRows];
-		for (i = 0; i < nCols; i++) dupl->jd[i] = jd[i];
-	}
-	else
-		dupl->jd = 0;
-
-	dupl->doFreeMemory( );
-
-	return dupl;
-}
-
-
-
-real_t SparseMatrixRow::diag(int_t i) const
-{
-	if ( jd == 0 )
-	{
-		THROWERROR( RET_DIAGONAL_NOT_INITIALISED );
-		return INFTY;
-	}
-
-	int_t entry = jd[i];
-	return (entry < jr[i+1] && ic[entry] == i) ? val[entry] : 0.0;
-}
-
-
-BooleanType SparseMatrixRow::isDiag() const
-{
-	int_t i;
-
-	if ( nCols != nRows )
-		return BT_FALSE;
-
-	for (i = 0; i < nRows; ++i)
-	{
-		if ( jr[i+1] > jr[i]+1 )
-			return BT_FALSE;
-
-		if ( ( jr[i+1] == jr[i]+1 ) && ( ic[jr[i]] != i ) )
-			return BT_FALSE;
-	}
-
-	return BT_TRUE;
-}
-
-
-
-real_t SparseMatrixRow::getNorm(	int_t type
-									) const
-{
-	int_t length = jr[nRows];
-	return REFER_NAMESPACE_QPOASES getNorm( val,length,type );
-
-}
-
-
-real_t SparseMatrixRow::getRowNorm( int_t rNum, int_t type ) const
-{
-	int_t length = jr[rNum+1] - jr[rNum];
-	return REFER_NAMESPACE_QPOASES getNorm( &(val[jr[rNum]]),length,type );
-}
-
-
-
-returnValue SparseMatrixRow::getRow(int_t rNum, const Indexlist* const icols, real_t alpha, real_t *row) const
-{
-	long i, j;
-
-	if (icols != 0)
-	{
-		j = jr[rNum];
-		i = 0;
-		if ( isEqual(alpha,1.0) == BT_TRUE )
-			while (j < jr[rNum+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = val[j++];
-				else if (ic[j] > icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = 0.0;
-				else
-					j++;
-		else if ( isEqual(alpha,-1.0) == BT_TRUE )
-			while (j < jr[rNum+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = -val[j++];
-				else if (ic[j] > icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = 0.0;
-				else
-					j++;
-		else
-			while (j < jr[rNum+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = alpha * val[j++];
-				else if (ic[j] > icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = 0.0;
-				else
-					j++;
-
-		/* fill in remaining zeros */
-		while (i < icols->length)
-			row[icols->iSort[i++]] = 0.0;
-	}
-	else
-	{
-		for (i = 0; i < nCols; i++)
-			row[i] = 0;
-
-		if ( isEqual(alpha,1.0) == BT_TRUE )
-			for (j = jr[rNum]; j < jr[rNum+1]; j++)
-				row[ic[j]] = val[j];
-		else if ( isEqual(alpha,-1.0) == BT_TRUE )
-			for (j = jr[rNum]; j < jr[rNum+1]; j++)
-				row[ic[j]] = -val[j];
-		else
-			for (j = jr[rNum]; j < jr[rNum+1]; j++)
-				row[ic[j]] = alpha * val[j];
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrixRow::getCol(int_t cNum, const Indexlist* const irows, real_t alpha, real_t *col) const
-{
-	long i, j, k, srt;
-
-    if (irows != 0)
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (k = 0; k < irows->length; k++)
-		    {
-				srt = irows->iSort[k];
-			    j = irows->number[srt];
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[srt] = (i < jr[j+1] && ic[i] == cNum) ? val[i] : 0.0;
-		    }
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (k = 0; k < irows->length; k++)
-		    {
-				srt = irows->iSort[k];
-			    j = irows->number[srt];
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[srt] = (i < jr[j+1] && ic[i] == cNum) ? -val[i] : 0.0;
-		    }
-	    else
-		    for (k = 0; k < irows->length; k++)
-		    {
-				srt = irows->iSort[k];
-			    j = irows->number[srt];
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[srt] = (i < jr[j+1] && ic[i] == cNum) ? alpha*val[i] : 0.0;
-		    }
-    }
-    else
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (j = 0; j < nCols; j++)
-		    {
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[j] = (i < jr[j+1] && ic[i] == cNum) ? val[i] : 0.0;
-		    }
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (j = 0; j < irows->length; j++)
-		    {
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[j] = (i < jr[j+1] && ic[i] == cNum) ? -val[i] : 0.0;
-		    }
-	    else
-		    for (j = 0; j < irows->length; j++)
-		    {
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[j] = (i < jr[j+1] && ic[i] == cNum) ? alpha*val[i] : 0.0;
-		    }
-    }
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SparseMatrixRow::getSparseSubmatrix (
-				int_t irowsLength, const int_t* const irowsNumber,
-				int_t icolsLength, const int_t* const icolsNumber,
-				int_t rowoffset, int_t coloffset, int_t& numNonzeros,	int_t* irn,
-				int_t* jcn, real_t* avals, BooleanType only_lower_triangular /*= BT_FALSE */) const
-{
-	fprintf(stderr, "SparseMatrixRow::getSparseSubmatrix not implemented!\n");
-
-	return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-}
-
-returnValue SparseMatrixRow::times(int_t xN, real_t alpha, const real_t *x, int_t xLD,
-		real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				for (i = jr[j]; i < jr[j+1]; i++)
-					y[j+k*yLD] += val[i] * x[ic[i]+k*xLD];
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				for (i = jr[j]; i < jr[j+1]; i++)
-					y[j+k*yLD] -= val[i] * x[ic[i]+k*xLD];
-	else
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				for (i = jr[j]; i < jr[j+1]; i++)
-					y[j+k*yLD] += alpha * val[i] * x[ic[i]+k*xLD];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrixRow::transTimes(int_t xN, real_t alpha, const real_t *x, int_t xLD,
-		real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (i = 0; i < nRows; i++)
-				for (j = jr[i]; j < jr[i+1]; j++)
-					y[ic[j]+k*yLD] += val[j] * x[i+k*xLD];
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (i = 0; i < nRows; i++)
-				for (j = jr[i]; j < jr[i+1]; j++)
-					y[ic[j]+k*yLD] -= val[j] * x[i+k*xLD];
-	else
-		for (k = 0; k < xN; k++)
-			for (i = 0; i < nRows; i++)
-				for (j = jr[i]; j < jr[i+1]; j++)
-					y[ic[j]+k*yLD] += alpha * val[j] * x[i+k*xLD];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrixRow::times(const Indexlist* const irows, const Indexlist* const icols,
-		int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD,
-		BooleanType yCompr) const
-{
-	long i, j, k, l, srt, row;
-
-	if (yCompr == BT_TRUE)
-	{
-		if ( isZero(beta) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = 0.0;
-		else if ( isEqual(beta,-1.0) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = -y[j+k*yLD];
-		else if ( isEqual(beta,1.0) == BT_FALSE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] *= beta;
-
-		if (icols == 0)
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+srt] += val[j] * x[k*xLD+ic[j]];
-				}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+srt] -= val[j] * x[k*xLD+ic[j]];
-				}
-			else
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+srt] += alpha * val[j] * x[k*xLD+ic[j]];
-				}
-		else /* icols != 0 */
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					j = jr[row];
-					i = 0;
-					while (j < jr[row+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+srt] += val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					j = jr[row];
-					i = 0;
-					while (j < jr[row+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+srt] -= val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-			else
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					j = jr[row];
-					i = 0;
-					while (j < jr[row+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+srt] += alpha * val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-	}
-	else /* y not compressed */
-	{
-		if ( isZero(beta) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = 0.0;
-		else if ( isEqual(beta,-1.0) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = -y[j+k*yLD];
-		else if ( isEqual(beta,1.0) == BT_FALSE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] *= beta;
-
-		if (icols == 0)
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->number[irows->iSort[l]];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+row] += val[j] * x[k*xLD+ic[j]];
-				}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->number[irows->iSort[l]];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+row] -= val[j] * x[k*xLD+ic[j]];
-				}
-			else
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->number[irows->iSort[l]];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+row] += alpha * val[j] * x[k*xLD+ic[j]];
-				}
-		else /* icols != 0 */
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->iSort[l];
-					j = jr[irows->number[row]];
-					i = 0;
-					while (j < jr[irows->number[row]+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+row] += val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->iSort[l];
-					j = jr[irows->number[row]];
-					i = 0;
-					while (j < jr[irows->number[row]+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+row] -= val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-			else
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->iSort[l];
-					j = jr[irows->number[row]];
-					i = 0;
-					while (j < jr[irows->number[row]+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+row] += alpha * val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-	}
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrixRow::transTimes(const Indexlist* const irows, const Indexlist* const icols,
-		int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k, l, row, srt;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (l = 0; l < irows->length; l++)
-		{
-			srt = irows->iSort[l];
-			row = irows->number[srt];
-			j = jr[row];
-			i = 0;
-			while (j < jr[row+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-				{
-					for (k = 0; k < xN; k++)
-						y[k*yLD+icols->iSort[i]] += val[j] * x[k*xLD+srt];
-					j++, i++;
-				}
-				else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-				else j++;
-		}
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (l = 0; l < irows->length; l++)
-		{
-			srt = irows->iSort[l];
-			row = irows->number[srt];
-			j = jr[row];
-			i = 0;
-			while (j < jr[row+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-				{
-					for (k = 0; k < xN; k++)
-						y[k*yLD+icols->iSort[i]] -= val[j] * x[k*xLD+srt];
-					j++, i++;
-				}
-				else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-				else j++;
-		}
-	else
-		for (l = 0; l < irows->length; l++)
-		{
-			srt = irows->iSort[l];
-			row = irows->number[srt];
-			j = jr[row];
-			i = 0;
-			while (j < jr[row+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-				{
-					for (k = 0; k < xN; k++)
-						y[k*yLD+icols->iSort[i]] += alpha * val[j] * x[k*xLD+srt];
-					j++, i++;
-				}
-				else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-				else j++;
-		}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-returnValue SparseMatrixRow::addToDiag(real_t alpha)
-{
-	long i;
-
-	if ( jd == 0 )
-		return THROWERROR( RET_DIAGONAL_NOT_INITIALISED );
-
-	if ( isZero(alpha) == BT_FALSE )
-	{
-		for (i = 0; i < nRows && i < nCols; i++)
-		{
-			if (ic[jd[i]] == i)
-				val[jd[i]] += alpha;
-			else
-				return RET_NO_DIAGONAL_AVAILABLE;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-sparse_int_t *SparseMatrixRow::createDiagInfo()
-{
-	sparse_int_t i, j;
-
-	if (jd == 0) {
-		jd = new sparse_int_t[nRows];
-
-		for (i = 0; i < nRows; i++)
-		{
-			for (j = jr[i]; j < jr[i+1] && ic[j] < i; j++);
-			jd[i] = j;
-		}
-	}
-
-	return jd;
-}
-
-
-real_t *SparseMatrixRow::full() const
-{
-	sparse_int_t i, j;
-	real_t *v = new real_t[nRows*nCols];
-
-	for (i = 0; i < nCols*nRows; i++)
-		v[i] = 0.0;
-
-	for (i = 0; i < nRows; i++)
-		for (j = jr[i]; j < jr[i+1]; j++)
-			v[ic[j] + i * nCols] = val[j];
-
-	return v;
-}
-
-
-returnValue SparseMatrixRow::print( const char* name ) const
-{
-	real_t* tmp = this->full();
-	returnValue retVal = REFER_NAMESPACE_QPOASES print( tmp,nRows,nCols,name );
-	delete[] tmp;
-
-	return retVal;
-}
-
-returnValue SparseMatrixRow::writeToFile( FILE* output_file, const char* prefix ) const
-{
-	return THROWERROR( RET_NOT_YET_IMPLEMENTED );
-}
-
-Matrix *SymSparseMat::duplicate() const
-{
-	return duplicateSym();
-}
-
-
-SymmetricMatrix *SymSparseMat::duplicateSym() const
-{
-	/* "same" as duplicate() in SparseMatrix */
-	long i, length = jc[nCols];
-	SymSparseMat *dupl = new SymSparseMat;
-
-	dupl->nRows = nRows;
-	dupl->nCols = nCols;
-	dupl->ir = new sparse_int_t[length];
-	dupl->jc = new sparse_int_t[nCols+1];
-	dupl->val = new real_t[length];
-
-	for (i = 0; i < length; i++) dupl->ir[i] = ir[i];
-	for (i = 0; i <= nCols; i++) dupl->jc[i] = jc[i];
-	for (i = 0; i < length; i++) dupl->val[i] = val[i];
-
-	if ( jd != 0 )
-	{
-		dupl->jd = new sparse_int_t[nCols];
-		for (i = 0; i < nCols; i++) dupl->jd[i] = jd[i];
-	}
-	else
-		dupl->jd = 0;
-
-	dupl->doFreeMemory( );
-
-	return dupl;
-}
-
-
-returnValue SymSparseMat::bilinear(const Indexlist* const icols,
-		int_t xN, const real_t *x, int_t xLD, real_t *y, int_t yLD) const
-{
-	int_t i, j, k, l, idx, row, col;
-
-	if ( jd == 0 )
-		return THROWERROR( RET_DIAGONAL_NOT_INITIALISED );
-
-	/* clear output */
-	for (i = 0; i < xN*xN; i++)
-		y[i] = 0.0;
-
-	/* compute lower triangle */
-	for (l = 0; l < icols->length; l++)
-	{
-		col = icols->number[icols->iSort[l]];
-		idx = jd[col];
-		k = 0;
-		while (idx < jc[col+1] && k < icols->length)
-		{
-			row = icols->number[icols->iSort[k]];
-			if (ir[idx] == row)
-			{
-				/* TODO: It is possible to formulate this as DSYR and DSYR2
-				 * operations. */
-				if (row == col) /* diagonal element */
-					for (i = 0; i < xN; i++)
-						for (j = i; j < xN; j++)
-							y[i*yLD+j] += val[idx] * x[i*xLD+col] * x[j*xLD+col];
-				else /* subdiagonal elements */
-					for (i = 0; i < xN; i++)
-						for (j = i; j < xN; j++)
-							y[i*yLD+j] += val[idx] * (x[i*xLD+col] * x[j*xLD+row] + x[i*xLD+row] * x[j*xLD+col]);
-				idx++, k++;
-			}
-			else if (ir[idx] > row) k++;
-			else idx++;
-		}
-	}
-
-	/* fill upper triangle */
-	for (i = 0; i < xN; i++)
-		for (j = i; j < xN; j++)
-			y[j*yLD+i] = y[i*yLD+j];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/MessageHandling.cpp b/extlibs/qpOASES-3.2.0/src/MessageHandling.cpp
deleted file mode 100644
index 00a3985..0000000
--- a/extlibs/qpOASES-3.2.0/src/MessageHandling.cpp
+++ /dev/null
@@ -1,632 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/MessageHandling.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the MessageHandling class including global return values.
- *
- */
-
-
-#include <stdio.h>
-
-#ifdef __MATLAB__
-  #include "mex.h"
-#endif
-
-#include <qpOASES/MessageHandling.hpp>
-#include <qpOASES/Utils.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-/** Default file to display messages. */
-FILE* stdFile = stdout;
-
-
-
-#ifndef __SUPPRESSANYOUTPUT__
-
-/** Defines pairs of global return values and messages. */
-MessageHandling::ReturnValueList returnValueList[] =
-{
-/* miscellaneous */
-{ SUCCESSFUL_RETURN, "Successful return", VS_VISIBLE },
-{ RET_DIV_BY_ZERO, "Division by zero", VS_VISIBLE },
-{ RET_INDEX_OUT_OF_BOUNDS, "Index out of bounds", VS_VISIBLE },
-{ RET_INVALID_ARGUMENTS, "At least one of the arguments is invalid", VS_VISIBLE },
-{ RET_ERROR_UNDEFINED, "Error number undefined", VS_VISIBLE },
-{ RET_WARNING_UNDEFINED, "Warning number undefined", VS_VISIBLE },
-{ RET_INFO_UNDEFINED, "Info number undefined", VS_VISIBLE },
-{ RET_EWI_UNDEFINED, "Error/warning/info number undefined", VS_VISIBLE },
-{ RET_AVAILABLE_WITH_LINUX_ONLY, "This function is available under Linux only", VS_HIDDEN },
-{ RET_UNKNOWN_BUG, "The error occurred is not yet known", VS_VISIBLE },
-{ RET_PRINTLEVEL_CHANGED, "Print level changed", VS_VISIBLE },
-{ RET_NOT_YET_IMPLEMENTED, "Requested function is not yet implemented.", VS_VISIBLE },
-/* Indexlist */
-{ RET_INDEXLIST_MUST_BE_REORDERD, "Index list has to be reordered", VS_VISIBLE },
-{ RET_INDEXLIST_EXCEEDS_MAX_LENGTH, "Index list exceeds its maximal physical length", VS_VISIBLE },
-{ RET_INDEXLIST_CORRUPTED, "Index list corrupted", VS_VISIBLE },
-{ RET_INDEXLIST_OUTOFBOUNDS, "Physical index is out of bounds", VS_VISIBLE },
-{ RET_INDEXLIST_ADD_FAILED, "Adding indices from another index set failed", VS_VISIBLE },
-{ RET_INDEXLIST_INTERSECT_FAILED, "Intersection with another index set failed", VS_VISIBLE },
-/* SubjectTo / Bounds / Constraints */
-{ RET_INDEX_ALREADY_OF_DESIRED_STATUS, "Index is already of desired status", VS_VISIBLE },
-{ RET_ADDINDEX_FAILED, "Adding index to index set failed", VS_VISIBLE },
-{ RET_REMOVEINDEX_FAILED, "Removing index from index set failed", VS_VISIBLE },
-{ RET_SWAPINDEX_FAILED, "Cannot swap between different indexsets", VS_VISIBLE },
-{ RET_NOTHING_TO_DO, "Nothing to do", VS_VISIBLE },
-{ RET_SETUP_BOUND_FAILED, "Setting up bound index failed", VS_VISIBLE },
-{ RET_SETUP_CONSTRAINT_FAILED, "Setting up constraint index failed", VS_VISIBLE },
-{ RET_MOVING_BOUND_FAILED, "Moving bound between index sets failed", VS_VISIBLE },
-{ RET_MOVING_CONSTRAINT_FAILED, "Moving constraint between index sets failed", VS_VISIBLE },
-{ RET_SHIFTING_FAILED, "Shifting of bounds/constraints failed", VS_VISIBLE },
-{ RET_ROTATING_FAILED, "Rotating of bounds/constraints failed", VS_VISIBLE },
-/* QProblem */
-{ RET_QPOBJECT_NOT_SETUP, "The QP object has not been setup correctly, use another constructor", VS_VISIBLE },
-{ RET_QP_ALREADY_INITIALISED, "QProblem has already been initialised", VS_VISIBLE },
-{ RET_NO_INIT_WITH_STANDARD_SOLVER, "Initialisation via extern QP solver is not yet implemented", VS_VISIBLE },
-{ RET_RESET_FAILED, "Reset failed", VS_VISIBLE },
-{ RET_INIT_FAILED, "Initialisation failed", VS_VISIBLE },
-{ RET_INIT_FAILED_TQ, "Initialisation failed due to TQ factorisation", VS_VISIBLE },
-{ RET_INIT_FAILED_CHOLESKY, "Initialisation failed due to Cholesky decomposition", VS_VISIBLE },
-{ RET_INIT_FAILED_HOTSTART, "Initialisation failed! QP could not be solved!", VS_VISIBLE },
-{ RET_INIT_FAILED_INFEASIBILITY, "Initial QP could not be solved due to infeasibility!", VS_VISIBLE },
-{ RET_INIT_FAILED_UNBOUNDEDNESS, "Initial QP could not be solved due to unboundedness!", VS_VISIBLE },
-{ RET_INIT_FAILED_REGULARISATION, "Initialisation failed as Hessian matrix could not be regularised", VS_VISIBLE },
-{ RET_INIT_SUCCESSFUL, "Initialisation done", VS_VISIBLE },
-{ RET_OBTAINING_WORKINGSET_FAILED, "Failed to obtain working set for auxiliary QP", VS_VISIBLE },
-{ RET_SETUP_WORKINGSET_FAILED, "Failed to setup working set for auxiliary QP", VS_VISIBLE },
-{ RET_SETUP_AUXILIARYQP_FAILED, "Failed to setup auxiliary QP for initialised homotopy", VS_VISIBLE },
-{ RET_NO_CHOLESKY_WITH_INITIAL_GUESS, "Externally computed Cholesky factor cannot be combined with an initial guess", VS_VISIBLE },
-{ RET_NO_EXTERN_SOLVER, "No extern QP solver available", VS_VISIBLE },
-{ RET_QP_UNBOUNDED, "QP is unbounded", VS_VISIBLE },
-{ RET_QP_INFEASIBLE, "QP is infeasible", VS_VISIBLE },
-{ RET_QP_NOT_SOLVED, "Problems occurred while solving QP with standard solver", VS_VISIBLE },
-{ RET_QP_SOLVED, "QP successfully solved", VS_VISIBLE },
-{ RET_UNABLE_TO_SOLVE_QP, "Problems occurred while solving QP", VS_VISIBLE },
-{ RET_INITIALISATION_STARTED, "Starting problem initialisation...", VS_VISIBLE },
-{ RET_HOTSTART_FAILED, "Unable to perform homotopy due to internal error", VS_VISIBLE },
-{ RET_HOTSTART_FAILED_TO_INIT, "Unable to initialise problem", VS_VISIBLE },
-{ RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED, "Unable to perform homotopy as previous QP is not solved", VS_VISIBLE },
-{ RET_ITERATION_STARTED, "Iteration", VS_VISIBLE },
-{ RET_SHIFT_DETERMINATION_FAILED, "Determination of shift of the QP data failed", VS_VISIBLE },
-{ RET_STEPDIRECTION_DETERMINATION_FAILED, "Determination of step direction failed", VS_VISIBLE },
-{ RET_STEPLENGTH_DETERMINATION_FAILED, "Determination of step direction failed", VS_VISIBLE },
-{ RET_OPTIMAL_SOLUTION_FOUND, "Optimal solution of neighbouring QP found", VS_VISIBLE },
-{ RET_HOMOTOPY_STEP_FAILED, "Unable to perform homotopy step", VS_VISIBLE },
-{ RET_HOTSTART_STOPPED_INFEASIBILITY, "Premature homotopy termination because QP is infeasible", VS_VISIBLE },
-{ RET_HOTSTART_STOPPED_UNBOUNDEDNESS, "Premature homotopy termination because QP is unbounded", VS_VISIBLE },
-{ RET_WORKINGSET_UPDATE_FAILED, "Unable to update working sets according to initial guesses", VS_VISIBLE },
-{ RET_MAX_NWSR_REACHED, "Maximum number of working set recalculations performed", VS_VISIBLE },
-{ RET_CONSTRAINTS_NOT_SPECIFIED, "Problem does comprise constraints! You have to specify new constraints' bounds", VS_VISIBLE },
-{ RET_INVALID_FACTORISATION_FLAG, "Invalid factorisation flag", VS_VISIBLE },
-{ RET_UNABLE_TO_SAVE_QPDATA, "Unable to save QP data", VS_VISIBLE },
-{ RET_STEPDIRECTION_FAILED_TQ, "Abnormal termination due to TQ factorisation", VS_VISIBLE },
-{ RET_STEPDIRECTION_FAILED_CHOLESKY, "Abnormal termination due to Cholesky factorisation", VS_VISIBLE },
-{ RET_CYCLING_DETECTED, "Cycling detected", VS_VISIBLE },
-{ RET_CYCLING_NOT_RESOLVED, "Cycling cannot be resolved, QP is probably infeasible", VS_VISIBLE },
-{ RET_CYCLING_RESOLVED, "Cycling probably resolved", VS_VISIBLE },
-{ RET_STEPSIZE, "", VS_VISIBLE },
-{ RET_STEPSIZE_NONPOSITIVE, "", VS_VISIBLE },
-{ RET_SETUPSUBJECTTOTYPE_FAILED, "Setup of SubjectToTypes failed", VS_VISIBLE },
-{ RET_ADDCONSTRAINT_FAILED, "Addition of constraint to working set failed", VS_VISIBLE },
-{ RET_ADDCONSTRAINT_FAILED_INFEASIBILITY, "Addition of constraint to working set failed", VS_VISIBLE },
-{ RET_ADDBOUND_FAILED, "Addition of bound to working set failed", VS_VISIBLE },
-{ RET_ADDBOUND_FAILED_INFEASIBILITY, "Addition of bound to working set failed", VS_VISIBLE },
-{ RET_REMOVECONSTRAINT_FAILED, "Removal of constraint from working set failed", VS_VISIBLE },
-{ RET_REMOVEBOUND_FAILED, "Removal of bound from working set failed", VS_VISIBLE },
-{ RET_REMOVE_FROM_ACTIVESET, "Removing from active set:", VS_VISIBLE },
-{ RET_ADD_TO_ACTIVESET, "Adding to active set:", VS_VISIBLE },
-{ RET_REMOVE_FROM_ACTIVESET_FAILED, "Removing from active set failed", VS_VISIBLE },
-{ RET_ADD_TO_ACTIVESET_FAILED, "Adding to active set failed", VS_VISIBLE },
-{ RET_CONSTRAINT_ALREADY_ACTIVE, "Constraint is already active", VS_VISIBLE },
-{ RET_ALL_CONSTRAINTS_ACTIVE, "All constraints are active, no further constraint can be added", VS_VISIBLE },
-{ RET_LINEARLY_DEPENDENT, "New bound/constraint is linearly dependent", VS_VISIBLE },
-{ RET_LINEARLY_INDEPENDENT, "New bound/constraint is linearly independent", VS_VISIBLE },
-{ RET_LI_RESOLVED, "Linear independence of active constraint matrix successfully resolved", VS_VISIBLE },
-{ RET_ENSURELI_FAILED, "Failed to ensure linear independence of active constraint matrix", VS_VISIBLE },
-{ RET_ENSURELI_FAILED_TQ, "Abnormal termination due to TQ factorisation", VS_VISIBLE },
-{ RET_ENSURELI_FAILED_NOINDEX, "QP is infeasible", VS_VISIBLE },
-{ RET_ENSURELI_FAILED_CYCLING, "QP is infeasible", VS_VISIBLE },
-{ RET_BOUND_ALREADY_ACTIVE, "Bound is already active", VS_VISIBLE },
-{ RET_ALL_BOUNDS_ACTIVE, "All bounds are active, no further bound can be added", VS_VISIBLE },
-{ RET_CONSTRAINT_NOT_ACTIVE, "Constraint is not active", VS_VISIBLE },
-{ RET_BOUND_NOT_ACTIVE, "Bound is not active", VS_VISIBLE },
-{ RET_HESSIAN_NOT_SPD, "Projected Hessian matrix not positive definite", VS_VISIBLE },
-{ RET_HESSIAN_INDEFINITE, "Hessian matrix is indefinite", VS_VISIBLE },
-{ RET_MATRIX_SHIFT_FAILED, "Unable to update matrices or to transform vectors", VS_VISIBLE },
-{ RET_MATRIX_FACTORISATION_FAILED, "Unable to calculate new matrix factorisations", VS_VISIBLE },
-{ RET_PRINT_ITERATION_FAILED, "Unable to print information on current iteration", VS_VISIBLE },
-{ RET_NO_GLOBAL_MESSAGE_OUTPUTFILE, "No global message output file initialised", VS_VISIBLE },
-{ RET_DISABLECONSTRAINTS_FAILED, "Unable to disable constraints", VS_VISIBLE },
-{ RET_ENABLECONSTRAINTS_FAILED, "Unable to enable constraints", VS_VISIBLE },
-{ RET_ALREADY_ENABLED, "Bound or constraint is already enabled", VS_VISIBLE },
-{ RET_ALREADY_DISABLED, "Bound or constraint is already disabled", VS_VISIBLE },
-{ RET_NO_HESSIAN_SPECIFIED, "No Hessian matrix has been specified", VS_VISIBLE },
-{ RET_USING_REGULARISATION, "Using regularisation as Hessian matrix is not positive definite", VS_VISIBLE },
-{ RET_EPS_MUST_BE_POSITVE, "Eps for regularisation must be sufficiently positive", VS_VISIBLE },
-{ RET_REGSTEPS_MUST_BE_POSITVE, "Maximum number of regularisation steps must be non-negative", VS_VISIBLE },
-{ RET_HESSIAN_ALREADY_REGULARISED, "Hessian has been already regularised", VS_VISIBLE },
-{ RET_CANNOT_REGULARISE_IDENTITY, "Identity Hessian matrix cannot be regularised", VS_VISIBLE },
-{ RET_CANNOT_REGULARISE_SPARSE, "Sparse matrix cannot be regularised as diagonal entry is missing", VS_VISIBLE },
-{ RET_NO_REGSTEP_NWSR, "No additional regularisation step could be performed due to limits", VS_VISIBLE },
-{ RET_FEWER_REGSTEPS_NWSR, "Fewer additional regularisation steps have been performed due to limits", VS_VISIBLE },
-{ RET_CHOLESKY_OF_ZERO_HESSIAN, "Cholesky decomposition of (unregularised) zero Hessian matrix", VS_VISIBLE },
-{ RET_ZERO_HESSIAN_ASSUMED, "Zero Hessian matrix assumed as null pointer passed without specifying hessianType", VS_VISIBLE },
-{ RET_CONSTRAINTS_ARE_NOT_SCALED, "(should not be thrown, no longer in use)", VS_VISIBLE },
-{ RET_INITIAL_BOUNDS_STATUS_NYI, "(should not be thrown, no longer in use)", VS_VISIBLE },
-{ RET_ERROR_IN_CONSTRAINTPRODUCT, "Error in user-defined constraint product function", VS_VISIBLE },
-{ RET_FIX_BOUNDS_FOR_LP, "All initial bounds must be fixed when solving an (unregularised) LP", VS_VISIBLE },
-{ RET_USE_REGULARISATION_FOR_LP, "Set options.enableRegularisation=BT_TRUE for solving LPs", VS_VISIBLE },
-/* SQProblem */
-{ RET_UPDATEMATRICES_FAILED, "Unable to update QP matrices", VS_VISIBLE },
-{ RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED, "Unable to update matrices as previous QP is not solved", VS_VISIBLE },
-/* Utils */
-{ RET_UNABLE_TO_OPEN_FILE, "Unable to open file", VS_VISIBLE },
-{ RET_UNABLE_TO_WRITE_FILE, "Unable to write into file", VS_VISIBLE },
-{ RET_UNABLE_TO_READ_FILE, "Unable to read from file", VS_VISIBLE },
-{ RET_FILEDATA_INCONSISTENT, "File contains inconsistent data", VS_VISIBLE },
-/* Options */
-{ RET_OPTIONS_ADJUSTED,	"Options needed to be adjusted for consistency reasons", VS_VISIBLE },
-/* SolutionAnalysis */
-{ RET_UNABLE_TO_ANALYSE_QPROBLEM, "Unable to analyse (S)QProblem(B) object", VS_VISIBLE },
-/* Benchmark */
-{ RET_NWSR_SET_TO_ONE, "Maximum number of working set changes was set to 1", VS_VISIBLE },
-{ RET_UNABLE_TO_READ_BENCHMARK, "Unable to read benchmark data", VS_VISIBLE },
-{ RET_BENCHMARK_ABORTED, "Benchmark aborted", VS_VISIBLE },
-{ RET_INITIAL_QP_SOLVED, "Initial QP solved", VS_VISIBLE },
-{ RET_QP_SOLUTION_STARTED, "Solving QP no.", VS_VISIBLE },
-{ RET_BENCHMARK_SUCCESSFUL, "Benchmark terminated successfully", VS_VISIBLE },
-/* Sparse matrices */
-{ RET_NO_DIAGONAL_AVAILABLE, "Sparse matrix does not have entries on full diagonal", VS_VISIBLE },
-{ RET_DIAGONAL_NOT_INITIALISED, "Diagonal data of sparse matrix has not been initialised", VS_VISIBLE },
-/* Dropping of infeasible constraints */
-{ RET_ENSURELI_DROPPED, "Linear independence resolved by dropping blocking constraint", VS_VISIBLE },
-/* Schur complement computations */
-{ RET_KKT_MATRIX_SINGULAR, "KKT matrix is singular", VS_VISIBLE },
-{ RET_QR_FACTORISATION_FAILED, "QR factorization of Schur complement failed", VS_VISIBLE },
-{ RET_INERTIA_CORRECTION_FAILED, "Inertia correction of KKT matrix failed", VS_VISIBLE },
-{ RET_NO_SPARSE_SOLVER, "No Sparse Solver installed", VS_VISIBLE },
-/* Simple exitflags */
-{ RET_SIMPLE_STATUS_P1, "QP problem could not be solved within given number of iterations", VS_VISIBLE },
-{ RET_SIMPLE_STATUS_P0, "QP problem solved", VS_VISIBLE },
-{ RET_SIMPLE_STATUS_M1, "QP problem could not be solved due to an internal error", VS_VISIBLE },
-{ RET_SIMPLE_STATUS_M2, "QP problem is infeasible (and thus could not be solved)", VS_VISIBLE },
-{ RET_SIMPLE_STATUS_M3, "QP problem is unbounded (and thus could not be solved)", VS_VISIBLE },
-/* IMPORTANT: Terminal list element! */
-{ TERMINAL_LIST_ELEMENT, "", VS_HIDDEN }
-};
-
-#else /* __SUPPRESSANYOUTPUT__ */
-
-MessageHandling::ReturnValueList returnValueList[1]; /* Do not use messages for embedded platforms! */
-
-#endif /* __SUPPRESSANYOUTPUT__ */
-
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-/*
- *	M e s s a g e H a n d l i n g
- */
-MessageHandling::MessageHandling( )
-{
-	errorVisibility   = VS_VISIBLE;
-	warningVisibility = VS_VISIBLE;
-	infoVisibility    = VS_VISIBLE;
-
-	outputFile = stdFile;
-	errorCount = 0;
-}
-
-/*
- *	M e s s a g e H a n d l i n g
- */
-MessageHandling::MessageHandling( FILE* _outputFile )
-{
-	errorVisibility   = VS_VISIBLE;
-	warningVisibility = VS_HIDDEN;
-	infoVisibility    = VS_HIDDEN;
-
-	outputFile = _outputFile;
-	errorCount = 0;
-}
-
-/*
- *	M e s s a g e H a n d l i n g
- */
-MessageHandling::MessageHandling(	VisibilityStatus _errorVisibility,
-									VisibilityStatus _warningVisibility,
-		 							VisibilityStatus _infoVisibility
-									)
-{
-	errorVisibility   = _errorVisibility;
-	warningVisibility = _warningVisibility;
-	infoVisibility    = _infoVisibility;
-
-	outputFile = stdFile;
-	errorCount = 0;
-}
-
-/*
- *	M e s s a g e H a n d l i n g
- */
-MessageHandling::MessageHandling( 	FILE* _outputFile,
-									VisibilityStatus _errorVisibility,
-									VisibilityStatus _warningVisibility,
-		 							VisibilityStatus _infoVisibility
-									)
-{
-	errorVisibility   = _errorVisibility;
-	warningVisibility = _warningVisibility;
-	infoVisibility    = _infoVisibility;
-
-	outputFile = _outputFile;
-	errorCount = 0;
-}
-
-
-
-/*
- *	M e s s a g e H a n d l i n g
- */
-MessageHandling::MessageHandling( const MessageHandling& rhs )
-{
-	errorVisibility   = rhs.errorVisibility;
-	warningVisibility = rhs.warningVisibility;
-	infoVisibility    = rhs.infoVisibility;
-
-	outputFile = rhs.outputFile;
-	errorCount = rhs.errorCount;
-}
-
-
-/*
- *	~ M e s s a g e H a n d l i n g
- */
-MessageHandling::~MessageHandling( )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	if ( ( outputFile != 0 ) && ( outputFile != stdout ) && ( outputFile != stderr ) )
-		fclose( outputFile );
- 	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	o p e r a t o r =
- */
-MessageHandling& MessageHandling::operator=( const MessageHandling& rhs )
-{
-	if ( this != &rhs )
-	{
-		errorVisibility   = rhs.errorVisibility;
-		warningVisibility = rhs.warningVisibility;
-		infoVisibility    = rhs.infoVisibility;
-
-		outputFile = rhs.outputFile;
-		errorCount = rhs.errorCount;
-	}
-
-	return *this;
-}
-
-
-/*
- *	t h r o w E r r o r
- */
-returnValue MessageHandling::throwError(	returnValue Enumber,
-											const char* additionaltext,
-											const char* functionname,
-											const char* filename,
-											const unsigned long linenumber,
-											VisibilityStatus localVisibilityStatus
-											)
-{
-	/* consistency check */
-	if ( Enumber <= SUCCESSFUL_RETURN )
-		return throwError( RET_ERROR_UNDEFINED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-
-	/* Call to common throwMessage function if error shall be displayed. */
-	if ( errorVisibility == VS_VISIBLE )
-		return throwMessage( Enumber,additionaltext,functionname,filename,linenumber,localVisibilityStatus,"ERROR" );
-	else
-		return Enumber;
-}
-
-
-/*
- *	t h r o w W a r n i n g
- */
-returnValue MessageHandling::throwWarning(	returnValue Wnumber,
-											const char* additionaltext,
-											const char* functionname,
-											const char* filename,
-											const unsigned long linenumber,
-											VisibilityStatus localVisibilityStatus
-											)
-{
-	/* consistency check */
-  	if ( Wnumber <= SUCCESSFUL_RETURN )
-		return throwError( RET_WARNING_UNDEFINED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-
-	/* Call to common throwMessage function if warning shall be displayed. */
-	if ( warningVisibility == VS_VISIBLE )
-		return throwMessage( Wnumber,additionaltext,functionname,filename,linenumber,localVisibilityStatus,"WARNING" );
-  	else
-  		return Wnumber;
-}
-
-
-/*
- *	t h r o w I n f o
- */
-returnValue MessageHandling::throwInfo(	returnValue Inumber,
-										const char* additionaltext,
-										const char* functionname,
-										const char* filename,
-										const unsigned long linenumber,
-										VisibilityStatus localVisibilityStatus
-										)
-{
-	/* consistency check */
-	if ( Inumber < SUCCESSFUL_RETURN )
-		return throwError( RET_INFO_UNDEFINED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-
-	/* Call to common throwMessage function if info shall be displayed. */
-	if ( infoVisibility == VS_VISIBLE )
-		return throwMessage( Inumber,additionaltext,functionname,filename,linenumber,localVisibilityStatus,"INFO" );
-	else
-		return Inumber;
-}
-
-
-/*
- *	r e s e t
- */
-returnValue MessageHandling::reset( )
-{
-	setErrorVisibilityStatus(   VS_VISIBLE );
-	setWarningVisibilityStatus( VS_HIDDEN );
-	setInfoVisibilityStatus(    VS_HIDDEN );
-
-	setOutputFile( stdFile );
-	setErrorCount( 0 );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	l i s t A l l M e s s a g e s
- */
-returnValue MessageHandling::listAllMessages( )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	int_t keypos = 0;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Run through whole returnValueList and print each item. */
-	while ( returnValueList[keypos].key != TERMINAL_LIST_ELEMENT )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH," %d - %s \n",(int)keypos,returnValueList[keypos].data );
-		myPrintf( myPrintfString );
-
-		++keypos;
-	}
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-
-/*
- *	t h r o w M e s s a g e
- */
-returnValue MessageHandling::throwMessage(	returnValue RETnumber,
-											const char* additionaltext,
-											const char* functionname,
-											const char* filename,
-											const unsigned long linenumber,
-											VisibilityStatus localVisibilityStatus,
-											const char* RETstring
-											)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t keypos = 0;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* 1) Determine number of whitespace for output. */
-	char whitespaces[MAX_STRING_LENGTH];
-	int_t numberOfWhitespaces = (errorCount-1)*2;
-
-	if ( numberOfWhitespaces < 0 )
-		numberOfWhitespaces = 0;
-
-	if ( numberOfWhitespaces > 40 )
-		numberOfWhitespaces = 40;
-
-	if ( numberOfWhitespaces >= (int_t)MAX_STRING_LENGTH )
-		numberOfWhitespaces = (int_t)MAX_STRING_LENGTH-1;
-
-	memset( whitespaces, ' ', (size_t) numberOfWhitespaces );
-	whitespaces[numberOfWhitespaces] = '\0';
-
-	/* 2) Find error/warning/info in list. */
-	while ( returnValueList[keypos].key != TERMINAL_LIST_ELEMENT )
-	{
-		if ( returnValueList[keypos].key == RETnumber )
-			break;
-		else
-			++keypos;
-	}
-
-	if ( returnValueList[keypos].key == TERMINAL_LIST_ELEMENT )
-	{
-		throwError( RET_EWI_UNDEFINED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		return RETnumber;
-	}
-
-	/* 3) Print error/warning/info. */
-	if ( ( returnValueList[keypos].globalVisibilityStatus == VS_VISIBLE ) && ( localVisibilityStatus == VS_VISIBLE ) )
-	{
-		if ( errorCount < 0 )
-		{
-			myPrintf( "\n" );
-			errorCount = 0;
-		}
-
-		if ( errorCount > 0 )
-		{
-			snprintf( myPrintfString,MAX_STRING_LENGTH,"%s->", whitespaces );
-			myPrintf( myPrintfString );
-		}
-
-		if ( additionaltext == 0 )
-		{
-			#ifdef __DEBUG__
-			snprintf(	myPrintfString,MAX_STRING_LENGTH,"%s (%s, %s:%d): \t%s\n",
-						RETstring,functionname,filename,(int_t)linenumber,returnValueList[keypos].data
-						);
-			#else
-			snprintf(	myPrintfString,MAX_STRING_LENGTH,"%s:  %s\n",
-						RETstring,returnValueList[keypos].data
-						);
-			#endif
-			myPrintf( myPrintfString );
-		}
-		else
-		{
-			#ifdef __DEBUG__
-			snprintf(	myPrintfString,MAX_STRING_LENGTH,"%s (%s, %s:%d): \t%s %s\n",
-						RETstring,functionname,filename,(int_t)linenumber,returnValueList[keypos].data,additionaltext
-						);
-			#else
-			snprintf(	myPrintfString,MAX_STRING_LENGTH,"%s:  %s %s\n",
-						RETstring,returnValueList[keypos].data,additionaltext
-						);
-			#endif
-			myPrintf( myPrintfString );
-		}
-
-		/* take care of proper indention for subsequent error messages */
-		if ( RETstring[0] == 'E' )
-		{
-			++errorCount;
-		}
-		else
-		{
-			if ( errorCount > 0 )
-				myPrintf( "\n" );
-			errorCount = 0;
-		}
-	}
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return RETnumber;
-}
-
-/****************************************************************************/
-/* S T A T I C  P U B L I C */
-/****************************************************************************/
-
-const char* MessageHandling::getErrorCodeMessage(	const returnValue _returnValue
-													)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t keypos = 0;
-	
-	/* 2) Find error/warning/info in list. */
-	while ( returnValueList[keypos].key != TERMINAL_LIST_ELEMENT )
-	{
-		if ( returnValueList[keypos].key == _returnValue )
-			break;
-		else
-			++keypos;
-	}
-
-	if ( returnValueList[keypos].key == TERMINAL_LIST_ELEMENT )
-	{
-		return "Unknown error code";
-	}
-
-	return (returnValueList[keypos].data != 0) ? returnValueList[keypos].data : "No message for this error code";
-    
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return "No message for this error code";
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*****************************************************************************
- *  G L O B A L  M E S S A G E  H A N D L E R                                *
- *****************************************************************************/
-
-
-/** Global message handler for all qpOASES modules.*/
-#if defined(__DSPACE__) || defined(__XPCTARGET__)
-static MessageHandling globalMessageHandler( stdFile,VS_VISIBLE,VS_HIDDEN,VS_HIDDEN );
-#endif
-
-
-/*
- *	g e t G l o b a l M e s s a g e H a n d l e r
- */
-MessageHandling* getGlobalMessageHandler( )
-{
-	#ifndef __DSPACE__
-    #ifndef __XPCTARGET__
-	static MessageHandling globalMessageHandler( stdFile,VS_VISIBLE,VS_VISIBLE,VS_VISIBLE );
-	#endif /* __DSPACE__ */
-    #endif /* __XPCTARGET__ */
-
-	return &globalMessageHandler;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/OQPinterface.cpp b/extlibs/qpOASES-3.2.0/src/OQPinterface.cpp
deleted file mode 100644
index 861b59c..0000000
--- a/extlibs/qpOASES-3.2.0/src/OQPinterface.cpp
+++ /dev/null
@@ -1,683 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/OQPinterface.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Implementation of an interface comprising several utility functions
- *	for solving test problems from the Online QP Benchmark Collection
- *	(This collection is no longer maintained, see 
- *	http://www.qpOASES.org/onlineQP for a backup).
- *
- */
-
-
-#include <qpOASES/extras/OQPinterface.hpp>
-#include <qpOASES/QProblem.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*
- *	r e a d O q p D i m e n s i o n s
- */
-returnValue readOqpDimensions(	const char* path,
-								int_t& nQP, int_t& nV, int_t& nC, int_t& nEC
-								)
-{
-	/* 1) Setup file name where dimensions are stored. */
-	char filename[MAX_STRING_LENGTH];
-	snprintf( filename,MAX_STRING_LENGTH,"%sdims.oqp",path );
-
-	/* 2) Load dimensions from file. */
-	int_t dims[4];
-	if ( readFromFile( dims,4,filename ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-
-	nQP = dims[0];
-	nV  = dims[1];
-	nC  = dims[2];
-	nEC = dims[3];
-
-
-	/* consistency check */
-	if ( ( nQP <= 0 ) || ( nV <= 0 ) || ( nC < 0 ) || ( nEC < 0 ) )
-		return THROWERROR( RET_FILEDATA_INCONSISTENT );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e a d O q p D a t a
- */
-returnValue readOqpData(	const char* path,
-							int_t& nQP, int_t& nV, int_t& nC, int_t& nEC,
-							real_t** H, real_t** g, real_t** A, real_t** lb, real_t** ub, real_t** lbA, real_t** ubA,
-							real_t** xOpt, real_t** yOpt, real_t** objOpt
-							)
-{
-	char filename[MAX_STRING_LENGTH];
-
-	/* consistency check */
-	if ( ( H == 0 ) || ( g == 0 ) || ( lb == 0 ) || ( ub == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Obtain OQP dimensions. */
-	if ( readOqpDimensions( path, nQP,nV,nC,nEC ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-
-
-	/* another consistency check */
-	if ( ( nC > 0 ) && ( ( A == 0 ) || ( lbA == 0 ) || ( ubA == 0 ) ) )
-		return THROWERROR( RET_FILEDATA_INCONSISTENT );
-
-
-	/* 2) Allocate memory and load OQP data: */
-	/* Hessian matrix */
-	*H  = new real_t[nV*nV];
-	snprintf( filename,MAX_STRING_LENGTH,"%sH.oqp",path );
-	if ( readFromFile( *H,nV,nV,filename ) != SUCCESSFUL_RETURN )
-	{
-		delete[] *H;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	/* gradient vector sequence */
-	*g  = new real_t[nQP*nV];
-	snprintf( filename,MAX_STRING_LENGTH,"%sg.oqp",path );
-	if ( readFromFile( *g,nQP,nV,filename ) != SUCCESSFUL_RETURN )
-	{
-		delete[] *g; delete[] *H;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	/* lower bound vector sequence */
-	*lb  = new real_t[nQP*nV];
-	snprintf( filename,MAX_STRING_LENGTH,"%slb.oqp",path );
-	if ( readFromFile( *lb,nQP,nV,filename ) != SUCCESSFUL_RETURN )
-	{
-		delete[] *lb; delete[] *g; delete[] *H;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	/* upper bound vector sequence */
-	*ub  = new real_t[nQP*nV];
-	snprintf( filename,MAX_STRING_LENGTH,"%sub.oqp",path );
-	if ( readFromFile( *ub,nQP,nV,filename ) != SUCCESSFUL_RETURN )
-	{
-		delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	if ( nC > 0 )
-	{
-		/* Constraint matrix */
-		*A   = new real_t[nC*nV];
-		snprintf( filename,MAX_STRING_LENGTH,"%sA.oqp",path );
-		if ( readFromFile( *A,nC,nV,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] *A;
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-
-		/* lower constraints' bound vector sequence */
-		*lbA = new real_t[nQP*nC];
-		snprintf( filename,MAX_STRING_LENGTH,"%slbA.oqp",path );
-		if ( readFromFile( *lbA,nQP,nC,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] *lbA; delete[] *A;
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-
-		/* upper constraints' bound vector sequence */
-		*ubA = new real_t[nQP*nC];
-		snprintf( filename,MAX_STRING_LENGTH,"%subA.oqp",path );
-		if ( readFromFile( *ubA,nQP,nC,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] *ubA; delete[] *lbA; delete[] *A;
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-	}
-	else
-	{
-		*A = 0;
-		*lbA = 0;
-		*ubA = 0;
-	}
-
-	if ( xOpt != 0 )
-	{
-		/* primal solution vector sequence */
-		*xOpt = new real_t[nQP*nV];
-		snprintf( filename,MAX_STRING_LENGTH,"%sx_opt.oqp",path );
-		if ( readFromFile( *xOpt,nQP,nV,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] xOpt;
-			if ( nC > 0 ) { delete[] *ubA; delete[] *lbA; delete[] *A; };
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-	}
-
-	if ( yOpt != 0 )
-	{
-		/* dual solution vector sequence */
-		*yOpt = new real_t[nQP*(nV+nC)];
-		snprintf( filename,MAX_STRING_LENGTH,"%sy_opt.oqp",path );
-		if ( readFromFile( *yOpt,nQP,nV+nC,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] yOpt;
-			if ( xOpt != 0 ) { delete[] xOpt; };
-			if ( nC > 0 ) { delete[] *ubA; delete[] *lbA; delete[] *A; };
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-	}
-
-	if ( objOpt != 0 )
-	{
-		/* dual solution vector sequence */
-		*objOpt = new real_t[nQP];
-		snprintf( filename,MAX_STRING_LENGTH,"%sobj_opt.oqp",path );
-		if ( readFromFile( *objOpt,nQP,1,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] objOpt;
-			if ( yOpt != 0 ) { delete[] yOpt; };
-			if ( xOpt != 0 ) { delete[] xOpt; };
-			if ( nC > 0 ) { delete[] *ubA; delete[] *lbA; delete[] *A; };
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s o l v e O q p B e n c h m a r k
- */
-returnValue solveOqpBenchmark(	int_t nQP, int_t nV, int_t nC, int_t nEC,
-								const real_t* const _H, const real_t* const g, const real_t* const _A,
-								const real_t* const lb, const real_t* const ub,
-								const real_t* const lbA, const real_t* const ubA,
-								BooleanType isSparse, 
-								const Options& options, int_t& nWSR, real_t& maxCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	real_t maxNWSR = 0.0;
-	real_t avgNWSR = 0.0;
-	real_t avgCPUtime = 0.0;
-
-	returnValue returnvalue = solveOqpBenchmark(	nQP,nV,nC,nEC,
-													_H,g,_A,lb,ub,lbA,ubA,
-													isSparse,BT_TRUE,
-													options,nWSR,
-													maxNWSR,avgNWSR,maxCPUtime,avgCPUtime, 
-													maxStationarity,maxFeasibility,maxComplementarity
-													);
-	nWSR = (int_t)maxNWSR;
-
-	return returnvalue;
-}
-
-
-
-/*
- *	s o l v e O q p B e n c h m a r k
- */
-returnValue solveOqpBenchmark(	int_t nQP, int_t nV, int_t nC, int_t nEC,
-								const real_t* const _H, const real_t* const g, const real_t* const _A,
-								const real_t* const lb, const real_t* const ub,
-								const real_t* const lbA, const real_t* const ubA,
-								BooleanType isSparse, BooleanType useHotstarts, 
-								const Options& options, int_t maxAllowedNWSR,
-								real_t& maxNWSR, real_t& avgNWSR, real_t& maxCPUtime, real_t& avgCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	int_t k;
-
-	/* I) SETUP AUXILIARY VARIABLES: */
-	/* 1) Keep nWSR and store current and maximum number of
-	 *    working set recalculations in temporary variables */
-	int_t nWSRcur;
-
-	real_t CPUtimeLimit = maxCPUtime;
-	real_t CPUtimeCur = CPUtimeLimit;
-	maxNWSR = 0.0;
-	avgNWSR = 0.0;
-	maxCPUtime = 0.0;
-	avgCPUtime = 0.0;
-	maxStationarity    = 0.0;
-	maxFeasibility     = 0.0;
-	maxComplementarity = 0.0;
-	real_t stat, feas, cmpl;
-
-	/* 2) Pointers to data of current QP ... */
-	const real_t* gCur;
-	const real_t* lbCur;
-	const real_t* ubCur;
-	const real_t* lbACur;
-	const real_t* ubACur;
-
-	/* 3) Vectors for solution obtained by qpOASES. */
-	real_t* x = new real_t[nV];
-	real_t* y = new real_t[nV+nC];
-	//real_t obj;
-
-	/* 4) Prepare matrix objects */
-	SymmetricMatrix *H; 
-	Matrix *A;
-
-	real_t* H_cpy = new real_t[nV*nV];
-	memcpy( H_cpy,_H, ((uint_t)(nV*nV))*sizeof(real_t) );
-	real_t* A_cpy = new real_t[nC*nV];
-	memcpy( A_cpy,_A, ((uint_t)(nC*nV))*sizeof(real_t) );
-
-	if ( isSparse == BT_TRUE )
-	{
-		SymSparseMat *Hs;
-		H = Hs = new SymSparseMat(nV, nV, nV, H_cpy);
-		A = new SparseMatrixRow(nC, nV, nV, A_cpy);
-		Hs->createDiagInfo();
-		delete[] A_cpy; delete[] H_cpy;
-	}
-	else
-	{
-		H = new SymDenseMat(nV, nV, nV, const_cast<real_t *>(H_cpy));
-		A = new DenseMatrix(nC, nV, nV, const_cast<real_t *>(A_cpy));
-	}
-
-	H->doFreeMemory( );
-	A->doFreeMemory( );
-
-	/* II) SETUP QPROBLEM OBJECT */
-	QProblem qp( nV,nC );
-	qp.setOptions( options );
-	//qp.setPrintLevel( PL_LOW );
-
-	//qp.printOptions();
-
-	/* III) RUN BENCHMARK SEQUENCE: */
-	returnValue returnvalue;
-
-	for( k=0; k<nQP; ++k )
-	{
-		//if ( k%50 == 0 )
-		//	printf( "%d\n",k );
-
-		/* 1) Update pointers to current QP data. */
-		gCur   = &( g[k*nV] );
-		lbCur  = &( lb[k*nV] );
-		ubCur  = &( ub[k*nV] );
-		lbACur = &( lbA[k*nC] );
-		ubACur = &( ubA[k*nC] );
-
-		/* 2) Set nWSR and maximum CPU time. */
-		nWSRcur = maxAllowedNWSR;
-		CPUtimeCur = CPUtimeLimit;
-
-		/* 3) Solve current QP. */
-		if ( ( k == 0 ) || ( useHotstarts == BT_FALSE ) )
-		{
-			/* initialise */
-			returnvalue = qp.init( H,gCur,A,lbCur,ubCur,lbACur,ubACur, nWSRcur,&CPUtimeCur );
-			if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-			{
-				delete A; delete H; delete[] y; delete[] x;
-				return THROWERROR( returnvalue );
-			}
-		}
-		else
-		{
-			/* hotstart */
-			returnvalue = qp.hotstart( gCur,lbCur,ubCur,lbACur,ubACur, nWSRcur,&CPUtimeCur );
-			if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-			{
-				delete A; delete H; delete[] y; delete[] x;
-				return THROWERROR( returnvalue );
-			}
-		}
-
-		/* 4) Obtain solution vectors and objective function value */
-		qp.getPrimalSolution( x );
-		qp.getDualSolution( y );
-		//obj = qp.getObjVal( );
-
-		/* 5) Compute KKT residuals */
-		getKktViolation( nV,nC, _H,gCur,_A,lbCur,ubCur,lbACur,ubACur, x,y, stat,feas,cmpl );
-		
-		/* 6) Update maximum and average values. */
-		if ( ((double)nWSRcur) > maxNWSR )
-			maxNWSR = ((double)nWSRcur);
-		if (stat > maxStationarity) maxStationarity = stat;
-		if (feas > maxFeasibility) maxFeasibility = feas;
-		if (cmpl > maxComplementarity) maxComplementarity = cmpl;
-
-		if ( CPUtimeCur > maxCPUtime )
-			maxCPUtime = CPUtimeCur;
-
-		avgNWSR += ((double)nWSRcur);
-		avgCPUtime += CPUtimeCur;
-	}
-	avgNWSR /= ((double)nQP);
-	avgCPUtime /= ((double)nQP);
-
-	delete A; delete H; delete[] y; delete[] x;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s o l v e O q p B e n c h m a r k
- */
-returnValue solveOqpBenchmark(	int_t nQP, int_t nV,
-								const real_t* const _H, const real_t* const g,
-								const real_t* const lb, const real_t* const ub,
-								BooleanType isSparse, 
-								const Options& options, int_t& nWSR, real_t& maxCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	real_t maxNWSR = 0.0;
-	real_t avgNWSR = 0.0;
-	real_t avgCPUtime = 0.0;
-
-	returnValue returnvalue = solveOqpBenchmark(	nQP,nV,
-													_H,g,lb,ub,
-													isSparse,BT_TRUE,
-													options,nWSR,
-													maxNWSR,avgNWSR,maxCPUtime,avgCPUtime, 
-													maxStationarity,maxFeasibility,maxComplementarity
-													);
-	nWSR = (int_t)maxNWSR;
-
-	return returnvalue;
-}
-
-
-/*
- *	s o l v e O q p B e n c h m a r k
- */
-returnValue solveOqpBenchmark(	int_t nQP, int_t nV,
-								const real_t* const _H, const real_t* const g,
-								const real_t* const lb, const real_t* const ub,
-								BooleanType isSparse, BooleanType useHotstarts, 
-								const Options& options, int_t maxAllowedNWSR,
-								real_t& maxNWSR, real_t& avgNWSR, real_t& maxCPUtime, real_t& avgCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	int_t k;
-
-	/* I) SETUP AUXILIARY VARIABLES: */
-	/* 1) Keep nWSR and store current and maximum number of
-	 *    working set recalculations in temporary variables */
-	int_t nWSRcur;
-
-	real_t CPUtimeLimit = maxCPUtime;
-	real_t CPUtimeCur = CPUtimeLimit;
-	real_t stat, feas, cmpl;
-	maxNWSR = 0;
-	avgNWSR = 0;
-	maxCPUtime = 0.0;
-	avgCPUtime = 0.0;
-	maxStationarity = 0.0;
-	maxFeasibility = 0.0;
-	maxComplementarity = 0.0;
-
-	/* 2) Pointers to data of current QP ... */
-	const real_t* gCur;
-	const real_t* lbCur;
-	const real_t* ubCur;
-
-	/* 3) Vectors for solution obtained by qpOASES. */
-	real_t* x = new real_t[nV];
-	real_t* y = new real_t[nV];
-	//real_t  obj;
-
-	/* 4) Prepare matrix objects */
-	SymmetricMatrix *H; 
-	real_t* H_cpy = new real_t[nV*nV];
-	memcpy( H_cpy,_H, ((uint_t)(nV*nV))*sizeof(real_t) );
-
-	if ( isSparse == BT_TRUE )
-	{
-		SymSparseMat *Hs;
-		H = Hs = new SymSparseMat(nV, nV, nV, H_cpy);
-		Hs->createDiagInfo();
-		delete[] H_cpy;
-	}
-	else
-	{
-		H = new SymDenseMat(nV, nV, nV, const_cast<real_t *>(H_cpy));
-	}
-	
-	H->doFreeMemory( );
-
-	/* II) SETUP QPROBLEM OBJECT */
-	QProblemB qp( nV );
-	qp.setOptions( options );
-	//qp.setPrintLevel( PL_LOW );
-
-
-	/* III) RUN BENCHMARK SEQUENCE: */
-	returnValue returnvalue;
-
-	for( k=0; k<nQP; ++k )
-	{
-		//if ( k%50 == 0 )
-		//	printf( "%d\n",k );
-
-		/* 1) Update pointers to current QP data. */
-		gCur   = &( g[k*nV] );
-		lbCur  = &( lb[k*nV] );
-		ubCur  = &( ub[k*nV] );
-
-		/* 2) Set nWSR and maximum CPU time. */
-		nWSRcur = maxAllowedNWSR;
-		CPUtimeCur = CPUtimeLimit;
-
-		/* 3) Solve current QP. */
-		if ( ( k == 0 ) || ( useHotstarts == BT_FALSE ) )
-		{
-			/* initialise */
-			returnvalue = qp.init( H,gCur,lbCur,ubCur, nWSRcur,&CPUtimeCur );
-			if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-			{
-				delete H; delete[] y; delete[] x;
-				return THROWERROR( returnvalue );
-			}
-		}
-		else
-		{
-			/* hotstart */
-			returnvalue = qp.hotstart( gCur,lbCur,ubCur, nWSRcur,&CPUtimeCur );
-			if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-			{
-				delete H; delete[] y; delete[] x;
-				return THROWERROR( returnvalue );
-			}
-		}
-
-		/* 4) Obtain solution vectors and objective function value ... */
-		qp.getPrimalSolution( x );
-		qp.getDualSolution( y );
-		//obj = qp.getObjVal( );
-
-		/* 5) Compute KKT residuals */
-		getKktViolation( nV, _H,gCur,lbCur,ubCur, x,y, stat,feas,cmpl );
-
-		/* 6) update maximum values. */
-		if ( nWSRcur > maxNWSR )
-			maxNWSR = nWSRcur;
-		if (stat > maxStationarity) maxStationarity = stat;
-		if (feas > maxFeasibility) maxFeasibility = feas;
-		if (cmpl > maxComplementarity) maxComplementarity = cmpl;
-
-		if ( CPUtimeCur > maxCPUtime )
-			maxCPUtime = CPUtimeCur;
-
-		avgNWSR += nWSRcur;
-		avgCPUtime += CPUtimeCur;
-	}
-	avgNWSR /= nQP;
-	avgCPUtime /= ((double)nQP);
-
-	delete H; delete[] y; delete[] x;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r u n O q p B e n c h m a r k
- */
-returnValue runOqpBenchmark(	const char* path, BooleanType isSparse, const Options& options,
-								int_t& nWSR, real_t& maxCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	real_t maxNWSR = 0.0;
-	real_t avgNWSR = 0.0;
-	real_t avgCPUtime = 0.0;
-
-	returnValue returnvalue = runOqpBenchmark(	path,isSparse,BT_TRUE,
-												options,nWSR,
-												maxNWSR,avgNWSR,maxCPUtime,avgCPUtime, 
-												maxStationarity,maxFeasibility,maxComplementarity
-												);
-	nWSR = (int_t)maxNWSR;
-
-	return returnvalue;
-}
-
-
-/*
- *	r u n O q p B e n c h m a r k
- */
-returnValue runOqpBenchmark(	const char* path, BooleanType isSparse, BooleanType useHotstarts, 
-								const Options& options, int_t maxAllowedNWSR,
-								real_t& maxNWSR, real_t& avgNWSR, real_t& maxCPUtime, real_t& avgCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	int_t nQP=0, nV=0, nC=0, nEC=0;
-
-	real_t *H=0, *g=0, *A=0, *lb=0, *ub=0, *lbA=0, *ubA=0;
-
-
-	returnValue returnvalue;
-
-	/* I) SETUP BENCHMARK: */
-	/* 1) Obtain QP sequence dimensions. */
-	if ( readOqpDimensions( path, nQP,nV,nC,nEC ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_BENCHMARK_ABORTED );
-
-	/* 2) Read OQP benchmark data. */
-	if ( readOqpData(	path,
-						nQP,nV,nC,nEC,
-						&H,&g,&A,&lb,&ub,&lbA,&ubA,
-						0,0,0
-						) != SUCCESSFUL_RETURN )
-	{
-		return THROWERROR( RET_UNABLE_TO_READ_BENCHMARK );
-	}
-
-	// normaliseConstraints( nV,nC,A,lbA,ubA ); //only works when nP==1
-
-	/* II) SOLVE BENCHMARK */
-	if ( nC > 0 )
-	{
-		returnvalue = solveOqpBenchmark(	nQP,nV,nC,nEC,
-											H,g,A,lb,ub,lbA,ubA,
-											isSparse,useHotstarts,
-											options,maxAllowedNWSR,
-											maxNWSR,avgNWSR,maxCPUtime,avgCPUtime,
-											maxStationarity,maxFeasibility,maxComplementarity
-											);
-
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			if ( H != 0 )   delete[] H;
-			if ( g != 0 )   delete[] g;
-			if ( A != 0 )   delete[] A;
-			if ( lb != 0 )  delete[] lb;
-			if ( ub != 0 )  delete[] ub;
-			if ( lbA != 0 ) delete[] lbA;
-			if ( ubA != 0 ) delete[] ubA;
-			return THROWERROR( returnvalue );
-		}
-	}
-	else
-	{
-		returnvalue = solveOqpBenchmark(	nQP,nV,
-											H,g,lb,ub,
-											isSparse,useHotstarts,
-											options,maxAllowedNWSR,
-											maxNWSR,avgNWSR,maxCPUtime,avgCPUtime,
-											maxStationarity,maxFeasibility,maxComplementarity
-											);
-
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			if ( H != 0 )   delete[] H;
-			if ( g != 0 )   delete[] g;
-			if ( A != 0 )   delete[] A;
-			if ( lb != 0 )  delete[] lb;
-			if ( ub != 0 )  delete[] ub;
-			return THROWERROR( returnvalue );
-		}
-	}
-
-	if ( H != 0 )   delete[] H;
-	if ( g != 0 )   delete[] g;
-	if ( A != 0 )   delete[] A;
-	if ( lb != 0 )  delete[] lb;
-	if ( ub != 0 )  delete[] ub;
-	if ( lbA != 0 ) delete[] lbA;
-	if ( ubA != 0 ) delete[] ubA;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/Options.cpp b/extlibs/qpOASES-3.2.0/src/Options.cpp
deleted file mode 100644
index cde9f37..0000000
--- a/extlibs/qpOASES-3.2.0/src/Options.cpp
+++ /dev/null
@@ -1,563 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Options.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the Options class designed to manage working sets of
- *	constraints and bounds within a QProblem.
- */
-
-
-#include <qpOASES/Options.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	O p t i o n s
- */
-Options::Options( )
-{
-	setToDefault( );
-}
-
-
-/*
- *	O p t i o n s
- */
-Options::Options( const Options& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ O p t i o n s
- */
-Options::~Options( )
-{
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Options& Options::operator=( const Options& rhs )
-{
-	if ( this != &rhs )
-	{
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-
-/*
- *	s e t T o D e f a u l t
- */
-returnValue Options::setToDefault( )
-{
-	printLevel = PL_MEDIUM;
-	#ifdef __DEBUG__
-	printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	printLevel = PL_NONE;
-	#endif
-
-	enableRamping                 =  BT_TRUE;
-	enableFarBounds               =  BT_TRUE;
-	enableFlippingBounds          =  BT_TRUE;
-	enableRegularisation          =  BT_FALSE;
-	enableFullLITests             =  BT_FALSE;
-	enableNZCTests                =  BT_TRUE;
-	enableDriftCorrection         =  1;
-	enableCholeskyRefactorisation =  0;
-	enableEqualities              =  BT_FALSE;
-
-	#ifdef __USE_SINGLE_PRECISION__
-	terminationTolerance          =  1.0e2 * EPS;
-	boundTolerance                =  1.0e2 * EPS;
-	#else
-	terminationTolerance          =  5.0e6 * EPS;
-	boundTolerance                =  1.0e6 * EPS;
-	#endif
-	boundRelaxation               =  1.0e4;
-	#ifdef __USE_SINGLE_PRECISION__
-	epsNum                        = -1.0e2 * EPS;
-	epsDen                        =  1.0e2 * EPS;
-	#else
-	epsNum                        = -1.0e3 * EPS;
-	epsDen                        =  1.0e3 * EPS;
-	#endif
-	maxPrimalJump                 =  1.0e8;
-	maxDualJump                   =  1.0e8;
-
-	initialRamping                =  0.5;
-	finalRamping                  =  1.0;
-	initialFarBounds              =  1.0e6;
-	growFarBounds                 =  1.0e3;
- 	initialStatusBounds           =  ST_LOWER;
-	#ifdef __USE_SINGLE_PRECISION__
-	epsFlipping                   =  5.0e1 * EPS;
-	#else
-	epsFlipping                   =  1.0e3 * EPS;
-	#endif
-	numRegularisationSteps        =  0;
-	#ifdef __USE_SINGLE_PRECISION__
-	epsRegularisation             =  2.0e1 * EPS;
-	numRefinementSteps            =  2;
-	#else
-	epsRegularisation             =  1.0e3 * EPS;
-	numRefinementSteps            =  1;
-	#endif
-	epsIterRef                    =  1.0e2 * EPS;
-	#ifdef __USE_SINGLE_PRECISION__
-	epsLITests                    =  5.0e1 * EPS;
-	epsNZCTests                   =  1.0e2 * EPS;
-	#else
-	epsLITests                    =  1.0e5 * EPS;
-	epsNZCTests                   =  3.0e3 * EPS;
-	#endif
-
-	enableDropInfeasibles         =  BT_FALSE;
-    dropBoundPriority             =  1;
-    dropEqConPriority             =  1;
-    dropIneqConPriority           =  1;
-
-    enableInertiaCorrection       =  BT_TRUE;
-    rcondSMin                     =  1.0e-14;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t T o R e l i a b l e
- */
-returnValue Options::setToReliable( )
-{
-	setToDefault( );
-
-	enableFullLITests             =  BT_TRUE;
-	enableCholeskyRefactorisation =  1;
-
-	#ifdef __USE_SINGLE_PRECISION__
-	numRefinementSteps            =  3;
-	#else
-	numRefinementSteps            =  2;
-	#endif
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t T o M P C
- */
-returnValue Options::setToMPC( )
-{
-	setToDefault( );
-
-	enableRamping                 =  BT_FALSE;
-	enableFarBounds               =  BT_TRUE;
-	enableFlippingBounds          =  BT_FALSE;
-	enableRegularisation          =  BT_TRUE;
-	enableNZCTests                =  BT_FALSE;
-	enableDriftCorrection         =  0;
-	enableEqualities              =  BT_TRUE;
-
-	#ifdef __USE_SINGLE_PRECISION__
-	terminationTolerance          =  1.0e3 * EPS;
-	#else
-	terminationTolerance          =  1.0e9 * EPS;
-	#endif
-
-	initialStatusBounds           =  ST_INACTIVE;
-	numRegularisationSteps        =  1;
-	#ifdef __USE_SINGLE_PRECISION__
-	numRefinementSteps            =  2;
-	#else
-	numRefinementSteps            =  0;
-	#endif
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t T o F a s t
- */
-returnValue Options::setToFast( )
-{
-	return setToMPC( );
-}
-
-
-
-/*
- *	e n s u r e C o n s i s t e n c y
- */
-returnValue Options::ensureConsistency( )
-{
-	BooleanType needToAdjust = BT_FALSE;
-
-	/* flipping bounds require far bounds */
-    /* (ckirches) Removed this as per filter's trust region
-	if( enableFlippingBounds == BT_TRUE )
-		enableFarBounds = BT_TRUE;
-    */
-
-	if( enableDriftCorrection < 0 )
-	{
-		enableDriftCorrection = 0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if( enableCholeskyRefactorisation < 0 )
-	{
-		enableCholeskyRefactorisation = 0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( terminationTolerance <= 0.0 )
-	{
-		terminationTolerance = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsIterRef <= 0.0 )
-	{
-		epsIterRef = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsRegularisation <= 0.0 )
-	{
-		epsRegularisation = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( boundTolerance <= 0.0 )
-	{
-		boundTolerance = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( boundRelaxation <= 0.0 )
-	{
-		boundRelaxation = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( maxPrimalJump <= 0.0 )
-	{
-		maxPrimalJump = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( maxDualJump <= 0.0 )
-	{
-		maxDualJump = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-
-	if ( initialRamping < 0.0 )
-	{
-		initialRamping = 0.0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( finalRamping < 0.0 )
-	{
-		finalRamping = 0.0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( initialFarBounds <= boundRelaxation )
-	{
-		initialFarBounds = boundRelaxation+EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( growFarBounds < 1.1 )
-	{
-		growFarBounds = 1.1;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsFlipping <= 0.0 )
-	{
-		epsFlipping = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( numRegularisationSteps < 0 )
-	{
-		numRegularisationSteps = 0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsRegularisation < 0.0 )
-	{
-		epsRegularisation = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( numRefinementSteps < 0 )
-	{
-		numRefinementSteps = 0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsIterRef < 0.0 )
-	{
-		epsIterRef = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsLITests < 0.0 )
-	{
-		epsLITests = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsNZCTests < 0.0 )
-	{
-		epsNZCTests = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( needToAdjust == BT_TRUE)
-		return THROWWARNING( RET_OPTIONS_ADJUSTED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue Options::print( ) const
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	char myPrintfString[MAX_STRING_LENGTH];
-	char info[MAX_STRING_LENGTH];
-
-	myPrintf( "\n###################   qpOASES  --  QP OPTIONS   ##################\n" );
-	myPrintf( "\n" );
-
-	convertPrintLevelToString( printLevel,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"printLevel                     =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	myPrintf( "\n" );
-
-	convertBooleanTypeToString( enableRamping,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableRamping                  =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableFarBounds,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableFarBounds                =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableFlippingBounds,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableFlippingBounds           =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableRegularisation,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableRegularisation           =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableFullLITests,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableFullLITests              =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableNZCTests,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableNZCTests                 =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableDriftCorrection          =  %d\n",(int)enableDriftCorrection );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableCholeskyRefactorisation  =  %d\n",(int)enableCholeskyRefactorisation );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableEqualities,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableEqualities               =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableInertiaCorrection,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableInertiaCorrection        =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"rcondSMin                      =  %e\n",rcondSMin );
-	myPrintf( myPrintfString );
-
-	myPrintf( "\n" );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"terminationTolerance           =  %e\n",terminationTolerance );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"boundTolerance                 =  %e\n",boundTolerance );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"boundRelaxation                =  %e\n",boundRelaxation );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsNum                         =  %e\n",epsNum );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsDen                         =  %e\n",epsDen );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"maxPrimalJump                  =  %e\n",maxPrimalJump );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"maxDualJump                    =  %e\n",maxDualJump );
-	myPrintf( myPrintfString );
-
-	myPrintf( "\n" );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"initialRamping                 =  %e\n",initialRamping );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"finalRamping                   =  %e\n",finalRamping );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"initialFarBounds               =  %e\n",initialFarBounds );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"growFarBounds                  =  %e\n",growFarBounds );
-	myPrintf( myPrintfString );
-
-	convertSubjectToStatusToString( initialStatusBounds,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"initialStatusBounds            =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsFlipping                    =  %e\n",epsFlipping );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"numRegularisationSteps         =  %d\n",(int)numRegularisationSteps );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsRegularisation              =  %e\n",epsRegularisation );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"numRefinementSteps             =  %d\n",(int)numRefinementSteps );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsIterRef                     =  %e\n",epsIterRef );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsLITests                     =  %e\n",epsLITests );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsNZCTests                    =  %e\n",epsNZCTests );
-	myPrintf( myPrintfString );
-
-	myPrintf( "\n\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c o p y
- */
-returnValue Options::copy(	const Options& rhs
-							)
-{
-	printLevel             = rhs.printLevel;
-
-	enableRamping                 =  rhs.enableRamping;
-	enableFarBounds               =  rhs.enableFarBounds;
-	enableFlippingBounds          =  rhs.enableFlippingBounds;
-	enableRegularisation          =  rhs.enableRegularisation;
-	enableFullLITests             =  rhs.enableFullLITests;
-	enableNZCTests                =  rhs.enableNZCTests;
-	enableDriftCorrection         =  rhs.enableDriftCorrection;
-	enableCholeskyRefactorisation =  rhs.enableCholeskyRefactorisation;
-	enableEqualities              =  rhs.enableEqualities;
-
-	terminationTolerance          =  rhs.terminationTolerance;
-	boundTolerance                =  rhs.boundTolerance;
-	boundRelaxation               =  rhs.boundRelaxation;
-	epsNum                        =  rhs.epsNum;
-	epsDen                        =  rhs.epsDen;
-	maxPrimalJump                 =  rhs.maxPrimalJump;
-	maxDualJump                   =  rhs.maxDualJump;
-
-	initialRamping                =  rhs.initialRamping;
-	finalRamping                  =  rhs.finalRamping;
-	initialFarBounds              =  rhs.initialFarBounds;
-	growFarBounds                 =  rhs.growFarBounds;
- 	initialStatusBounds           =  rhs.initialStatusBounds;
-	epsFlipping                   =  rhs.epsFlipping;
-	numRegularisationSteps        =  rhs.numRegularisationSteps;
-	epsRegularisation             =  rhs.epsRegularisation;
-	numRefinementSteps            =  rhs.numRefinementSteps;
-	epsIterRef                    =  rhs.epsIterRef;
-	epsLITests                    =  rhs.epsLITests;
-	epsNZCTests                   =  rhs.epsNZCTests;
-
-	enableInertiaCorrection       =  rhs.enableInertiaCorrection;
-	rcondSMin                     =  rhs.rcondSMin;
-
-	enableDropInfeasibles         =  rhs.enableDropInfeasibles;
-    dropBoundPriority             =  rhs.dropBoundPriority;
-    dropEqConPriority             =  rhs.dropEqConPriority;
-    dropIneqConPriority           =  rhs.dropIneqConPriority;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/QProblem.cpp b/extlibs/qpOASES-3.2.0/src/QProblem.cpp
deleted file mode 100644
index a8f199a..0000000
--- a/extlibs/qpOASES-3.2.0/src/QProblem.cpp
+++ /dev/null
@@ -1,6433 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/QProblem.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the QProblem class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming.
- */
-
-
-#include <qpOASES/QProblem.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	Q P r o b l e m
- */
-QProblem::QProblem( ) : QProblemB( )
-{
-	freeConstraintMatrix = BT_FALSE;
-	A = 0;
-
-	lbA = 0;
-	ubA = 0;
-
-	sizeT = 0;
-	T = 0;
-	Q = 0;
-
-	Ax = 0;
-	Ax_l = 0;
-	Ax_u = 0;
-
-	constraintProduct = 0;
-
-	tempA = 0;
-	ZFR_delta_xFRz = 0;
-	delta_xFRy = 0;
-	delta_xFRz = 0;
-	tempB = 0;
-	delta_yAC_TMP = 0;
-}
-
-
-/*
- *	Q P r o b l e m
- */
-QProblem::QProblem( int_t _nV, int_t _nC, HessianType _hessianType ) : QProblemB( _nV,_hessianType )
-{
-	int_t i;
-
-	/* consistency checks */
-	if ( _nV <= 0 )
-	{
-		_nV = 1;
-		THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( _nC < 0 )
-	{
-		_nC = 0;
-		THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( _nC > 0 )
-	{
-		freeConstraintMatrix = BT_FALSE;
-		A = 0;
-
-		lbA = new real_t[_nC];
-		for( i=0; i<_nC; ++i ) lbA[i] = 0.0;
-
-		ubA = new real_t[_nC];
-		for( i=0; i<_nC; ++i ) ubA[i] = 0.0;
-	}
-	else
-	{
-		/* prevent segmentation faults in case nC == 0
-		 * (avoiding checks for A!=0 around all calls to A->... */
-		freeConstraintMatrix = BT_TRUE;
-		A = new DenseMatrix( );
-
-		lbA = 0;
-		ubA = 0;
-	}
-
-	constraints.init( _nC );
-
-	delete[] y; /* y of no constraints version too short! */
-	y = new real_t[_nV+_nC];
-	for( i=0; i<_nV+_nC; ++i ) y[i] = 0.0;
-
-	sizeT = getMin( _nV,_nC );
-	T = new real_t[sizeT*sizeT];
-	Q = new real_t[_nV*_nV];
-
-	if ( _nC > 0 )
-	{
-		Ax = new real_t[_nC];
-		Ax_l = new real_t[_nC];
-		Ax_u = new real_t[_nC];
-	}
-	else
-	{
-		Ax = 0;
-		Ax_l = 0;
-		Ax_u = 0;
-	}
-
-	constraintProduct = 0;
-
-	tempA = new real_t[_nV];			/* nFR */
-	ZFR_delta_xFRz = new real_t[_nV];	/* nFR */
-	delta_xFRz = new real_t[_nV];		/* nZ */
-
-	if ( _nC > 0 )
-	{
-		tempB = new real_t[_nC];			/* nAC */
-		delta_xFRy = new real_t[_nC];		/* nAC */
-		delta_yAC_TMP = new real_t[_nC];   /* nAC */
-	}
-	else
-	{
-		tempB = 0;
-		delta_xFRy = 0;
-		delta_yAC_TMP = 0;
-	}
-
-	flipper.init( (uint_t)_nV,(uint_t)_nC );
-}
-
-
-/*
- *	Q P r o b l e m
- */
-QProblem::QProblem( const QProblem& rhs ) : QProblemB( rhs )
-{
-	freeConstraintMatrix = BT_FALSE;
-	A = 0;
-
-	copy( rhs );
-}
-
-
-/*
- *	~ Q P r o b l e m
- */
-QProblem::~QProblem( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-QProblem& QProblem::operator=( const QProblem& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		QProblemB::operator=( rhs );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-/*
- *	r e s e t
- */
-returnValue QProblem::reset( )
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-
-	/* 1) Reset bounds, Cholesky decomposition and status flags. */
-	if ( QProblemB::reset( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_RESET_FAILED );
-
-	/* 2) Reset constraints. */
-	constraints.init( nC );
-
-	/* 3) Reset TQ factorisation. */
-	if ( T!=0 )
-		for( i=0; i<sizeT*sizeT; ++i )
-			T[i] = 0.0;
-
-	if ( Q!=0 )
-		for( i=0; i<nV*nV; ++i )
-			Q[i] = 0.0;
-
-	/* 4) Reset constraint product pointer. */
-	constraintProduct = 0;
-
-	/* 5) Reset flipper object */
-	flipper.init( (uint_t)nV,(uint_t)nC );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblem::init(	SymmetricMatrix *_H, const real_t* const _g, Matrix *_A,
-							const real_t* const _lb, const real_t* const _ub,
-							const real_t* const _lbA, const real_t* const _ubA,
-							int_t& nWSR, real_t* const cputime,
-							const real_t* const xOpt, const real_t* const yOpt,
-							const Bounds* const guessedBounds, const Constraints* const guessedConstraints,
-							const real_t* const _R
-							)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	if ( guessedConstraints != 0 )
-	{
-		for( i=0; i<nC; ++i )
-			if ( guessedConstraints->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* exclude these possibilities in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( _R != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data. */
-	if ( setupQPdata( _H,_g,_A,_lb,_ub,_lbA,_ubA ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* 3) Call to main initialisation routine. */
-	return solveInitialQP( xOpt,yOpt,guessedBounds,guessedConstraints,_R, nWSR,cputime );
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblem::init(	const real_t* const _H, const real_t* const _g, const real_t* const _A,
-							const real_t* const _lb, const real_t* const _ub,
-							const real_t* const _lbA, const real_t* const _ubA,
-							int_t& nWSR, real_t* const cputime,
-							const real_t* const xOpt, const real_t* const yOpt,
-							const Bounds* const guessedBounds, const Constraints* const guessedConstraints,
-							const real_t* const _R
-							)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	if ( guessedConstraints != 0 )
-	{
-		for( i=0; i<nC; ++i )
-			if ( guessedConstraints->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* exclude these possibilities in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( _R != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data. */
-	if ( setupQPdata( _H,_g,_A,_lb,_ub,_lbA,_ubA ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 3) Call to main initialisation routine. */
-	return solveInitialQP( xOpt,yOpt,guessedBounds,guessedConstraints,_R, nWSR,cputime );
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblem::init(	const char* const H_file, const char* const g_file, const char* const A_file,
-							const char* const lb_file, const char* const ub_file,
-							const char* const lbA_file, const char* const ubA_file,
-							int_t& nWSR, real_t* const cputime,
-							const real_t* const xOpt, const real_t* const yOpt,
-							const Bounds* const guessedBounds, const Constraints* const guessedConstraints,
-							const char* const R_file
-							)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	if ( guessedConstraints != 0 )
-	{
-		for( i=0; i<nC; ++i )
-			if ( guessedConstraints->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* exclude these possibilities in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( R_file != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data from files. */
-	if ( setupQPdataFromFile( H_file,g_file,A_file,lb_file,ub_file,lbA_file,ubA_file ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-
-	if ( R_file == 0 )
-	{
-		/* 3) Call to main initialisation routine. */
-		return solveInitialQP( xOpt,yOpt,guessedBounds,guessedConstraints,0, nWSR,cputime );
-	}
-	else
-	{
-		/* Also read Cholesky factor from file and store it directly into R [thus... */
-		returnValue returnvalue = readFromFile( R, nV,nV, R_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-			return THROWWARNING( returnvalue );
-
-		/* 3) Call to main initialisation routine. ...passing R here!] */
-		return solveInitialQP( xOpt,yOpt,guessedBounds,guessedConstraints,R, nWSR,cputime );
-	}
-}
-
-
-
-/*
- *	h o t s t a r t
- */
-returnValue QProblem::hotstart(	const real_t* const g_new,
-								const real_t* const lb_new, const real_t* const ub_new,
-								const real_t* const lbA_new, const real_t* const ubA_new,
-								int_t& nWSR, real_t* const cputime,
-								const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-								)
-{
-	int_t i, nActiveFar;
-	int_t nV = getNV ();
-	int_t nC = getNC ();
-	real_t starttime = 0.0;
-	real_t auxTime = 0.0;
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-
-	/* Possibly update working sets according to guesses for working sets of bounds and constraints. */
-	if ( ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) )
-	{
-		if ( cputime != 0 )
-			starttime = getCPUtime( );
-
-		const Bounds*      actualGuessedBounds      = ( guessedBounds != 0 )      ? guessedBounds      : &bounds;
-		const Constraints* actualGuessedConstraints = ( guessedConstraints != 0 ) ? guessedConstraints : &constraints;
-
-		if ( setupAuxiliaryQP( actualGuessedBounds,actualGuessedConstraints ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		status = QPS_AUXILIARYQPSOLVED;
-
-		/* Allow only remaining CPU time for usual hotstart. */
-		if ( cputime != 0 )
-		{
-			auxTime = getCPUtime( ) - starttime;
-			*cputime -= auxTime;
-		}
-	}
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	/* Simple check for consistency of bounds and constraints. */
-	if ( areBoundsConsistent(lb_new, ub_new, lbA_new, ubA_new) != SUCCESSFUL_RETURN )
-		return setInfeasibilityFlag(returnvalue,BT_TRUE);
-
-	++count;
-
-	int_t nWSR_max = nWSR;
-	int_t nWSR_performed = 0;
-
-	real_t cputime_remaining = INFTY, *pcputime_rem;
-	real_t cputime_needed = 0.0;
-
-	real_t farbound = options.initialFarBounds;
-
-	/* writeQpDataIntoMatFile( "qpData.mat" ); */
-	/* writeQpWorkspaceIntoMatFile( "qpWorkspace.mat" ); */
-
-	if ( haveCholesky == BT_FALSE )
-	{
-		returnvalue = setupInitialCholesky( );
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return THROWERROR(returnvalue);
-	}
-
-	BooleanType isFirstCall = BT_TRUE;
-
-	if ( options.enableFarBounds == BT_FALSE )
-	{
-		/* Automatically call standard solveQP if regularisation is not active. */
-		returnvalue = solveRegularisedQP(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-											nWSR,cputime,0,
-											isFirstCall
-											);
-	}
-	else
-	{
-		real_t *ub_new_far = new real_t[nV];
-		real_t *lb_new_far = new real_t[nV];
-		real_t *ubA_new_far = new real_t[nC];
-		real_t *lbA_new_far = new real_t[nC];
-
-		/* possibly extend initial far bounds to largest bound/constraint data */
-		if (ub_new)
-			for (i = 0; i < nV; i++)
-				if ((ub_new[i] < INFTY) && (ub_new[i] > farbound)) farbound = ub_new[i];
-		if (lb_new)
-			for (i = 0; i < nV; i++)
-				if ((lb_new[i] > -INFTY) && (lb_new[i] < -farbound)) farbound = -lb_new[i];
-		if (ubA_new)
-			for (i = 0; i < nC; i++)
-				if ((ubA_new[i] < INFTY) && (ubA_new[i] > farbound)) farbound = ubA_new[i];
-		if (lbA_new)
-			for (i = 0; i < nC; i++)
-				if ((lbA_new[i] > -INFTY) && (lbA_new[i] < -farbound)) farbound = -lbA_new[i];
-
-		updateFarBounds(	farbound,nV+nC,
-							lb_new,lb_new_far, ub_new,ub_new_far,
-							lbA_new,lbA_new_far, ubA_new,ubA_new_far
-							);
-
-		for ( ;; )
-		{
-			nWSR = nWSR_max;
-			if ( cputime != 0 )
-			{
-				cputime_remaining = *cputime - cputime_needed;
-				pcputime_rem = &cputime_remaining;
-			}
-			else
-				pcputime_rem = 0;
-
-			/* Automatically call standard solveQP if regularisation is not active. */
-			returnvalue = solveRegularisedQP(	g_new,lb_new_far,ub_new_far,lbA_new_far,ubA_new_far,
-												nWSR,pcputime_rem,nWSR_performed,
-												isFirstCall
-												);
-
-			nWSR_performed  = nWSR;
-			cputime_needed += cputime_remaining;
-			isFirstCall     = BT_FALSE;
-
-			/* Check for active far-bounds and move them away */
-			nActiveFar = 0;
-			farbound *= options.growFarBounds;
-
-			if ( infeasible == BT_TRUE )
-			{
-				if ( farbound >= INFTY )
-				{
-					returnvalue = RET_HOTSTART_STOPPED_INFEASIBILITY;
-					break; // goto farewell;
-				}
-
-				updateFarBounds(	farbound,nV+nC,
-									lb_new,lb_new_far, ub_new,ub_new_far,
-									lbA_new,lbA_new_far, ubA_new,ubA_new_far
-									);
-			}
-			else if ( status == QPS_SOLVED )
-			{
-				real_t tol = farbound/options.growFarBounds * options.boundTolerance;
-
-				for ( i=0; i<nV; ++i )
-				{
-					if ( ( ( lb_new == 0 ) || ( lb_new_far[i] > lb_new[i] ) ) && ( getAbs ( lb_new_far[i] - x[i] ) < tol ) )
-						++nActiveFar;
-					if ( ( ( ub_new == 0 ) || ( ub_new_far[i] < ub_new[i] ) ) && ( getAbs ( ub_new_far[i] - x[i] ) < tol ) )
-						++nActiveFar;
-				}
-				for ( i=0; i<nC; ++i )
-				{
-					if ( ( ( lbA_new == 0 ) || ( lbA_new_far[i] > lbA_new[i] ) ) && ( getAbs ( lbA_new_far[i] - Ax[i] ) < tol ) )
-						++nActiveFar;
-					if ( ( ( ubA_new == 0 ) || ( ubA_new_far[i] < ubA_new[i] ) ) && ( getAbs ( ubA_new_far[i] - Ax[i] ) < tol ) )
-						++nActiveFar;
-				}
-
-				if ( nActiveFar == 0 )
-					break;
-
-				status = QPS_HOMOTOPYQPSOLVED;
-
-				if ( farbound >= INFTY )
-				{
-					unbounded = BT_TRUE;
-					returnvalue = RET_HOTSTART_STOPPED_UNBOUNDEDNESS;
-					goto farewell;
-				}
-
-				updateFarBounds(	farbound,nV+nC,
-									lb_new,lb_new_far, ub_new,ub_new_far,
-									lbA_new,lbA_new_far, ubA_new,ubA_new_far
-									);
-			}
-			else
-			{
-				/* some other error when solving QP */
-				break;
-			}
-
-			/* advance ramp offset to avoid Ramping cycles */
-			rampOffset++;
-		}
-
-		farewell:
-			/* add time to setup auxiliary QP */
-			if ( cputime != 0 )
-				*cputime = cputime_needed + auxTime;
-			delete[] lbA_new_far; delete[] ubA_new_far;
-			delete[] lb_new_far; delete[] ub_new_far;
-	}
-
-	return ( returnvalue != SUCCESSFUL_RETURN ) ? THROWERROR( returnvalue ) : returnvalue;
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue QProblem::hotstart(	const char* const g_file,
-								const char* const lb_file, const char* const ub_file,
-								const char* const lbA_file, const char* const ubA_file,
-								int_t& nWSR, real_t* const cputime,
-								const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-								)
-{
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* consistency check */
-	if ( g_file == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Allocate memory (if bounds exist). */
-	real_t* g_new   = new real_t[nV];
-	real_t* lb_new  = ( lb_file != 0 )  ? new real_t[nV] : 0;
-	real_t* ub_new  = ( ub_file != 0 )  ? new real_t[nV] : 0;
-	real_t* lbA_new = ( lbA_file != 0 ) ? new real_t[nC] : 0;
-	real_t* ubA_new = ( ubA_file != 0 ) ? new real_t[nC] : 0;
-
-
-	/* 2) Load new QP vectors from file. */
-	returnValue returnvalue;
-	returnvalue = loadQPvectorsFromFile(	g_file,lb_file,ub_file,lbA_file,ubA_file,
-											g_new,lb_new,ub_new,lbA_new,ubA_new
-											);
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		if ( ubA_file != 0 )
-			delete[] ubA_new;
-		if ( lbA_file != 0 )
-			delete[] lbA_new;
-		if ( ub_file != 0 )
-			delete[] ub_new;
-		if ( lb_file != 0 )
-			delete[] lb_new;
-		delete[] g_new;
-
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-
-	/* 3) Actually perform hotstart. */
-	returnvalue = hotstart(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-							nWSR,cputime,
-							guessedBounds,guessedConstraints
-							);
-
-
-	/* 4) Free memory. */
-	if ( ubA_file != 0 )
-		delete[] ubA_new;
-	if ( lbA_file != 0 )
-		delete[] lbA_new;
-	if ( ub_file != 0 )
-		delete[] ub_new;
-	if ( lb_file != 0 )
-		delete[] lb_new;
-	delete[] g_new;
-
-	return returnvalue;
-}
-
-
-/*
- * s o l v e C u r r e n t E Q P
- */
-returnValue QProblem::solveCurrentEQP(	const int_t n_rhs,
-										const real_t* g_in,
-										const real_t* lb_in,
-										const real_t* ub_in,
-										const real_t* lbA_in,
-										const real_t* ubA_in,
-										real_t* x_out,
-										real_t* y_out
-										)
-{
-	if ( ( x_out == 0 ) || ( y_out == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-	int_t ii, jj;
-	int_t nV  = getNV( );
-	int_t nC  = getNC( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-
-	real_t *delta_xFX = new real_t[nFX];
-	real_t *delta_xFR = new real_t[nFR];
-	real_t *delta_yAC = new real_t[nAC];
-	real_t *delta_yFX = new real_t[nFX];
-
-	/* 1) Determine index arrays. */
-	int_t* FR_idx;
-	int_t* FX_idx;
-	int_t* AC_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	for ( ii = 0 ; ii < (nV+nC)*n_rhs; ++ii )
-		y_out[ii] = 0.0;
-
-	for ( ii = 0 ; ii < n_rhs; ++ii )
-	{
-		returnvalue = determineStepDirection(
-			g_in, lbA_in, ubA_in, lb_in, ub_in, BT_FALSE, BT_FALSE,
-			delta_xFX, delta_xFR, delta_yAC, delta_yFX );
-
-		for ( jj = 0; jj < nFX; ++jj )
-			x_out[FX_idx[jj]] = delta_xFX[jj];
-		for ( jj = 0; jj < nFR; ++jj )
-			x_out[FR_idx[jj]] = delta_xFR[jj];
-		for ( jj = 0; jj < nFX; ++jj )
-			y_out[FX_idx[jj]] = delta_yFX[jj];
-		for ( jj = 0; jj < nAC; ++jj )
-			y_out[nV+AC_idx[jj]] = delta_yAC[jj];
-
-		g_in += nV;
-		lb_in += nV;
-		ub_in += nV;
-		lbA_in += nC;
-		ubA_in += nC;
-		x_out += nV;
-		y_out += nV+nC;
-	}
-
-
-	delete[] delta_yFX;
-	delete[] delta_yAC;
-	delete[] delta_xFR;
-	delete[] delta_xFX;
-
-	return returnvalue;
-}
-
-
-
-/*
- *	g e t W o r k i n g S e t
- */
-returnValue QProblem::getWorkingSet( real_t* workingSet )
-{
-	int_t nV = this->getNV();
-
-	if ( workingSet == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* At which limit are the bounds active? */
-	getWorkingSetBounds( workingSet );
-
-	/* At which limit are the contraints active? */
-	getWorkingSetConstraints( &(workingSet[nV]) );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t W o r k i n g S e t B o u n d s
- */
-returnValue QProblem::getWorkingSetBounds( real_t* workingSetB )
-{
-	return QProblemB::getWorkingSetBounds( workingSetB );
-}
-
-
-/*
- *	g e t W o r k i n g S e t C o n s t r a i n t s
- */
-returnValue QProblem::getWorkingSetConstraints( real_t* workingSetC )
-{
-	int_t i;
-	int_t nC = this->getNC();
-
-	if ( workingSetC == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	for ( i=0; i<nC; ++i )
-	{
-		switch ( constraints.getStatus(i) )
-		{
-			case ST_LOWER: workingSetC[i] = -1.0; break;
-			case ST_UPPER: workingSetC[i] = +1.0; break;
-			default:       workingSetC[i] =  0.0; break;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	g e t N Z
- */
-int_t QProblem::getNZ( ) const
-{
-	/* nZ = nFR - nAC */
-	return getNFR( ) - getNAC( );
-}
-
-
-/*
- *	g e t D u a l S o l u t i o n
- */
-returnValue QProblem::getDualSolution( real_t* const yOpt ) const
-{
-	int_t i;
-
-	for( i=0; i<getNV( )+getNC( ); ++i )
-		yOpt[i] = y[i];
-
-	/* return optimal dual solution vector
-	 * only if current QP has been solved */
-	if ( ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED ) )
-	{
-		return SUCCESSFUL_RETURN;
-	}
-	else
-	{
-		return RET_QP_NOT_SOLVED;
-	}
-}
-
-
-
-/*
- *	s e t C o n s t r a i n t P r o d u c t
- */
-returnValue QProblem::setConstraintProduct( ConstraintProduct* const _constraintProduct )
-{
-	constraintProduct = _constraintProduct;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t P r o p e r t i e s
- */
-returnValue QProblem::printProperties( )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	/* Do not print properties if print level is set to none! */
-	if ( options.printLevel == PL_NONE )
-		return SUCCESSFUL_RETURN;
-
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	myPrintf( "\n#################   qpOASES  --  QP PROPERTIES   #################\n" );
-	myPrintf( "\n" );
-
-	/* 1) Variables properties. */
-	snprintf( myPrintfString,MAX_STRING_LENGTH,  "Number of Variables: %4.1d\n",(int)getNV( ) );
-	myPrintf( myPrintfString );
-
-	if ( bounds.hasNoLower( ) == BT_TRUE )
-			myPrintf( "Variables are not bounded from below.\n" );
-		else
-			myPrintf( "Variables are bounded from below.\n" );
-
-	if ( bounds.hasNoUpper( ) == BT_TRUE )
-			myPrintf( "Variables are not bounded from above.\n" );
-		else
-			myPrintf( "Variables are bounded from above.\n" );
-
-	myPrintf( "\n" );
-
-
-	/* 2) Constraints properties. */
-	snprintf( myPrintfString,MAX_STRING_LENGTH,  "Total number of Constraints:      %4.1d\n",(int)getNC( ) );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,  "Number of Equality Constraints:   %4.1d\n",(int)getNEC( ) );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,  "Number of Inequality Constraints: %4.1d\n",(int)(getNC( )-getNEC( )) );
-	myPrintf( myPrintfString );
-
-	if ( getNC( ) > 0 )
-	{
-		if ( constraints.hasNoLower( ) == BT_TRUE )
-				myPrintf( "Constraints are not bounded from below.\n" );
-			else
-				myPrintf( "Constraints are bounded from below.\n" );
-
-		if ( constraints.hasNoUpper( ) == BT_TRUE )
-				myPrintf( "Constraints are not bounded from above.\n" );
-			else
-				myPrintf( "Constraints are bounded from above.\n" );
-	}
-
-	myPrintf( "\n" );
-
-
-	/* 3) Further properties. */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			myPrintf( "Hessian is zero matrix (i.e. actually an LP is solved).\n" );
-			break;
-
-		case HST_IDENTITY:
-			myPrintf( "Hessian is identity matrix.\n" );
-			break;
-
-		case HST_POSDEF:
-			myPrintf( "Hessian matrix is (strictly) positive definite.\n" );
-			break;
-
-		case HST_POSDEF_NULLSPACE:
-			myPrintf( "Hessian matrix is positive definite on null space of active constraints.\n" );
-			break;
-
-		case HST_SEMIDEF:
-			myPrintf( "Hessian matrix is positive semi-definite.\n" );
-			break;
-
-		case HST_INDEF:
-			myPrintf( "Hessian matrix is indefinite.\n" );
-			break;
-
-		default:
-			myPrintf( "Hessian matrix has unknown type.\n" );
-			break;
-	}
-
-	if ( infeasible == BT_TRUE )
-		myPrintf( "QP was found to be infeasible.\n" );
-	else
-		myPrintf( "QP seems to be feasible.\n" );
-
-	if ( unbounded == BT_TRUE )
-		myPrintf( "QP was found to be unbounded from below.\n" );
-	else
-		myPrintf( "QP seems to be bounded from below.\n" );
-
-	myPrintf( "\n" );
-
-
-	/* 4) QP object properties. */
-	switch ( status )
-	{
-		case QPS_NOTINITIALISED:
-			myPrintf( "Status of QP object: freshly instantiated or reset.\n" );
-			break;
-
-		case QPS_PREPARINGAUXILIARYQP:
-			myPrintf( "Status of QP object: an auxiliary QP is currently setup.\n" );
-			break;
-
-		case QPS_AUXILIARYQPSOLVED:
-			myPrintf( "Status of QP object: an auxilary QP was solved.\n" );
-			break;
-
-		case QPS_PERFORMINGHOMOTOPY:
-			myPrintf( "Status of QP object: a homotopy step is performed.\n" );
-			break;
-
-		case QPS_HOMOTOPYQPSOLVED:
-			myPrintf( "Status of QP object: an intermediate QP along the homotopy path was solved.\n" );
-			break;
-
-		case QPS_SOLVED:
-			myPrintf( "Status of QP object: solution of the actual QP was found.\n" );
-			break;
-	}
-
-	switch ( options.printLevel )
-	{
-		case PL_DEBUG_ITER:
-			myPrintf( "Print level of QP object is set to display a tabular output for debugging.\n" );
-			break;
-
-		case PL_TABULAR:
-			myPrintf( "Print level of QP object is set to display a tabular output.\n" );
-			break;
-
-		case PL_LOW:
-			myPrintf( "Print level of QP object is low, i.e. only error are printed.\n" );
-			break;
-
-		case PL_MEDIUM:
-			myPrintf( "Print level of QP object is medium, i.e. error and warnings are printed.\n" );
-			break;
-
-		case PL_HIGH:
-			myPrintf( "Print level of QP object is high, i.e. all available output is printed.\n" );
-			break;
-
-		default:
-			break;
-	}
-
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue QProblem::getFreeVariablesFlags( BooleanType* varIsFree )
-{
-	int_t nV  = getNV( );
-	for ( int_t i=0; i<nV; i++ )
-		varIsFree[i] = BT_FALSE;
-
-	int_t nFR  = getNFR( );
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	for ( int_t i=0; i<nFR; i++ )
-		varIsFree[FR_idx[i]] = BT_TRUE;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue QProblem::clear( )
-{
-	if ( ( freeConstraintMatrix == BT_TRUE ) && ( A != 0 ) )
-	{
-		delete A;
-		A = 0;
-	}
-
-	if ( lbA != 0 )
-	{
-		delete[] lbA;
-		lbA = 0;
-	}
-
-	if ( ubA != 0 )
-	{
-		delete[] ubA;
-		ubA = 0;
-	}
-
-	if ( T != 0 )
-	{
-		delete[] T;
-		T = 0;
-	}
-
-	if ( Q != 0 )
-	{
-		delete[] Q;
-		Q = 0;
-	}
-
-	if ( Ax != 0 )
-	{
-		delete[] Ax;
-		Ax = 0;
-	}
-
-	if ( Ax_l != 0 )
-	{
-		delete[] Ax_l;
-		Ax_l = 0;
-	}
-
-	if ( Ax_u != 0 )
-	{
-		delete[] Ax_u;
-		Ax_u = 0;
-	}
-
-	if ( tempA != 0 )
-	{
-		delete[] tempA;
-		tempA = 0;
-	}
-
-	if ( ZFR_delta_xFRz != 0 )
-	{
-		delete[] ZFR_delta_xFRz;
-		ZFR_delta_xFRz = 0;
-	}
-
-	if ( delta_xFRy != 0 )
-	{
-		delete[] delta_xFRy;
-		delta_xFRy = 0;
-	}
-
-	if ( delta_xFRz != 0 )
-	{
-		delete[] delta_xFRz;
-		delta_xFRz = 0;
-	}
-
-	if ( tempB != 0 )
-	{
-		delete[] tempB;
-		tempB = 0;
-	}
-
-	if ( delta_yAC_TMP != 0 )
-	{
-		delete[] delta_yAC_TMP;
-		delta_yAC_TMP = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue QProblem::copy(	const QProblem& rhs
-							)
-{
-	uint_t _nV = (uint_t)rhs.getNV( );
-	uint_t _nC = (uint_t)rhs.getNC( );
-
-	constraints = rhs.constraints;
-
-	if ( ( freeConstraintMatrix == BT_TRUE ) && ( A != 0 ) )
-	{
-		delete A;
-		A = 0;
-	}
-
-	freeConstraintMatrix = rhs.freeConstraintMatrix;
-
-	if ( freeConstraintMatrix == BT_TRUE )
-		A = rhs.A->duplicate();
-	else
-		A = rhs.A;
-
-	if ( rhs.lbA != 0 )
-	{
-		lbA = new real_t[_nC];
-		setLBA( rhs.lbA );
-	}
-	else
-		lbA = 0;
-
-	if ( rhs.ubA != 0 )
-	{
-		ubA = new real_t[_nC];
-		setUBA( rhs.ubA );
-	}
-	else
-		ubA = 0;
-
-	if ( rhs.y != 0 )
-	{
-		delete[] y; /* y of no constraints version too short! */
-		y = new real_t[_nV+_nC];
-		memcpy( y,rhs.y,(_nV+_nC)*sizeof(real_t) );
-	}
-	else
-		y = 0;
-
-	sizeT = rhs.sizeT;
-
-	if ( rhs.T != 0 )
-	{
-		T = new real_t[sizeT*sizeT];
-		memcpy( T,rhs.T,((uint_t)(sizeT*sizeT))*sizeof(real_t) );
-	}
-	else
-		T = 0;
-
-	if ( rhs.Q != 0 )
-	{
-		Q = new real_t[_nV*_nV];
-		memcpy( Q,rhs.Q,_nV*_nV*sizeof(real_t) );
-	}
-	else
-		Q = 0;
-
-	if ( rhs.Ax != 0 )
-	{
-		Ax = new real_t[_nC];
-		memcpy( Ax,rhs.Ax,_nC*sizeof(real_t) );
-	}
-	else
-		Ax = 0;
-
-	if ( rhs.Ax_l != 0 )
-	{
-		Ax_l = new real_t[_nC];
-		memcpy( Ax_l,rhs.Ax_l,_nC*sizeof(real_t) );
-	}
-	else
-		Ax_l = 0;
-
-	if ( rhs.Ax_u != 0 )
-	{
-		Ax_u = new real_t[_nC];
-		memcpy( Ax_u,rhs.Ax_u,_nC*sizeof(real_t) );
-	}
-	else
-		Ax_u = 0;
-
-	if ( rhs.constraintProduct != 0 )
-		constraintProduct = rhs.constraintProduct;
-	else
-		constraintProduct = 0;
-
-	tempA = new real_t[_nV];			/* nFR */
-	ZFR_delta_xFRz = new real_t[_nV];	/* nFR */
-	delta_xFRz = new real_t[_nV];		/* nZ */
-
-	if ( _nC > 0 )
-	{
-		delta_xFRy = new real_t[_nC];		/* nAC */
-		tempB = new real_t[_nC];			/* nAC */
-		delta_yAC_TMP = new real_t[_nC];   /* nAC */
-	}
-	else
-	{
-		delta_xFRy = 0;
-		tempB = 0;
-		delta_yAC_TMP = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s o l v e I n i t i a l Q P
- */
-returnValue QProblem::solveInitialQP(	const real_t* const xOpt, const real_t* const yOpt,
-										const Bounds* const guessedBounds, const Constraints* const guessedConstraints,
-										const real_t* const _R,
-										int_t& nWSR, real_t* const cputime
-										)
-{
-	int_t i,j;
-
-	/* some definitions */
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	//writeQpDataIntoMatFile( "qpData.mat" );
-
-	/* start runtime measurement */
-	real_t starttime = 0.0;
-	if ( cputime != 0 )
-		starttime = getCPUtime( );
-
-	status = QPS_NOTINITIALISED;
-
-	/* I) ANALYSE QP DATA: */
-	/* 1) Check if Hessian happens to be the identity matrix. */
-	if ( determineHessianType( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 2) Setup type of bounds and constraints (i.e. unbounded, implicitly fixed etc.). */
-	if ( setupSubjectToType( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* II) SETUP AUXILIARY QP WITH GIVEN OPTIMAL SOLUTION: */
-	/* 1) Setup bounds and constraints data structure. */
-	if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	if ( constraints.setupAllInactive( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 2) Setup optimal primal/dual solution for auxiliary QP. */
-	if ( setupAuxiliaryQPsolution( xOpt,yOpt ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 3) Obtain linear independent working set for auxiliary QP. */
-	Bounds auxiliaryBounds( nV );
-	Constraints auxiliaryConstraints( nC );
-
-	if ( obtainAuxiliaryWorkingSet(	xOpt,yOpt,guessedBounds,guessedConstraints,
-									&auxiliaryBounds,&auxiliaryConstraints ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 4) Setup working set of auxiliary QP and setup matrix factorisations. */
-	/* a) Regularise Hessian if necessary. */
-	if ( ( hessianType == HST_ZERO ) || ( hessianType == HST_SEMIDEF ) )
-	{
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_INIT_FAILED_REGULARISATION );
-	}
-
-	/* b) TQ factorisation. */
-	if ( setupTQfactorisation( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED_TQ );
-
-	/* c) Working set of auxiliary QP. */
-	if ( setupAuxiliaryWorkingSet( &auxiliaryBounds,&auxiliaryConstraints,BT_TRUE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* d) Copy external Cholesky factor if provided */
-	haveCholesky = BT_FALSE;
-
-	if ( _R != 0 )
-	{
-		if ( options.initialStatusBounds != ST_INACTIVE )
-		{
-			THROWWARNING( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-		}
-		else
-		{
-			if ( _R == R )
-			{
-				/* Cholesky factor read from file and already loaded into R. */
-				haveCholesky = BT_TRUE;
-			}
-			else if ( ( xOpt == 0 ) && ( yOpt == 0 ) && ( guessedBounds == 0 ) && ( guessedConstraints == 0 ) )
-			{
-				for( i=0; i<nV; ++i )
-					for( j=i; j<nV; ++j )
-						RR(i,j) = _R[i*nV+j];
-				haveCholesky = BT_TRUE;
-			}
-			else
-			{
-				THROWWARNING( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-			}
-		}
-	}
-
-	/* 5) Store original QP formulation... */
-	real_t* g_original = new real_t[nV];
-	real_t* lb_original = new real_t[nV];
-	real_t* ub_original = new real_t[nV];
-	real_t* lbA_original = new real_t[nC];
-	real_t* ubA_original = new real_t[nC];
-
-	for( i=0; i<nV; ++i )
-	{
-		g_original[i] = g[i];
-		lb_original[i] = lb[i];
-		ub_original[i] = ub[i];
-	}
-
-	for( i=0; i<nC; ++i )
-	{
-		lbA_original[i] = lbA[i];
-		ubA_original[i] = ubA[i];
-	}
-
-	/* ... and setup QP data of an auxiliary QP having an optimal solution
-	 * as specified by the user (or xOpt = yOpt = 0, by default). */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-	{
-		delete[] ubA_original; delete[] lbA_original; delete[] ub_original; delete[] lb_original; delete[] g_original;
-		return THROWERROR( RET_INIT_FAILED );
-	}
-
-	if ( setupAuxiliaryQPbounds( &auxiliaryBounds,&auxiliaryConstraints,BT_TRUE ) != SUCCESSFUL_RETURN )
-	{
-		delete[] ubA_original; delete[] lbA_original; delete[] ub_original; delete[] lb_original; delete[] g_original;
-		return THROWERROR( RET_INIT_FAILED );
-	}
-
-	status = QPS_AUXILIARYQPSOLVED;
-
-
-	if ( options.enableRamping == BT_TRUE )
-		performRamping( );
-
-
-	/* III) SOLVE ACTUAL INITIAL QP: */
-	/* Allow only remaining CPU time for usual hotstart. */
-	if ( cputime != 0 )
-		*cputime -= getCPUtime( ) - starttime;
-
-	/* Use hotstart method to find the solution of the original initial QP,... */
-	returnValue returnvalue = hotstart( g_original,lb_original,ub_original,lbA_original,ubA_original, nWSR,cputime );
-
-	/* ... deallocate memory,... */
-	delete[] ubA_original; delete[] lbA_original; delete[] ub_original; delete[] lb_original; delete[] g_original;
-
-	/* ... check for infeasibility and unboundedness... */
-	if ( isInfeasible( ) == BT_TRUE )
-		return THROWERROR( RET_INIT_FAILED_INFEASIBILITY );
-
-	if ( isUnbounded( ) == BT_TRUE )
-		return THROWERROR( RET_INIT_FAILED_UNBOUNDEDNESS );
-
-	/* ... and internal errors. */
-	if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-		return THROWERROR( RET_INIT_FAILED_HOTSTART );
-
-
-	/* stop runtime measurement */
-	if ( cputime != 0 )
-		*cputime = getCPUtime( ) - starttime;
-
-	THROWINFO( RET_INIT_SUCCESSFUL );
-
-	return returnvalue;
-}
-
-
-/*
- *	s o l v e Q P
- */
-returnValue QProblem::solveQP(	const real_t* const g_new,
-								const real_t* const lb_new, const real_t* const ub_new,
-								const real_t* const lbA_new, const real_t* const ubA_new,
-								int_t& nWSR, real_t* const cputime, int_t nWSRperformed,
-								BooleanType isFirstCall
-								)
-{
-	int_t iter;
-	int_t nV  = getNV( );
-	int_t nC  = getNC( );
-
-	returnValue returnvalue;
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED );
-	}
-
-	/* start runtime measurement */
-	real_t starttime = 0.0;
-	if ( cputime != 0 )
-		starttime = getCPUtime( );
-
-	/* AW: Remove bounds if they were active before but are now infinity */
-	status = QPS_PERFORMINGHOMOTOPY; // AW TODO: Not sure if this is too early, but otherwise removeBounds will complain
-	returnvalue = updateActivitiesForHotstart( lb_new, ub_new, lbA_new, ubA_new );
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		THROWERROR( RET_HOTSTART_FAILED );
-		return returnvalue;
-	}
-
-	/* I) PREPARATIONS */
-	/* 1) Allocate delta vectors of gradient and (constraints') bounds,
-	 *    index arrays and step direction arrays. */
-	real_t* delta_xFR = new real_t[nV];
-	real_t* delta_xFX = new real_t[nV];
-	real_t* delta_yAC = new real_t[nC];
-	real_t* delta_yFX = new real_t[nV];
-
-	real_t* delta_g   = new real_t[nV];
-	real_t* delta_lb  = new real_t[nV];
-	real_t* delta_ub  = new real_t[nV];
-	real_t* delta_lbA = new real_t[nC];
-	real_t* delta_ubA = new real_t[nC];
-
-	BooleanType Delta_bC_isZero, Delta_bB_isZero;
-
-	int_t BC_idx;
-	SubjectToStatus BC_status;
-	BooleanType BC_isBound;
-
-	real_t homotopyLength;
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-
-	/* 2) Update type of bounds and constraints, e.g.
-	 *    a former equality constraint might have become a normal one etc. */
-
-  // (ckirches) disabled this, as inactive but tight bounds may become inactive equalities
-    //            which would then never become active again!
-/*
-	if ( setupSubjectToType( lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_HOTSTART_FAILED );
-*/
-
-	/* 3) Reset status flags. */
-	infeasible = BT_FALSE;
-	unbounded  = BT_FALSE;
-
-
-	/* II) MAIN HOMOTOPY LOOP */
-	for( iter=nWSRperformed; iter<nWSR; ++iter )
-	{
-		tabularOutput.idxAddB = tabularOutput.idxRemB = tabularOutput.idxAddC = tabularOutput.idxRemC = -1;
-		tabularOutput.excAddB = tabularOutput.excRemB = tabularOutput.excAddC = tabularOutput.excRemC = 0;
-
-		if ( isCPUtimeLimitExceeded( cputime,starttime,iter-nWSRperformed ) == BT_TRUE )
-		{
-			/* If CPU time limit is exceeded, stop homotopy loop immediately!
-			* Assign number of working set recalculations (runtime measurement is stopped later). */
-			nWSR = iter;
-			break;
-		}
-
-		status = QPS_PERFORMINGHOMOTOPY;
-
-		#ifndef __SUPPRESSANYOUTPUT__
-		if ( isFirstCall == BT_TRUE )
-			snprintf( messageString,MAX_STRING_LENGTH,"%d ...",(int)iter );
-		else
-			snprintf( messageString,MAX_STRING_LENGTH,"%d* ...",(int)iter );
-		getGlobalMessageHandler( )->throwInfo( RET_ITERATION_STARTED,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#endif
-
-		/* 2) Determination of shift direction of the gradient and the (constraints') bounds. */
-		returnvalue = determineDataShift(	g_new,lbA_new,ubA_new,lb_new,ub_new,
-											delta_g,delta_lbA,delta_ubA,delta_lb,delta_ub,
-											Delta_bC_isZero, Delta_bB_isZero
-											);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_SHIFT_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-		/* 3) Determination of step direction of X and Y. */
-		returnvalue = determineStepDirection(	delta_g,delta_lbA,delta_ubA,delta_lb,delta_ub,
-												Delta_bC_isZero, Delta_bB_isZero,
-												delta_xFX,delta_xFR,delta_yAC,delta_yFX
-												);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_STEPDIRECTION_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-		/* 4) Determination of step length TAU.
-		 *    This step along the homotopy path is also taken (without changing working set). */
-		returnvalue = performStep(	delta_g, delta_lbA,delta_ubA,delta_lb,delta_ub,
-									delta_xFX,delta_xFR,delta_yAC,delta_yFX,
-									BC_idx,BC_status,BC_isBound
-									);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_STEPLENGTH_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-		/* 5) Termination criterion. */
-		nV = getNV( );
-		nC = getNC( );
-
-		homotopyLength = getRelativeHomotopyLength( g_new,lb_new,ub_new,lbA_new,ubA_new );
-		if ( homotopyLength <= options.terminationTolerance )
-		{
-			status = QPS_SOLVED;
-
-			THROWINFO( RET_OPTIMAL_SOLUTION_FOUND );
-
-			if ( printIteration( iter,BC_idx,BC_status,BC_isBound,homotopyLength,isFirstCall ) != SUCCESSFUL_RETURN )
-				THROWERROR( RET_PRINT_ITERATION_FAILED ); /* do not pass this as return value! */
-
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-			return SUCCESSFUL_RETURN;
-		}
-
-		/* 6) Change active set. */
-		returnvalue = changeActiveSet( BC_idx,BC_status,BC_isBound );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			/* Checks for infeasibility... */
-			if ( isInfeasible( ) == BT_TRUE )
-			{
-				status = QPS_HOMOTOPYQPSOLVED;
-				return setInfeasibilityFlag( RET_HOTSTART_STOPPED_INFEASIBILITY );
-			}
-
-			/* ...unboundedness... */
-			if ( unbounded == BT_TRUE ) /* not necessary since objective function convex! */
-				return THROWERROR( RET_HOTSTART_STOPPED_UNBOUNDEDNESS );
-
-			/* ... and throw unspecific error otherwise */
-			THROWERROR( RET_HOMOTOPY_STEP_FAILED );
-			return returnvalue;
-		}
-
-		/* 6a) Possibly refactorise projected Hessian from scratch. */
-		if ( ( options.enableCholeskyRefactorisation > 0 ) && ( (iter % options.enableCholeskyRefactorisation) == 0 ) )
-		{
-			returnvalue = computeProjectedCholesky( );
-			if (returnvalue != SUCCESSFUL_RETURN)
-			{
-				delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-				delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-				return returnvalue;
-			}
-		}
-
-		/* 7) Output information of successful QP iteration. */
-		status = QPS_HOMOTOPYQPSOLVED;
-
-		if ( printIteration( iter,BC_idx,BC_status,BC_isBound,homotopyLength,isFirstCall ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_PRINT_ITERATION_FAILED ); /* do not pass this as return value! */
-
-		/* 8) Perform Ramping Strategy on zero homotopy step or drift correction (if desired). */
-		if (BC_status != ST_UNDEFINED)
-		{
-			if ( ( tau <= EPS ) && ( options.enableRamping == BT_TRUE ) )
-				performRamping( );
-			else
-			if ( (options.enableDriftCorrection > 0)
-			  && ((iter+1) % options.enableDriftCorrection == 0) )
-				performDriftCorrection( );  /* always returns SUCCESSFUL_RETURN */
-		}
-		else // AW: Added this.  Otherwise, I observed that the gradient might become incorrect
-		{
-			if ( (options.enableDriftCorrection > 0)
-			  && ((iter+1) % options.enableDriftCorrection == 0) )
-				performDriftCorrection( );  /* always returns SUCCESSFUL_RETURN */
-		}
-	}
-
-	delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-	delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-	/* stop runtime measurement */
-	if ( cputime != 0 )
-		*cputime = getCPUtime( ) - starttime;
-
-
-	/* if program gets to here, output information that QP could not be solved
-	 * within the given maximum numbers of working set changes */
-	if ( options.printLevel == PL_HIGH )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		snprintf( messageString,MAX_STRING_LENGTH,"(nWSR = %d)",(int)iter );
-		return getGlobalMessageHandler( )->throwWarning( RET_MAX_NWSR_REACHED,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#else
-		return RET_MAX_NWSR_REACHED;
-		#endif
-	}
-	else
-	{
-		return RET_MAX_NWSR_REACHED;
-	}
-}
-
-
-/*
- *	s o l v e R e g u l a r i s e d Q P
- */
-returnValue QProblem::solveRegularisedQP(	const real_t* const g_new,
-											const real_t* const lb_new, const real_t* const ub_new,
-											const real_t* const lbA_new, const real_t* const ubA_new,
-											int_t& nWSR, real_t* const cputime, int_t nWSRperformed,
-											BooleanType isFirstCall
-											)
-{
-	int_t i, step;
-	int_t nV = getNV( );
-
-
-	/* Perform normal QP solution if QP has not been regularised. */
-	if ( usingRegularisation( ) == BT_FALSE )
-		return solveQP( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,cputime,nWSRperformed,isFirstCall );
-
-
-	/* I) SOLVE USUAL REGULARISED QP */
-	returnValue returnvalue;
-
-	int_t nWSR_max   = nWSR;
-	int_t nWSR_total = nWSRperformed;
-
-	real_t cputime_total = 0.0;
-	real_t cputime_cur   = 0.0;
-
-	if ( cputime == 0 )
-	{
-		returnvalue = solveQP( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0,nWSRperformed,isFirstCall );
-	}
-	else
-	{
-		cputime_cur = *cputime;
-		returnvalue = solveQP( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,&cputime_cur,nWSRperformed,isFirstCall );
-	}
-	nWSR_total     = nWSR;
-	cputime_total += cputime_cur;
-	isFirstCall    = BT_FALSE;
-
-	/* Only continue if QP solution has been successful. */
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		if ( cputime != 0 )
-			*cputime = cputime_total;
-
-		if ( returnvalue == RET_MAX_NWSR_REACHED )
-			THROWWARNING( RET_NO_REGSTEP_NWSR );
-
-		return returnvalue;
-	}
-
-
-	/* II) PERFORM SUCCESSIVE REGULARISATION STEPS */
-	real_t* gMod = new real_t[nV];
-
-	for( step=0; step<options.numRegularisationSteps; ++step )
-	{
-		/* 1) Modify gradient: gMod = g - eps*xOpt
-		 *    (assuming regularisation matrix to be regVal*Id). */
-		for( i=0; i<nV; ++i )
-			gMod[i] = g_new[i] - regVal*x[i];
-
-		/* 2) Solve regularised QP with modified gradient allowing
-		 *    only as many working set recalculations and CPU time
-		 *    as have been left from previous QP solutions. */
-		nWSR = nWSR_max;
-
-		if ( cputime == 0 )
-		{
-			returnvalue = solveQP( gMod,lb_new,ub_new,lbA_new,ubA_new, nWSR,0,nWSR_total,isFirstCall );
-		}
-		else
-		{
-			cputime_cur = *cputime - cputime_total;
-			returnvalue = solveQP( gMod,lb_new,ub_new,lbA_new,ubA_new, nWSR,&cputime_cur,nWSR_total,isFirstCall );
-		}
-
-		nWSR_total     = nWSR;
-		cputime_total += cputime_cur;
-
-		/* Only continue if QP solution has been successful. */
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] gMod;
-
-			if ( cputime != 0 )
-				*cputime = cputime_total;
-
-			if ( returnvalue == RET_MAX_NWSR_REACHED )
-				THROWWARNING( RET_FEWER_REGSTEPS_NWSR );
-
-			return returnvalue;
-		}
-	}
-
-	for( i=0; i<nV; ++i )
-		g[i] = g_new[i];
-
-	delete[] gMod;
-
-	if ( cputime != 0 )
-		*cputime = cputime_total;
-
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	s e t u p S u b j e c t T o T y p e
- */
-returnValue QProblem::updateActivitiesForHotstart( const real_t* const lb_new, const real_t* const ub_new,
-												   const real_t* const lbA_new, const real_t* const ubA_new
-												   )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	returnValue returnvalue;
-
-	if ( QProblemB::setupSubjectToType( lb_new,ub_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUPSUBJECTTOTYPE_FAILED );
-
-	for ( i=0; i<nV; i++ )
-	{
-		if ( lb_new[i] <= -INFTY && bounds.getStatus(i) == ST_LOWER )
-		{
-			returnvalue = removeBound( i, BT_TRUE, BT_FALSE, options.enableNZCTests );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return returnvalue;
-			g[i] -= y[i];
-			y[i] = 0.0;
-		}
-		if ( ub_new[i] >= INFTY && bounds.getStatus(i) == ST_UPPER )
-		{
-			returnvalue = removeBound( i, BT_TRUE, BT_FALSE, options.enableNZCTests );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return returnvalue;
-			g[i] -= y[i];
-			y[i] = 0.0;
-		}
-		if ( lb_new[i] > -INFTY && lb[i] <= -INFTY )
-		{
-			/* Now a lower bound has become finite.  To avoid numerical issues, adjust lb */
-			lb[i] = x[i] - options.boundRelaxation;
-		}
-		if ( ub_new[i] < INFTY && ub[i] >= INFTY )
-		{
-			/* Now a lower bound has become finite.  To avoid numerical issues, adjust lb */
-			ub[i] = x[i] + options.boundRelaxation;
-		}
-	}
-
-	for ( i=0; i<nV; i++ )
-	{
-	  if ( bounds.getType(i) == ST_EQUALITY ) // ?? && lb[i] != ub[i]
-		{
-			/* AW: Are the following two lines OK? */
-			lb[i] = x[i];
-			ub[i] = x[i];
-			if (  bounds.getStatus(i) == ST_INACTIVE )
-			{
-				returnvalue = addBound_checkLI(i);
-				if ( returnvalue == RET_LINEARLY_INDEPENDENT )
-				{
-					returnvalue = addBound( i,ST_LOWER, BT_TRUE );
-					if ( returnvalue != SUCCESSFUL_RETURN )
-						return returnvalue;
-				}
-				/* AW: Check: This allows to have variables that are
-				   equalities to be in the set of free variables. */
-			}
-		}
-	}
-
-
-	// AW TODO: We could also implement something here for the constraints
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p S u b j e c t T o T y p e
- */
-returnValue QProblem::setupSubjectToType( )
-{
-	return setupSubjectToType( lb,ub,lbA,ubA );
-}
-
-
-/*
- *	s e t u p S u b j e c t T o T y p e
- */
-returnValue QProblem::setupSubjectToType(	const real_t* const lb_new, const real_t* const ub_new,
-											const real_t* const lbA_new, const real_t* const ubA_new
-											)
-{
-	int_t i;
-	int_t nC = getNC( );
-
-
-	/* I) SETUP SUBJECTTOTYPE FOR BOUNDS */
-	if ( QProblemB::setupSubjectToType( lb_new,ub_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUPSUBJECTTOTYPE_FAILED );
-
-
-	/* II) SETUP SUBJECTTOTYPE FOR CONSTRAINTS */
-	/* 1) Check if lower constraints' bounds are present. */
-	constraints.setNoLower( BT_TRUE );
-	if ( lbA_new != 0 )
-	{
-		for( i=0; i<nC; ++i )
-		{
-			if ( lbA_new[i] > -INFTY )
-			{
-				constraints.setNoLower( BT_FALSE );
-				break;
-			}
-		}
-	}
-
-	/* 2) Check if upper constraints' bounds are present. */
-	constraints.setNoUpper( BT_TRUE );
-	if ( ubA_new != 0 )
-	{
-		for( i=0; i<nC; ++i )
-		{
-			if ( ubA_new[i] < INFTY )
-			{
-				constraints.setNoUpper( BT_FALSE );
-				break;
-			}
-		}
-	}
-
-	/* 3) Determine implicit equality constraints and unbounded constraints. */
-	if ( ( lbA_new != 0 ) && ( ubA_new != 0 ) )
-	{
-		for( i=0; i<nC; ++i )
-		{
-			if (constraints.getType (i) == ST_DISABLED)
-				continue;
-
-			if ( ( lbA_new[i] < -INFTY+options.boundTolerance ) && ( ubA_new[i] > INFTY-options.boundTolerance )
-					&& (options.enableFarBounds == BT_FALSE))
-			{
-				constraints.setType( i,ST_UNBOUNDED );
-			}
-			else
-			{
-				if ( options.enableEqualities && lbA[i] > ubA[i] - options.boundTolerance
-				                              && lbA_new[i] > ubA_new[i] - options.boundTolerance)
-					constraints.setType( i,ST_EQUALITY );
-				else
-					constraints.setType( i,ST_BOUNDED );
-			}
-		}
-	}
-	else
-	{
-		if ( ( lbA_new == 0 ) && ( ubA_new == 0 ) )
-		{
-			for( i=0; i<nC; ++i )
-				constraints.setType( i,ST_UNBOUNDED );
-		}
-		else
-		{
-			for( i=0; i<nC; ++i )
-				constraints.setType( i,ST_BOUNDED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o m p u t e P r o j e c t e d C h o l e s k y
- */
-returnValue QProblem::computeProjectedCholesky( )
-{
-	int_t i, j;
-	int_t nV  = getNV( );
-	int_t nZ  = getNZ( );
-
-	SymSparseMat* Id;
-
-	/* Revert to unprotected Cholesky decomposition */
-	if ( getNFX() + getNAC() == 0 )
-		return QProblemB::computeCholesky( );
-
-	/* 1) Initialises R with all zeros. */
-	for( i=0; i<nV*nV; ++i )
-		R[i] = 0.0;
-
-	/* Do not do anything for empty null spaces (important for LP case, HST_ZERO !)*/
-	if ( nZ == 0 ) // nZ == nV - getNFX() - getNAC()
-		return SUCCESSFUL_RETURN;
-
-	/* 2) Calculate Cholesky decomposition of projected Hessian Z'*H*Z. */
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	/* calculate Z'*H*Z */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			if ( usingRegularisation() == BT_TRUE )
-			{
-				Id = createDiagSparseMat( nV, regVal );
-				Id->bilinear(bounds.getFree(), nZ, Q, nV, R, nV);
-				delete Id;
-			}
-			else
-			{
-				/* Code should not get here, as  nZ == 0  always holds for an LP (without regularisation)! */
-				if ( nZ > 0 )
-					return THROWERROR( RET_UNKNOWN_BUG );
-			}
-			break;
-
-		case HST_IDENTITY:
-			Id = createDiagSparseMat( nV, 1.0 );
-			Id->bilinear(bounds.getFree(), nZ, Q, nV, R, nV);
-			delete Id;
-			break;
-
-		default:
-			if ( getNAC() == 0 ) {
-				/* make Z trivial */
-				for ( j=0; j < nZ; ++j ) {
-					for ( i=0; i < nV; ++i )
-						QQ(i,j) = 0.0;
-					QQ(FR_idx[j],j) = 1.0;
-				}
-				/* now Z is trivial, and so is Z'HZ */
-				int_t nFR = getNFR ();
-				for ( j=0; j < nFR; ++j )
-					H->getCol (FR_idx[j], bounds.getFree (), 1.0, &R[j*nV]);
-			} else {
-				/* this is expensive if Z is large! */
-				H->bilinear(bounds.getFree(), nZ, Q, nV, R, nV);
-			}
-	}
-
-	/* R'*R = Z'*H*Z */
-	long info = 0;
-	unsigned long _nZ = (unsigned long)nZ, _nV = (unsigned long)nV;
-
-	POTRF( "U", &_nZ, R, &_nV, &info );
-
-	/* <0 = invalid call, =0 ok, >0 not spd */
-	if (info > 0) {
-		if ( R[0] < 0.0 )
-		{
-			/* Cholesky decomposition has tunneled a negative
-			 * diagonal element. */
-			options.epsRegularisation = getMin( -R[0]+options.epsRegularisation,getSqrt(getAbs(options.epsRegularisation)) );
-		}
-
-		hessianType = HST_SEMIDEF;
-		return RET_HESSIAN_NOT_SPD;
-	}
-
-	/* zero first subdiagonal to make givens updates work */
-	for (i=0;i<nZ-1;++i)
-		RR(i+1,i) = 0.0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p I n i t i a l C h o l e s k y
- */
-returnValue QProblem::setupInitialCholesky( )
-{
-	returnValue returnvalueCholesky;
-
-	/* If regularisation shall be used, always regularise at beginning
-	 * if initial working set is not empty. */
-	if ( ( getNV() != getNFR()-getNFV() ) && ( options.enableRegularisation == BT_TRUE ) )
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return RET_INIT_FAILED_REGULARISATION;
-
-	/* Factorise projected Hessian
-	 * now handles all special cases (no active bounds/constraints, no nullspace) */
-	returnvalueCholesky = computeProjectedCholesky( );
-
-	/* If Hessian is not positive definite, regularise and try again. */
-	if ( returnvalueCholesky == RET_HESSIAN_NOT_SPD )
-	{
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return RET_INIT_FAILED_REGULARISATION;
-
-		returnvalueCholesky = computeProjectedCholesky( );
-	}
-
-	if ( returnvalueCholesky != SUCCESSFUL_RETURN )
-		return RET_INIT_FAILED_CHOLESKY;
-
-	haveCholesky = BT_TRUE;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p T Q f a c t o r i s a t i o n
- */
-returnValue QProblem::setupTQfactorisation( )
-{
-	int_t i, ii;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	/* 1) Set Q to unity matrix. */
-	for( i=0; i<nV*nV; ++i )
-		Q[i] = 0.0;
-
-	for( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		QQ(ii,i) = 1.0;
-	}
-
- 	/* 2) Set T to zero matrix. */
-	for( i=0; i<sizeT*sizeT; ++i )
-		T[i] = 0.0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	o b t a i n A u x i l i a r y W o r k i n g S e t
- */
-returnValue QProblem::obtainAuxiliaryWorkingSet(	const real_t* const xOpt, const real_t* const yOpt,
-													const Bounds* const guessedBounds, const Constraints* const guessedConstraints,
-													Bounds* auxiliaryBounds, Constraints* auxiliaryConstraints
-													) const
-{
-	int_t i = 0;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-
-	/* 1) Ensure that desiredBounds is allocated (and different from guessedBounds). */
-	if ( ( auxiliaryBounds == 0 ) || ( auxiliaryBounds == guessedBounds ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( auxiliaryConstraints == 0 ) || ( auxiliaryConstraints == guessedConstraints ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	SubjectToStatus guessedStatus;
-
-	/* 2) Setup working set of bounds for auxiliary initial QP. */
-	if ( QProblemB::obtainAuxiliaryWorkingSet( xOpt,yOpt,guessedBounds, auxiliaryBounds ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-
-	/* 3) Setup working set of constraints for auxiliary initial QP. */
-	if ( guessedConstraints != 0 )
-	{
-		/* If an initial working set is specific, use it!
-		 * Moreover, add all equality constraints if specified. */
-		for( i=0; i<nC; ++i )
-		{
-			/* Add constraint only if it is not (going to be) disabled! */
-			guessedStatus = guessedConstraints->getStatus( i );
-
-			#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-			if ( constraints.getType( i ) == ST_EQUALITY )
-			{
-				if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-			}
-			else
-			#endif
-			{
-				if ( auxiliaryConstraints->setupConstraint( i,guessedStatus ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-			}
-		}
-	}
-	else	/* No initial working set specified. */
-	{
-		/* Obtain initial working set by "clipping". */
-		if ( ( xOpt != 0 ) && ( yOpt == 0 ) )
-		{
-			for( i=0; i<nC; ++i )
-			{
-				if ( Ax[i] - lbA[i] <= options.boundTolerance )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				if ( ubA[i] - Ax_u[i] <= options.boundTolerance )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_UPPER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				/* Moreover, add all equality constraints if specified. */
-				#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-				if ( constraints.getType( i ) == ST_EQUALITY )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-				else
-				#endif
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-			}
-		}
-
-		/* Obtain initial working set in accordance to sign of dual solution vector. */
-		if ( ( xOpt == 0 ) && ( yOpt != 0 ) )
-		{
-			for( i=0; i<nC; ++i )
-			{
-				if ( yOpt[nV+i] > EPS )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				if ( yOpt[nV+i] < -EPS )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_UPPER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				/* Moreover, add all equality constraints if specified. */
-				#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-				if ( constraints.getType( i ) == ST_EQUALITY )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-				else
-				#endif
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-			}
-		}
-
-		/* If xOpt and yOpt are null pointer and no initial working is specified,
-		 * start with empty working set (or implicitly fixed bounds and equality constraints only)
-		 * for auxiliary QP. */
-		if ( ( xOpt == 0 ) && ( yOpt == 0 ) )
-		{
-			for( i=0; i<nC; ++i )
-			{
-				/* Only add all equality constraints if specified. */
-				#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-				if ( constraints.getType( i ) == ST_EQUALITY )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-				else
-				#endif
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p A u x i l i a r y W o r k i n g S e t
- */
-returnValue QProblem::setupAuxiliaryWorkingSet(	const Bounds* const auxiliaryBounds,
-												const Constraints* const auxiliaryConstraints,
-												BooleanType setupAfresh
-												)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-	BooleanType WSisTrivial = BT_TRUE;
-
-	/* consistency checks */
-	if ( auxiliaryBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-			if ( ( bounds.getStatus( i ) == ST_UNDEFINED ) || ( auxiliaryBounds->getStatus( i ) == ST_UNDEFINED ) )
-				return THROWERROR( RET_UNKNOWN_BUG );
-	}
-	else
-	{
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( auxiliaryConstraints != 0 )
-	{
-		for( i=0; i<nC; ++i )
-			if ( ( constraints.getStatus( i ) == ST_UNDEFINED ) || ( auxiliaryConstraints->getStatus( i ) == ST_UNDEFINED ) )
-				return THROWERROR( RET_UNKNOWN_BUG );
-	}
-	else
-	{
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* Check for trivial working set (all and only bounds active) */
-	for (i = 0; i < nV; i++)
-		if (auxiliaryBounds->getStatus(i) == ST_INACTIVE)
-		{
-			WSisTrivial = BT_FALSE;
-			break;
-		}
-	for (i = 0; i < nC; i++)
-		// (ckirches) here we chose to ignore an invalid ST_INACTIVE on
-		//            constraints that are ST_EQUALITies or may just have become equalities
-		if ( (constraints.getType(i) == ST_EQUALITY) // NOT auxiliaryConstraints here
-			|| (auxiliaryConstraints->getStatus(i) != ST_INACTIVE) )
-		{
-			WSisTrivial = BT_FALSE;
-			break;
-		}
-
-	if (WSisTrivial == BT_TRUE)
-	{
-		for (i = 0; i < nV; i++)
-			if (bounds.getStatus(i) == ST_INACTIVE)
-				bounds.moveFreeToFixed(i, auxiliaryBounds->getStatus(i));
-
-		return SUCCESSFUL_RETURN;
-	}
-
-
-	/* I) SETUP CHOLESKY FLAG:
-	 *    Cholesky decomposition shall only be updated if working set
-	 *    shall be updated (i.e. NOT setup afresh!) */
-	BooleanType updateCholesky;
-	if ( setupAfresh == BT_TRUE )
-		updateCholesky = BT_FALSE;
-	else
-		updateCholesky = BT_TRUE;
-
-
-	BooleanType was_fulli = options.enableFullLITests;
-	real_t backupEpsLITests = options.epsLITests;
-
-	options.enableFullLITests = BT_FALSE;
-	/* options.epsLITests = 1e-1; */
-
-	/* II) REMOVE FORMERLY ACTIVE (CONSTRAINTS') BOUNDS (IF NECESSARY): */
-	if ( setupAfresh == BT_FALSE )
-	{
-		/* 1) Remove all active constraints that shall be inactive or disabled AND
-		*    all active constraints that are active at the wrong bound. */
-		for( i=0; i<nC; ++i )
-		{
-			if ( ( constraints.getStatus( i ) == ST_LOWER ) && ( auxiliaryConstraints->getStatus( i ) != ST_LOWER ) )
-				if ( removeConstraint( i,updateCholesky,BT_FALSE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-			if ( ( constraints.getStatus( i ) == ST_UPPER ) && ( auxiliaryConstraints->getStatus( i ) != ST_UPPER ) )
-				if ( removeConstraint( i,updateCholesky,BT_FALSE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-		}
-
-		/* 2) Remove all active bounds that shall be inactive AND
-		*    all active bounds that are active at the wrong bound. */
-		for( i=0; i<nV; ++i )
-		{
-			if ( ( bounds.getStatus( i ) == ST_LOWER ) && ( auxiliaryBounds->getStatus( i ) != ST_LOWER ) )
-				if ( removeBound( i,updateCholesky,BT_FALSE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-			if ( ( bounds.getStatus( i ) == ST_UPPER ) && ( auxiliaryBounds->getStatus( i ) != ST_UPPER ) )
-				if ( removeBound( i,updateCholesky,BT_FALSE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-		}
-	}
-
-
-	/* III) ADD NEWLY ACTIVE (CONSTRAINTS') BOUNDS: */
-
-	/* 1) Add all equality bounds. */
-	for( i=0; i<nV; ++i )
-	{
-		//if ( ( bounds.getType( i ) == ST_EQUALITY ) && ( ( bounds.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryBounds->getStatus( i ) != ST_INACTIVE ) ) )
-
-		// (ckirches) force equalities active
-
-		if ( ( bounds.getType( i ) == ST_EQUALITY ) && ( bounds.getStatus( i ) == ST_INACTIVE ) )
-		{
-            // assert ( auxiliaryBounds->getStatus( i ) != ST_INACTIVE );
-			/* No check for linear independence necessary. */
-			if ( addBound( i,ST_LOWER,updateCholesky ) != SUCCESSFUL_RETURN ) // was auxiliaryBounds->getStatus( i )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-		}
-	}
-
-	/* 2) Add all equality constraints. */
-	for( i=0; i<nC; ++i )
-	{
-        //if ( ( constraints.getType( i ) == ST_EQUALITY ) && ( ( constraints.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryConstraints->getStatus( i ) != ST_INACTIVE ) ) )
-
-		// (ckirches) force equalities active
-
-		if ( ( constraints.getType( i ) == ST_EQUALITY ) && ( constraints.getStatus( i ) == ST_INACTIVE ) )
-		{
-            // assert ( auxiliaryConstraints->getStatus( i ) != ST_INACTIVE );
-			/* Add constraint only if it is linearly independent from the current working set. */
-			if ( addConstraint_checkLI( i ) == RET_LINEARLY_INDEPENDENT )
-			{
-				if ( addConstraint( i,ST_LOWER,updateCholesky ) != SUCCESSFUL_RETURN )  // was auxiliaryConstraints->getStatus( i )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-			}
-			else
-			{
-				/* Equalities are not linearly independent! */
-				constraints.setType(i, ST_BOUNDED);
-			}
-		}
-	}
-
-
-	/* 3) Add all inactive bounds that shall be active AND
-	 *    all formerly active bounds that have been active at the wrong bound. */
-	for( i=0; i<nV; ++i )
-	{
-		if ( ( bounds.getType( i ) != ST_EQUALITY ) && ( ( bounds.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryBounds->getStatus( i ) != ST_INACTIVE ) ) )
-		{
-			/* Add bound only if it is linearly independent from the current working set. */
-			if ( addBound_checkLI( i ) == RET_LINEARLY_INDEPENDENT )
-			{
-				if ( addBound( i,auxiliaryBounds->getStatus( i ),updateCholesky ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-			}
-		}
-	}
-
-	/* 4) Add all inactive constraints that shall be active AND
-	 *    all formerly active constraints that have been active at the wrong bound. */
-	for( i=0; i<nC; ++i )
-	{
-		if ( ( constraints.getType( i ) != ST_EQUALITY ) && ( auxiliaryConstraints->getStatus( i ) != ST_INACTIVE ) )
-		{
-			/* formerly inactive */
-			if ( constraints.getStatus( i ) == ST_INACTIVE )
-			{
-				/* Add constraint only if it is linearly independent from the current working set. */
-				if ( addConstraint_checkLI( i ) == RET_LINEARLY_INDEPENDENT )
-				{
-					if ( addConstraint( i,auxiliaryConstraints->getStatus( i ),updateCholesky ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-				}
-			}
-		}
-	}
-
-	options.enableFullLITests = was_fulli;
-	options.epsLITests = backupEpsLITests;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P s o l u t i o n
- */
-returnValue QProblem::setupAuxiliaryQPsolution(	const real_t* const xOpt, const real_t* const yOpt
-												)
-{
-	int_t i, j;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-
-	/* Setup primal/dual solution vector for auxiliary initial QP:
-	 * if a null pointer is passed, a zero vector is assigned;
-	 *  old solution vector is kept if pointer to internal solution vector is passed. */
-	if ( xOpt != 0 )
-	{
-		if ( xOpt != x )
-			for( i=0; i<nV; ++i )
-				x[i] = xOpt[i];
-
-		A->times(1, 1.0, x, nV, 0.0, Ax, nC);
-
-		for ( j=0; j<nC; ++j )
-		{
-			Ax_l[j] = Ax[j];
-			Ax_u[j] = Ax[j];
-		}
-	}
-	else
-	{
-		for( i=0; i<nV; ++i )
-			x[i] = 0.0;
-
-		for ( j=0; j<nC; ++j )
-		{
-			Ax[j] = 0.0;
-			Ax_l[j] = 0.0;
-			Ax_u[j] = 0.0;
-		}
-	}
-
-	if ( yOpt != 0 )
-	{
-		if ( yOpt != y )
-			for( i=0; i<nV+nC; ++i )
-				y[i] = yOpt[i];
-	}
-	else
-	{
-		for( i=0; i<nV+nC; ++i )
-			y[i] = 0.0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P g r a d i e n t
- */
-returnValue QProblem::setupAuxiliaryQPgradient( )
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-
-	/* Setup gradient vector: g = -H*x + [Id A]'*[yB yC]
-	 *                          = yB - H*x + A'*yC. */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			if ( usingRegularisation( ) == BT_FALSE )
-				for ( i=0; i<nV; ++i )
-					g[i] = y[i];
-			else
-				for ( i=0; i<nV; ++i )
-					g[i] = y[i] - regVal*x[i];
-			break;
-
-		case HST_IDENTITY:
-			for ( i=0; i<nV; ++i )
-				g[i] = y[i] - x[i];
-			break;
-
-		default:
-			/* y'*Id */
-			for ( i=0; i<nV; ++i )
-				g[i] = y[i];
-
-			/* - H*x */
-			H->times(1, -1.0, x, nV, 1.0, g, nV);
-			break;
-	}
-
-	/* + A'*yC */
-	A->transTimes(1, 1.0, y + nV, nC, 1.0, g, nV);
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a r e B o u n d s C o n s i s t e n t
- */
-returnValue QProblem::areBoundsConsistent(	const real_t* const lb_new, const real_t* const ub_new,
-											const real_t* const lbA_new, const real_t* const ubA_new) const
-{
-	if (QProblemB::areBoundsConsistent(lb_new, ub_new) == RET_QP_INFEASIBLE)
-		return RET_QP_INFEASIBLE;
-
-	if (lbA_new && ubA_new) {
-		for (int_t i = 0; i < getNC(); ++i) {
-			if (lbA_new[i] > ubA_new[i]+EPS) {
-				return RET_QP_INFEASIBLE;
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P b o u n d s
- */
-returnValue QProblem::setupAuxiliaryQPbounds(	const Bounds* const auxiliaryBounds,
-												const Constraints* const auxiliaryConstraints,
-												BooleanType useRelaxation
-												)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-
-	/* 1) Setup bound vectors. */
-	for ( i=0; i<nV; ++i )
-	{
-		switch ( bounds.getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( useRelaxation == BT_TRUE )
-				{
-					if ( bounds.getType( i ) == ST_EQUALITY )
-					{
-						lb[i] = x[i];
-						ub[i] = x[i];
-					}
-					else
-					{
-						/* If a bound is inactive although it was supposed to be
-						* active by the auxiliaryBounds, it could not be added
-						* due to linear dependence. Thus set it "strongly inactive". */
-						if ( auxiliaryBounds->getStatus( i ) == ST_LOWER )
-							lb[i] = x[i];
-						else
-							lb[i] = x[i] - options.boundRelaxation;
-
-						if ( auxiliaryBounds->getStatus( i ) == ST_UPPER )
-							ub[i] = x[i];
-						else
-							ub[i] = x[i] + options.boundRelaxation;
-					}
-				}
-				break;
-
-			case ST_LOWER:
-				lb[i] = x[i];
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					ub[i] = x[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						ub[i] = x[i] + options.boundRelaxation;
-				}
-				break;
-
-			case ST_UPPER:
-				ub[i] = x[i];
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					lb[i] = x[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						lb[i] = x[i] - options.boundRelaxation;
-				}
-				break;
-
-            case ST_DISABLED:
-                break;
-
-			default:
-				return THROWERROR( RET_UNKNOWN_BUG );
-		}
-	}
-
-	/* 2) Setup constraints vectors. */
-	for ( i=0; i<nC; ++i )
-	{
-		switch ( constraints.getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( useRelaxation == BT_TRUE )
-				{
-					if ( constraints.getType( i ) == ST_EQUALITY )
-					{
-						lbA[i] = Ax_l[i];
-						ubA[i] = Ax_u[i];
-					}
-					else
-					{
-						/* If a constraint is inactive although it was supposed to be
-						* active by the auxiliaryConstraints, it could not be added
-						* due to linear dependence. Thus set it "strongly inactive". */
-						if ( auxiliaryConstraints->getStatus( i ) == ST_LOWER )
-							lbA[i] = Ax_l[i];
-						else
-							lbA[i] = Ax_l[i] - options.boundRelaxation;
-
-						if ( auxiliaryConstraints->getStatus( i ) == ST_UPPER )
-							ubA[i] = Ax_u[i];
-						else
-							ubA[i] = Ax_u[i] + options.boundRelaxation;
-					}
-				}
-				break;
-
-			case ST_LOWER:
-				lbA[i] = Ax_l[i];
-				if ( constraints.getType( i ) == ST_EQUALITY )
-				{
-					ubA[i] = Ax_l[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						ubA[i] = Ax_l[i] + options.boundRelaxation;
-				}
-				break;
-
-			case ST_UPPER:
-				ubA[i] = Ax_u[i];
-				if ( constraints.getType( i ) == ST_EQUALITY )
-				{
-					lbA[i] = Ax_u[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						lbA[i] = Ax_u[i] - options.boundRelaxation;
-				}
-				break;
-
-            case ST_DISABLED:
-                break;
-
-			default:
-				return THROWERROR( RET_UNKNOWN_BUG );
-		}
-		Ax_l[i] = Ax_l[i] - lbA[i];
-		Ax_u[i] = ubA[i] - Ax_u[i];
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a d d C o n s t r a i n t
- */
-returnValue QProblem::addConstraint(	int_t number, SubjectToStatus C_status,
-										BooleanType updateCholesky,
-										BooleanType ensureLI
-										)
-{
-	int_t i, j, ii;
-
-	/* consistency checks */
-	if ( constraints.getStatus( number ) != ST_INACTIVE )
-		return THROWERROR( RET_CONSTRAINT_ALREADY_ACTIVE );
-
-	if ( ( constraints.getNC( ) - getNAC( ) ) == constraints.getNUC( ) )
-		return THROWERROR( RET_ALL_CONSTRAINTS_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-
-	/* I) ENSURE LINEAR INDEPENDENCE OF THE WORKING SET,
-	 *    i.e. remove a constraint or bound if linear dependence occurs. */
-	/* check for LI only if Cholesky decomposition shall be updated! */
-	if ( updateCholesky == BT_TRUE && ensureLI == BT_TRUE )
-	{
-		returnValue ensureLIreturnvalue = addConstraint_ensureLI( number,C_status );
-
-		switch ( ensureLIreturnvalue )
-		{
-			case SUCCESSFUL_RETURN:
-				break;
-
-			case RET_LI_RESOLVED:
-				break;
-
-			case RET_ENSURELI_FAILED_NOINDEX:
-				return RET_ADDCONSTRAINT_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_FAILED_CYCLING:
-				return RET_ADDCONSTRAINT_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_DROPPED:
-				return SUCCESSFUL_RETURN;
-
-			default:
-				return THROWERROR( RET_ENSURELI_FAILED );
-		}
-	}
-
-	/* some definitions */
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-	int_t tcol = sizeT - nAC;
-
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	real_t* aFR = new real_t[nFR];
-	real_t* wZ = new real_t[nZ];
-	for( i=0; i<nZ; ++i )
-		wZ[i] = 0.0;
-
-
-	/* II) ADD NEW ACTIVE CONSTRAINT TO MATRIX T: */
-	/* 1) Add row [wZ wY] = aFR'*[Z Y] to the end of T: assign aFR. */
-	A->getRow(number, bounds.getFree(), 1.0, aFR);
-
-	/* calculate wZ */
-	for( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		for( j=0; j<nZ; ++j )
-			wZ[j] += aFR[i] * QQ(ii,j);
-	}
-
-	/* 2) Calculate wY and store it directly into T. */
-	if ( nAC > 0 )
-	{
-		for( j=0; j<nAC; ++j )
-			TT(nAC,tcol+j) = 0.0;
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			for( j=0; j<nAC; ++j )
-				TT(nAC,tcol+j) += aFR[i] * QQ(ii,nZ+j);
-		}
-	}
-
-	delete[] aFR;
-
-
-	real_t c, s, nu;
-
-	if ( nZ > 0 )
-	{
-		/* II) RESTORE TRIANGULAR FORM OF T: */
-		/*     Use column-wise Givens rotations to restore reverse triangular form
-		*      of T, simultanenous change of Q (i.e. Z) and R. */
-		for( j=0; j<nZ-1; ++j )
-		{
-			computeGivens( wZ[j+1],wZ[j], wZ[j+1],wZ[j],c,s );
-			nu = s/(1.0+c);
-
-			for( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				applyGivens( c,s,nu,QQ(ii,1+j),QQ(ii,j), QQ(ii,1+j),QQ(ii,j) );
-			}
-
-			if ( ( updateCholesky == BT_TRUE ) &&
-				 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-			{
-				for( i=0; i<=j+1; ++i )
-					applyGivens( c,s,nu,RR(i,1+j),RR(i,j), RR(i,1+j),RR(i,j) );
-			}
-		}
-
-		TT(nAC,tcol-1) = wZ[nZ-1];
-
-
-		if ( ( updateCholesky == BT_TRUE ) &&
-			 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-		{
-			/* III) RESTORE TRIANGULAR FORM OF R:
-			 *      Use row-wise Givens rotations to restore upper triangular form of R. */
-			for( i=0; i<nZ-1; ++i )
-			{
-				computeGivens( RR(i,i),RR(1+i,i), RR(i,i),RR(1+i,i),c,s );
-				nu = s/(1.0+c);
-
-				for( j=(1+i); j<(nZ-1); ++j ) /* last column of R is thrown away */
-					applyGivens( c,s,nu,RR(i,j),RR(1+i,j), RR(i,j),RR(1+i,j) );
-			}
-			/* last column of R is thrown away */
-			for( i=0; i<nZ; ++i )
-				RR(i,nZ-1) = 0.0;
-		}
-	}
-
-	delete[] wZ;
-
-
-	/* IV) UPDATE INDICES */
-	tabularOutput.idxAddC = number;
-	if ( constraints.moveInactiveToActive( number,C_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	a d d C o n s t r a i n t _ c h e c k L I
- */
-returnValue QProblem::addConstraint_checkLI( int_t number )
-{
-	returnValue returnvalue = RET_LINEARLY_DEPENDENT;
-
-	int_t i, j, ii;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nZ  = getNZ( );
-	int_t nC  = getNC( );
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	int_t *FR_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-
-	if (options.enableFullLITests)
-	{
-		/*
-		 * expensive LI test. Backsolve with refinement using special right
-		 * hand side. This gives an estimate for what should be considered
-		 * "zero". We then check linear independence relative to this estimate.
-		 */
-
-		int_t *FX_idx, *AC_idx, *IAC_idx;
-
-		real_t *delta_g   = new real_t[nV];
-		real_t *delta_xFX = new real_t[nFX];
-		real_t *delta_xFR = new real_t[nFR];
-		real_t *delta_yAC = new real_t[nAC];
-		real_t *delta_yFX = new real_t[nFX];
-
-		bounds.getFixed( )->getNumberArray( &FX_idx );
-		constraints.getActive( )->getNumberArray( &AC_idx );
-		constraints.getInactive( )->getNumberArray( &IAC_idx );
-
-		int_t dim = (nC>nV)?nC:nV;
-		real_t *nul = new real_t[dim];
-		for (ii = 0; ii < dim; ++ii)
-			nul[ii]=0.0;
-
-		A->getRow (number, 0, 1.0, delta_g);
-
-		// AW: I think original line overwrote correct return value
-		// original: returnvalue = determineStepDirection ( delta_g,
-		returnValue dsdreturnvalue = determineStepDirection ( delta_g,
-											  nul, nul, nul, nul,
-											  BT_FALSE, BT_FALSE,
-											  delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		if (dsdreturnvalue!=SUCCESSFUL_RETURN)
-			returnvalue = dsdreturnvalue;
-
-		delete[] nul;
-
-		/* compute the weight in inf-norm */
-		real_t weight = 0.0;
-		for (ii = 0; ii < nAC; ++ii)
-		{
-			real_t a = getAbs (delta_yAC[ii]);
-			if (weight < a) weight = a;
-		}
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_yFX[ii]);
-			if (weight < a) weight = a;
-		}
-
-		/* look at the "zero" in a relative inf-norm */
-		real_t zero = 0.0;
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_xFX[ii]);
-			if (zero < a) zero = a;
-		}
-		for (ii = 0; ii < nFR; ++ii)
-		{
-			real_t a = getAbs (delta_xFR[ii]);
-			if (zero < a) zero = a;
-		}
-
-		/* relative test against zero in inf-norm */
-		if (zero > options.epsLITests * weight)
-			returnvalue = RET_LINEARLY_INDEPENDENT;
-
-		delete[] delta_yFX;
-		delete[] delta_yAC;
-		delete[] delta_xFR;
-		delete[] delta_xFX;
-		delete[] delta_g;
-
-	}
-	else
-	{
-		/*
-		 * cheap LI test for constraint. Check if constraint <number> is
-		 * linearly independent from the the active ones (<=> is element of null
-		 * space of Afr).
-		 */
-
-		real_t *Arow = new real_t[nFR];
-		A->getRow(number, bounds.getFree(), 1.0, Arow);
-
-		real_t sum, l2;
-
-		l2  = 0.0;
-		for (i = 0; i < nFR; i++)
-			l2  += Arow[i]*Arow[i];
-
-		for( j=0; j<nZ; ++j )
-		{
-			sum = 0.0;
-			for( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				sum += Arow[i] * QQ(ii,j);
-			}
-
-			if ( getAbs( sum ) > options.epsLITests*l2 )
-			{
-				/*fprintf(stdFile, "LI test: |sum| = %9.2e, l2 = %9.2e, var = %d\n", getAbs(sum), l2, jj+1); */
-				returnvalue = RET_LINEARLY_INDEPENDENT;
-				break;
-			}
-		}
-
-		delete[] Arow;
-	}
-
-	return THROWINFO( returnvalue );
-}
-
-
-/*
- *	a d d C o n s t r a i n t _ e n s u r e L I
- */
-returnValue QProblem::addConstraint_ensureLI( int_t number, SubjectToStatus C_status )
-{
-	int_t i, j, ii, jj;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addConstraint_checkLI( number );
-
-	if ( returnvalueCheckLI == RET_INDEXLIST_CORRUPTED )
-		return THROWERROR( RET_ENSURELI_FAILED );
-
-	if ( returnvalueCheckLI == RET_LINEARLY_INDEPENDENT )
-		return SUCCESSFUL_RETURN;
-
-
- 	/* II) NEW CONSTRAINT IS LINEARLY DEPENDENT: */
-	/* 1) Determine coefficients of linear combination,
-	 *    cf. M.J. Best. Applied Mathematics and Parallel Computing, chapter:
-	 *    An Algorithm for the Solution of the Parametric Quadratic Programming
-	 *    Problem, pages 57-76. Physica-Verlag, Heidelberg, 1996. */
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	real_t* xiC = new real_t[nAC];
-	real_t* xiC_TMP = new real_t[nAC];
-	real_t* xiB = new real_t[nFX];
-	real_t* Arow = new real_t[nFR];
-	real_t* num = new real_t[nV];
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	real_t y_min = options.maxDualJump;
-	int_t y_min_number = -1;
-	int_t y_min_number_bound = -1;
-	BooleanType y_min_isBound = BT_FALSE;
-
-	A->getRow(number, bounds.getFree(), C_status == ST_LOWER ? 1.0 : -1.0, Arow);
-
-	/* 2) Calculate xiC */
-	if ( nAC > 0 )
-	{
-		for( i=0; i<nAC; ++i )
-		{
-			xiC_TMP[i] = 0.0;
-			for( j=0; j<nFR; ++j )
-			{
-				jj = FR_idx[j];
-				xiC_TMP[i] += QQ(jj,nZ+i) * Arow[j];
-			}
-		}
-
-		if ( backsolveT( xiC_TMP, BT_TRUE, xiC ) != SUCCESSFUL_RETURN )
-		{
-			returnvalue = RET_ENSURELI_FAILED_TQ;
-			goto farewell;
-		}
-	}
-
-	/* 3) Calculate xiB. */
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	A->getRow(number, bounds.getFixed(), C_status == ST_LOWER ? 1.0 : -1.0, xiB);
-	A->transTimes(constraints.getActive(), bounds.getFixed(), 1, -1.0, xiC, nAC, 1.0, xiB, nFX);
-
-	/* III) DETERMINE CONSTRAINT/BOUND TO BE REMOVED. */
-
-	/* 1) Constraints. */
-	for( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-		num[i] = y[nV+ii];
-	}
-
-	performRatioTest (nAC, AC_idx, &constraints, num, xiC, options.epsNum, options.epsDen, y_min, y_min_number);
-
-	/* 2) Bounds. */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-	}
-
-	performRatioTest (nFX, FX_idx, &bounds, num, xiB, options.epsNum, options.epsDen, y_min, y_min_number_bound);
-
-	if ( y_min_number_bound >= 0 )
-	{
-		y_min_number = y_min_number_bound;
-		y_min_isBound = BT_TRUE;
-	}
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	/* setup output preferences */
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-	/* IV) REMOVE CONSTRAINT/BOUND FOR RESOLVING LINEAR DEPENDENCE: */
-	if ( y_min_number >= 0 )
-	{
-		/* Update Lagrange multiplier... */
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			y[nV+ii] -= y_min * xiC[i];
-		}
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			y[ii] -= y_min * xiB[i];
-		}
-
-		/* ... also for newly active constraint... */
-		if ( C_status == ST_LOWER )
-			y[nV+number] = y_min;
-		else
-			y[nV+number] = -y_min;
-
-		/* ... and for constraint to be removed. */
-		if ( y_min_isBound == BT_TRUE )
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			snprintf( messageString,MAX_STRING_LENGTH,"bound no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeBound( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemB = 1;
-
-			y[y_min_number] = 0.0;
-		}
-		else
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			snprintf( messageString,MAX_STRING_LENGTH,"constraint no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeConstraint( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemC = 1;
-
-			y[nV+y_min_number] = 0.0;
-		}
-	}
-	else
-	{
-		if (options.enableDropInfeasibles == BT_TRUE) {
-			/* dropping of infeasible constraints according to drop priorities */
-			returnvalue = dropInfeasibles (number, C_status, BT_FALSE, xiB, xiC);
-		}
-		else
-		{
-			/* no constraint/bound can be removed => QP is infeasible! */
-			returnvalue = RET_ENSURELI_FAILED_NOINDEX;
-			setInfeasibilityFlag( returnvalue );
-		}
-	}
-
-farewell:
-	delete[] num;
-	delete[] Arow;
-	delete[] xiB;
-	delete[] xiC_TMP;
-	delete[] xiC;
-
-	getGlobalMessageHandler( )->throwInfo( RET_LI_RESOLVED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-
-	return ( (returnvalue != SUCCESSFUL_RETURN) && (returnvalue != RET_ENSURELI_FAILED_NOINDEX ) ) ? THROWERROR (returnvalue) : returnvalue;
-}
-
-
-
-/*
- *	a d d B o u n d
- */
-returnValue QProblem::addBound(	int_t number, SubjectToStatus B_status,
-								BooleanType updateCholesky,
-								BooleanType ensureLI
-								)
-{
-	int_t i, j, ii;
-
-	/* consistency checks */
-	if ( bounds.getStatus( number ) != ST_INACTIVE )
-		return THROWERROR( RET_BOUND_ALREADY_ACTIVE );
-
-	if ( getNFR( ) == bounds.getNUV( ) )
-		return THROWERROR( RET_ALL_BOUNDS_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-
-	/* I) ENSURE LINEAR INDEPENDENCE OF THE WORKING SET,
-	 *    i.e. remove a constraint or bound if linear dependence occurs. */
-	/* check for LI only if Cholesky decomposition shall be updated! */
-	if ( ( updateCholesky == BT_TRUE ) && ( ensureLI == BT_TRUE ) )
-	{
-		returnValue ensureLIreturnvalue = addBound_ensureLI( number,B_status );
-
-		switch ( ensureLIreturnvalue )
-		{
-			case SUCCESSFUL_RETURN:
-				break;
-
-			case RET_LI_RESOLVED:
-				break;
-
-			case RET_ENSURELI_FAILED_NOINDEX:
-				return RET_ADDBOUND_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_FAILED_CYCLING:
-				return RET_ADDBOUND_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_DROPPED:
-				return SUCCESSFUL_RETURN;
-
-			default:
-				return THROWERROR( RET_ENSURELI_FAILED );
-		}
-	}
-
-
-	/* some definitions */
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-	int_t tcol = sizeT - nAC;
-
-
-	/* II) SWAP INDEXLIST OF FREE VARIABLES:
-	 *     move the variable to be fixed to the end of the list of free variables. */
-	int_t lastfreenumber = bounds.getFree( )->getLastNumber( );
-	if ( lastfreenumber != number )
-		if ( bounds.swapFree( number,lastfreenumber ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_ADDBOUND_FAILED );
-
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	real_t* w = new real_t[nFR];
-
-
-	/* III) ADD NEW ACTIVE BOUND TO TOP OF MATRIX T: */
-	/* 1) add row [wZ wY] = [Z Y](number) at the top of T: assign w */
-	for( i=0; i<nFR; ++i )
-		w[i] = QQ(FR_idx[nFR-1],i);
-
-
-	/* 2) Use column-wise Givens rotations to restore reverse triangular form
-	 *    of the first row of T, simultanenous change of Q (i.e. Z) and R. */
-	real_t c, s, nu;
-
-	for( j=0; j<nZ-1; ++j )
-	{
-		computeGivens( w[j+1],w[j], w[j+1],w[j],c,s );
-		nu = s/(1.0+c);
-
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			applyGivens( c,s,nu,QQ(ii,1+j),QQ(ii,j), QQ(ii,1+j),QQ(ii,j) );
-		}
-
-		if ( ( updateCholesky == BT_TRUE ) &&
-			 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-		{
-			for( i=0; i<=j+1; ++i )
-				applyGivens( c,s,nu,RR(i,1+j),RR(i,j), RR(i,1+j),RR(i,j) );
-		}
-	}
-
-
-	if ( nAC > 0 )	  /* ( nAC == 0 ) <=> ( nZ == nFR ) <=> Y and T are empty => nothing to do */
-	{
-		/* store new column a in a temporary vector instead of shifting T one column to the left */
-		real_t* tmp = new real_t[nAC];
-		for( i=0; i<nAC; ++i )
-			tmp[i] = 0.0;
-
-		{
-			j = nZ-1;
-
-			computeGivens( w[j+1],w[j], w[j+1],w[j],c,s );
-			nu = s/(1.0+c);
-
-			for( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				applyGivens( c,s,nu,QQ(ii,1+j),QQ(ii,j), QQ(ii,1+j),QQ(ii,j) );
-			}
-
-			applyGivens( c,s,nu,TT(nAC-1,tcol),tmp[nAC-1], tmp[nAC-1],TT(nAC-1,tcol) );
-		}
-
-		for( j=nZ; j<nFR-1; ++j )
-		{
-			computeGivens( w[j+1],w[j], w[j+1],w[j],c,s );
-			nu = s/(1.0+c);
-
-			for( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				applyGivens( c,s,nu,QQ(ii,1+j),QQ(ii,j), QQ(ii,1+j),QQ(ii,j) );
-			}
-
-			for( i=(nFR-2-j); i<nAC; ++i )
-				applyGivens( c,s,nu,TT(i,1+tcol-nZ+j),tmp[i], tmp[i],TT(i,1+tcol-nZ+j) );
-		}
-
-		delete[] tmp;
-	}
-
-	delete[] w;
-
-
-	if ( ( updateCholesky == BT_TRUE ) &&
-		 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-	{
-		/* IV) RESTORE TRIANGULAR FORM OF R:
-		 *     use row-wise Givens rotations to restore upper triangular form of R */
-		for( i=0; i<nZ-1; ++i )
-		{
-			computeGivens( RR(i,i),RR(1+i,i), RR(i,i),RR(1+i,i),c,s );
-			nu = s/(1.0+c);
-
-			for( j=(1+i); j<nZ-1; ++j ) /* last column of R is thrown away */
-				applyGivens( c,s,nu,RR(i,j),RR(1+i,j), RR(i,j),RR(1+i,j) );
-		}
-		/* last column of R is thrown away */
-		for( i=0; i<nZ; ++i )
-			RR(i,nZ-1) = 0.0;
-	}
-
-
-	/* V) UPDATE INDICES */
-	tabularOutput.idxAddB = number;
-	if ( bounds.moveFreeToFixed( number,B_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_ADDBOUND_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a d d B o u n d _ c h e c k L I
- */
-returnValue QProblem::addBound_checkLI( int_t number )
-{
-	int_t i, ii;
-	int_t nV  = getNV( );  /* for QQ() macro */
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	int_t nC  = getNC( );
-	returnValue returnvalue = RET_LINEARLY_DEPENDENT;
-
-	if (options.enableFullLITests)
-	{
-		/*
-		 * expensive LI test. Backsolve with refinement using special right
-		 * hand side. This gives an estimate for what should be considered
-		 * "zero". We then check linear independence relative to this estimate.
-		 */
-
-		/*
-		 * expensive LI test. Backsolve with refinement using special right
-		 * hand side. This gives an estimate for what should be considered
-		 * "zero". We then check linear independence relative to this estimate.
-		 */
-
-		real_t *delta_g   = new real_t[nV];
-		real_t *delta_xFX = new real_t[nFX];
-		real_t *delta_xFR = new real_t[nFR];
-		real_t *delta_yAC = new real_t[nAC];
-		real_t *delta_yFX = new real_t[nFX];
-
-		for (ii = 0; ii < nV; ++ii)
-			delta_g[ii] = 0.0;
-		delta_g[number] = 1.0;	/* sign doesn't matter here */
-
-		int_t dim = (nC>nV)?nC:nV;
-		real_t *nul = new real_t[dim];
-		for (ii = 0; ii < dim; ++ii)
-			nul[ii]=0.0;
-
-		returnValue dsdReturnValue = determineStepDirection (
-				delta_g, nul, nul, nul, nul, BT_FALSE, BT_FALSE,
-				delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		if (dsdReturnValue != SUCCESSFUL_RETURN)
-			returnvalue = dsdReturnValue;
-
-		/* compute the weight in inf-norm */
-		real_t weight = 0.0;
-		for (ii = 0; ii < nAC; ++ii)
-		{
-			real_t a = getAbs (delta_yAC[ii]);
-			if (weight < a) weight = a;
-		}
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_yFX[ii]);
-			if (weight < a) weight = a;
-		}
-
-		/* look at the "zero" in a relative inf-norm */
-		real_t zero = 0.0;
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_xFX[ii]);
-			if (zero < a) zero = a;
-		}
-		for (ii = 0; ii < nFR; ++ii)
-		{
-			real_t a = getAbs (delta_xFR[ii]);
-			if (zero < a) zero = a;
-		}
-
-		/* relative test against zero in inf-norm */
-		if (zero > options.epsLITests * weight)
-			returnvalue = RET_LINEARLY_INDEPENDENT;
-
-		delete[] nul;
-		delete[] delta_yFX;
-		delete[] delta_yAC;
-		delete[] delta_xFR;
-		delete[] delta_xFX;
-		delete[] delta_g;
-
-	}
-	else
-	{
-		/*
-		 * cheap LI test for simple bound. Check if constraint <number> is
-		 * linearly independent from the the active ones (<=> is element of null
-		 * space of Afr).
-		 */
-
-		/* some definitions */
-		int_t nZ  = getNZ( );
-
-		for( i=0; i<nZ; ++i )
-			if ( getAbs( QQ(number,i) ) > options.epsLITests )
-			{
-				returnvalue = RET_LINEARLY_INDEPENDENT;
-				break;
-			}
-	}
-
-	return THROWINFO( returnvalue );
-}
-
-
-/*
- *	a d d B o u n d _ e n s u r e L I
- */
-returnValue QProblem::addBound_ensureLI( int_t number, SubjectToStatus B_status )
-{
-	int_t i, ii;
-	int_t nV  = getNV( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addBound_checkLI( number );
-
-	if ( returnvalueCheckLI == RET_INDEXLIST_CORRUPTED )
-		return THROWERROR( RET_ENSURELI_FAILED );
-
-	if ( returnvalueCheckLI == RET_LINEARLY_INDEPENDENT )
-		return SUCCESSFUL_RETURN;
-
-
- 	/* II) NEW BOUND IS LINEARLY DEPENDENT: */
-	/* 1) Determine coefficients of linear combination,
-	 *    cf. M.J. Best. Applied Mathematics and Parallel Computing, chapter:
-	 *    An Algorithm for the Solution of the Parametric Quadratic Programming
-	 *    Problem, pages 57-76. Physica-Verlag, Heidelberg, 1996. */
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	real_t* xiC = new real_t[nAC];
-	real_t* xiC_TMP = new real_t[nAC];
-	real_t* xiB = new real_t[nFX];
-	real_t* num = new real_t[nV];
-
-	real_t y_min = options.maxDualJump;
-	int_t y_min_number = -1;
-	int_t y_min_number_bound = -1;
-	BooleanType y_min_isBound = BT_FALSE;
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-
-	/* 2) Calculate xiC. */
-	if ( nAC > 0 )
-	{
-		if ( B_status == ST_LOWER )
-		{
-			for( i=0; i<nAC; ++i )
-				xiC_TMP[i] = QQ(number,nZ+i);
-		}
-		else
-		{
-			for( i=0; i<nAC; ++i )
-				xiC_TMP[i] = -QQ(number,nZ+i);
-		}
-
-		if ( backsolveT( xiC_TMP, BT_TRUE, xiC ) != SUCCESSFUL_RETURN )
-		{
-			returnvalue = RET_ENSURELI_FAILED_TQ;
-			goto farewell;
-		}
-	}
-
-	/* 3) Calculate xiB. */
-	A->transTimes(constraints.getActive(), bounds.getFixed(), 1, -1.0, xiC, nAC, 0.0, xiB, nFX);
-
-
-	/* III) DETERMINE CONSTRAINT/BOUND TO BE REMOVED. */
-
-	/* 1) Constraints. */
-	for( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-		num[i] = y[nV+ii];
-	}
-
-	performRatioTest( nAC,AC_idx,&constraints, num,xiC, options.epsNum,options.epsDen, y_min,y_min_number );
-
-	/* 2) Bounds. */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-	}
-
-	performRatioTest( nFX,FX_idx,&bounds, num,xiB, options.epsNum,options.epsDen, y_min,y_min_number_bound );
-
-	if ( y_min_number_bound >= 0 )
-	{
-		y_min_number = y_min_number_bound;
-		y_min_isBound = BT_TRUE;
-	}
-
-	/* IV) REMOVE CONSTRAINT/BOUND FOR RESOLVING LINEAR DEPENDENCE: */
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-	if ( y_min_number >= 0 )
-	{
-		/* Update Lagrange multiplier... */
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			y[nV+ii] -= y_min * xiC[i];
-		}
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			y[ii] -= y_min * xiB[i];
-		}
-
-		/* ... also for newly active bound ... */
-		if ( B_status == ST_LOWER )
-			y[number] = y_min;
-		else
-			y[number] = -y_min;
-
-		/* ... and for bound to be removed. */
-		if ( y_min_isBound == BT_TRUE )
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			snprintf( messageString,MAX_STRING_LENGTH,"bound no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeBound( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemB = 1;
-
-			y[y_min_number] = 0.0;
-		}
-		else
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			snprintf( messageString,MAX_STRING_LENGTH,"constraint no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeConstraint( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemC = 1;
-
-			y[nV+y_min_number] = 0.0;
-		}
-	}
-	else
-	{
-		if (options.enableDropInfeasibles == BT_TRUE) {
-			/* dropping of infeasible constraints according to drop priorities */
-			returnvalue = dropInfeasibles (number, B_status, BT_TRUE, xiB, xiC);
-		}
-		else
-		{
-			/* no constraint/bound can be removed => QP is infeasible! */
-			returnvalue = RET_ENSURELI_FAILED_NOINDEX;
-			setInfeasibilityFlag( returnvalue );
-		}
-	}
-
-farewell:
-	delete[] num;
-	delete[] xiB;
-	delete[] xiC_TMP;
-	delete[] xiC;
-
-	getGlobalMessageHandler( )->throwInfo( RET_LI_RESOLVED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-
-	return ( (returnvalue != SUCCESSFUL_RETURN) && (returnvalue != RET_ENSURELI_FAILED_NOINDEX ) ) ? THROWERROR (returnvalue) : returnvalue;
-}
-
-
-
-/*
- *	r e m o v e C o n s t r a i n t
- */
-returnValue QProblem::removeConstraint(	int_t number,
-										BooleanType updateCholesky,
-										BooleanType allowFlipping,
-										BooleanType ensureNZC
-										)
-{
-	int_t i, j, ii, jj;
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-	BooleanType hasFlipped = BT_FALSE;
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* some definitions */
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-	int_t tcol = sizeT - nAC;
-	int_t number_idx = constraints.getActive( )->getIndex( number );
-
-	int_t addIdx;
-	BooleanType addBoundNotConstraint;
-	SubjectToStatus addStatus;
-	BooleanType exchangeHappened = BT_FALSE;
-
-
-	/* consistency checks */
-	if ( constraints.getStatus( number ) == ST_INACTIVE )
-		return THROWERROR( RET_CONSTRAINT_NOT_ACTIVE );
-
-	if ( ( number_idx < 0 ) || ( number_idx >= nAC ) )
-		return THROWERROR( RET_CONSTRAINT_NOT_ACTIVE );
-
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	/* N) PERFORM ZERO CURVATURE TEST. */
-	if (ensureNZC == BT_TRUE)
-	{
-		returnvalue = ensureNonzeroCurvature(BT_FALSE, number, exchangeHappened, addBoundNotConstraint, addIdx, addStatus);
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return returnvalue;
-	}
-
-	/* save index sets and decompositions for flipping bounds strategy */
-	if ( ( exchangeHappened == BT_FALSE ) && ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) )
-		flipper.set( &bounds,R,&constraints,Q,T );
-
-	/* I) REMOVE <number>th ROW FROM T,
-	 *    i.e. shift rows number+1 through nAC  upwards (instead of the actual
-	 *    constraint number its corresponding index within matrix A is used). */
-	if ( number_idx < nAC-1 )
-	{
-		for( i=(number_idx+1); i<nAC; ++i )
-			for( j=(nAC-i-1); j<nAC; ++j )
-				TT(i-1,tcol+j) = TT(i,tcol+j);
-		/* gimmick: write zeros into the last row of T */
-		for( j=0; j<nAC; ++j )
-			TT(nAC-1,tcol+j) = 0.0;
-
-
-		/* II) RESTORE TRIANGULAR FORM OF T,
-		 *     use column-wise Givens rotations to restore reverse triangular form
-		 *     of T simultanenous change of Q (i.e. Y). */
-		real_t c, s, nu;
-
-		for( j=(nAC-2-number_idx); j>=0; --j )
-		{
-			computeGivens( TT(nAC-2-j,tcol+1+j),TT(nAC-2-j,tcol+j), TT(nAC-2-j,tcol+1+j),TT(nAC-2-j,tcol+j),c,s );
-			nu = s/(1.0+c);
-
-			for( i=(nAC-j-1); i<(nAC-1); ++i )
-				applyGivens( c,s,nu,TT(i,tcol+1+j),TT(i,tcol+j), TT(i,tcol+1+j),TT(i,tcol+j) );
-
-			for( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				applyGivens( c,s,nu,QQ(ii,nZ+1+j),QQ(ii,nZ+j), QQ(ii,nZ+1+j),QQ(ii,nZ+j) );
-			}
-		}
-	}
-	else
-	{
-		/* gimmick: write zeros into the last row of T */
-		for( j=0; j<nAC; ++j )
-			TT(nAC-1,tcol+j) = 0.0;
-	}
-
-
-	if ( ( updateCholesky == BT_TRUE ) &&
-		 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-	{
-		/* III) UPDATE CHOLESKY DECOMPOSITION,
-		 *      calculate new additional column (i.e. [r sqrt(rho2)]')
-		 *      of the Cholesky factor R. */
-		real_t* Hz = new real_t[nFR];
-		real_t* z = new real_t[nFR];
-		real_t rho2 = 0.0;
-
-		/* 1) Calculate Hz = H*z, where z is the new rightmost column of Z
-		 *    (i.e. the old leftmost column of Y).  */
-		for( j=0; j<nFR; ++j )
-			z[j] = QQ(FR_idx[j],nZ);
-		H->times(bounds.getFree(), bounds.getFree(), 1, 1.0, z, nFR, 0.0, Hz, nFR);
-		delete[] z;
-
-		if ( nZ > 0 )
-		{
-			real_t* ZHz = new real_t[nZ];
-			for ( i=0; i<nZ; ++i )
-				ZHz[i] = 0.0;
-			real_t* r = new real_t[nZ];
-
-			/* 2) Calculate ZHz = Z'*Hz (old Z). */
-			for( j=0; j<nFR; ++j )
-			{
-				jj = FR_idx[j];
-
-				for( i=0; i<nZ; ++i )
-					ZHz[i] += QQ(jj,i) * Hz[j];
-			}
-
-			/* 3) Calculate r = R^-T * ZHz. */
-			if ( backsolveR( ZHz,BT_TRUE,r ) != SUCCESSFUL_RETURN )
-			{
-				delete[] Hz; delete[] r; delete[] ZHz;
-				return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-			}
-
-			/* 4) Calculate rho2 = rho^2 = z'*Hz - r'*r
-			 *    and store r into R. */
-			for( i=0; i<nZ; ++i )
-			{
-				rho2 -= r[i]*r[i];
-				RR(i,nZ) = r[i];
-			}
-
-			delete[] r; delete[] ZHz;
-		}
-
-		/* 5) Store rho into R. */
-		for( j=0; j<nFR; ++j )
-			rho2 += QQ(FR_idx[j],nZ) * Hz[j];
-
-		delete[] Hz;
-
-		if ( ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) && ( exchangeHappened == BT_FALSE ) )
-		{
-			if ( rho2 > options.epsFlipping )
-				RR(nZ,nZ) = getSqrt( rho2 );
-			else
-			{
-				hessianType = HST_SEMIDEF;
-
-				flipper.get( &bounds,R,&constraints,Q,T );
-				constraints.flipFixed(number);
-				tabularOutput.idxAddC = number;
-				tabularOutput.excAddC = 2;
-
-				switch (constraints.getStatus(number))
-				{
-					case ST_LOWER:
-						lbA[number] = ubA[number]; Ax_l[number] = -Ax_u[number]; break;
-					case ST_UPPER:
-						ubA[number] = lbA[number]; Ax_u[number] = -Ax_l[number]; break;
-					default:
-						return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-
-				hasFlipped = BT_TRUE;
-			}
-		}
-		else if ( exchangeHappened == BT_FALSE )
-		{
-			if ( rho2 > ZERO )
-				RR(nZ,nZ) = getSqrt( rho2 );
-			else
-			{
-				if ( allowFlipping == BT_FALSE )
-				{
-					RR(nZ,nZ) = 100.0*EPS;
-				}
-				else
-				{
-					hessianType = HST_SEMIDEF;
-					return THROWERROR( RET_HESSIAN_NOT_SPD );
-				}
-			}
-		}
-	}
-
-
-	/* IV) UPDATE INDICES */
-	tabularOutput.idxRemC = number;
-	if ( hasFlipped == BT_FALSE )
-	{
-		if ( constraints.moveActiveToInactive( number ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-	}
-
-	if (exchangeHappened == BT_TRUE)
-	{
-		/* add bound or constraint */
-
-		/* hessianType = HST_SEMIDEF; */
-		RR(nZ,nZ) = 0.0;
-
-		if ( addBoundNotConstraint )
-		{
-			addBound(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddB = 1;
-		}
-		else
-		{
-			addConstraint(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddC = 1;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e B o u n d
- */
-returnValue QProblem::removeBound(	int_t number,
-									BooleanType updateCholesky,
-									BooleanType allowFlipping,
-									BooleanType ensureNZC
-									)
-{
-	int_t i, j, ii, jj;
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-	int_t addIdx;
-	BooleanType addBoundNotConstraint;
-	SubjectToStatus addStatus;
-	BooleanType exchangeHappened = BT_FALSE;
-
-
-	/* consistency checks */
-	if ( bounds.getStatus( number ) == ST_INACTIVE )
-		return THROWERROR( RET_BOUND_NOT_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* some definitions */
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-	int_t tcol = sizeT - nAC;
-
-	/* 0) PERFORM ZERO CURVATURE TEST. */
-	if (ensureNZC == BT_TRUE)
-	{
-		returnvalue = ensureNonzeroCurvature(BT_TRUE, number, exchangeHappened, addBoundNotConstraint, addIdx, addStatus);
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return returnvalue;
-	}
-
-	/* save index sets and decompositions for flipping bounds strategy */
-	if ( ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) && ( exchangeHappened == BT_FALSE ) )
-		flipper.set( &bounds,R,&constraints,Q,T );
-
-	/* I) UPDATE INDICES */
-	tabularOutput.idxRemB = number;
-	if ( bounds.moveFixedToFree( number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	/* I) APPEND <nFR+1>th UNITY VECTOR TO Q. */
-	int_t nnFRp1 = FR_idx[nFR];
-	for( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		QQ(ii,nFR) = 0.0;
-		QQ(nnFRp1,i) = 0.0;
-	}
-	QQ(nnFRp1,nFR) = 1.0;
-
-	if ( nAC > 0 )
-	{
-		/* store new column a in a temporary vector instead of shifting T one column to the left and appending a */
-		int_t* AC_idx;
-		constraints.getActive( )->getNumberArray( &AC_idx );
-
-		real_t* tmp = new real_t[nAC];
-		A->getCol(number, constraints.getActive(), 1.0, tmp);
-
-
-		/* II) RESTORE TRIANGULAR FORM OF T,
-		 *     use column-wise Givens rotations to restore reverse triangular form
-		 *     of T = [T A(:,number)], simultanenous change of Q (i.e. Y and Z). */
-		real_t c, s, nu;
-
-		for( j=(nAC-1); j>=0; --j )
-		{
-			computeGivens( tmp[nAC-1-j],TT(nAC-1-j,tcol+j),TT(nAC-1-j,tcol+j),tmp[nAC-1-j],c,s );
-			nu = s/(1.0+c);
-
-			for( i=(nAC-j); i<nAC; ++i )
-				applyGivens( c,s,nu,tmp[i],TT(i,tcol+j),TT(i,tcol+j),tmp[i] );
-
-			for( i=0; i<=nFR; ++i )
-			{
-				ii = FR_idx[i];
-				/* nZ+1+nAC = nFR+1  /  nZ+(1) = nZ+1 */
-				applyGivens( c,s,nu,QQ(ii,nZ+1+j),QQ(ii,nZ+j),QQ(ii,nZ+1+j),QQ(ii,nZ+j) );
-			}
-		}
-
-		delete[] tmp;
-	}
-
-
-	if ( ( updateCholesky == BT_TRUE ) &&
-	     ( hessianType != HST_ZERO ) && ( hessianType != HST_IDENTITY ) )
-	{
-		/* III) UPDATE CHOLESKY DECOMPOSITION,
-		 *      calculate new additional column (i.e. [r sqrt(rho2)]')
-		 *      of the Cholesky factor R: */
-		real_t z2 = QQ(nnFRp1,nZ);
-		real_t rho2 = H->diag(nnFRp1) * z2*z2;
-
-		if ( nFR > 0 )
-		{
-			/* Attention: Index list of free variables has already grown by one! */
-			real_t* Hz = new real_t[nFR+1];
-			real_t* z = new real_t[nFR+1];
-			/* 1) Calculate R'*r = Zfr'*Hfr*z1 + z2*Zfr'*h1 =: Zfr'*Hz + z2*Zfr'*h1 =: rhs and
-			 *    rho2 = z1'*Hfr*z1 + 2*z2*h1'*z1 + h2*z2^2 - r'*r =: z1'*Hz + 2*z2*h1'*z1 + h2*z2^2 - r'r */
-			for( j=0; j<nFR; ++j )
-				z[j] = QQ(FR_idx[j],nZ);
-			z[nFR] = 0.0;
-
-			H->times(bounds.getFree(), bounds.getFree(), 1, 1.0, z, nFR+1, 0.0, Hz, nFR+1);
-			H->getCol(nnFRp1, bounds.getFree(), 1.0, z);
-
-			if ( nZ > 0 )
-			{
-				real_t* r = new real_t[nZ];
-				real_t* rhs = new real_t[nZ];
-				for( i=0; i<nZ; ++i )
-					rhs[i] = 0.0;
-
-				/* 2) Calculate rhs. */
-				for( j=0; j<nFR; ++j )
-				{
-					jj = FR_idx[j];
-					for( i=0; i<nZ; ++i )
-										/* Zfr' * ( Hz + z2*h1 ) */
-						rhs[i] += QQ(jj,i) * ( Hz[j] + z2 * z[j] );
-				}
-
-				/* 3) Calculate r = R^-T * rhs. */
-				if ( backsolveR( rhs,BT_TRUE,BT_TRUE,r ) != SUCCESSFUL_RETURN )
-				{
-					delete[] z;
-					delete[] Hz; delete[] r; delete[] rhs;
-					return THROWERROR( RET_REMOVEBOUND_FAILED );
-				}
-
-
-				/* 4) Calculate rho2 = rho^2 = z'*Hz - r'*r
-				 *    and store r into R. */
-				for( i=0; i<nZ; ++i )
-				{
-					rho2 -= r[i]*r[i];
-					RR(i,nZ) = r[i];
-				}
-
-				delete[] rhs; delete[] r;
-			}
-
-			for( j=0; j<nFR; ++j )
-			{
-				jj = FR_idx[j];
-							/* z1' * ( Hz + 2*z2*h1 ) */
-				rho2 += QQ(jj,nZ) * ( Hz[j] + 2.0*z2*z[j] );
-			}
-
-			delete[] z;
-			delete[] Hz;
-		}
-
-		/* 5) Store rho into R. */
-		if ( ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) && ( exchangeHappened == BT_FALSE ) )
-		{
-			if ( rho2 > options.epsFlipping )
-				RR(nZ,nZ) = getSqrt( rho2 );
-			else
-			{
-				if ( hessianType != HST_ZERO )
-					hessianType = HST_SEMIDEF;
-
-				flipper.get( &bounds,R,&constraints,Q,T );
-				bounds.flipFixed(number);
-				tabularOutput.idxAddB = number;
-				tabularOutput.excAddB = 2;
-
-				switch (bounds.getStatus(number))
-				{
-					case ST_LOWER:
-						lb[number] = ub[number];
-						break;
-					case ST_UPPER:
-						ub[number] = lb[number];
-						break;
-					default: return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-
-			}
-		}
-		else if ( exchangeHappened == BT_FALSE )
-		{
-			if ( rho2 > ZERO )
-				RR(nZ,nZ) = getSqrt( rho2 );
-			else
-			{
-				if ( allowFlipping == BT_FALSE )
-					RR(nZ,nZ) = 100.0*EPS;
-				else
-				{
-					hessianType = HST_SEMIDEF;
-					return THROWERROR( RET_HESSIAN_NOT_SPD );
-				}
-			}
-		}
-		else
-		{
-			/* add bound or constraint */
-
-			/* hessianType = HST_SEMIDEF; */
-			RR(nZ,nZ) = 0.0;
-
-			if ( addBoundNotConstraint )
-			{
-				addBound(addIdx, addStatus, BT_TRUE, BT_FALSE);
-				tabularOutput.excAddB = 1;
-			}
-			else
-			{
-				addConstraint(addIdx, addStatus, BT_TRUE, BT_FALSE);
-				tabularOutput.excAddC = 1;
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-returnValue QProblem::performPlainRatioTest(	int_t nIdx,
-												const int_t* const idxList,
-												const real_t* const num,
-												const real_t* const den,
-												real_t epsNum,
-												real_t epsDen,
-												real_t& t,
-												int_t& BC_idx
-												) const
-{
-	int_t i;
-	for (i = 0; i < nIdx; i++)
-		if ( (num[i] > epsNum) && (den[i] > epsDen) && (t * den[i] > num[i]) )
-		{
-			t = num[i] / den[i];
-			BC_idx = idxList[i];
-		}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue QProblem::ensureNonzeroCurvature(	BooleanType removeBoundNotConstraint,
-												int_t remIdx,
-												BooleanType &exchangeHappened,
-												BooleanType &addBoundNotConstraint,
-												int_t &addIdx,
-												SubjectToStatus &addStatus
-												)
-{
-	int_t i, ii;
-	int_t addLBndIdx = -1, addLCnstrIdx = -1, addUBndIdx = -1, addUCnstrIdx = -1; /* exchange indices */
-	int_t *FX_idx, *AC_idx, *IAC_idx;
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-	int_t nC  = getNC( );
-	int_t nFX = getNFX( );
-	int_t nIAC = getNIAC( );
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-// 	real_t *delta_g   = new real_t[nV];
-	real_t *delta_xFX = new real_t[nFX];
-	real_t *delta_xFR = new real_t[nFR];
-	real_t *delta_yAC = new real_t[nAC];
-	real_t *delta_yFX = new real_t[nFX];
-
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-	constraints.getInactive( )->getNumberArray( &IAC_idx );
-
-	addBoundNotConstraint = BT_TRUE;
-	addStatus = ST_INACTIVE;
-	exchangeHappened = BT_FALSE;
-
-	if (removeBoundNotConstraint)
-	{
-		int_t dim = nV < nC ? nC : nV;
-		real_t *nul = new real_t[dim];
-		real_t *ek = new real_t[nV]; /* minus e_k (bound k is removed) */
-		for (ii = 0; ii < dim; ++ii)
-			nul[ii]=0.0;
-		for (ii = 0; ii < nV; ++ii)
-			ek[ii]=0.0;
-		ek[remIdx] = bounds.getStatus(remIdx) == ST_LOWER ? 1.0 : -1.0;
-
-		returnvalue = determineStepDirection (nul, nul, nul, ek, ek,
-											  BT_FALSE, BT_FALSE,
-											  delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		delete[] ek;
-		delete[] nul;
-	}
-	else
-	{
-		real_t *nul = new real_t[nV];
-		real_t *ek = new real_t[nC]; /* minus e_k (constraint k is removed) */
-		for (ii = 0; ii < nV; ++ii)
-			nul[ii]=0.0;
-		for (ii = 0; ii < nC; ++ii)
-			ek[ii]=0.0;
-		ek[remIdx] = constraints.getStatus(remIdx) == ST_LOWER ? 1.0 : -1.0;
-
-		returnvalue = determineStepDirection (nul,
-											  ek, ek, nul, nul,
-											  BT_FALSE, BT_TRUE,
-											  delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		delete[] ek;
-		delete[] nul;
-	}
-
-	/* compute the weight in inf-norm */
-	real_t normXi = 0.0;
-	for (ii = 0; ii < nAC; ++ii)
-	{
-		real_t a = getAbs (delta_yAC[ii]);
-		if (normXi < a) normXi = a;
-	}
-	for (ii = 0; ii < nFX; ++ii)
-	{
-		real_t a = getAbs (delta_yFX[ii]);
-		if (normXi < a) normXi = a;
-	}
-
-	/* look at the "zero" in a relative inf-norm */
-	real_t normS = 0.0;
-	for (ii = 0; ii < nFX; ++ii)
-	{
-		real_t a = getAbs (delta_xFX[ii]);
-		if (normS < a) normS = a;
-	}
-	for (ii = 0; ii < nFR; ++ii)
-	{
-		real_t a = getAbs (delta_xFR[ii]);
-		if (normS < a) normS = a;
-	}
-
-	/* relative test against zero in inf-norm */
-	if (normXi < options.epsNZCTests * normS)
-	{
-		/* determine jump in x via ratio tests */
-		real_t sigmaLBnd, sigmaLCnstr, sigmaUBnd, sigmaUCnstr, sigma;
-
-		/* bounds */
-
-		/* compress x-u */
-		real_t *x_W = new real_t[getMax(1,nFR)];
-		for (i = 0; i < nFR; i++)
-		{
-			ii = FR_idx[i];
-			x_W[i] = ub[ii] - x[ii];
-		}
-		/* performRatioTest( nFR,FR_idx,&bounds, x_W,delta_xFR, options.epsNum,options.epsDen, sigmaUBnd,addUBndIdx ); */
-		sigmaUBnd = options.maxPrimalJump;
-		addUBndIdx = -1;
-		performPlainRatioTest(nFR, FR_idx, x_W, delta_xFR, options.epsNum, options.epsDen, sigmaUBnd, addUBndIdx);
-		if (removeBoundNotConstraint == BT_TRUE && bounds.getStatus(remIdx) == ST_LOWER)
-		{
-			/* also consider bound which is to be removed */
-			real_t one = 1.0;
-			x_W[0] = ub[remIdx] - x[remIdx];
-			performPlainRatioTest(1, &remIdx, x_W, &one, options.epsNum, options.epsDen, sigmaUBnd, addUBndIdx);
-		}
-
-		/* compress x-l */
-		for (i = 0; i < nFR; i++)
-		{
-			ii = FR_idx[i];
-			x_W[i] = x[ii] - lb[ii];
-		}
-		for (i = 0; i < nFR; i++)
-			delta_xFR[i] = -delta_xFR[i];
-		/* performRatioTest( nFR,FR_idx,&bounds, x_W,delta_xFR, options.epsNum,options.epsDen, sigmaLBnd,addLBndIdx ); */
-		sigmaLBnd = options.maxPrimalJump;
-		addLBndIdx = -1;
-		performPlainRatioTest(nFR, FR_idx, x_W, delta_xFR, options.epsNum, options.epsDen, sigmaLBnd, addLBndIdx);
-		if (removeBoundNotConstraint == BT_TRUE && bounds.getStatus(remIdx) == ST_UPPER)
-		{
-			/* also consider bound which is to be removed */
-			real_t one = 1.0;
-			x_W[0] = x[remIdx] - lb[remIdx];
-			performPlainRatioTest(1, &remIdx, x_W, &one, options.epsNum, options.epsDen, sigmaLBnd, addLBndIdx);
-		}
-		for (i = 0; i < nFR; i++)
-			delta_xFR[i] = -delta_xFR[i];
-
-		delete[] x_W;
-
-		/* constraints */
-
-		/* compute As (compressed to inactive constraints) */
-		real_t *As = new real_t[nIAC];
-		A->times(constraints.getInactive(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 0.0, As, nIAC);
-		A->times(constraints.getInactive(), bounds.getFree(), 1, 1.0, delta_xFR, nFR, 1.0, As, nIAC);
-
-		/* compress Ax_u */
-		real_t *Ax_W = new real_t[nIAC];
-		for (i = 0; i < nIAC; i++)
-		{
-			ii = IAC_idx[i];
-			Ax_W[i] = Ax_u[ii];
-		}
-		/* performRatioTest( nIAC,IAC_idx,&constraints, Ax_W,As, options.epsNum,options.epsDen, sigmaUCnstr,addUCnstrIdx ); */
-		sigmaUCnstr = options.maxPrimalJump;
-		addUCnstrIdx = -1;
-		performPlainRatioTest(nIAC, IAC_idx, Ax_W, As, options.epsNum, options.epsDen, sigmaUCnstr, addUCnstrIdx);
-		if (removeBoundNotConstraint == BT_FALSE && constraints.getStatus(remIdx) == ST_LOWER)
-		{
-			/* also consider constraint which is to be removed */
-			real_t one = 1.0;
-			performPlainRatioTest(1, &remIdx, &Ax_u[remIdx], &one, options.epsNum, options.epsDen, sigmaUCnstr, addUCnstrIdx);
-		}
-
-		/* compress Ax_l */
-		for (i = 0; i < nIAC; i++)
-		{
-			ii = IAC_idx[i];
-			Ax_W[i] = Ax_l[ii];
-		}
-		for (i = 0; i < nIAC; i++)
-			As[i] = -As[i];
-		/* performRatioTest( nIAC,IAC_idx,&constraints, Ax_W,As, options.epsNum,options.epsDen, sigmaLCnstr,addLCnstrIdx ); */
-		sigmaLCnstr = options.maxPrimalJump;
-		addLCnstrIdx = -1;
-		performPlainRatioTest(nIAC, IAC_idx, Ax_W, As, options.epsNum, options.epsDen, sigmaLCnstr, addLCnstrIdx);
-		if (removeBoundNotConstraint == BT_FALSE && constraints.getStatus(remIdx) == ST_UPPER)
-		{
-			/* also consider constraint which is to be removed */
-			real_t one = 1.0;
-			performPlainRatioTest(1, &remIdx, &Ax_l[remIdx], &one, options.epsNum, options.epsDen, sigmaLCnstr, addLCnstrIdx);
-		}
-
-		/* perform primal jump */
-		sigma = options.maxPrimalJump;
-		if (sigmaUCnstr < sigma) { sigma = sigmaUCnstr; addStatus = ST_UPPER; addBoundNotConstraint = BT_FALSE; addIdx = addUCnstrIdx; }
-		if (sigmaLCnstr < sigma) { sigma = sigmaLCnstr; addStatus = ST_LOWER; addBoundNotConstraint = BT_FALSE; addIdx = addLCnstrIdx; }
-		if (sigmaUBnd < sigma) { sigma = sigmaUBnd; addStatus = ST_UPPER; addBoundNotConstraint = BT_TRUE; addIdx = addUBndIdx; }
-		if (sigmaLBnd < sigma) { sigma = sigmaLBnd; addStatus = ST_LOWER; addBoundNotConstraint = BT_TRUE; addIdx = addLBndIdx; }
-
-		if (sigma >= options.maxPrimalJump)
-		{
-			unbounded = BT_TRUE;
-			returnvalue = RET_HOTSTART_STOPPED_UNBOUNDEDNESS;
-		}
-		else
-		{
-			for (i = 0; i < nFR; i++)
-				x[FR_idx[i]] += sigma * delta_xFR[i];
-
-			for (i = 0; i < nFX; i++)
-				x[FX_idx[i]] += sigma * delta_xFX[i];
-
-			/* update Ax, Ax_u, and Ax_l */
-			A->times(1, 1.0, x, nV, 0.0, Ax, nC);
-			for (i = 0; i < nC; i++) Ax_u[i] = ubA[i] - Ax[i];
-			for (i = 0; i < nC; i++) Ax_l[i] = Ax[i] - lbA[i];
-
-			/* change working set later */
-			exchangeHappened = BT_TRUE;
-		}
-
-		delete[] Ax_W;
-		delete[] As;
-	}
-
-	delete[] delta_yFX;
-	delete[] delta_yAC;
-	delete[] delta_xFR;
-	delete[] delta_xFX;
-// 	delete[] delta_g;
-
-	return returnvalue;
-}
-
-
-
-/*
- *	b a c k s o l v e T
- */
-returnValue QProblem::backsolveT( const real_t* const b, BooleanType transposed, real_t* const a ) const
-{
-	int_t i, j;
-	int_t nT = getNAC( );
-	int_t tcol = sizeT - nT;
-
-	real_t sum;
-
-	/* nothing to do */
-	if ( nT <= 0 )
-		return SUCCESSFUL_RETURN;
-
-
-	/* Solve Ta = b, where T might be transposed. */
-	if ( transposed == BT_FALSE )
-	{
-		/* solve Ta = b */
-		for( i=0; i<nT; ++i )
-		{
-			sum = b[i];
-			for( j=0; j<i; ++j )
-				sum -= TT(i,sizeT-1-j) * a[nT-1-j];
-
-			if ( getAbs( TT(i,sizeT-1-i) ) > EPS )
-				a[nT-1-i] = sum / TT(i,sizeT-1-i);
-			else
-				return THROWERROR( RET_DIV_BY_ZERO );
-		}
-	}
-	else
-	{
-		/* solve T^T*a = b */
-		for( i=0; i<nT; ++i )
-		{
-			sum = b[i];
-			for( j=0; j<i; ++j )
-				sum -= TT(nT-1-j,tcol+i) * a[nT-1-j];
-
-			if ( getAbs( TT(nT-1-i,tcol+i) ) > EPS )
-				a[nT-1-i] = sum / TT(nT-1-i,tcol+i);
-			else
-				return THROWERROR( RET_DIV_BY_ZERO );
-		}
-	}
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	d e t e r m i n e D a t a S h i f t
- */
-returnValue QProblem::determineDataShift(	const real_t* const g_new, const real_t* const lbA_new, const real_t* const ubA_new,
-											const real_t* const lb_new, const real_t* const ub_new,
-											real_t* const delta_g, real_t* const delta_lbA, real_t* const delta_ubA,
-											real_t* const delta_lb, real_t* const delta_ub,
-											BooleanType& Delta_bC_isZero, BooleanType& Delta_bB_isZero
-											)
-{
-	int_t i, ii;
-	int_t nC  = getNC( );
-	int_t nAC = getNAC( );
-
-	int_t* FX_idx;
-	int_t* AC_idx;
-
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-
-
-	/* I) DETERMINE DATA SHIFT FOR BOUNDS */
-	QProblemB::determineDataShift(	g_new,lb_new,ub_new,
-									delta_g,delta_lb,delta_ub,
-									Delta_bB_isZero );
-
-
-	/* II) DETERMINE DATA SHIFT FOR CONSTRAINTS */
-	/* 1) Calculate shift directions. */
-	for( i=0; i<nC; ++i )
-	{
-		/* if lower constraints' bounds are to be disabled or do not exist, shift them to -infinity */
-		if ( lbA_new != 0 )
-			delta_lbA[i] = lbA_new[i] - lbA[i];
-		else
-			delta_lbA[i] = -INFTY - lbA[i];
-	}
-
-	for( i=0; i<nC; ++i )
-	{
-		/* if upper constraints' bounds are to be disabled or do not exist, shift them to infinity */
-		if ( ubA_new != 0 )
-			delta_ubA[i] = ubA_new[i] - ubA[i];
-		else
-			delta_ubA[i] = INFTY - ubA[i];
-	}
-
-	/* 2) Determine if active constraints' bounds are to be shifted. */
-	Delta_bC_isZero = BT_TRUE;
-
-	for ( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-
-		if ( ( getAbs( delta_lbA[ii] ) > EPS ) || ( getAbs( delta_ubA[ii] ) > EPS ) )
-		{
-			Delta_bC_isZero = BT_FALSE;
-			break;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	d e t e r m i n e S t e p D i r e c t i o n
- */
-returnValue QProblem::determineStepDirection(	const real_t* const delta_g, const real_t* const delta_lbA, const real_t* const delta_ubA,
-												const real_t* const delta_lb, const real_t* const delta_ub,
-												BooleanType Delta_bC_isZero, BooleanType Delta_bB_isZero,
-												real_t* const delta_xFX, real_t* const delta_xFR,
-												real_t* const delta_yAC, real_t* const delta_yFX
-												)
-{
-	int_t i, j, ii, jj, r;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-	int_t* FR_idx;
-	int_t* FX_idx;
-	int_t* AC_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-
-	/* I) DETERMINE delta_xFX (this is exact, does not need refinement) */
-	if ( Delta_bB_isZero == BT_FALSE )
-	{
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-
-			if ( bounds.getStatus( ii ) == ST_LOWER )
-				delta_xFX[i] = delta_lb[ii];
-			else
-				delta_xFX[i] = delta_ub[ii];
-		}
-	}
-	else
-	{
-		for( i=0; i<nFX; ++i )
-			delta_xFX[i] = 0.0;
-	}
-
-
-	/* tempA and tempB hold the residuals in gFR and bA (= lbA or ubA)
-	 * delta_xFR, delta_yAC hold the steps that get refined */
-	for ( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		tempA[i] = delta_g[ii];
-		delta_xFR[i] = 0.0;
-	}
-	for ( i=0; i<nAC; ++i )
-		delta_yAC[i] = 0.0;
-	if ( Delta_bC_isZero == BT_FALSE )
-	{
-		for ( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			if ( constraints.getStatus( ii ) == ST_LOWER )
-				tempB[i] = delta_lbA[ii];
-			else
-				tempB[i] = delta_ubA[ii];
-		}
-	}
-	else
-	{
-		for ( i=0; i<nAC; ++i )
-			tempB[i] = 0.0;
-	}
-
-	/* Iterative refinement loop for delta_xFRz, delta_xFRy, delta_yAC */
-	for ( r=0; r<=options.numRefinementSteps; ++r )
-	{
-		/* II) DETERMINE delta_xFR */
-		if ( nFR > 0 )
-		{
-			for( i=0; i<nFR; ++i )
-				delta_xFR_TMP[i] = 0.0;
-
-			/* 1) Determine delta_xFRy. */
-			if ( nAC > 0 )
-			{
-				if ( ( Delta_bC_isZero == BT_TRUE ) && ( Delta_bB_isZero == BT_TRUE ) )
-				{
-					for( i=0; i<nAC; ++i )
-						delta_xFRy[i] = 0.0;
-				}
-				else
-				{
-					/* compute bA - A * delta_xFX. tempB already holds bA->
-					 * in refinements r>=1, delta_xFX is exactly zero */
-					if ( ( Delta_bB_isZero == BT_FALSE ) && ( r == 0 ) )
-						A->times(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, tempB, nAC);
-
-					if ( backsolveT( tempB, BT_FALSE, delta_xFRy ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_STEPDIRECTION_FAILED_TQ );
-
-					for( i=0; i<nFR; ++i )
-					{
-						ii = FR_idx[i];
-						for( j=0; j<nAC; ++j )
-							delta_xFR_TMP[i] += QQ(ii,nZ+j) * delta_xFRy[j];
-					}
-				}
-			}
-
-
-			/* 2) Determine delta_xFRz. */
-			for( i=0; i<nZ; ++i )
-				delta_xFRz[i] = 0.0;
-
-			if ( ( hessianType == HST_ZERO ) || ( hessianType == HST_IDENTITY ) )
-			{
-				/* compute Z*delta_gFR [/eps] (delta_gFR is stored in tempA) */
-				for( j=0; j<nFR; ++j )
-				{
-					jj = FR_idx[j];
-					for( i=0; i<nZ; ++i )
-						delta_xFRz[i] -= QQ(jj,i) * tempA[j];
-				}
-
-				if ( hessianType == HST_ZERO )
-				{
-					if ( usingRegularisation( ) == BT_TRUE )
-					{
-						for( i=0; i<nZ; ++i )
-							delta_xFRz[i] /= regVal;
-					}
-					else
-					{
-						/* When solving LPs without regularisation, iterates must always be at a vertex. */
-						if ( nZ > 0 )
-							return THROWERROR( RET_UNKNOWN_BUG );
-					}
-				}
-			}
-			else
-			{
-				/* compute HMX*delta_xFX. DESTROY delta_gFR that was in tempA */
-				if ( ( Delta_bB_isZero == BT_FALSE ) && ( r == 0 ) )
-					H->times(bounds.getFree(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, tempA, nFR);
-
-				/* compute HFR*delta_xFRy */
-				if ( ( nAC > 0 ) && ( ( Delta_bC_isZero == BT_FALSE ) || ( Delta_bB_isZero == BT_FALSE ) ) )
-					H->times(bounds.getFree(), bounds.getFree(), 1, 1.0, delta_xFR_TMP, nFR, 1.0, tempA, nFR);
-
-				/* compute ZFR_delta_xFRz = (Z'*HFR*Z) \ Z * (HFR*delta_xFR + HMX*delta_xFX + delta_gFR) */
-				if ( nZ > 0 )
-				{
-					for( j=0; j<nFR; ++j )
-					{
-						jj = FR_idx[j];
-						for( i=0; i<nZ; ++i )
-							delta_xFRz[i] -= QQ(jj,i) * tempA[j];
-					}
-
-					if ( backsolveR( delta_xFRz,BT_TRUE,delta_xFRz ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_STEPDIRECTION_FAILED_CHOLESKY );
-
-					if ( backsolveR( delta_xFRz,BT_FALSE,delta_xFRz ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_STEPDIRECTION_FAILED_CHOLESKY );
-				}
-			}
-
-			/* compute Z * ZFR_delta_xFRz */
-			if ( nZ > 0 )
-			{
-				for( i=0; i<nFR; ++i )
-				{
-					ZFR_delta_xFRz[i] = 0.0;
-
-					ii = FR_idx[i];
-					for( j=0; j<nZ; ++j )
-						ZFR_delta_xFRz[i] += QQ(ii,j) * delta_xFRz[j];
-
-					delta_xFR_TMP[i] += ZFR_delta_xFRz[i];
-				}
-			}
-		}
-
-		/* III) DETERMINE delta_yAC */
-		if ( nAC > 0 ) /* => ( nFR = nZ + nAC > 0 ) */
-		{
-			if ( ( hessianType == HST_ZERO ) || ( hessianType == HST_IDENTITY ) )
-			{
-				/* if zero:     delta_yAC = (T')^-1 * ( Yfr*delta_gFR + eps*delta_xFRy ),
-				 * if identity: delta_yAC = (T')^-1 * ( Yfr*delta_gFR +     delta_xFRy )
-				 *
-				 * DESTROY residual_bA that was stored in tempB
-				 * If we come here, residual_gFR in tempA is STILL VALID
-				 */
-				if ( hessianType == HST_IDENTITY )
-				{
-					for( j=0; j<nAC; ++j )
-						tempB[j] = delta_xFRy[j];
-				}
-				else /* hessianType == HST_ZERO */
-				{
-					if ( usingRegularisation( ) == BT_TRUE )
-					{
-						for( j=0; j<nAC; ++j )
-							tempB[j] = regVal*delta_xFRy[j];
-					}
-					else
-					{
-						for( j=0; j<nAC; ++j )
-							tempB[j] = 0.0;
-					}
-				}
-
-				for( j=0; j<nAC; ++j )
-				{
-					for( i=0; i<nFR; ++i )
-					{
-						ii = FR_idx[i];
-						tempB[j] += QQ(ii,nZ+j) * tempA[i];
-					}
-				}
-			}
-			else
-			{
-				/* Compute HFR * delta_xFR + HMX*delta_xFX
-				 * Here, tempA holds (HFR*delta_xFRy + HMX*delta_xFX) */
-				if ( nZ > 0 )
-					H->times(bounds.getFree(), bounds.getFree(), 1, 1.0, ZFR_delta_xFRz, nFR, 1.0, tempA, nFR);
-
-				for( i=0; i<nAC; ++i)
-				{
-					tempB[i] = 0.0;
-					for( j=0; j<nFR; ++j )
-					{
-						jj = FR_idx[j];
-						tempB[i] += QQ(jj,nZ+i) * tempA[j];
-					}
-				}
-			}
-
-			if ( backsolveT( tempB,BT_TRUE,delta_yAC_TMP ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_STEPDIRECTION_FAILED_TQ );
-		}
-
-		/* refine the solution found so far */
-		for ( i=0; i<nFR; ++i )
-			delta_xFR[i] += delta_xFR_TMP[i];
-		for ( i=0; i<nAC; ++i )
-			delta_yAC[i] += delta_yAC_TMP[i];
-
-		if ( options.numRefinementSteps > 0 )
-		{
-			/* compute residuals in tempA and tempB, and max-norm */
-			for ( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				tempA[i] = delta_g[ii];
-			}
-
-			switch ( hessianType )
-			{
-				case HST_ZERO:
-					if ( usingRegularisation( ) == BT_TRUE )
-						for ( i=0; i<nFR; ++i )
-							tempA[i] += regVal*delta_xFR[i];
-					break;
-
-				case HST_IDENTITY:
-					for ( i=0; i<nFR; ++i )
-						tempA[i] += delta_xFR[i];
-					break;
-
-				default:
-					H->times(bounds.getFree(), bounds.getFree(),  1, 1.0, delta_xFR, nFR, 1.0, tempA, nFR);
-					H->times(bounds.getFree(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, tempA, nFR);
-					break;
-			}
-
-			A->transTimes(constraints.getActive(), bounds.getFree(), 1, -1.0, delta_yAC, nAC, 1.0, tempA, nFR);
-			real_t rnrm = 0.0;
-			for ( i=0; i<nFR; ++i )
-				if (rnrm < getAbs (tempA[i]))
-					rnrm = getAbs (tempA[i]);
-
-			if (!Delta_bC_isZero)
-			{
-				for ( i=0; i<nAC; ++i )
-				{
-					ii = AC_idx[i];
-					if ( constraints.getStatus( ii ) == ST_LOWER )
-						tempB[i] = delta_lbA[ii];
-					else
-						tempB[i] = delta_ubA[ii];
-				}
-			}
-			else
-			{
-				for ( i=0; i<nAC; ++i )
-					tempB[i] = 0.0;
-			}
-			A->times(constraints.getActive(), bounds.getFree(), 1, -1.0, delta_xFR, nFR, 1.0, tempB, nAC);
-			A->times(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, tempB, nAC);
-			for ( i=0; i<nAC; ++i )
-				if (rnrm < getAbs (tempB[i]))
-					rnrm = getAbs (tempB[i]);
-
-			/* early termination of residual norm small enough */
-			if ( rnrm < options.epsIterRef )
-				break;
-		}
-	} /* end of refinement loop for delta_xFRz, delta_xFRy, delta_yAC */
-
-
-	/* IV) DETERMINE delta_yFX */
-	if ( nFX > 0 )
-	{
-		for( i=0; i<nFX; ++i )
-			delta_yFX[i] = delta_g[FX_idx[i]];
-
-		A->transTimes(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_yAC, nAC, 1.0, delta_yFX, nFX);
-
-		switch( hessianType )
-		{
-			case HST_ZERO:
-				if ( usingRegularisation( ) == BT_TRUE )
-					for( i=0; i<nFX; ++i )
-						delta_yFX[i] += regVal*delta_xFX[i];
-				break;
-
-			case HST_IDENTITY:
-				for( i=0; i<nFX; ++i )
-					delta_yFX[i] += 1.0 * delta_xFX[i];
-				break;
-
-			default:
-				H->times(bounds.getFixed(), bounds.getFree(), 1, 1.0, delta_xFR, nFR, 1.0, delta_yFX, nFX);
-				H->times(bounds.getFixed(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, delta_yFX, nFX);
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p e r f o r m S t e p
- */
-returnValue QProblem::performStep(	const real_t* const delta_g,
-									const real_t* const delta_lbA, const real_t* const delta_ubA,
-									const real_t* const delta_lb, const real_t* const delta_ub,
-									const real_t* const delta_xFX, const real_t* const delta_xFR,
-									const real_t* const delta_yAC, const real_t* const delta_yFX,
-									int_t& BC_idx, SubjectToStatus& BC_status, BooleanType& BC_isBound
-									)
-{
-	int_t i, j, ii, jj;
-	int_t nV  = getNV( );
-	int_t nC  = getNC( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-	int_t nIAC = getNIAC( );
-
-	int_t* FR_idx;
-	int_t* FX_idx;
-	int_t* AC_idx;
-	int_t* IAC_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-	constraints.getInactive( )->getNumberArray( &IAC_idx );
-
-	/* initialise maximum steplength array */
-	tau = 1.0;
-	BC_idx = -1;
-	BC_status = ST_UNDEFINED;
-
-	int_t BC_idx_tmp = -1;
-
-	real_t* num = new real_t[ getMax( nV,nC ) ];
-	real_t* den = new real_t[ getMax( nV,nC ) ];
-
-	real_t* delta_Ax_l = new real_t[nC];
-	real_t* delta_Ax_u = new real_t[nC];
-	real_t* delta_Ax   = new real_t[nC];
-
-	real_t* delta_x = new real_t[nV];
-	for( j=0; j<nFR; ++j )
-	{
-		jj = FR_idx[j];
-		delta_x[jj] = delta_xFR[j];
-	}
-	for( j=0; j<nFX; ++j )
-	{
-		jj = FX_idx[j];
-		delta_x[jj] = delta_xFX[j];
-	}
-
-
-	/* I) DETERMINE MAXIMUM DUAL STEPLENGTH: */
-	/* 1) Ensure that active dual constraints' bounds remain valid
-	 *    (ignoring inequality constraints).  */
-	for( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-
-		num[i] = y[nV+ii];
-		den[i] = -delta_yAC[i];
-	}
-
-	performRatioTest( nAC,AC_idx,&constraints, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-	if ( BC_idx_tmp >= 0 )
-	{
-		BC_idx = BC_idx_tmp;
-		BC_status = ST_INACTIVE;
-		BC_isBound = BT_FALSE;
-	}
-
-
-	/* 2) Ensure that active dual bounds remain valid
-	 *    (ignoring implicitly fixed variables). */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-		den[i] = -delta_yFX[i];
-	}
-
-	performRatioTest( nFX,FX_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-	if ( BC_idx_tmp >= 0 )
-	{
-		BC_idx = BC_idx_tmp;
-		BC_status = ST_INACTIVE;
-		BC_isBound = BT_TRUE;
-	}
-
-
- 	/* II) DETERMINE MAXIMUM PRIMAL STEPLENGTH */
-	/* 1) Ensure that inactive constraints' bounds remain valid
-	 *    (ignoring unbounded constraints). */
-
-	/* calculate product A*x */
-	if ( constraintProduct == 0 )
-	{
-		A->times(constraints.getInactive(), 0, 1, 1.0, delta_x, nV, 0.0, delta_Ax, nC, BT_FALSE);
-	}
-	else
-	{
-		for( i=0; i<nIAC; ++i )
-		{
-			ii = IAC_idx[i];
-
-			if ( constraints.getType( ii ) != ST_UNBOUNDED )
-			{
-				if ( (*constraintProduct)( ii,delta_x, &(delta_Ax[ii]) ) != 0 )
-				{
-					delete[] den; delete[] num;
-					delete[] delta_Ax; delete[] delta_Ax_u; delete[] delta_Ax_l; delete[] delta_x;
-					return THROWERROR( RET_ERROR_IN_CONSTRAINTPRODUCT );
-				}
-			}
-		}
-	}
-
-	if ( constraints.hasNoLower( ) == BT_FALSE )
-	{
-		for( i=0; i<nIAC; ++i )
-		{
-			ii = IAC_idx[i];
-			num[i] = getMax( Ax_l[ii],0.0 );
-			den[i] = delta_lbA[ii] - delta_Ax[ii];
-		}
-
-		performRatioTest( nIAC,IAC_idx,&constraints, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_LOWER;
-			BC_isBound = BT_FALSE;
-		}
-	}
-
-	if ( constraints.hasNoUpper( ) == BT_FALSE )
-	{
-		for( i=0; i<nIAC; ++i )
-		{
-			ii = IAC_idx[i];
-			num[i] = getMax( Ax_u[ii],0.0 );
-			den[i] = delta_Ax[ii] - delta_ubA[ii];
-		}
-
-		performRatioTest( nIAC,IAC_idx,&constraints, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_UPPER;
-			BC_isBound = BT_FALSE;
-		}
-	}
-
-
-	for( i=0; i<nIAC; ++i )
-	{
-		ii = IAC_idx[i];
-
-		if ( constraints.getType( ii ) != ST_UNBOUNDED )
-		{
-			delta_Ax_l[ii] = delta_Ax[ii] - delta_lbA[ii];
-			delta_Ax_u[ii] = delta_ubA[ii] - delta_Ax[ii];
-		}
-	}
-
-
-	/* 2) Ensure that inactive bounds remain valid
-	 *    (ignoring unbounded variables). */
-	/* inactive lower bounds */
-	if ( bounds.hasNoLower( ) == BT_FALSE )
-	{
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			num[i] = getMax( x[ii] - lb[ii],0.0 );
-			den[i] = delta_lb[ii] - delta_xFR[i];
-		}
-
-		performRatioTest( nFR,FR_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_LOWER;
-			BC_isBound = BT_TRUE;
-		}
-	}
-
-	/* inactive upper bounds */
-	if ( bounds.hasNoUpper( ) == BT_FALSE )
-	{
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			num[i] = getMax( ub[ii] - x[ii],0.0 );
-			den[i] = delta_xFR[i] - delta_ub[ii];
-		}
-
-		performRatioTest( nFR,FR_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_UPPER;
-			BC_isBound = BT_TRUE;
-		}
-	}
-
-	delete[] den;
-	delete[] num;
-	delete[] delta_x;
-
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-
-	if ( BC_status == ST_UNDEFINED )
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e!",tau );
-	else
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e! (idx = %d, isBound = %d, status = %d)",tau,(int)BC_idx,(int)BC_isBound,(int)BC_status );
-
-	getGlobalMessageHandler( )->throwInfo( RET_STEPSIZE_NONPOSITIVE,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-	#endif
-
-
-	/* III) PERFORM STEP ALONG HOMOTOPY PATH */
-	if ( tau > ZERO )
-	{
-		/* 1) Perform step in primal and dual space... */
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			x[ii] += tau*delta_xFR[i];
-		}
-
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			x[ii] += tau*delta_xFX[i];
-			y[ii] += tau*delta_yFX[i];
-		}
-
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			y[nV+ii] += tau*delta_yAC[i];
-		}
-
-		/* 2) Shift QP data. */
-		for( i=0; i<nV; ++i )
-		{
-			g[i]  += tau*delta_g[i];
-			lb[i] += tau*delta_lb[i];
-			ub[i] += tau*delta_ub[i];
-		}
-
-		for( i=0; i<nC; ++i )
-		{
-			lbA[i] += tau*delta_lbA[i];
-			ubA[i] += tau*delta_ubA[i];
-		}
-
-		A->times( constraints.getActive(),0, 1, 1.0, x, nV, 0.0, Ax, nC, BT_FALSE );
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			Ax_u[ii] = ubA[ii] - Ax[ii];
-			Ax_l[ii] = Ax[ii] - lbA[ii];
-		}
-		for( i=0; i<nIAC; ++i )
-		{
-			ii = IAC_idx[i];
-			if ( constraints.getType( ii ) != ST_UNBOUNDED )
-			{
-				Ax[ii]   += tau*delta_Ax[ii];
-				Ax_l[ii] += tau*delta_Ax_l[ii];
-				Ax_u[ii] += tau*delta_Ax_u[ii];
-			}
-		}
-	}
-	else
-	{
-		/* print a stepsize warning if stepsize is zero */
-		#ifndef __SUPPRESSANYOUTPUT__
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e",tau );
-		getGlobalMessageHandler( )->throwWarning( RET_STEPSIZE,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#endif
-	}
-
-	delete[] delta_Ax; delete[] delta_Ax_u; delete[] delta_Ax_l;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c h a n g e A c t i v e S e t
- */
-returnValue QProblem::changeActiveSet( int_t BC_idx, SubjectToStatus BC_status, BooleanType BC_isBound )
-{
-	int_t nV = getNV( );
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-	switch ( BC_status )
-	{
-		/* Optimal solution found as no working set change detected. */
-		case ST_UNDEFINED:
-			return SUCCESSFUL_RETURN;
-
-		/* Remove one variable from active set. */
-		case ST_INACTIVE:
-			if ( BC_isBound == BT_TRUE )
-			{
-				#ifndef __SUPPRESSANYOUTPUT__
-				snprintf( messageString,MAX_STRING_LENGTH,"bound no. %d.",(int)BC_idx );
-				getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-				#endif
-
-				if ( removeBound( BC_idx,BT_TRUE,BT_TRUE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_REMOVE_FROM_ACTIVESET_FAILED );
-
-				y[BC_idx] = 0.0;
-			}
-			else
-			{
-				#ifndef __SUPPRESSANYOUTPUT__
-				snprintf( messageString,MAX_STRING_LENGTH,"constraint no. %d.",(int)BC_idx );
-				getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-				#endif
-
-				if ( removeConstraint( BC_idx,BT_TRUE,BT_TRUE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_REMOVE_FROM_ACTIVESET_FAILED );
-
-				y[nV+BC_idx] = 0.0;
-			}
-			break;
-
-
-		/* Add one variable to active set. */
-		default:
-			returnValue returnvalue;
-			if ( BC_isBound == BT_TRUE )
-			{
-				#ifndef __SUPPRESSANYOUTPUT__
-				if ( BC_status == ST_LOWER )
-					snprintf( messageString,MAX_STRING_LENGTH,"lower bound no. %d.",(int)BC_idx );
-				else
-					snprintf( messageString,MAX_STRING_LENGTH,"upper bound no. %d.",(int)BC_idx );
-				getGlobalMessageHandler( )->throwInfo( RET_ADD_TO_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-				#endif
-
-				returnvalue = addBound( BC_idx,BC_status,BT_TRUE );
-				if ( returnvalue == RET_ADDBOUND_FAILED_INFEASIBILITY )
-					return returnvalue;
-				if ( returnvalue != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ADD_TO_ACTIVESET_FAILED );
-			}
-			else
-			{
-				#ifndef __SUPPRESSANYOUTPUT__
-				if ( BC_status == ST_LOWER )
-					snprintf( messageString,MAX_STRING_LENGTH,"lower constraint's bound no. %d.",(int)BC_idx );
-				else
-					snprintf( messageString,MAX_STRING_LENGTH,"upper constraint's bound no. %d.",(int)BC_idx );
-				getGlobalMessageHandler( )->throwInfo( RET_ADD_TO_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-				#endif
-
-				returnvalue = addConstraint( BC_idx,BC_status,BT_TRUE );
-				if ( returnvalue == RET_ADDCONSTRAINT_FAILED_INFEASIBILITY )
-					return returnvalue;
-				if ( returnvalue != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ADD_TO_ACTIVESET_FAILED );
-			}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- * g e t R e l a t i v e H o m o t o p y L e n g t h
- */
-real_t QProblem::getRelativeHomotopyLength(	const real_t* const g_new, const real_t* const lb_new, const real_t* const ub_new,
-											const real_t* const lbA_new, const real_t* const ubA_new
-											)
-{
-	int_t i;
-	int_t nC = getNC( );
-	real_t len = QProblemB::getRelativeHomotopyLength( g_new,lb_new,ub_new );
-	real_t d, s;
-
-	/*fprintf( stdFile, "len in homotopyLength = %.3e\n",len ); */
-
-	/* lower constraint bounds */
-	if ( lbA_new != 0 )
-	{
-		for (i = 0; i < nC; i++)
-		{
-			s = getAbs(lbA_new[i]);
-			if (s < 1.0) s = 1.0;
-			d = getAbs(lbA_new[i] - lbA[i]) / s;
-			if (d > len) len = d;
-		}
-	}
-	/*fprintf( stdFile, "len in homotopyLength = %.3e\n",len ); */
-
-	/* upper constraint bounds */
-	if ( ubA_new != 0 )
-	{
-		for (i = 0; i < nC; i++)
-		{
-			s = getAbs(ubA_new[i]);
-			if (s < 1.0) s = 1.0;
-			d = getAbs(ubA_new[i] - ubA[i]) / s;
-			if (d > len) len = d;
-		}
-	}
-	/*fprintf( stdFile, "len in homotopyLength = %.3e\n",len ); */
-
-	return len;
-}
-
-
-/*
- * p e r f o r m R a m p i n g
- */
-returnValue QProblem::performRamping( )
-{
-	int_t nV = getNV( ), nC = getNC( ), bstat, cstat, i, nRamp;
-	real_t tP, rampValP, tD, rampValD, sca;
-
-	/* compute number of values in ramp */
-	nRamp = nV + nC + nC + nV;
-
-	/* ramp inactive variable bounds and active dual bound variables */
-	for (i = 0; i < nV; i++)
-	{
-		switch (bounds.getType(i))
-		{
-			case ST_EQUALITY:
-				lb[i] = x[i]; ub[i] = x[i];  /* reestablish exact feasibility */
-				continue;
-
-			case ST_BOUNDED:
-				tP = static_cast<real_t>((i+rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-				rampValP = (1.0-tP) * ramp0 + tP * ramp1;
-				tD = static_cast<real_t>((nV+nC+nC+i+rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-				rampValD = (1.0-tD) * ramp0 + tD * ramp1;
-				bstat = bounds.getStatus(i);
-				if (bstat != ST_LOWER) { sca = getMax(getAbs(x[i]), 1.0); lb[i] = x[i] - sca * rampValP; }
-				if (bstat != ST_UPPER) { sca = getMax(getAbs(x[i]), 1.0); ub[i] = x[i] + sca * rampValP; }
-				if (bstat == ST_LOWER) { lb[i] = x[i]; y[i] = +rampValD; }
-				if (bstat == ST_UPPER) { ub[i] = x[i]; y[i] = -rampValD; }
-				if (bstat == ST_INACTIVE) y[i] = 0.0; /* reestablish exact complementarity */
-				break;
-
-			case ST_UNBOUNDED:
-			case ST_DISABLED:
-			default:
-				 continue;
-		}
-	}
-
-	/* ramp inactive constraints and active dual constraint variables */
-	for (i = 0; i < nC; i++)
-	{
-		switch (constraints.getType(i))
-		{
-			case ST_EQUALITY:
-				lbA[i] = Ax[i]; ubA[i] = Ax[i];  /* reestablish exact feasibility */
-				continue;
-
-			case ST_BOUNDED:
-				tP = static_cast<real_t>((nV+i+rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-				rampValP = (1.0-tP) * ramp0 + tP * ramp1;
-				tD = static_cast<real_t>((nV+nC+i+rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-				rampValD = (1.0-tD) * ramp0 + tD * ramp1;
-				cstat = constraints.getStatus(i);
-				if (cstat != ST_LOWER) { sca = getMax(getAbs(Ax[i]), 1.0); lbA[i] = Ax[i] - sca * rampValP; }
-				if (cstat != ST_UPPER) { sca = getMax(getAbs(Ax[i]), 1.0); ubA[i] = Ax[i] + sca * rampValP; }
-				if (cstat == ST_LOWER) { lbA[i] = Ax[i]; y[nV+i] = +rampValD; }
-				if (cstat == ST_UPPER) { ubA[i] = Ax[i]; y[nV+i] = -rampValD; }
-				if (cstat == ST_INACTIVE) y[nV+i] = 0.0; /* reestablish exact complementarity */
-
-				Ax_l[i] = Ax[i] - lbA[i];
-				Ax_u[i] = ubA[i] - Ax[i];
-				break;
-
-			case ST_UNBOUNDED:
-			case ST_DISABLED:
-			default:
-				continue;
-		}
-	}
-
-	/* reestablish exact stationarity */
-	setupAuxiliaryQPgradient( );
-
-	/* advance ramp offset to avoid Ramping cycles */
-	rampOffset++;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- * u p d a t e F a r B o u n d s
- */
-returnValue QProblem::updateFarBounds(	real_t curFarBound, int_t nRamp,
-										const real_t* const lb_new, real_t* const lb_new_far,
-										const real_t* const ub_new, real_t* const ub_new_far,
-										const real_t* const lbA_new, real_t* const lbA_new_far,
-										const real_t* const ubA_new, real_t* const ubA_new_far
-										) const
-{
-	int_t i;
-	real_t rampVal, t;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-    returnValue returnvalue = QProblemB::updateFarBounds(	curFarBound,nRamp,
-															lb_new,lb_new_far, ub_new,ub_new_far
-															);
-    if ( returnvalue != SUCCESSFUL_RETURN )
-        return returnvalue;
-
-	if ( options.enableRamping == BT_TRUE )
-	{
-		for ( i=0; i<nC; ++i )
-		{
-			t = static_cast<real_t>((nV+i + rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-			rampVal = curFarBound * (1.0 + (1.0-t)*ramp0 + t*ramp1);
-
-			if ( lbA_new == 0 )
-				lbA_new_far[i] = -rampVal;
-			else
-				lbA_new_far[i] = getMax( -rampVal,lbA_new[i] );
-
-			if ( ubA_new == 0 )
-				ubA_new_far[i] = rampVal;
-			else
-				ubA_new_far[i] = getMin( rampVal,ubA_new[i] );
-		}
-	}
-	else
-	{
-		for ( i=0; i<nC; ++i )
-		{
-			if ( lbA_new == 0 )
-				lbA_new_far[i] = -curFarBound;
-			else
-				lbA_new_far[i] = getMax( -curFarBound,lbA_new[i] );
-
-			if ( ubA_new == 0 )
-				ubA_new_far[i] = curFarBound;
-			else
-				ubA_new_far[i] = getMin( curFarBound,ubA_new[i] );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- * p e r f o r m D r i f t C o r r e c t i o n
- */
-returnValue QProblem::performDriftCorrection( )
-{
-	int_t i;
-	int_t nV = getNV ();
-	int_t nC = getNC ();
-
-	for ( i=0; i<nV; ++i )
-	{
-		switch ( bounds.getType ( i ) )
-		{
-			case ST_BOUNDED:
-				switch ( bounds.getStatus ( i ) )
-				{
-					case ST_LOWER:
-						lb[i] = x[i];
-						ub[i] = getMax (ub[i], x[i]);
-						y[i] = getMax (y[i], 0.0);
-						break;
-					case ST_UPPER:
-						lb[i] = getMin (lb[i], x[i]);
-						ub[i] = x[i];
-						y[i] = getMin (y[i], 0.0);
-						break;
-					case ST_INACTIVE:
-						lb[i] = getMin (lb[i], x[i]);
-						ub[i] = getMax (ub[i], x[i]);
-						y[i] = 0.0;
-						break;
-					case ST_UNDEFINED:
-					case ST_INFEASIBLE_LOWER:
-					case ST_INFEASIBLE_UPPER:
-						break;
-				}
-				break;
-			case ST_EQUALITY:
-				lb[i] = x[i];
-				ub[i] = x[i];
-				break;
-			case ST_UNBOUNDED:
-			case ST_UNKNOWN:
-            case ST_DISABLED:
-				break;
-		}
-	}
-
-	for ( i=0; i<nC; ++i )
-	{
-		switch ( constraints.getType ( i ) )
-		{
-			case ST_BOUNDED:
-				switch ( constraints.getStatus ( i ) )
-				{
-					case ST_LOWER:
-						lbA[i] = Ax[i];
-						Ax_l[i] = 0.0;
-						ubA[i] = getMax (ubA[i], Ax[i]);
-						Ax_u[i] = ubA[i] - Ax[i];
-						y[i+nV] = getMax (y[i+nV], 0.0);
-						break;
-					case ST_UPPER:
-						lbA[i] = getMin (lbA[i], Ax[i]);
-						Ax_l[i] = Ax[i] - lbA[i];
-						ubA[i] = Ax[i];
-						Ax_u[i] = 0.0;
-						y[i+nV] = getMin (y[i+nV], 0.0);
-						break;
-					case ST_INACTIVE:
-						lbA[i] = getMin (lbA[i], Ax[i]);
-						Ax_l[i] = Ax[i] - lbA[i];
-						ubA[i] = getMax (ubA[i], Ax[i]);
-						Ax_u[i] = ubA[i] - Ax[i];
-						y[i+nV] = 0.0;
-						break;
-					case ST_UNDEFINED:
-					case ST_INFEASIBLE_LOWER:
-					case ST_INFEASIBLE_UPPER:
-						break;
-				}
-				break;
-			case ST_EQUALITY:
-				lbA[i] = Ax[i];
-				Ax_l[i] = 0.0;
-				ubA[i] = Ax[i];
-				Ax_u[i] = 0.0;
-				break;
-			case ST_UNBOUNDED:
-			case ST_UNKNOWN:
-            case ST_DISABLED:
-				break;
-		}
-	}
-
-	return setupAuxiliaryQPgradient( );
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P
- */
-returnValue QProblem::setupAuxiliaryQP( const Bounds* const guessedBounds, const Constraints* const guessedConstraints )
-{
-	int_t i, j;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	/* consistency check */
-	if ( ( guessedBounds == 0 ) || ( guessedConstraints == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* nothing to do */
-	if ( ( guessedBounds == &bounds ) && ( guessedConstraints == &constraints ) )
-		return SUCCESSFUL_RETURN;
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* I) SETUP WORKING SET ... */
-	if ( shallRefactorise( guessedBounds,guessedConstraints ) == BT_TRUE )
-	{
-		/* ... WITH REFACTORISATION: */
-		/* 1) Reset bounds/constraints ... */
-		bounds.init( nV );
-		constraints.init( nC );
-
-		/*    ... and set them up afresh. */
-		if ( setupSubjectToType( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		if ( constraints.setupAllInactive( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* 2) Setup TQ factorisation. */
-		if ( setupTQfactorisation( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* 3) Setup guessed working sets afresh. */
-		if ( setupAuxiliaryWorkingSet( guessedBounds,guessedConstraints,BT_TRUE ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* 4) Computes Cholesky decomposition of projected Hessian
-		 *    This now handles all special cases (no active bounds/constraints, no nullspace) */
-		if ( computeProjectedCholesky( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-	else
-	{
-		/* ... WITHOUT REFACTORISATION: */
-		if ( setupAuxiliaryWorkingSet( guessedBounds,guessedConstraints,BT_FALSE ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-
-
-	/* II) SETUP AUXILIARY QP DATA: */
-	/* 1) Ensure that dual variable is zero for free bounds and inactive constraints. */
-	for ( i=0; i<nV; ++i )
-		if ( bounds.getStatus( i ) == ST_INACTIVE )
-			y[i] = 0.0;
-
-	for ( i=0; i<nC; ++i )
-		if ( constraints.getStatus( i ) == ST_INACTIVE )
-			y[nV+i] = 0.0;
-
-	/* 2) Setup gradient and (constraints') bound vectors. */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-		THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	A->times(1, 1.0, x, nV, 0.0, Ax, nC);
-	for ( j=0; j<nC; ++j )
-	{
-		Ax_l[j] = Ax[j];
-		Ax_u[j] = Ax[j];
-	}
-
-	/* (also sets Ax_l and Ax_u) */
-	if ( setupAuxiliaryQPbounds( 0,0,BT_FALSE ) != SUCCESSFUL_RETURN )
-		THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s h a l l R e f a c t o r i s e
- */
-
-BooleanType QProblem::shallRefactorise(	const Bounds* const guessedBounds,
-										const Constraints* const guessedConstraints
-										) const
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	/* always refactorise if Hessian is not known to be positive definite */
-	if ( ( hessianType == HST_SEMIDEF ) || ( hessianType == HST_INDEF ) )
-		return BT_TRUE;
-
-	/* 1) Determine number of bounds that have same status
-	 *    in guessed AND current bounds.*/
-	int_t differenceNumberBounds = 0;
-
-	for( i=0; i<nV; ++i )
-		if ( guessedBounds->getStatus( i ) != bounds.getStatus( i ) )
-			++differenceNumberBounds;
-
-	/* 2) Determine number of constraints that have same status
-	 *    in guessed AND current constraints.*/
-	int_t differenceNumberConstraints = 0;
-
-	for( i=0; i<nC; ++i )
-		if ( guessedConstraints->getStatus( i ) != constraints.getStatus( i ) )
-			++differenceNumberConstraints;
-
-	/* 3) Decide wheter to refactorise or not. */
-	if ( 2*(differenceNumberBounds+differenceNumberConstraints) > guessedConstraints->getNAC( )+guessedBounds->getNFX( ) )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *	s e t u p Q P d a t a
- */
-returnValue QProblem::setupQPdata(	SymmetricMatrix *_H, const real_t* const _g, Matrix *_A,
-									const real_t* const _lb, const real_t* const _ub,
-									const real_t* const _lbA, const real_t* const _ubA
-									)
-{
-	int_t nC = getNC( );
-
-#ifdef __WRITE_DATA_FILES__
-	{
-		int_t i;
-		const double Infinity = 1e20;
-		int_t nV = getNV( );
-		GlobalOutputFileCounter++;
-		char buf[256];
-		snprintf(buf,256,"QP%d_setupQPdata.dat",GlobalOutputFileCounter);
-		MyPrintf("+++ Writing output file %s\n", buf);
-
-		FILE* output_file = fopen(buf,"w");
-
-		fprintf(output_file,"nVar = %d\n", nV);
-		fprintf(output_file,"nCon = %d\n", nC);
-
-		_H->writeToFile(output_file,"H_");
-		for (i=0; i<nV; i++) {
-			fprintf(output_file,"g[%d] = %23.16e\n",i,_g[i]);
-		}
-		_A->writeToFile(output_file,"A_");
-		for (i=0; i<nV; i++) {
-			fprintf(output_file,"lb[%d] = %23.16e\n",i,getMax(-Infinity,_lb[i]));
-		}
-		for (i=0; i<nV; i++) {
-			fprintf(output_file,"ub[%d] = %23.16e\n",i,getMin(Infinity,_ub[i]));
-		}
-
-		for (i=0; i<nC; i++) {
-			fprintf(output_file,"lbA[%d] = %23.16e\n",i,getMax(-Infinity,_lbA[i]));
-		}
-		for (i=0; i<nC; i++) {
-			fprintf(output_file,"ubA[%d] = %23.16e\n",i,getMin(Infinity,_ubA[i]));
-		}
-		fclose(output_file);
-  }
-#endif
-
-	/* 1) Load Hessian matrix as well as lower and upper bounds vectors. */
-	if ( QProblemB::setupQPdata( _H,_g,_lb,_ub ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( nC > 0 ) && ( _A == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( nC > 0 )
-	{
-		/* 2) Setup lower/upper constraints' bounds vector. */
-		setLBA( _lbA );
-		setUBA( _ubA );
-
-		/* 3) Only load constraint matrix after setting up vectors! */
-		setA( _A );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p Q P d a t a
- */
-returnValue QProblem::setupQPdata(	const real_t* const _H, const real_t* const _g, const real_t* const _A,
-									const real_t* const _lb, const real_t* const _ub,
-									const real_t* const _lbA, const real_t* const _ubA
-									)
-{
-	int_t nC = getNC( );
-
-	/* 1) Load Hessian matrix as well as lower and upper bounds vectors. */
-	if ( QProblemB::setupQPdata( _H,_g,_lb,_ub ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( nC > 0 ) && ( _A == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( nC > 0 )
-	{
-		/* 2) Setup lower/upper constraints' bounds vector. */
-		setLBA( _lbA );
-		setUBA( _ubA );
-
-		/* 3) Only load constraint matrix after setting up vectors! */
-		setA( _A );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p Q P d a t a F r o m F i l e
- */
-returnValue QProblem::setupQPdataFromFile(	const char* const H_file, const char* const g_file, const char* const A_file,
-											const char* const lb_file, const char* const ub_file,
-											const char* const lbA_file, const char* const ubA_file
-											)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	returnValue returnvalue;
-
-
-	/* 1) Load Hessian matrix as well as lower and upper bounds vectors from files. */
-	returnvalue = QProblemB::setupQPdataFromFile( H_file,g_file,lb_file,ub_file );
-	if ( returnvalue != SUCCESSFUL_RETURN )
-		return THROWERROR( returnvalue );
-
-	if ( ( nC > 0 ) && ( A_file == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( nC > 0 )
-	{
-		/* 2) Load lower constraints' bounds vector from file. */
-		if ( lbA_file != 0 )
-		{
-			returnvalue = readFromFile( lbA, nC, lbA_file );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( returnvalue );
-		}
-		else
-		{
-			/* if no lower constraints' bounds are specified, set them to -infinity */
-			for( i=0; i<nC; ++i )
-				lbA[i] = -INFTY;
-		}
-
-		/* 3) Load upper constraints' bounds vector from file. */
-		if ( ubA_file != 0 )
-		{
-			returnvalue = readFromFile( ubA, nC, ubA_file );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( returnvalue );
-		}
-		else
-		{
-			/* if no upper constraints' bounds are specified, set them to infinity */
-			for( i=0; i<nC; ++i )
-				ubA[i] = INFTY;
-		}
-
-		/* 4) Only load constraint matrix from file after setting up vectors! */
-		real_t* _A = new real_t[nC * nV];
-		returnvalue = readFromFile( _A, nC,nV, A_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] _A;
-			return THROWERROR( returnvalue );
-		}
-		setA( _A );
-		A->doFreeMemory( );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	l o a d Q P v e c t o r s F r o m F i l e
- */
-returnValue QProblem::loadQPvectorsFromFile(	const char* const g_file, const char* const lb_file, const char* const ub_file,
-												const char* const lbA_file, const char* const ubA_file,
-												real_t* const g_new, real_t* const lb_new, real_t* const ub_new,
-												real_t* const lbA_new, real_t* const ubA_new
-												) const
-{
-	int_t nC = getNC( );
-
-	returnValue returnvalue;
-
-
-	/* 1) Load gradient vector as well as lower and upper bounds vectors from files. */
-	returnvalue = QProblemB::loadQPvectorsFromFile( g_file,lb_file,ub_file, g_new,lb_new,ub_new );
-	if ( returnvalue != SUCCESSFUL_RETURN )
-		return THROWERROR( returnvalue );
-
-	if ( nC > 0 )
-	{
-		/* 2) Load lower constraints' bounds vector from file. */
-		if ( lbA_file != 0 )
-		{
-			if ( lbA_new != 0 )
-			{
-				returnvalue = readFromFile( lbA_new, nC, lbA_file );
-				if ( returnvalue != SUCCESSFUL_RETURN )
-					return THROWERROR( returnvalue );
-			}
-			else
-			{
-				/* If filename is given, storage must be provided! */
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			}
-		}
-
-		/* 3) Load upper constraints' bounds vector from file. */
-		if ( ubA_file != 0 )
-		{
-			if ( ubA_new != 0 )
-			{
-				returnvalue = readFromFile( ubA_new, nC, ubA_file );
-				if ( returnvalue != SUCCESSFUL_RETURN )
-					return THROWERROR( returnvalue );
-			}
-			else
-			{
-				/* If filename is given, storage must be provided! */
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t I t e r a t i o n
- */
-returnValue QProblem::printIteration( 	int_t iter,
-										int_t BC_idx,	SubjectToStatus BC_status, BooleanType BC_isBound, real_t homotopyLength,
-										BooleanType isFirstCall
-		  								)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	/* consistency check */
-	if ( iter < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	int_t i;
-	int_t nV = getNV();
-	int_t nC = getNC();
-	int_t nAC = getNAC();
-
-	real_t stat, bfeas, cfeas, bcmpl, ccmpl, Tmaxomin;
-	real_t *grad = 0;
-	real_t *AX = 0;
-	real_t Tmin, Tmax;
-
-	char myPrintfString[MAX_STRING_LENGTH];
-	char info[MAX_STRING_LENGTH];
-	const char excStr[] = " ef";
-
-	switch ( options.printLevel )
-	{
-		case PL_DEBUG_ITER:
-			grad = new real_t[nV];
-			AX = new real_t[nC];
-			stat = bfeas = cfeas = bcmpl = ccmpl = Tmaxomin = 0.0;
-
-			/* stationarity */
-			for (i = 0; i < nV; i++) grad[i] = g[i] - y[i];
-
-			switch ( hessianType )
-			{
-				case HST_ZERO:
-					for( i=0; i<nV; ++i )
-						grad[i] += regVal * x[i];
-					break;
-
-				case HST_IDENTITY:
-					for( i=0; i<nV; ++i )
-						grad[i] += 1.0 * x[i];
-					break;
-
-				default:
-					H->times(1, 1.0, x, nV, 1.0, grad, nV);
-					break;
-			}
-
-			A->transTimes(1, -1.0, y+nV, nC, 1.0, grad, nV);
-			for (i = 0; i < nV; i++) if (getAbs(grad[i]) > stat) stat = getAbs(grad[i]);
-
-			/* feasibility */
-			for (i = 0; i < nV; i++) if (lb[i] - x[i] > bfeas) bfeas = lb[i] - x[i];
-			for (i = 0; i < nV; i++) if (x[i] - ub[i] > bfeas) bfeas = x[i] - ub[i];
-			A->times(1, 1.0, x, nV, 0.0, AX, nC);
-			for (i = 0; i < nC; i++) if (lbA[i] - AX[i] > cfeas) cfeas = lbA[i] - AX[i];
-			for (i = 0; i < nC; i++) if (AX[i] - ubA[i] > cfeas) cfeas = AX[i] - ubA[i];
-
-			/* complementarity */
-			for (i = 0; i < nV; i++) if (y[i] > +EPS && getAbs((lb[i] - x[i])*y[i]) > bcmpl) bcmpl = getAbs((lb[i] - x[i])*y[i]);
-			for (i = 0; i < nV; i++) if (y[i] < -EPS && getAbs((ub[i] - x[i])*y[i]) > bcmpl) bcmpl = getAbs((ub[i] - x[i])*y[i]);
-			for (i = 0; i < nC; i++) if (y[nV+i] > +EPS && getAbs((lbA[i]-AX[i])*y[nV+i]) > ccmpl) ccmpl = getAbs((lbA[i]-AX[i])*y[nV+i]);
-			for (i = 0; i < nC; i++) if (y[nV+i] < -EPS && getAbs((ubA[i]-AX[i])*y[nV+i]) > ccmpl) ccmpl = getAbs((ubA[i]-AX[i])*y[nV+i]);
-
-			Tmin = 1.0e16; Tmax = 0.0;
-			for (i = 0; i < nAC; i++)
-				if (getAbs(TT(i,sizeT-i-1)) < Tmin)
-					Tmin = getAbs(TT(i,sizeT-i-1));
-				else if (getAbs(TT(i,sizeT-i-1)) > Tmax)
-					Tmax = getAbs(TT(i,sizeT-i-1));
-			Tmaxomin = Tmax/Tmin;
-
-			if ( (iter % 10 == 0) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "\n%5s %4s %4s %4s %4s %9s %9s %9s %9s %9s %9s %9s %9s\n",
-						"iter", "addB", "remB", "addC", "remC", "hom len", "tau", "stat",
-						"bfeas", "cfeas", "bcmpl", "ccmpl", "Tmin");
-				myPrintf( myPrintfString );
-			}
-
-			if ( isFirstCall == BT_TRUE )
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d ",(int)iter );
-			else
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d*",(int)iter );
-			myPrintf( myPrintfString );
-
-			if (tabularOutput.idxAddB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxAddB) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			if (tabularOutput.idxRemB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxRemB) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			if (tabularOutput.idxAddC >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxAddC) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			if (tabularOutput.idxRemC >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxRemC) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%9.2e %9.2e %9.2e %9.2e %9.2e %9.2e %9.2e %9.2e\n",
-					homotopyLength, tau, stat, bfeas, cfeas, bcmpl, ccmpl, Tmin);
-			myPrintf( myPrintfString );
-
-			delete[] AX;
-			delete[] grad;
-			break;
-
-		case PL_TABULAR:
-			if ( (iter % 10 == 0) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "\n%5s %6s %6s %6s %6s %9s %9s\n",
-						"iter", "addB", "remB", "addC", "remC", "hom len", "tau" );
-				myPrintf( myPrintfString );
-			}
-			if ( isFirstCall == BT_TRUE )
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d ",(int)iter);
-			else
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d*",(int)iter);
-			myPrintf( myPrintfString );
-
-			if (tabularOutput.idxAddB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxAddB), excStr[tabularOutput.excAddB]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			if (tabularOutput.idxRemB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxRemB), excStr[tabularOutput.excRemB]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			if (tabularOutput.idxAddC >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxAddC), excStr[tabularOutput.excAddC]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			if (tabularOutput.idxRemC >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxRemC), excStr[tabularOutput.excRemC]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%9.2e %9.2e\n", homotopyLength, tau);
-			myPrintf( myPrintfString );
-			break;
-
-		case PL_MEDIUM:
-			/* 1) Print header at first iteration. */
- 			if ( ( iter == 0 ) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH,"\n\n####################   qpOASES  --  QP NO. %3.0d   #####################\n\n",(int)count );
-				myPrintf( myPrintfString );
-
-				myPrintf( "    Iter   |    StepLength    |       Info       |   nFX   |   nAC    \n" );
-				myPrintf( " ----------+------------------+------------------+---------+--------- \n" );
-			}
-
-			/* 2) Print iteration line. */
-			if ( BC_status == ST_UNDEFINED )
-			{
-				if ( hessianType == HST_ZERO )
-					snprintf( info,3,"LP" );
-				else
-					snprintf( info,3,"QP" );
-
-				if ( isFirstCall == BT_TRUE )
-					snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d   |   %1.6e   |    %s SOLVED     |  %4.1d   |  %4.1d   \n", (int)iter,tau,info,(int)getNFX( ),(int)getNAC( ) );
-				else
-					snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d*  |   %1.6e   |    %s SOLVED     |  %4.1d   |  %4.1d   \n", (int)iter,tau,info,(int)getNFX( ),(int)getNAC( ) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				if ( BC_status == ST_INACTIVE )
-					snprintf( info,5,"REM " );
-				else
-					snprintf( info,5,"ADD " );
-
-				if ( BC_isBound == BT_TRUE )
-					snprintf( &(info[4]),4,"BND" );
-				else
-					snprintf( &(info[4]),4,"CON" );
-
-				snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d   |   %1.6e   |   %s %4.1d   |  %4.1d   |  %4.1d   \n", (int)iter,tau,info,(int)BC_idx,(int)getNFX( ),(int)getNAC( ) );
-				myPrintf( myPrintfString );
-			}
-			break;
-
-		default:
-			/* nothing to display */
-			break;
-	}
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-inline real_t abs (real_t x) { return (x>0)?x:-x; }
-
-/*
- * d r o p I n f e a s i b l e s
- */
-returnValue QProblem::dropInfeasibles( int_t BC_number, SubjectToStatus BC_status, BooleanType BC_isBound,
-										real_t *xiB, real_t *xiC )
-{
-	int_t i;
-
-	int_t nAC                   = getNAC ();
-	int_t nFX                   = getNFX ();
-	int_t blockingPriority      = (BC_isBound) ? options.dropBoundPriority : options.dropIneqConPriority;
-	int_t y_min_number          = -1;
-	BooleanType y_min_isBound = BC_isBound;
-	int_t y_min_priority        = blockingPriority;
-
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	if (options.dropEqConPriority <= y_min_priority)
-	{
-		// look for an equality constraint we can drop according to priorities
-		for ( i = 0; i < nAC; ++i )
-			if ( (constraints.getType (i) == ST_EQUALITY)
-				&& (getAbs (xiC[i]) > options.epsDen) )
-			{
-				y_min_number = AC_idx[i];
-				y_min_isBound = BT_FALSE;
-				y_min_priority = options.dropEqConPriority;
-				break;
-			}
-	}
-
-	if (options.dropIneqConPriority <= y_min_priority)
-	{
-		// look for an inequality constraint we can drop according to priorities
-		for ( i = 0; i < nAC; ++i )
-			if ( (constraints.getType (i) == ST_BOUNDED)
-				&& (getAbs (xiC[i]) > options.epsDen) )
-			{
-				y_min_number = AC_idx[i];
-				y_min_isBound = BT_FALSE;
-				y_min_priority = options.dropIneqConPriority;
-				break;
-			}
-	}
-
-	if (options.dropBoundPriority <= y_min_priority)
-	{
-		// look for a simple bound we can drop according to priorities
-		for ( i = 0; i < nFX; ++i )
-			if (getAbs (xiB[i]) > options.epsDen)
-			{
-				y_min_number = FX_idx[i];
-				y_min_isBound = BT_TRUE;
-				y_min_priority = options.dropBoundPriority;
-				break;
-			}
-	}
-
-	if (y_min_number >= 0) {
-
-		// drop active equality or active bound we have found
-		if (y_min_isBound) {
-			SubjectToStatus status_ = bounds.getStatus (y_min_number);
-			removeBound (y_min_number, BT_TRUE, BT_FALSE, BT_FALSE);
-			bounds.setStatus (y_min_number, (status_ == ST_LOWER) ? ST_INFEASIBLE_LOWER : ST_INFEASIBLE_UPPER);
-			// TODO: fix duals y[]
-			/* fprintf (stdFile, "Dropping bounds %d for %s %d\n", y_min_number, BC_isBound?"bound":"constraint", BC_number); */
-		} else {
-			SubjectToStatus status_ = constraints.getStatus (y_min_number);
-			removeConstraint (y_min_number, BT_TRUE, BT_FALSE, BT_FALSE);
-			constraints.setStatus (y_min_number, (status_ == ST_LOWER) ? ST_INFEASIBLE_LOWER : ST_INFEASIBLE_UPPER);
-			// TODO: fix duals y[]
-			/* fprintf (stdFile, "Dropping constraint %d for %s %d\n", y_min_number, BC_isBound?"bound":"constraint", BC_number); */
-		}
-
-		// ... now return, add the blocking constraint, and continue solving QP with dropped bound/constraint
-		return SUCCESSFUL_RETURN;
-
-	} else {
-
-		// nothing found, then drop the blocking (still inactive) constraint
-		if (BC_isBound)
-			bounds.setStatus (BC_number, (BC_status == ST_LOWER) ? ST_INFEASIBLE_LOWER : ST_INFEASIBLE_UPPER);
-		else
-			constraints.setStatus (BC_number, (BC_status == ST_LOWER) ? ST_INFEASIBLE_LOWER : ST_INFEASIBLE_UPPER);
-
-		/* fprintf (stdFile, "Dropping %s %d itself\n", BC_isBound?"bound":"constraint", BC_number); */
-
-		// ... now return, and continue solving QP with dropped bound/constraint
-		return RET_ENSURELI_DROPPED;
-	}
-}
-
-
-
-/*
- *  w r i t e Q p D a t a I n t o M a t F i l e
- */
-returnValue QProblem::writeQpDataIntoMatFile(	const char* const filename
-												) const
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	FILE* matFile;
-	matFile = fopen( filename,"w+" );
-
-	if ( matFile == 0 )
-		return RET_UNABLE_TO_OPEN_FILE;
-
-	int_t nV = getNV();
-	int_t nC = getNC();
-
-	real_t* Hfull = H->full();
-	writeIntoMatFile( matFile, Hfull, nV,nV, "H"   );
-	delete[] Hfull;
-
-	writeIntoMatFile( matFile, g,     nV,1,  "g"   );
-
-	real_t* Afull = A->full();
-	writeIntoMatFile( matFile, Afull, nC,nV, "A"   );
-	delete[] Afull;
-
-	writeIntoMatFile( matFile, lb,    nV,1,  "lb"  );
-	writeIntoMatFile( matFile, ub,    nV,1,  "ub"  );
-	writeIntoMatFile( matFile, lbA,   nC,1,  "lbA" );
-	writeIntoMatFile( matFile, ubA,   nC,1,  "ubA" );
-
-	fclose( matFile );
-
-	return SUCCESSFUL_RETURN;
-    
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *  w r i t e Q p W o r k s p a c e I n t o M a t F i l e
- */
-returnValue QProblem::writeQpWorkspaceIntoMatFile(	const char* const filename
-													)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	FILE* matFile;
-	matFile = fopen( filename,"w+" );
-
-	if ( matFile == 0 )
-		return RET_UNABLE_TO_OPEN_FILE;
-
-	int_t nV = getNV();
-	int_t nC = getNC();
-	int_t nFR  = getNFR();
-	int_t nFX  = getNFX();
-	int_t nAC  = getNAC();
-	int_t nIAC = getNIAC();
-
-
-	writeIntoMatFile( matFile, T, sizeT,sizeT, "T" );
-	writeIntoMatFile( matFile, Q, nV,nV, "Q" );
-
-	writeIntoMatFile( matFile, Ax, nC,1, "Ax" );
-	writeIntoMatFile( matFile, Ax_l, nC,1, "Ax_l" );
-	writeIntoMatFile( matFile, Ax_u, nC,1, "Ax_u" );
-
-
-	int_t *FR_idx, *FX_idx, *AC_idx, *IAC_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-	constraints.getInactive( )->getNumberArray( &IAC_idx );
-
-	writeIntoMatFile( matFile, FR_idx,  nFR, 1, "FR_idx"  );
-	writeIntoMatFile( matFile, FX_idx,  nFX, 1, "FX_idx"  );
-	writeIntoMatFile( matFile, AC_idx,  nAC, 1, "AC_idx"  );
-	writeIntoMatFile( matFile, IAC_idx, nIAC,1, "IAC_idx" );
-
-	fclose( matFile );
-
-	return SUCCESSFUL_RETURN;
-    
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/QProblemB.cpp b/extlibs/qpOASES-3.2.0/src/QProblemB.cpp
deleted file mode 100644
index b1812c4..0000000
--- a/extlibs/qpOASES-3.2.0/src/QProblemB.cpp
+++ /dev/null
@@ -1,3850 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/QProblemB.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the QProblemB class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming.
- */
-
-
-#include <qpOASES/QProblemB.hpp>
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	Q P r o b l e m B
- */
-QProblemB::QProblemB( )
-{
-	/* print copyright notice */
-	if (options.printLevel != PL_NONE)
-		printCopyrightNotice( );
-
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-
-	freeHessian = BT_FALSE;
-	H = 0;
-
-	g = 0;
-	lb = 0;
-	ub = 0;
-
-	R = 0;
-	haveCholesky = BT_FALSE;
-
-	x = 0;
-	y = 0;
-
-	tau = 0.0;
-
-	hessianType = HST_UNKNOWN;
-	regVal = 0.0;
-
-	infeasible  = BT_FALSE;
-	unbounded   = BT_FALSE;
-
-	status = QPS_NOTINITIALISED;
-
-	count = 0;
-
-	ramp0 = options.initialRamping;
-	ramp1 = options.finalRamping;
-	rampOffset = 0;
-
-	delta_xFR_TMP = 0;
-
-	setPrintLevel( options.printLevel );
-}
-
-
-/*
- *	Q P r o b l e m B
- */
-QProblemB::QProblemB( int_t _nV, HessianType _hessianType )
-{
-	int_t i;
-
-	/* print copyright notice */
-	if (options.printLevel != PL_NONE)
-		printCopyrightNotice( );
-
-	/* consistency check */
-	if ( _nV <= 0 )
-	{
-		_nV = 1;
-		THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-
-	freeHessian = BT_FALSE;
-	H = 0;
-
-	g = new real_t[_nV];
-	for( i=0; i<_nV; ++i ) g[i] = 0.0;
-
-	lb = new real_t[_nV];
-	for( i=0; i<_nV; ++i ) lb[i] = 0.0;
-
-	ub = new real_t[_nV];
-	for( i=0; i<_nV; ++i ) ub[i] = 0.0;
-
-	bounds.init( _nV );
-
-	R = new real_t[_nV*_nV];
-	for( i=0; i<_nV*_nV; ++i ) R[i] = 0.0;
-	haveCholesky = BT_FALSE;
-
-	x = new real_t[_nV];
-	for( i=0; i<_nV; ++i ) x[i] = 0.0;
-
-	y = new real_t[_nV];
-	for( i=0; i<_nV; ++i ) y[i] = 0.0;
-
-	tau = 0.0;
-
-	hessianType = _hessianType;
-	regVal = 0.0;
-
-	infeasible  = BT_FALSE;
-	unbounded   = BT_FALSE;
-
-	status = QPS_NOTINITIALISED;
-
-	count = 0;
-
-	ramp0 = options.initialRamping;
-	ramp1 = options.finalRamping;
-	rampOffset = 0;
-
-	delta_xFR_TMP = new real_t[_nV];
-
-	setPrintLevel( options.printLevel );
-
-	flipper.init( (uint_t)_nV );
-}
-
-
-/*
- *	Q P r o b l e m B
- */
-QProblemB::QProblemB( const QProblemB& rhs )
-{
-	freeHessian = BT_FALSE;
-	H = 0;
-
-	copy( rhs );
-}
-
-
-/*
- *	~ Q P r o b l e m B
- */
-QProblemB::~QProblemB( )
-{
-	clear( );
-
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-QProblemB& QProblemB::operator=( const QProblemB& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-/*
- *	r e s e t
- */
-returnValue QProblemB::reset( )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Reset bounds. */
-	bounds.init( nV );
-
-	/* 2) Reset Cholesky decomposition. */
-	if ( R!=0 )
-		for( i=0; i<nV*nV; ++i )
-			R[i] = 0.0;
-
-	haveCholesky = BT_FALSE;
-
-	/* 3) Reset steplength and status flags. */
-	tau = 0.0;
-
-	hessianType = HST_UNKNOWN;
-	regVal = 0.0;
-
-	infeasible  = BT_FALSE;
-	unbounded   = BT_FALSE;
-
-	status = QPS_NOTINITIALISED;
-
-	ramp0 = options.initialRamping;
-	ramp1 = options.finalRamping;
-	rampOffset = 0;
-
-	/* 4) Reset flipper object */
-	flipper.init( (uint_t)nV );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblemB::init( 	SymmetricMatrix *_H, const real_t* const _g,
-								const real_t* const _lb, const real_t* const _ub,
-								int_t& nWSR, real_t* const cputime,
-								const real_t* const xOpt, const real_t* const yOpt,
-								const Bounds* const guessedBounds,
-								const real_t* const _R
-								)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	/* exclude this possibility in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( guessedBounds != 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( _R != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data. */
-	if ( setupQPdata( _H,_g,_lb,_ub ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* 3) Call to main initialisation routine. */
-	return solveInitialQP( xOpt,yOpt,guessedBounds,_R, nWSR,cputime );
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblemB::init( 	const real_t* const _H, const real_t* const _g,
-								const real_t* const _lb, const real_t* const _ub,
-								int_t& nWSR, real_t* const cputime,
-								const real_t* const xOpt, const real_t* const yOpt,
-								const Bounds* const guessedBounds,
-								const real_t* const _R
-								)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	/* exclude this possibility in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( guessedBounds != 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( _R != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data. */
-	if ( setupQPdata( _H,_g,_lb,_ub ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* 3) Call to main initialisation routine. */
-	return solveInitialQP( xOpt,yOpt,guessedBounds,_R, nWSR,cputime );
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblemB::init( 	const char* const H_file, const char* const g_file,
-								const char* const lb_file, const char* const ub_file,
-								int_t& nWSR, real_t* const cputime,
-								const real_t* const xOpt, const real_t* const yOpt,
-								const Bounds* const guessedBounds,
-								const char* const R_file
-								)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	/* exclude this possibility in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( guessedBounds != 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( R_file != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data from files. */
-	if ( setupQPdataFromFile( H_file,g_file,lb_file,ub_file ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-
-	if ( R_file == 0 )
-	{
-		/* 3) Call to main initialisation routine. */
-		return solveInitialQP( xOpt,yOpt,guessedBounds,0, nWSR,cputime );
-	}
-	else
-	{
-		/* Also read Cholesky factor from file and store it directly into R [thus... */
-		returnValue returnvalue = readFromFile( R, nV,nV, R_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-			return THROWWARNING( returnvalue );
-
-		/* 3) Call to main initialisation routine. ...passing R here!] */
-		return solveInitialQP( xOpt,yOpt,guessedBounds,R, nWSR,cputime );
-	}
-}
-
-
-
-/*
- *	h o t s t a r t
- */
-returnValue QProblemB::hotstart(	const real_t* const g_new,
-									const real_t* const lb_new, const real_t* const ub_new,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds
-									)
-{
-	int_t i, nActiveFar;
-	int_t nV = getNV ();
-	real_t starttime = 0.0;
-	real_t auxTime = 0.0;
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-
-	/* Possibly update working set according to guess for working set of bounds. */
-	if ( guessedBounds != 0 )
-	{
-		if ( cputime != 0 )
-			starttime = getCPUtime( );
-
-		if ( setupAuxiliaryQP( guessedBounds ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		status = QPS_AUXILIARYQPSOLVED;
-
-		/* Allow only remaining CPU time for usual hotstart. */
-		if ( cputime != 0 )
-		{
-			auxTime = getCPUtime( ) - starttime;
-			*cputime -= auxTime;
-		}
-	}
-
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	/* Simple check for consistency of bounds */
-	if ( areBoundsConsistent( lb_new,ub_new ) != SUCCESSFUL_RETURN )
-		return setInfeasibilityFlag(returnvalue,BT_TRUE);
-
-	++count;
-
-
-	int_t nWSR_max = nWSR;
-	int_t nWSR_performed = 0;
-
-	real_t cputime_remaining = INFTY;
-	real_t cputime_needed = 0.0;
-
-	real_t farbound = options.initialFarBounds;
-
-	if ( haveCholesky == BT_FALSE )
-	{
-		returnvalue = setupInitialCholesky( );
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return THROWERROR(returnvalue);
-	}
-
-	BooleanType isFirstCall = BT_TRUE;
-
-	if ( options.enableFarBounds == BT_FALSE )
-	{
-		/* Automatically call standard solveQP if regularisation is not active. */
-		returnvalue = solveRegularisedQP(	g_new,lb_new,ub_new,
-											nWSR,cputime,0,
-											isFirstCall
-											);
-	}
-	else
-	{
-		real_t *ub_new_far = new real_t[nV];
-		real_t *lb_new_far = new real_t[nV];
-
-		/* possibly extend initial far bounds to largest bound/constraint data */
-		if (ub_new)
-			for (i = 0; i < nV; i++)
-				if ((ub_new[i] < INFTY) && (ub_new[i] > farbound)) farbound = ub_new[i];
-		if (lb_new)
-			for (i = 0; i < nV; i++)
-				if ((lb_new[i] > -INFTY) && (lb_new[i] < -farbound)) farbound = -lb_new[i];
-
-		updateFarBounds(	farbound,nV,
-							lb_new,lb_new_far, ub_new,ub_new_far
-							);
-
-		for ( ;; )
-		{
-			nWSR = nWSR_max;
-			if ( cputime != 0 )
-				cputime_remaining = *cputime - cputime_needed;
-
-			/* Automatically call standard solveQP if regularisation is not active. */
-			returnvalue = solveRegularisedQP(	g_new,lb_new_far,ub_new_far,
-												nWSR,&cputime_remaining,nWSR_performed,
-												isFirstCall
-												);
-
-			nWSR_performed  = nWSR;
-			cputime_needed += cputime_remaining;
-			isFirstCall     = BT_FALSE;
-
-			/* Check for active far-bounds and move them away */
-			nActiveFar = 0;
-			farbound *= options.growFarBounds;
-
-			if ( infeasible == BT_TRUE )
-			{
-				if ( farbound >= INFTY )
-				{
-					returnvalue = RET_HOTSTART_STOPPED_INFEASIBILITY;
-					goto farewell;
-				}
-
-				updateFarBounds(	farbound,nV,
-									lb_new,lb_new_far, ub_new,ub_new_far
-									);
-			}
-			else if ( status == QPS_SOLVED )
-			{
-				real_t tol = farbound/options.growFarBounds * options.boundTolerance;
-				nActiveFar = 0;
-				for ( i=0; i<nV; ++i )
-				{
-					if ( ( ( lb_new == 0 ) || ( lb_new_far[i] > lb_new[i] ) ) && ( getAbs ( lb_new_far[i] - x[i] ) < tol ) )
-						++nActiveFar;
-					if ( ( ( ub_new == 0 ) || ( ub_new_far[i] < ub_new[i] ) ) && ( getAbs ( ub_new_far[i] - x[i] ) < tol ) )
-						++nActiveFar;
-				}
-
-				if ( nActiveFar == 0 )
-					break;
-
-				status = QPS_HOMOTOPYQPSOLVED;
-
-				if ( farbound >= INFTY )
-				{
-					unbounded = BT_TRUE;
-					returnvalue = RET_HOTSTART_STOPPED_UNBOUNDEDNESS;
-					goto farewell;
-				}
-
-				updateFarBounds(	farbound,nV,
-									lb_new,lb_new_far, ub_new,ub_new_far
-									);
-			}
-			else
-			{
-				/* some other error when solving QP */
-				break;
-			}
-
-			/* advance ramp offset to avoid Ramping cycles */
-			rampOffset++;
-		}
-
-		farewell:
-			/* add time to setup auxiliary QP */
-			if ( cputime != 0 )
-				*cputime = cputime_needed + auxTime;
-			delete[] lb_new_far; delete[] ub_new_far;
-	}
-
-	return ( returnvalue != SUCCESSFUL_RETURN ) ? THROWERROR( returnvalue ) : returnvalue;
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue QProblemB::hotstart(	const char* const g_file,
-									const char* const lb_file, const char* const ub_file,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds
-									)
-{
-	int_t nV  = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* consistency check */
-	if ( g_file == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Allocate memory (if bounds exist). */
-	real_t* g_new  = new real_t[nV];
-	real_t* lb_new = ( lb_file != 0 ) ? new real_t[nV] : 0;
-	real_t* ub_new = ( ub_file != 0 ) ? new real_t[nV] : 0;
-
-
-	/* 2) Load new QP vectors from file. */
-	returnValue returnvalue;
-	returnvalue = loadQPvectorsFromFile(	g_file,lb_file,ub_file,
-											g_new,lb_new,ub_new
-											);
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		if ( ub_file != 0 )
-			delete[] ub_new;
-		if ( lb_file != 0 )
-			delete[] lb_new;
-		delete[] g_new;
-
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-
-	/* 3) Actually perform hotstart. */
-	returnvalue = hotstart(	g_new,lb_new,ub_new,
-							nWSR,cputime,
-							guessedBounds
-							);
-
-
-	/* 4) Free memory. */
-	if ( ub_file != 0 )
-		delete[] ub_new;
-	if ( lb_file != 0 )
-		delete[] lb_new;
-	delete[] g_new;
-
-	return returnvalue;
-}
-
-
-/*
- *	g e t W o r k i n g S e t
- */
-returnValue QProblemB::getWorkingSet( real_t* workingSet )
-{
-	return getWorkingSetBounds( workingSet );
-}
-
-
-/*
- *	g e t W o r k i n g S e t B o u n d s
- */
-returnValue QProblemB::getWorkingSetBounds( real_t* workingSetB )
-{
-	int_t i;
-	int_t nV = this->getNV();
-
-	if ( workingSetB == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	for ( i=0; i<nV; ++i )
-	{
-		switch ( bounds.getStatus(i) )
-		{
-			case ST_LOWER: workingSetB[i] = -1.0; break;
-			case ST_UPPER: workingSetB[i] = +1.0; break;
-			default:       workingSetB[i] =  0.0; break;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t W o r k i n g S e t C o n s t r a i n t s
- */
-returnValue QProblemB::getWorkingSetConstraints( real_t* workingSetC )
-{
-	if ( workingSetC == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	else
-		return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t N Z
- */
-int_t QProblemB::getNZ( ) const
-{
-	/* if no constraints are present: nZ=nFR */
-	return getNFR( );
-}
-
-
-/*
- *	g e t O b j V a l
- */
-real_t QProblemB::getObjVal( ) const
-{
-	real_t objVal;
-
-	/* calculated optimal objective function value
-	 * only if current QP has been solved */
-	if ( ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED ) )
-	{
-		objVal = getObjVal( x );
-	}
-	else
-	{
-		objVal = INFTY;
-	}
-
-	return objVal;
-}
-
-
-/*
- *	g e t O b j V a l
- */
-real_t QProblemB::getObjVal( const real_t* const _x ) const
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return 0.0;
-
-	real_t objVal = 0.0;
-
-	for( i=0; i<nV; ++i )
-		objVal += _x[i]*g[i];
-
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			break;
-
-		case HST_IDENTITY:
-			for( i=0; i<nV; ++i )
-				objVal += 0.5*_x[i]*_x[i];
-			break;
-
-		default:
-			real_t *Hx = new real_t[nV];
-			H->times(1, 1.0, _x, nV, 0.0, Hx, nV);
-			for( i=0; i<nV; ++i )
-				objVal += 0.5*_x[i]*Hx[i];
-			delete[] Hx;
-			break;
-	}
-
-	/* When using regularisation, the objective function value
-	 * needs to be modified as follows:
-	 * objVal = objVal - 0.5*_x*(Hmod-H)*_x - _x'*(gMod-g)
-	 *        = objVal - 0.5*_x*eps*_x * - _x'*(-eps*_x)
-	 *        = objVal + 0.5*_x*eps*_x */
-	if ( usingRegularisation( ) == BT_TRUE )
-	{
-		for( i=0; i<nV; ++i )
-			objVal += 0.5*_x[i]*regVal*_x[i];
-	}
-
-	return objVal;
-}
-
-
-/*
- *	g e t P r i m a l S o l u t i o n
- */
-returnValue QProblemB::getPrimalSolution( real_t* const xOpt ) const
-{
-	int_t i;
-
-	/* return optimal primal solution vector
-	 * only if current QP has been solved */
-	if ( ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED ) )
-	{
-		for( i=0; i<getNV( ); ++i )
-			xOpt[i] = x[i];
-
-		return SUCCESSFUL_RETURN;
-	}
-	else
-	{
-		return RET_QP_NOT_SOLVED;
-	}
-}
-
-
-/*
- *	g e t D u a l S o l u t i o n
- */
-returnValue QProblemB::getDualSolution( real_t* const yOpt ) const
-{
-	int_t i;
-
-	for( i=0; i<getNV( ); ++i )
-		yOpt[i] = y[i];
-
-	/* return optimal dual solution vector
-	 * only if current QP has been solved */
-	if ( ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED ) )
-	{
-		return SUCCESSFUL_RETURN;
-	}
-	else
-	{
-		return RET_QP_NOT_SOLVED;
-	}
-}
-
-
-/*
- *	s e t P r i n t L e v e l
- */
-returnValue QProblemB::setPrintLevel( PrintLevel _printLevel )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-		#ifndef __MATLAB__
-			if ( ( options.printLevel == PL_HIGH ) && ( options.printLevel != _printLevel ) )
-				THROWINFO( RET_PRINTLEVEL_CHANGED );
-		#endif /* __MATLAB__ */
-		options.printLevel = _printLevel;
-	#else
-	options.printLevel = PL_NONE;
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	/* update message handler preferences */
- 	switch ( options.printLevel )
- 	{
- 		case PL_NONE:
- 			getGlobalMessageHandler( )->setErrorVisibilityStatus( VS_HIDDEN );
-			getGlobalMessageHandler( )->setWarningVisibilityStatus( VS_HIDDEN );
-			getGlobalMessageHandler( )->setInfoVisibilityStatus( VS_HIDDEN );
-			break;
-
-		case PL_TABULAR:
-		case PL_LOW:
-			getGlobalMessageHandler( )->setErrorVisibilityStatus( VS_VISIBLE );
-			getGlobalMessageHandler( )->setWarningVisibilityStatus( VS_HIDDEN );
-			getGlobalMessageHandler( )->setInfoVisibilityStatus( VS_HIDDEN );
-			break;
-
-		case PL_DEBUG_ITER:
-		case PL_MEDIUM:
-			getGlobalMessageHandler( )->setErrorVisibilityStatus( VS_VISIBLE );
-			getGlobalMessageHandler( )->setWarningVisibilityStatus( VS_VISIBLE );
-			getGlobalMessageHandler( )->setInfoVisibilityStatus( VS_HIDDEN );
-			break;
-
-		default: /* PL_HIGH */
-			getGlobalMessageHandler( )->setErrorVisibilityStatus( VS_VISIBLE );
-			getGlobalMessageHandler( )->setWarningVisibilityStatus( VS_VISIBLE );
-			getGlobalMessageHandler( )->setInfoVisibilityStatus( VS_VISIBLE );
-			break;
- 	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t P r o p e r t i e s
- */
-returnValue QProblemB::printProperties( )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	/* Do not print properties if print level is set to none! */
-	if ( options.printLevel == PL_NONE )
-		return SUCCESSFUL_RETURN;
-
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	myPrintf( "\n#################   qpOASES  --  QP PROPERTIES   #################\n" );
-	myPrintf( "\n" );
-
-	/* 1) Variables properties. */
-	snprintf( myPrintfString,MAX_STRING_LENGTH,  "Number of Variables: %4.1d\n",(int)getNV( ) );
-	myPrintf( myPrintfString );
-
-	if ( bounds.hasNoLower( ) == BT_TRUE )
-			myPrintf( "Variables are not bounded from below.\n" );
-		else
-			myPrintf( "Variables are bounded from below.\n" );
-
-	if ( bounds.hasNoUpper( ) == BT_TRUE )
-			myPrintf( "Variables are not bounded from above.\n" );
-		else
-			myPrintf( "Variables are bounded from above.\n" );
-
-	myPrintf( "\n" );
-
-
-	/* 2) Further properties. */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			myPrintf( "Hessian is zero matrix (i.e. actually an LP is solved).\n" );
-			break;
-
-		case HST_IDENTITY:
-			myPrintf( "Hessian is identity matrix.\n" );
-			break;
-
-		case HST_POSDEF:
-			myPrintf( "Hessian matrix is (strictly) positive definite.\n" );
-			break;
-
-		case HST_POSDEF_NULLSPACE:
-			myPrintf( "Hessian matrix is positive definite on null space of active constraints.\n" );
-			break;
-
-		case HST_SEMIDEF:
-			myPrintf( "Hessian matrix is positive semi-definite.\n" );
-			break;
-
-		case HST_INDEF:
-			myPrintf( "Hessian matrix is indefinite.\n" );
-			break;
-
-		default:
-			myPrintf( "Hessian matrix has unknown type.\n" );
-			break;
-	}
-
-	if ( infeasible == BT_TRUE )
-		myPrintf( "QP was found to be infeasible.\n" );
-	else
-		myPrintf( "QP seems to be feasible.\n" );
-
-	if ( unbounded == BT_TRUE )
-		myPrintf( "QP was found to be unbounded from below.\n" );
-	else
-		myPrintf( "QP seems to be bounded from below.\n" );
-
-	myPrintf( "\n" );
-
-
-	/* 3) QP object properties. */
-	switch ( status )
-	{
-		case QPS_NOTINITIALISED:
-			myPrintf( "Status of QP object: freshly instantiated or reset.\n" );
-			break;
-
-		case QPS_PREPARINGAUXILIARYQP:
-			myPrintf( "Status of QP object: an auxiliary QP is currently setup.\n" );
-			break;
-
-		case QPS_AUXILIARYQPSOLVED:
-			myPrintf( "Status of QP object: an auxilary QP was solved.\n" );
-			break;
-
-		case QPS_PERFORMINGHOMOTOPY:
-			myPrintf( "Status of QP object: a homotopy step is performed.\n" );
-			break;
-
-		case QPS_HOMOTOPYQPSOLVED:
-			myPrintf( "Status of QP object: an intermediate QP along the homotopy path was solved.\n" );
-			break;
-
-		case QPS_SOLVED:
-			myPrintf( "Status of QP object: solution of the actual QP was found.\n" );
-			break;
-	}
-
-	switch ( options.printLevel )
-	{
-		case PL_DEBUG_ITER:
-			myPrintf( "Print level of QP object is set to display a tabular output for debugging.\n" );
-			break;
-
-		case PL_TABULAR:
-			myPrintf( "Print level of QP object is set to display a tabular output.\n" );
-			break;
-
-		case PL_LOW:
-					myPrintf( "Print level of QP object is low, i.e. only error are printed.\n" );
-			break;
-
-		case PL_MEDIUM:
-			myPrintf( "Print level of QP object is medium, i.e. error and warnings are printed.\n" );
-			break;
-
-		case PL_HIGH:
-			myPrintf( "Print level of QP object is high, i.e. all available output is printed.\n" );
-			break;
-
-		default:
-			break;
-	}
-
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue QProblemB::printOptions( ) const
-{
-	return options.print( );
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue QProblemB::clear( )
-{
-	if ( ( freeHessian == BT_TRUE ) && ( H != 0 ) )
-	{
-		delete H;
-		H = 0;
-	}
-
-	if ( g != 0 )
-	{
-		delete[] g;
-		g = 0;
-	}
-
-	if ( lb != 0 )
-	{
-		delete[] lb;
-		lb = 0;
-	}
-
-	if ( ub != 0 )
-	{
-		delete[] ub;
-		ub = 0;
-	}
-
-	if ( R != 0 )
-	{
-		delete[] R;
-		R = 0;
-	}
-
-	if ( x != 0 )
-	{
-		delete[] x;
-		x = 0;
-	}
-
-	if ( y != 0 )
-	{
-		delete[] y;
-		y = 0;
-	}
-
-	if ( delta_xFR_TMP != 0 )
-	{
-		delete[] delta_xFR_TMP;
-		delta_xFR_TMP = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue QProblemB::copy(	const QProblemB& rhs
-								)
-{
-	uint_t _nV = (uint_t)rhs.getNV( );
-
-	bounds = rhs.bounds;
-
-	freeHessian = rhs.freeHessian;
-
-	if ( freeHessian == BT_TRUE )
-		H = (SymmetricMatrix *)(rhs.H->duplicateSym());
-	else
-		H = rhs.H;
-
-	if ( rhs.g != 0 )
-	{
-		g = new real_t[_nV];
-		setG( rhs.g );
-	}
-	else
-		g = 0;
-
-	if ( rhs.lb != 0 )
-	{
-		lb = new real_t[_nV];
-		setLB( rhs.lb );
-	}
-	else
-		lb = 0;
-
-	if ( rhs.ub != 0 )
-	{
-		ub = new real_t[_nV];
-		setUB( rhs.ub );
-	}
-	else
-		ub = 0;
-
-	if ( rhs.R != 0 )
-	{
-		R = new real_t[_nV*_nV];
-		memcpy( R,rhs.R,_nV*_nV*sizeof(real_t) );
-	}
-	else
-		R = 0;
-
-	haveCholesky = rhs.haveCholesky;
-
-	if ( rhs.x != 0 )
-	{
-		x = new real_t[_nV];
-		memcpy( x,rhs.x,_nV*sizeof(real_t) );
-	}
-	else
-		x = 0;
-
-	if ( rhs.y != 0 )
-	{
-		y = new real_t[_nV];
-		memcpy( y,rhs.y,_nV*sizeof(real_t) );
-	}
-	else
-		y = 0;
-
-	tau = rhs.tau;
-
-	hessianType = rhs.hessianType;
-	regVal = rhs.regVal;
-
-	infeasible = rhs.infeasible;
-	unbounded = rhs.unbounded;
-
-	status = rhs.status;
-
-	count = rhs.count;
-
-	ramp0 = rhs.ramp0;
-	ramp1 = rhs.ramp1;
-	// AW: Following line seemed to be missing
-	rampOffset = rhs.rampOffset;
-
-	delta_xFR_TMP = new real_t[_nV];	/* nFR */
-
-	options = rhs.options;
-	setPrintLevel( options.printLevel );
-
-	flipper = rhs.flipper;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	d e t e r m i n e H e s s i a n T y p e
- */
-returnValue QProblemB::determineHessianType( )
-{
-	int_t i;
-	int_t nV = getNV( );
-	real_t curDiag;
-
-	/* if Hessian type has been set by user, do NOT change it! */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			/* ensure regularisation as default options do not always solve LPs */
-			if ( options.enableRegularisation == BT_FALSE )
-			{
-				options.enableRegularisation = BT_TRUE;
-				options.numRegularisationSteps = 1;
-			}
-			return SUCCESSFUL_RETURN;
-
-		case HST_IDENTITY:
-			return SUCCESSFUL_RETURN;
-
-		case HST_POSDEF:
-        case HST_POSDEF_NULLSPACE:
-        case HST_SEMIDEF:
-		case HST_INDEF:
-			/* if H == 0, continue to reset hessianType to HST_ZERO
-			 *  to avoid segmentation faults! */
-			if ( H != 0 )
-				return SUCCESSFUL_RETURN;
-
-		default:
-			/* HST_UNKNOWN, continue */
-			break;
-	}
-
-	/* if Hessian has not been allocated, assume it to be all zeros! */
-	if ( H == 0 )
-	{
-		hessianType = HST_ZERO;
-		THROWINFO( RET_ZERO_HESSIAN_ASSUMED );
-
-		/* ensure regularisation as default options do not always solve LPs */
-		if ( options.enableRegularisation == BT_FALSE )
-		{
-			options.enableRegularisation = BT_TRUE;
-			options.numRegularisationSteps = 1;
-		}
-
-		return SUCCESSFUL_RETURN;
-	}
-
-	/* 1) If Hessian has outer-diagonal elements,
-	 *    Hessian is assumed to be positive definite. */
-	hessianType = HST_POSDEF;
-	if ( H->isDiag() == BT_FALSE )
-		return SUCCESSFUL_RETURN;
-
-	/* 2) Otherwise it is diagonal and test for identity or zero matrix is performed. */
-	BooleanType isIdentity = BT_TRUE;
-	BooleanType isZero = BT_TRUE;
-
-	for ( i=0; i<nV; ++i )
-	{
-        curDiag = H->diag(i);
-        if ( curDiag >= INFTY )
-            return RET_DIAGONAL_NOT_INITIALISED;
-
-		if ( curDiag < -ZERO )
-		{
-			hessianType = HST_INDEF;
-			if ( options.enableFlippingBounds == BT_FALSE )
-				return THROWERROR( RET_HESSIAN_INDEFINITE );
-			else
-				return SUCCESSFUL_RETURN;
-		}
-
-		if ( getAbs( curDiag - 1.0 ) > EPS )
-			isIdentity = BT_FALSE;
-
-		if ( getAbs( curDiag ) > EPS )
-			isZero = BT_FALSE;
-	}
-
-	if ( isIdentity == BT_TRUE )
-		hessianType = HST_IDENTITY;
-
-	if ( isZero == BT_TRUE )
-	{
-		hessianType = HST_ZERO;
-
-		/* ensure regularisation as default options do not always solve LPs */
-		if ( options.enableRegularisation == BT_FALSE )
-		{
-			options.enableRegularisation = BT_TRUE;
-			options.numRegularisationSteps = 1;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p S u b j e c t T o T y p e
- */
-returnValue QProblemB::setupSubjectToType( )
-{
-	return setupSubjectToType( lb,ub );
-}
-
-
-/*
- *	s e t u p S u b j e c t T o T y p e
- */
-returnValue QProblemB::setupSubjectToType( const real_t* const lb_new, const real_t* const ub_new )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-
-	/* 1) Check if lower bounds are present. */
-	bounds.setNoLower( BT_TRUE );
-	if ( lb_new != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( lb_new[i] > -INFTY )
-			{
-				bounds.setNoLower( BT_FALSE );
-				break;
-			}
-		}
-	}
-
-	/* 2) Check if upper bounds are present. */
-	bounds.setNoUpper( BT_TRUE );
-	if ( ub_new != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( ub_new[i] < INFTY )
-			{
-				bounds.setNoUpper( BT_FALSE );
-				break;
-			}
-		}
-	}
-
-	/* 3) Determine implicitly fixed and unbounded variables. */
-	if ( ( lb_new != 0 ) && ( ub_new != 0 ) )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( ( lb_new[i] < -INFTY+options.boundTolerance ) && ( ub_new[i] > INFTY-options.boundTolerance )
-					&& (options.enableFarBounds == BT_FALSE))
-			{
-				bounds.setType( i,ST_UNBOUNDED );
-			}
-			else
-			{
-				if (options.enableEqualities
-						&& lb[i] > ub[i] - options.boundTolerance
-						&& lb_new[i] > ub_new[i] - options.boundTolerance)
-					bounds.setType( i,ST_EQUALITY );
-				else
-					bounds.setType( i,ST_BOUNDED );
-			}
-		}
-	}
-	else
-	{
-		if ( ( lb_new == 0 ) && ( ub_new == 0 ) )
-		{
-			for( i=0; i<nV; ++i )
-				bounds.setType( i,ST_UNBOUNDED );
-		}
-		else
-		{
-			for( i=0; i<nV; ++i )
-				bounds.setType( i,ST_BOUNDED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o m p u t e C h o l e s k y
- */
-returnValue QProblemB::computeCholesky( )
-{
-	int_t i, j;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-
-	/* 1) Initialises R with all zeros. */
-	for( i=0; i<nV*nV; ++i )
-		R[i] = 0.0;
-
-	/* 2) Calculate Cholesky decomposition of H (projected to free variables). */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-
-			/* if Hessian is zero matrix and it has been regularised,
-			 * its Cholesky factor is the identity matrix scaled by sqrt(eps). */
-			if ( usingRegularisation( ) == BT_TRUE )
-			{
-				for( i=0; i<nV; ++i )
-					RR(i,i) = getSqrt( regVal );
-			}
-			else
-			{
-				return THROWERROR( RET_CHOLESKY_OF_ZERO_HESSIAN );
-			}
-			break;
-
-
-		case HST_IDENTITY:
-
-			/* if Hessian is identity, so is its Cholesky factor. */
-			for( i=0; i<nV; ++i )
-				RR(i,i) = 1.0;
-			break;
-
-
-		default:
-
-			if ( nFR > 0 )
-			{
-				int_t* FR_idx;
-				bounds.getFree( )->getNumberArray( &FR_idx );
-
-				/* get H */
-				for ( j=0; j < nFR; ++j )
-					H->getCol (FR_idx[j], bounds.getFree (), 1.0, &(R[j*nV]) );
-
-				/* R'*R = H */
-				long info = 0;
-				unsigned long _nFR = (unsigned long)nFR, _nV = (unsigned long)nV;
-
-				POTRF( "U", &_nFR, R, &_nV, &info );
-
-				/* <0 = invalid call, =0 ok, >0 not spd */
-				if (info > 0) {
-					if ( R[0] < 0.0 )
-					{
-						/* Cholesky decomposition has tunneled a negative
-						 * diagonal element. */
-						options.epsRegularisation = getMin( -R[0]+options.epsRegularisation,getSqrt(getAbs(options.epsRegularisation)) );
-					}
-
-					hessianType = HST_SEMIDEF;
-					return RET_HESSIAN_NOT_SPD;
-				}
-
-				/* zero first subdiagonal to make givens updates work */
-				for ( i=0; i<nFR-1; ++i )
-					RR(i+1,i) = 0.0;
-			}
-			break;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p I n i t i a l C h o l e s k y
- */
-returnValue QProblemB::setupInitialCholesky( )
-{
-	returnValue returnvalueCholesky;
-
-	/* If regularisation shall be used, always regularise at beginning
-	 * if initial working set is not empty. */
-	if ( ( getNV() != getNFR()-getNFV() ) && ( options.enableRegularisation == BT_TRUE ) )
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return RET_INIT_FAILED_REGULARISATION;
-
-	returnvalueCholesky = computeCholesky( );
-
-	/* If Hessian is not positive definite, regularise and try again. */
-	if ( returnvalueCholesky == RET_HESSIAN_NOT_SPD )
-	{
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return RET_INIT_FAILED_REGULARISATION;
-
-		returnvalueCholesky = computeCholesky( );
-	}
-
-	if ( returnvalueCholesky != SUCCESSFUL_RETURN )
-		return RET_INIT_FAILED_CHOLESKY;
-
-	haveCholesky = BT_TRUE;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	o b t a i n A u x i l i a r y W o r k i n g S e t
- */
-returnValue QProblemB::obtainAuxiliaryWorkingSet(	const real_t* const xOpt, const real_t* const yOpt,
-													const Bounds* const guessedBounds, Bounds* auxiliaryBounds
-													) const
-{
-	int_t i = 0;
-	int_t nV = getNV( );
-
-
-	/* 1) Ensure that desiredBounds is allocated (and different from guessedBounds). */
-	if ( ( auxiliaryBounds == 0 ) || ( auxiliaryBounds == guessedBounds ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 2) Setup working set for auxiliary initial QP. */
-	if ( guessedBounds != 0 )
-	{
-		/* If an initial working set is specific, use it!
-		 * Moreover, add all implictly fixed variables if specified. */
-		for( i=0; i<nV; ++i )
-		{
-			#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-			if ( bounds.getType( i ) == ST_EQUALITY )
-			{
-				if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-			}
-			else
-			#endif
-			{
-				if ( auxiliaryBounds->setupBound( i,guessedBounds->getStatus( i ) ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-			}
-		}
-	}
-	else	/* No initial working set specified. */
-	{
-		if ( ( xOpt != 0 ) && ( yOpt == 0 ) )
-		{
-			/* Obtain initial working set by "clipping". */
-			for( i=0; i<nV; ++i )
-			{
-				if ( xOpt[i] <= lb[i] + options.boundTolerance )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				if ( xOpt[i] >= ub[i] - options.boundTolerance )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_UPPER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				/* Moreover, add all implictly fixed variables if specified. */
-				#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-				else
-				#endif
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-			}
-		}
-
-		if ( ( xOpt == 0 ) && ( yOpt != 0 ) )
-		{
-			/* Obtain initial working set in accordance to sign of dual solution vector. */
-			for( i=0; i<nV; ++i )
-			{
-				if ( yOpt[i] > EPS )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				if ( yOpt[i] < -EPS )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_UPPER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				/* Moreover, add all implictly fixed variables if specified. */
-				#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-				else
-				#endif
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-			}
-		}
-
-		/* If xOpt and yOpt are null pointer and no initial working is specified,
-		 * start with empty working set (or implicitly fixed bounds only)
-		 * for auxiliary QP. */
-		if ( ( xOpt == 0 ) && ( yOpt == 0 ) )
-		{
-			for( i=0; i<nV; ++i )
-			{
-				switch( bounds.getType( i ) )
-				{
-					case ST_UNBOUNDED:
-						if ( auxiliaryBounds->setupBound( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-							return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-						break;
-
-					/* Only add all implictly fixed variables if specified. */
-					#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-					case ST_EQUALITY:
-						if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-							return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-						break;
-					#endif
-
-					default:
-						if ( auxiliaryBounds->setupBound( i,options.initialStatusBounds ) != SUCCESSFUL_RETURN )
-							return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-						break;
-				}
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	b a c k s o l v e R
- */
-returnValue QProblemB::backsolveR(	const real_t* const b, BooleanType transposed,
-									real_t* const a
-									) const
-{
-	/* Call standard backsolve procedure (i.e. removingBound == BT_FALSE). */
-	return backsolveR( b,transposed,BT_FALSE,a );
-}
-
-
-/*
- *	b a c k s o l v e R
- */
-returnValue QProblemB::backsolveR(	const real_t* const b, BooleanType transposed,
-									BooleanType removingBound,
-									real_t* const a
-									) const
-{
-	int_t i, j;
-	int_t nV = getNV( );
-	int_t nR = getNZ( );
-
-	real_t sum;
-
-	/* if backsolve is called while removing a bound, reduce nZ by one. */
-	if ( removingBound == BT_TRUE )
-		--nR;
-
-	/* nothing to do */
-	if ( nR <= 0 )
-		return SUCCESSFUL_RETURN;
-
-
-	/* Solve Ra = b, where R might be transposed. */
-	if ( transposed == BT_FALSE )
-	{
-		/* solve Ra = b */
-		for( i=(nR-1); i>=0; --i )
-		{
-			sum = b[i];
-			for( j=(i+1); j<nR; ++j )
-				sum -= RR(i,j) * a[j];
-
-			if ( getAbs( RR(i,i) ) >= ZERO*getAbs( sum ) )
-				a[i] = sum / RR(i,i);
-			else
-				return THROWERROR( RET_DIV_BY_ZERO );
-		}
-	}
-	else
-	{
-		/* solve R^T*a = b */
-		for( i=0; i<nR; ++i )
-		{
-			sum = b[i];
-			for( j=0; j<i; ++j )
-				sum -= RR(j,i) * a[j];
-
-			if ( getAbs( RR(i,i) ) >= ZERO*getAbs( sum ) )
-				a[i] = sum / RR(i,i);
-			else
-				return THROWERROR( RET_DIV_BY_ZERO );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	d e t e r m i n e D a t a S h i f t
- */
-returnValue QProblemB::determineDataShift(	const real_t* const g_new, const real_t* const lb_new, const real_t* const ub_new,
-											real_t* const delta_g, real_t* const delta_lb, real_t* const delta_ub,
-											BooleanType& Delta_bB_isZero
-											)
-{
-	int_t i, ii;
-	int_t nV  = getNV( );
-	int_t nFX = getNFX( );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-
-	/* 1) Calculate shift directions. */
-	for( i=0; i<nV; ++i )
-		delta_g[i]  = g_new[i]  - g[i];
-
-	if ( lb_new != 0 )
-	{
-		for( i=0; i<nV; ++i )
-			delta_lb[i] = lb_new[i] - lb[i];
-	}
-	else
-	{
-		/* if no lower bounds exist, assume the new lower bounds to be -infinity */
-		for( i=0; i<nV; ++i )
-			delta_lb[i] = -INFTY - lb[i];
-	}
-
-	if ( ub_new != 0 )
-	{
-		for( i=0; i<nV; ++i )
-			delta_ub[i] = ub_new[i] - ub[i];
-	}
-	else
-	{
-		/* if no upper bounds exist, assume the new upper bounds to be infinity */
-		for( i=0; i<nV; ++i )
-			delta_ub[i] = INFTY - ub[i];
-	}
-
-	/* 2) Determine if active bounds are to be shifted. */
-	Delta_bB_isZero = BT_TRUE;
-
-	for ( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-
-		if ( ( getAbs( delta_lb[ii] ) > EPS ) || ( getAbs( delta_ub[ii] ) > EPS ) )
-		{
-			Delta_bB_isZero = BT_FALSE;
-			break;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p Q P d a t a
- */
-returnValue QProblemB::setupQPdata(	SymmetricMatrix *_H, const real_t* const _g,
-									const real_t* const _lb, const real_t* const _ub
-									)
-{
-	/* 1) Setup Hessian matrix. */
-	setH( _H );
-
-	/* 2) Setup gradient vector. */
-	if ( _g == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	else
-		setG( _g );
-
-	/* 3) Setup lower/upper bounds vector. */
-	setLB( _lb );
-	setUB( _ub );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p Q P d a t a
- */
-returnValue QProblemB::setupQPdata(	const real_t* const _H, const real_t* const _g,
-									const real_t* const _lb, const real_t* const _ub
-									)
-{
-	/* 1) Setup Hessian matrix. */
-	setH( _H );
-
-	/* 2) Setup gradient vector. */
-	if ( _g == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	else
-		setG( _g );
-
-	/* 3) Setup lower/upper bounds vector. */
-	setLB( _lb );
-	setUB( _ub );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p Q P d a t a F r o m F i l e
- */
-returnValue QProblemB::setupQPdataFromFile(	const char* const H_file, const char* const g_file,
-											const char* const lb_file, const char* const ub_file
-											)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	returnValue returnvalue;
-
-
-	/* 1) Load Hessian matrix from file. */
-	if ( H_file != 0 )
-	{
-		real_t* _H = new real_t[nV * nV];
-		returnvalue = readFromFile( _H, nV,nV, H_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] _H;
-			return THROWERROR( returnvalue );
-		}
-		setH( _H );
-		H->doFreeMemory( );
-	}
-	else
-	{
-		real_t* _H = 0;
-		setH( _H );
-	}
-
-	/* 2) Load gradient vector from file. */
-	if ( g_file == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	returnvalue = readFromFile( g, nV, g_file );
-	if ( returnvalue != SUCCESSFUL_RETURN )
-		return THROWERROR( returnvalue );
-
-	/* 3) Load lower bounds vector from file. */
-	if ( lb_file != 0 )
-	{
-		returnvalue = readFromFile( lb, nV, lb_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-			return THROWERROR( returnvalue );
-	}
-	else
-	{
-		/* if no lower bounds are specified, set them to -infinity */
-		for( i=0; i<nV; ++i )
-			lb[i] = -INFTY;
-	}
-
-	/* 4) Load upper bounds vector from file. */
-	if ( ub_file != 0 )
-	{
-		returnvalue = readFromFile( ub, nV, ub_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-			return THROWERROR( returnvalue );
-	}
-	else
-	{
-		/* if no upper bounds are specified, set them to infinity */
-		for( i=0; i<nV; ++i )
-			ub[i] = INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	l o a d Q P v e c t o r s F r o m F i l e
- */
-returnValue QProblemB::loadQPvectorsFromFile(	const char* const g_file, const char* const lb_file, const char* const ub_file,
-												real_t* const g_new, real_t* const lb_new, real_t* const ub_new
-												) const
-{
-	int_t nV = getNV( );
-
-	returnValue returnvalue;
-
-
-	/* 1) Load gradient vector from file. */
-	if ( ( g_file != 0 ) && ( g_new != 0 ) )
-	{
-		returnvalue = readFromFile( g_new, nV, g_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-			return THROWERROR( returnvalue );
-	}
-	else
-	{
-		/* At least gradient vector needs to be specified! */
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* 2) Load lower bounds vector from file. */
-	if ( lb_file != 0 )
-	{
-		if ( lb_new != 0 )
-		{
-			returnvalue = readFromFile( lb_new, nV, lb_file );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( returnvalue );
-		}
-		else
-		{
-			/* If filename is given, storage must be provided! */
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	/* 3) Load upper bounds vector from file. */
-	if ( ub_file != 0 )
-	{
-		if ( ub_new != 0 )
-		{
-			returnvalue = readFromFile( ub_new, nV, ub_file );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( returnvalue );
-		}
-		else
-		{
-			/* If filename is given, storage must be provided! */
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t I n f e a s i b i l i t y F l a g
- */
-returnValue QProblemB::setInfeasibilityFlag(	returnValue returnvalue,
-												BooleanType doThrowError
-												)
-{
-	infeasible = BT_TRUE;
-
-	if ( ( doThrowError == BT_TRUE ) || ( options.enableFarBounds == BT_FALSE ) )
-		THROWERROR( returnvalue );
-
-	return returnvalue;
-}
-
-
-/*
- *	a r e B o u n d s C o n s i s t e n t
- */
-returnValue QProblemB::areBoundsConsistent(	const real_t* const lb_new, const real_t* const ub_new ) const
-{
-	if (lb_new && ub_new) {
-		for (int_t i = 0; i < getNV(); ++i) {
-			if (lb_new[i] > ub_new[i]+EPS) {
-				return RET_QP_INFEASIBLE;
-			}
-		}
-	}
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	i s C P U t i m e L i m i t E x c e e d e d
- */
-BooleanType QProblemB::isCPUtimeLimitExceeded(	const real_t* const cputime,
-												real_t starttime,
-												int_t nWSR
-												) const
-{
-	/* Always perform next QP iteration if no CPU time limit is given. */
-	if ( cputime == 0 )
-		return BT_FALSE;
-
-	/* Always perform first QP iteration. */
-	if ( nWSR <= 0 )
-		return BT_FALSE;
-
-	real_t elapsedTime = getCPUtime( ) - starttime;
-	real_t timePerIteration = elapsedTime / ((real_t) nWSR);
-
-	/* Determine if next QP iteration exceed CPU time limit
-	 * considering the (current) average CPU time per iteration. */
-	if ( ( elapsedTime + timePerIteration*1.25 ) <= ( *cputime ) )
-		return BT_FALSE;
-	else
-		return BT_TRUE;
-}
-
-
-/*
- *	r e g u l a r i s e H e s s i a n
- */
-returnValue QProblemB::regulariseHessian( )
-{
-	/* Do nothing if Hessian regularisation is disbaled! */
-	if ( options.enableRegularisation == BT_FALSE )
-		return SUCCESSFUL_RETURN;
-
-	/* Regularisation of identity Hessian not possible. */
-	if ( hessianType == HST_IDENTITY )
-		return THROWERROR( RET_CANNOT_REGULARISE_IDENTITY );
-
-	/* Determine regularisation parameter. */
-	if ( usingRegularisation( ) == BT_TRUE )
-		return SUCCESSFUL_RETURN; /*THROWERROR( RET_HESSIAN_ALREADY_REGULARISED );*/
-	else
-	{
-		/* Regularisation of zero Hessian is done implicitly. */
-		if ( hessianType == HST_ZERO )
-		{
-			regVal = getNorm( g,getNV() ) * options.epsRegularisation;
-		}
-		else
-		{
-			regVal = H->getNorm() * options.epsRegularisation;
-
-			if ( H->addToDiag( regVal ) == RET_NO_DIAGONAL_AVAILABLE )
-				return THROWERROR( RET_CANNOT_REGULARISE_SPARSE );
-		}
-
-		THROWINFO( RET_USING_REGULARISATION );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *  c r e a t e D i a g S p a r s e M a t
- */
-SymSparseMat* QProblemB::createDiagSparseMat( int_t n, real_t diagVal )
-{
-	real_t* M_val = new real_t[n];
-	sparse_int_t* M_jc = new sparse_int_t[n+1];
-	sparse_int_t* M_ir = new sparse_int_t[n+1];
-
-	for( int_t ii=0; ii<n; ++ii )
-	{
-		M_val[ii] = diagVal;
-		M_jc[ii] = (sparse_int_t)ii;
-		M_ir[ii] = (sparse_int_t)ii;
-	}
-	M_jc[n] = (sparse_int_t)n;
-	M_ir[n] = (sparse_int_t)n;
-
-	SymSparseMat* M = new SymSparseMat( n,n, M_ir,M_jc,M_val );
-	M->createDiagInfo( );
-	M->doFreeMemory( );
-
-	return M;
-}
-
-
-
-/*
- *	p e r f o r m R a t i o T e s t
- */
-returnValue QProblemB::performRatioTest(	int_t nIdx,
-											const int_t* const idxList,
-											const SubjectTo* const subjectTo,
-											const real_t* const num,
-											const real_t* const den,
-											real_t epsNum,
-											real_t epsDen,
-											real_t& t,
-											int_t& BC_idx
-											) const
-{
-	int_t i, ii;
-
-	BC_idx = -1;
-
-	for( i=0; i<nIdx; ++i )
-	{
-		ii = idxList[i];
-
-		if ( subjectTo->getType( ii ) != ST_EQUALITY )
-		{
-			if ( ( subjectTo->getStatus( ii ) == ST_LOWER ) || ( subjectTo->getStatus( ii ) == ST_INACTIVE ) )
-			{
-				if ( isBlocking( num[i],den[i],epsNum,epsDen,t ) == BT_TRUE )
-				{
-					t = num[i] / den[i];
-					BC_idx = ii;
-				}
-			}
-			else
-			if ( subjectTo->getStatus( ii ) == ST_UPPER )
-			{
-				if ( isBlocking( -num[i],-den[i],epsNum,epsDen,t ) == BT_TRUE )
-				{
-					t = num[i] / den[i];
-					BC_idx = ii;
-				}
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- * g e t R e l a t i v e H o m o t o p y L e n g t h
- */
-real_t QProblemB::getRelativeHomotopyLength(	const real_t* const g_new, const real_t* const lb_new, const real_t* const ub_new
-												)
-{
-	int_t i;
-	int_t nV = getNV( );
-	real_t d, s, len = 0.0;
-
-	/* gradient */
-	for (i = 0; i < nV; i++)
-	{
-		s = getAbs(g_new[i]);
-		if (s < 1.0) s = 1.0;
-		d = getAbs(g_new[i] - g[i]) / s;
-		if (d > len) len = d;
-	}
-	/*fprintf( stderr, "homLen = %e\n", len );*/
-
-	/* lower bounds */
-	if ( lb_new != 0 )
-	{
-		for (i = 0; i < nV; i++)
-		{
-			s = getAbs(lb_new[i]);
-			if (s < 1.0) s = 1.0;
-			d = getAbs(lb_new[i] - lb[i]) / s;
-			if (d > len) len = d;
-		}
-	}
-	/*fprintf( stderr, "homLen = %e\n", len );*/
-
-	/* upper bounds */
-	if ( ub_new != 0 )
-	{
-		for (i = 0; i < nV; i++)
-		{
-			s = getAbs(ub_new[i]);
-			if (s < 1.0) s = 1.0;
-			d = getAbs(ub_new[i] - ub[i]) / s;
-			if (d > len) len = d;
-		}
-	}
-	/*fprintf( stderr, "homLen = %e\n", len );*/
-
-	return len;
-}
-
-
-/*
- * p e r f o r m R a m p i n g
- */
-returnValue QProblemB::performRamping( )
-{
-	int_t nV = getNV( ), bstat, i;
-	real_t t, rampVal;
-
-	/* ramp inactive bounds and active dual variables */
-	for (i = 0; i < nV; i++)
-	{
-		switch (bounds.getType(i))
-		{
-			case ST_EQUALITY: lb[i] = x[i]; ub[i] = x[i]; continue; /* reestablish exact feasibility */
-			case ST_UNBOUNDED: continue;
-			case ST_DISABLED: continue;
-			default: break;
-		}
-
-		t = static_cast<real_t>((i + rampOffset) % nV) / static_cast<real_t>(nV-1);
-		rampVal = (1.0-t) * ramp0 + t * ramp1;
-		bstat = bounds.getStatus(i);
-		if (bstat != ST_LOWER) { lb[i] = x[i] - rampVal; }
-		if (bstat != ST_UPPER) { ub[i] = x[i] + rampVal; }
-		if (bstat == ST_LOWER) { lb[i] = x[i]; y[i] = +rampVal; }
-		if (bstat == ST_UPPER) { ub[i] = x[i]; y[i] = -rampVal; }
-		if (bstat == ST_INACTIVE) y[i] = 0.0; /* reestablish exact complementarity */
-	}
-
-	/* reestablish exact stationarity */
-	setupAuxiliaryQPgradient( );
-
-	/* advance ramp offset to avoid Ramping cycles */
-	rampOffset++;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- * u p d a t e F a r B o u n d s
- */
-returnValue QProblemB::updateFarBounds(	real_t curFarBound, int_t nRamp,
-											const real_t* const lb_new, real_t* const lb_new_far,
-											const real_t* const ub_new, real_t* const ub_new_far
-											) const
-{
-	int_t i;
-	real_t rampVal, t;
-	int_t nV = getNV( );
-
-	if ( options.enableRamping == BT_TRUE )
-	{
-		for ( i=0; i<nV; ++i )
-		{
-			t = static_cast<real_t>((i + rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-			rampVal = curFarBound * (1.0 + (1.0-t)*ramp0 + t*ramp1);
-
-			if ( lb_new == 0 )
-				lb_new_far[i] = -rampVal;
-			else
-				lb_new_far[i] = getMax( -rampVal,lb_new[i] );
-
-			if ( ub_new == 0 )
-				ub_new_far[i] = rampVal;
-			else
-				ub_new_far[i] = getMin( rampVal,ub_new[i] );
-		}
-	}
-	else
-	{
-		for ( i=0; i<nV; ++i )
-		{
-			if ( lb_new == 0 )
-				lb_new_far[i] = -curFarBound;
-			else
-				lb_new_far[i] = getMax( -curFarBound,lb_new[i] );
-
-			if ( ub_new == 0 )
-				ub_new_far[i] = curFarBound;
-			else
-				ub_new_far[i] = getMin( curFarBound,ub_new[i] );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-
-
-/*****************************************************************************
- *  P R I V A T E                                                            *
- *****************************************************************************/
-
-/*
- *	s o l v e I n i t i a l Q P
- */
-returnValue QProblemB::solveInitialQP(	const real_t* const xOpt, const real_t* const yOpt,
-										const Bounds* const guessedBounds,
-										const real_t* const _R,
-										int_t& nWSR, real_t* const cputime
-										)
-{
-	int_t i,j;
-	int_t nV = getNV( );
-
-
-	/* start runtime measurement */
-	real_t starttime = 0.0;
-	if ( cputime != 0 )
-		starttime = getCPUtime( );
-
-
-	status = QPS_NOTINITIALISED;
-
-	/* I) ANALYSE QP DATA: */
-	/* 1) Check if Hessian happens to be the identity matrix. */
-	if ( determineHessianType( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 2) Setup type of bounds (i.e. unbounded, implicitly fixed etc.). */
-	if ( setupSubjectToType( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* II) SETUP AUXILIARY QP WITH GIVEN OPTIMAL SOLUTION: */
-	/* 1) Setup bounds data structure. */
-	if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 2) Setup optimal primal/dual solution for auxiliary QP. */
-	if ( setupAuxiliaryQPsolution( xOpt,yOpt ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 3) Obtain linear independent working set for auxiliary QP. */
-	Bounds auxiliaryBounds( nV );
-	if ( obtainAuxiliaryWorkingSet( xOpt,yOpt,guessedBounds, &auxiliaryBounds ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 4) Setup working set of auxiliary QP and possibly cholesky decomposition. */
-	/* a) Working set of auxiliary QP. */
-	if ( setupAuxiliaryWorkingSet( &auxiliaryBounds,BT_TRUE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* b) Regularise Hessian if necessary. */
-	if ( ( hessianType == HST_ZERO ) || ( hessianType == HST_SEMIDEF ) )
-	{
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_INIT_FAILED_REGULARISATION );
-	}
-
-	/* c) Copy external Cholesky factor if provided */
-	haveCholesky = BT_FALSE;
-
-	if ( _R != 0 )
-	{
-		if ( options.initialStatusBounds != ST_INACTIVE )
-		{
-			THROWWARNING( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-		}
-		else
-		{
-			if ( _R == R )
-			{
-				/* Cholesky factor read from file and already loaded into R. */
-				haveCholesky = BT_TRUE;
-			}
-			else if ( ( xOpt == 0 ) && ( yOpt == 0 ) && ( guessedBounds == 0 ) )
-			{
-				for( i=0; i<nV; ++i )
-					for( j=i; j<nV; ++j )
-						RR(i,j) = _R[i*nV+j];
-				haveCholesky = BT_TRUE;
-			}
-		}
-	}
-
-	/* 5) Store original QP formulation... */
-	real_t* g_original = new real_t[nV];
-	real_t* lb_original = new real_t[nV];
-	real_t* ub_original = new real_t[nV];
-
-	for( i=0; i<nV; ++i )
-	{
-		g_original[i]  = g[i];
-		lb_original[i] = lb[i];
-		ub_original[i] = ub[i];
-	}
-
-	/* ... and setup QP data of an auxiliary QP having an optimal solution
-	 * as specified by the user (or xOpt = yOpt = 0, by default). */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-	{
-		delete[] ub_original; delete[] lb_original; delete[] g_original;
-		return THROWERROR( RET_INIT_FAILED );
-	}
-
-	if ( setupAuxiliaryQPbounds( BT_TRUE ) != SUCCESSFUL_RETURN )
-	{
- 		delete[] ub_original; delete[] lb_original; delete[] g_original;
-		return THROWERROR( RET_INIT_FAILED );
-	}
-
-	status = QPS_AUXILIARYQPSOLVED;
-
-
-	/* III) SOLVE ACTUAL INITIAL QP: */
-
-	/* Allow only remaining CPU time for usual hotstart. */
-	if ( cputime != 0 )
-		*cputime -= getCPUtime( ) - starttime;
-
-	/* Use hotstart method to find the solution of the original initial QP,... */
-	returnValue returnvalue = hotstart( g_original,lb_original,ub_original, nWSR,cputime );
-
-	/* ... deallocate memory,... */
-	delete[] ub_original; delete[] lb_original; delete[] g_original;
-
-	/* ... check for infeasibility and unboundedness... */
-	if ( isInfeasible( ) == BT_TRUE )
-		return THROWERROR( RET_INIT_FAILED_INFEASIBILITY );
-
-	if ( isUnbounded( ) == BT_TRUE )
-		return THROWERROR( RET_INIT_FAILED_UNBOUNDEDNESS );
-
-	/* ... and internal errors. */
-	if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-		return THROWERROR( RET_INIT_FAILED_HOTSTART );
-
-
-	/* stop runtime measurement */
-	if ( cputime != 0 )
-		*cputime = getCPUtime( ) - starttime;
-
-	THROWINFO( RET_INIT_SUCCESSFUL );
-
-	return returnvalue;
-}
-
-
-/*
- *	s o l v e Q P
- */
-returnValue QProblemB::solveQP(	const real_t* const g_new,
-								const real_t* const lb_new, const real_t* const ub_new,
-								int_t& nWSR, real_t* const cputime, int_t nWSRperformed,
-								BooleanType isFirstCall
-								)
-{
-	int_t iter;
-	int_t nV  = getNV( );
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED );
-	}
-
-	/* start runtime measurement */
-	real_t starttime = 0.0;
-	if ( cputime != 0 )
-		starttime = getCPUtime( );
-
-
-	/* I) PREPARATIONS */
-	/* 1) Allocate delta vectors of gradient and bounds,
-	 *    index arrays and step direction arrays. */
-	real_t* delta_xFR = new real_t[nV];
-	real_t* delta_xFX = new real_t[nV];
-	real_t* delta_yFX = new real_t[nV];
-
-	real_t* delta_g  = new real_t[nV];
-	real_t* delta_lb = new real_t[nV];
-	real_t* delta_ub = new real_t[nV];
-
-	returnValue returnvalue;
-	BooleanType Delta_bB_isZero;
-
-	int_t BC_idx;
-	SubjectToStatus BC_status;
-
-	real_t homotopyLength;
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-	/* 2) Update type of bounds, e.g. a formerly implicitly fixed
-	 *    variable might have become a normal one etc. */
-	if ( setupSubjectToType( lb_new,ub_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_HOTSTART_FAILED );
-
-	/* 3) Reset status flags. */
-	infeasible = BT_FALSE;
-	unbounded  = BT_FALSE;
-
-
-	/* II) MAIN HOMOTOPY LOOP */
-	for( iter=nWSRperformed; iter<nWSR; ++iter )
-	{
-		tabularOutput.idxAddB = tabularOutput.idxRemB = tabularOutput.idxAddC = tabularOutput.idxRemC = -1;
-		tabularOutput.excAddB = tabularOutput.excRemB = tabularOutput.excAddC = tabularOutput.excRemC = 0;
-
-		if ( isCPUtimeLimitExceeded( cputime,starttime,iter-nWSRperformed ) == BT_TRUE )
-		{
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			break;
-		}
-
-		status = QPS_PERFORMINGHOMOTOPY;
-
-		#ifndef __SUPPRESSANYOUTPUT__
-		if ( isFirstCall == BT_TRUE )
-			snprintf( messageString,MAX_STRING_LENGTH,"%d ...",(int)iter );
-		else
-			snprintf( messageString,MAX_STRING_LENGTH,"%d* ...",(int)iter );
-		getGlobalMessageHandler( )->throwInfo( RET_ITERATION_STARTED,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#endif
-
-		/* 2) Initialise shift direction of the gradient and the bounds. */
-		returnvalue = determineDataShift(	g_new,lb_new,ub_new,
-											delta_g,delta_lb,delta_ub,
-											Delta_bB_isZero
-											);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_SHIFT_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-		/* 3) Determination of step direction of X and Y. */
-		returnvalue = determineStepDirection(	delta_g,delta_lb,delta_ub,
-												Delta_bB_isZero,
-												delta_xFX,delta_xFR,delta_yFX
-												);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_STEPDIRECTION_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-
-		/* 4) Determination of step length TAU.
-		 *    This step along the homotopy path is also taken (without changing working set). */
-		returnvalue = performStep(	delta_g,delta_lb,delta_ub,
-									delta_xFX,delta_xFR,delta_yFX,
-									BC_idx,BC_status
-									);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_STEPLENGTH_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-		/* 5) Termination criterion. */
-		homotopyLength = getRelativeHomotopyLength(g_new, lb_new, ub_new);
-		if ( homotopyLength <= options.terminationTolerance )
-		{
-			status = QPS_SOLVED;
-
-			THROWINFO( RET_OPTIMAL_SOLUTION_FOUND );
-
-			if ( printIteration( iter,BC_idx,BC_status,homotopyLength,isFirstCall ) != SUCCESSFUL_RETURN )
-				THROWERROR( RET_PRINT_ITERATION_FAILED ); /* do not pass this as return value! */
-
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-			return SUCCESSFUL_RETURN;
-		}
-
-
-		/* 6) Change active set. */
-		returnvalue = changeActiveSet( BC_idx,BC_status );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			/* checks for infeasibility... */
-			if ( infeasible == BT_TRUE )
-			{
-				status = QPS_HOMOTOPYQPSOLVED;
-				return setInfeasibilityFlag( RET_HOTSTART_STOPPED_INFEASIBILITY );
-			}
-
-			/* ...unboundedness... */
-			if ( unbounded == BT_TRUE ) /* not necessary since objective function convex! */
-				return THROWERROR( RET_HOTSTART_STOPPED_UNBOUNDEDNESS );
-
-			/* ... and throw unspecific error otherwise */
-			THROWERROR( RET_HOMOTOPY_STEP_FAILED );
-			return returnvalue;
-		}
-
-		/* 6a) Possibly refactorise projected Hessian from scratch. */
-		if ( ( options.enableCholeskyRefactorisation > 0 ) && ( (iter % options.enableCholeskyRefactorisation) == 0 ) )
-		{
-			returnvalue = computeCholesky( );
-			if (returnvalue != SUCCESSFUL_RETURN)
-			{
-				delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-				delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-				return returnvalue;
-			}
-		}
-
-
-		/* 7) Perform Ramping Strategy on zero homotopy step or drift correction (if desired). */
-		 if ( ( tau <= EPS ) && ( options.enableRamping == BT_TRUE ) )
-			performRamping( );
-		else
-		if ( (options.enableDriftCorrection > 0) && ((iter+1) % options.enableDriftCorrection == 0) )
-			performDriftCorrection( );  /* always returns SUCCESSFUL_RETURN */
-
-		/* 8) Output information of successful QP iteration. */
-		status = QPS_HOMOTOPYQPSOLVED;
-
-		if ( printIteration( iter,BC_idx,BC_status,homotopyLength,isFirstCall ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_PRINT_ITERATION_FAILED ); /* do not pass this as return value! */
-	}
-
-	delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-	delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-	/* stop runtime measurement */
-	if ( cputime != 0 )
-		*cputime = getCPUtime( ) - starttime;
-
-
-	/* if programm gets to here, output information that QP could not be solved
-	 * within the given maximum numbers of working set changes */
-	if ( options.printLevel == PL_HIGH )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		snprintf( messageString,MAX_STRING_LENGTH,"(nWSR = %d)",(int)iter );
-		return getGlobalMessageHandler( )->throwWarning( RET_MAX_NWSR_REACHED,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#else
-		return RET_MAX_NWSR_REACHED;
-		#endif
-	}
-	else
-	{
-		return RET_MAX_NWSR_REACHED;
-	}
-}
-
-
-/*
- *	s o l v e R e g u l a r i s e d Q P
- */
-returnValue QProblemB::solveRegularisedQP(	const real_t* const g_new,
-											const real_t* const lb_new, const real_t* const ub_new,
-											int_t& nWSR, real_t* const cputime, int_t nWSRperformed,
-											BooleanType isFirstCall
-											)
-{
-	int_t i, step;
-	int_t nV = getNV( );
-
-
-	/* Perform normal QP solution if QP has not been regularised. */
-	if ( usingRegularisation( ) == BT_FALSE )
-		return solveQP( g_new,lb_new,ub_new, nWSR,cputime,nWSRperformed,isFirstCall );
-
-
-	/* I) SOLVE USUAL REGULARISED QP */
-	returnValue returnvalue;
-
-	int_t nWSR_max   = nWSR;
-	int_t nWSR_total = nWSRperformed;
-
-	real_t cputime_total = 0.0;
-	real_t cputime_cur   = 0.0;
-
-	if ( cputime == 0 )
-	{
-		returnvalue = solveQP( g_new,lb_new,ub_new, nWSR,0,nWSRperformed,isFirstCall );
-	}
-	else
-	{
-		cputime_cur = *cputime;
-		returnvalue = solveQP( g_new,lb_new,ub_new, nWSR,&cputime_cur,nWSRperformed,isFirstCall );
-	}
-	nWSR_total     = nWSR;
-	cputime_total += cputime_cur;
-	isFirstCall    = BT_FALSE;
-
-
-	/* Only continue if QP solution has been successful. */
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		if ( cputime != 0 )
-			*cputime = cputime_total;
-
-		if ( returnvalue == RET_MAX_NWSR_REACHED )
-			THROWWARNING( RET_NO_REGSTEP_NWSR );
-
-		return returnvalue;
-	}
-
-
-	/* II) PERFORM SUCCESSIVE REGULARISATION STEPS */
-	real_t* gMod = new real_t[nV];
-
-	for( step=0; step<options.numRegularisationSteps; ++step )
-	{
-		/* 1) Modify gradient: gMod = g - eps*xOpt
-		 *    (assuming regularisation matrix to be regVal*Id). */
-		for( i=0; i<nV; ++i )
-			gMod[i] = g_new[i] - regVal*x[i];
-
-		/* 2) Solve regularised QP with modified gradient allowing
-		 *    only as many working set recalculations and CPU time
-		 *    as have been left from previous QP solutions. */
-		if ( cputime == 0 )
-		{
-			nWSR = nWSR_max;
-			returnvalue = solveQP( gMod,lb_new,ub_new, nWSR,0,nWSR_total,isFirstCall );
-		}
-		else
-		{
-			nWSR = nWSR_max;
-			cputime_cur = *cputime - cputime_total;
-			returnvalue = solveQP( gMod,lb_new,ub_new, nWSR,&cputime_cur,nWSR_total,isFirstCall );
-		}
-
-		nWSR_total     = nWSR;
-		cputime_total += cputime_cur;
-
-		/* Only continue if QP solution has been successful. */
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] gMod;
-
-			if ( cputime != 0 )
-				*cputime = cputime_total;
-
-			if ( returnvalue == RET_MAX_NWSR_REACHED )
-				THROWWARNING( RET_FEWER_REGSTEPS_NWSR );
-
-			return returnvalue;
-		}
-	}
-
-	for( i=0; i<nV; ++i )
-		g[i] = g_new[i];
-
-	delete[] gMod;
-
-	if ( cputime != 0 )
-		*cputime = cputime_total;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y W o r k i n g S e t
- */
-returnValue QProblemB::setupAuxiliaryWorkingSet( 	const Bounds* const auxiliaryBounds,
-													BooleanType setupAfresh
-													)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	/* consistency checks */
-	if ( auxiliaryBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-			if ( ( bounds.getStatus( i ) == ST_UNDEFINED ) || ( auxiliaryBounds->getStatus( i ) == ST_UNDEFINED ) )
-				return THROWERROR( RET_UNKNOWN_BUG );
-	}
-	else
-	{
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-
-	/* I) SETUP CHOLESKY FLAG:
-	 *    Cholesky decomposition shall only be updated if working set
-	 *    shall be updated (i.e. NOT setup afresh!) */
-	BooleanType updateCholesky;
-	if ( setupAfresh == BT_TRUE )
-		updateCholesky = BT_FALSE;
-	else
-		updateCholesky = BT_TRUE;
-
-
-	/* II) REMOVE FORMERLY ACTIVE BOUNDS (IF NECESSARY): */
-	if ( setupAfresh == BT_FALSE )
-	{
-		/* Remove all active bounds that shall be inactive AND
-		*  all active bounds that are active at the wrong bound. */
-		for( i=0; i<nV; ++i )
-		{
-			if ( ( bounds.getStatus( i ) == ST_LOWER ) && ( auxiliaryBounds->getStatus( i ) != ST_LOWER ) )
-				if ( removeBound( i,updateCholesky ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-			if ( ( bounds.getStatus( i ) == ST_UPPER ) && ( auxiliaryBounds->getStatus( i ) != ST_UPPER ) )
-				if ( removeBound( i,updateCholesky ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-		}
-	}
-
-
-	/* III) ADD NEWLY ACTIVE BOUNDS: */
-	/*      Add all inactive bounds that shall be active AND
-	 *      all formerly active bounds that have been active at the wrong bound. */
-	for( i=0; i<nV; ++i )
-	{
-		if ( ( bounds.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryBounds->getStatus( i ) != ST_INACTIVE ) )
-		{
-			if ( addBound( i,auxiliaryBounds->getStatus( i ),updateCholesky ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P s o l u t i o n
- */
-returnValue QProblemB::setupAuxiliaryQPsolution(	const real_t* const xOpt, const real_t* const yOpt
-													)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-
-	/* Setup primal/dual solution vectors for auxiliary initial QP:
-	 * if a null pointer is passed, a zero vector is assigned;
-	 * old solution vector is kept if pointer to internal solution vector is passed. */
-	if ( xOpt != 0 )
-	{
-		if ( xOpt != x )
-			for( i=0; i<nV; ++i )
-				x[i] = xOpt[i];
-	}
-	else
-	{
-		for( i=0; i<nV; ++i )
-			x[i] = 0.0;
-	}
-
-	if ( yOpt != 0 )
-	{
-		if ( yOpt != y )
-			for( i=0; i<nV; ++i )
-				y[i] = yOpt[i];
-	}
-	else
-	{
-		for( i=0; i<nV; ++i )
-			y[i] = 0.0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P g r a d i e n t
- */
-returnValue QProblemB::setupAuxiliaryQPgradient( )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	/* Setup gradient vector: g = -H*x + y'*Id. */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			if ( usingRegularisation( ) == BT_FALSE )
-				for ( i=0; i<nV; ++i )
-					g[i] = y[i];
-			else
-				for ( i=0; i<nV; ++i )
-					g[i] = y[i] - regVal*x[i];
-			break;
-
-		case HST_IDENTITY:
-			for ( i=0; i<nV; ++i )
-				g[i] = y[i] - x[i];
-			break;
-
-		default:
-			/* y'*Id */
-			for ( i=0; i<nV; ++i )
-				g[i] = y[i];
-
-			/* -H*x */
-			H->times(1, -1.0, x, nV, 1.0, g, nV);
-
-			break;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P b o u n d s
- */
-returnValue QProblemB::setupAuxiliaryQPbounds( BooleanType useRelaxation )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-
-	/* Setup bound vectors. */
-	for ( i=0; i<nV; ++i )
-	{
-		switch ( bounds.getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( useRelaxation == BT_TRUE )
-				{
-					if ( bounds.getType( i ) == ST_EQUALITY )
-					{
-						lb[i] = x[i];
-						ub[i] = x[i];
-					}
-					else
-					{
-						lb[i] = x[i] - options.boundRelaxation;
-						ub[i] = x[i] + options.boundRelaxation;
-					}
-				}
-				break;
-
-			case ST_LOWER:
-				lb[i] = x[i];
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					ub[i] = x[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						ub[i] = x[i] + options.boundRelaxation;
-				}
-				break;
-
-			case ST_UPPER:
-				ub[i] = x[i];
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					lb[i] = x[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						lb[i] = x[i] - options.boundRelaxation;
-				}
-				break;
-
-            case ST_DISABLED:
-                break;
-
-			default:
-				return THROWERROR( RET_UNKNOWN_BUG );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P
- */
-returnValue QProblemB::setupAuxiliaryQP( const Bounds* const guessedBounds )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	/* nothing to do */
-	if ( guessedBounds == &bounds )
-		return SUCCESSFUL_RETURN;
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* I) SETUP WORKING SET ... */
-	if ( shallRefactorise( guessedBounds ) == BT_TRUE )
-	{
-		/* ... WITH REFACTORISATION: */
-		/* 1) Reset bounds ... */
-		bounds.init( nV );
-
-		/*    ... and set them up afresh. */
-		if ( setupSubjectToType( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* 2) Setup guessed working set afresh. */
-		if ( setupAuxiliaryWorkingSet( guessedBounds,BT_TRUE ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* 3) Calculate Cholesky decomposition. */
-		if ( computeCholesky( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-	else
-	{
-		/* ... WITHOUT REFACTORISATION: */
-		if ( setupAuxiliaryWorkingSet( guessedBounds,BT_FALSE ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-
-
-	/* II) SETUP AUXILIARY QP DATA: */
-	/* 1) Ensure that dual variable is zero for free bounds. */
-	for ( i=0; i<nV; ++i )
-		if ( bounds.getStatus( i ) == ST_INACTIVE )
-			y[i] = 0.0;
-
-	/* 2) Setup gradient and bound vectors. */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-		THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	if ( setupAuxiliaryQPbounds( BT_FALSE ) != SUCCESSFUL_RETURN )
-		THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	d e t e r m i n e S t e p D i r e c t i o n
- */
-returnValue QProblemB::determineStepDirection(	const real_t* const delta_g, const real_t* const delta_lb, const real_t* const delta_ub,
-												BooleanType Delta_bB_isZero,
-												real_t* const delta_xFX, real_t* const delta_xFR,
-												real_t* const delta_yFX
-												)
-{
-	int_t i, ii;
-	int_t r;
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-
-	int_t* FR_idx;
-	int_t* FX_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-
-	/* This routine computes
-	 * delta_xFX := delta_b
-	 * delta_xFR := R \ R' \ -( delta_g + HMX*delta_xFX )
-	 * delta_yFX := HMX'*delta_xFR + HFX*delta_xFX  { + eps*delta_xFX }
-	 */
-
-	/* I) DETERMINE delta_xFX := delta_{l|u}b */
-	if ( Delta_bB_isZero == BT_FALSE )
-	{
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-
-			if ( bounds.getStatus( ii ) == ST_LOWER )
-				delta_xFX[i] = delta_lb[ii];
-			else
-				delta_xFX[i] = delta_ub[ii];
-		}
-	}
-	else
-	{
-		for( i=0; i<nFX; ++i )
-			delta_xFX[i] = 0.0;
-	}
-
-
-	/* delta_xFR_TMP holds the residual, initialized with right hand side
-	 * delta_xFR holds the step that gets refined incrementally */
-	for ( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		delta_xFR_TMP[i] = - delta_g[ii];
-		delta_xFR[i] = 0.0;
-	}
-
-
-	/* Iterative refinement loop for delta_xFR */
-	for ( r=0; r<=options.numRefinementSteps; ++r )
-	{
-		/* II) DETERMINE delta_xFR */
-		if ( nFR > 0 )
-		{
-			/* Add - HMX*delta_xFX
-			 * This is skipped if delta_b=0 or mixed part HM=0 (H=0 or H=Id) */
-			if ( ( hessianType != HST_ZERO ) && ( hessianType != HST_IDENTITY ) && ( Delta_bB_isZero == BT_FALSE ) && ( r == 0 ) )
-				H->times(bounds.getFree(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, delta_xFR_TMP, nFR);
-
-			/* Determine R' \ ( - HMX*delta_xFX - delta_gFR ) where R'R = HFR */
-			if ( backsolveR( delta_xFR_TMP,BT_TRUE,delta_xFR_TMP ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_STEPDIRECTION_FAILED_CHOLESKY );
-
-			/* Determine HFR \ ( - HMX*delta_xFX - delta_gFR ) */
-			if ( backsolveR( delta_xFR_TMP,BT_FALSE,delta_xFR_TMP ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_STEPDIRECTION_FAILED_CHOLESKY );
-		}
-
-		/* refine solution found for delta_xFR so far */
-		for ( i=0; i<nFR; ++i )
-			delta_xFR[i] += delta_xFR_TMP[i];
-
-		if ( options.numRefinementSteps > 0 )
-		{
-			real_t rnrm = 0.0;
-			/* compute new residual in delta_xFR_TMP:
-			 * residual := - HFR*delta_xFR - HMX*delta_xFX - delta_gFR
-			 * set to -delta_gFR */
-			for ( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				delta_xFR_TMP[i] = -delta_g[ii];
-			}
-			/* add - HFR*delta_xFR */
-			switch ( hessianType )
-			{
-				case HST_ZERO:
-					break;
-
-				case HST_IDENTITY:
-					for ( i=0; i<nFR; ++i )
-					{
-						delta_xFR_TMP[i] -= delta_xFR[i];
-
-						/* compute max norm */
-						if (rnrm < getAbs (delta_xFR_TMP[i]))
-							rnrm = getAbs (delta_xFR_TMP[i]);
-					}
-					break;
-
-				default:
-					H->times(bounds.getFree(), bounds.getFree(),  1, -1.0, delta_xFR, nFR, 1.0, delta_xFR_TMP, nFR);
-					H->times(bounds.getFree(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, delta_xFR_TMP, nFR);
-
-					/* compute max norm */
-					for ( i=0; i<nFR; ++i )
-						if (rnrm < getAbs (delta_xFR_TMP[i]))
-							rnrm = getAbs (delta_xFR_TMP[i]);
-
-					break;
-			}
-
-			/* early termination of residual norm small enough */
-			if ( rnrm < options.epsIterRef )
-				break;
-		}
-
-	} /* end of refinement loop for delta_xFR */
-
-	/* III) DETERMINE delta_yFX */
-	if ( nFX > 0 )
-	{
-		if ( ( hessianType == HST_ZERO ) || ( hessianType == HST_IDENTITY ) )
-		{
-			for( i=0; i<nFX; ++i )
-			{
-				/* set to delta_g */
-				ii = FX_idx[i];
-				delta_yFX[i] = delta_g[ii];
-
-				/* add HFX*delta_xFX = {0|I}*delta_xFX */
-				if ( hessianType == HST_ZERO )
-				{
-					if ( usingRegularisation( ) == BT_TRUE )
-						delta_yFX[i] += regVal*delta_xFX[i];
-				}
-				else
-					delta_yFX[i] += delta_xFX[i];
-			}
-		}
-		else
-		{
-			for( i=0; i<nFX; ++i )
-			{
-				/* set to delta_g */
-				ii = FX_idx[i];
-				delta_yFX[i] = delta_g[ii];
-			}
-			H->times(bounds.getFixed(), bounds.getFree(), 1, 1.0, delta_xFR, nFR, 1.0, delta_yFX, nFX);
-			if (Delta_bB_isZero == BT_FALSE)
-				H->times(bounds.getFixed(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, delta_yFX, nFX);
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p e r f o r m S t e p
- */
-returnValue QProblemB::performStep(	const real_t* const delta_g,
-									const real_t* const delta_lb, const real_t* const delta_ub,
-									const real_t* const delta_xFX,
-									const real_t* const delta_xFR,
-									const real_t* const delta_yFX,
-									int_t& BC_idx, SubjectToStatus& BC_status
-									)
-{
-	int_t i, ii;
-	int_t nV = getNV( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-
-	int_t* FR_idx;
-	int_t* FX_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	tau = 1.0;
-	BC_idx = -1;
-	BC_status = ST_UNDEFINED;
-
-	int_t BC_idx_tmp = -1;
-
-	real_t* num = new real_t[nV];
-	real_t* den = new real_t[nV];
-
-
-	/* I) DETERMINE MAXIMUM DUAL STEPLENGTH, i.e. ensure that
-	 *    active dual bounds remain valid (ignoring implicitly fixed variables): */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-		den[i] = -delta_yFX[i];
-	}
-
-	performRatioTest( nFX,FX_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-	if ( BC_idx_tmp >= 0 )
-	{
-		BC_idx = BC_idx_tmp;
-		BC_status = ST_INACTIVE;
-	}
-
-
-	/* II) DETERMINE MAXIMUM PRIMAL STEPLENGTH, i.e. ensure that
-	 *     inactive bounds remain valid (ignoring unbounded variables). */
-	/* 1) Inactive lower bounds. */
-	if ( bounds.hasNoLower( ) == BT_FALSE )
-	{
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			num[i] = getMax( x[ii] - lb[ii],0.0 );
-			den[i] = delta_lb[ii] - delta_xFR[i];
-		}
-
-		performRatioTest( nFR,FR_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_LOWER;
-		}
-	}
-
-	/* 2) Inactive upper bounds. */
-	if ( bounds.hasNoUpper( ) == BT_FALSE )
-	{
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			num[i] = getMax( ub[ii] - x[ii],0.0 );
-			den[i] = delta_xFR[i] - delta_ub[ii];
-		}
-
-		performRatioTest( nFR,FR_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_UPPER;
-		}
-	}
-
-	delete[] den;
-	delete[] num;
-
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-
-	if ( BC_status == ST_UNDEFINED )
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e!",tau );
-	else
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e! (idx = %d, status = %d)",tau,(int)BC_idx,(int)BC_status );
-
-	getGlobalMessageHandler( )->throwInfo( RET_STEPSIZE_NONPOSITIVE,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-	#endif
-
-
-	/* III) PERFORM STEP ALONG HOMOTOPY PATH */
-	if ( tau > ZERO )
-	{
-		/* 1) Perform step in primal und dual space. */
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			x[ii] += tau*delta_xFR[i];
-		}
-
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			x[ii] += tau*delta_xFX[i];
-			y[ii] += tau*delta_yFX[i];
-		}
-
-		/* 2) Shift QP data. */
-		for( i=0; i<nV; ++i )
-		{
-			g[i]  += tau*delta_g[i];
-			lb[i] += tau*delta_lb[i];
-			ub[i] += tau*delta_ub[i];
-		}
-	}
-	else
-	{
-		/* print a warning if stepsize is zero */
-		#ifndef __SUPPRESSANYOUTPUT__
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e",tau );
-		getGlobalMessageHandler( )->throwWarning( RET_STEPSIZE,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#endif
-	}
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c h a n g e A c t i v e S e t
- */
-returnValue QProblemB::changeActiveSet( int_t BC_idx, SubjectToStatus BC_status )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-	/* IV) UPDATE ACTIVE SET */
-	switch ( BC_status )
-	{
-		/* Optimal solution found as no working set change detected. */
-		case ST_UNDEFINED:
-			return RET_OPTIMAL_SOLUTION_FOUND;
-
-
-		/* Remove one variable from active set. */
-		case ST_INACTIVE:
-			#ifndef __SUPPRESSANYOUTPUT__
-			snprintf( messageString,MAX_STRING_LENGTH,"bound no. %d.",(int)BC_idx );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeBound( BC_idx,BT_TRUE ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_REMOVE_FROM_ACTIVESET_FAILED );
-
-			y[BC_idx] = 0.0;
-			break;
-
-
-		/* Add one variable to active set. */
-		default:
-			#ifndef __SUPPRESSANYOUTPUT__
-			if ( BC_status == ST_LOWER )
-				snprintf( messageString,MAX_STRING_LENGTH,"lower bound no. %d.",(int)BC_idx );
-			else
-				snprintf( messageString,MAX_STRING_LENGTH,"upper bound no. %d.",(int)BC_idx );
-				getGlobalMessageHandler( )->throwInfo( RET_ADD_TO_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( addBound( BC_idx,BC_status,BT_TRUE ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_ADD_TO_ACTIVESET_FAILED );
-			break;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- * p e r f o r m D r i f t C o r r e c t i o n
- */
-returnValue QProblemB::performDriftCorrection( )
-{
-	int_t i;
-	int_t nV = getNV ();
-
-	for ( i=0; i<nV; ++i )
-	{
-		switch ( bounds.getType ( i ) )
-		{
-			case ST_BOUNDED:
-				switch ( bounds.getStatus ( i ) )
-				{
-					case ST_LOWER:
-						lb[i] = x[i];
-						ub[i] = getMax (ub[i], x[i]);
-						y[i] = getMax (y[i], 0.0);
-						break;
-					case ST_UPPER:
-						lb[i] = getMin (lb[i], x[i]);
-						ub[i] = x[i];
-						y[i] = getMin (y[i], 0.0);
-						break;
-					case ST_INACTIVE:
-						lb[i] = getMin (lb[i], x[i]);
-						ub[i] = getMax (ub[i], x[i]);
-						y[i] = 0.0;
-						break;
-					case ST_UNDEFINED:
-					case ST_INFEASIBLE_LOWER:
-					case ST_INFEASIBLE_UPPER:
-						break;
-				}
-				break;
-			case ST_EQUALITY:
-				lb[i] = x[i];
-				ub[i] = x[i];
-				break;
-			case ST_UNBOUNDED:
-			case ST_UNKNOWN:
-            case ST_DISABLED:
-				break;
-		}
-	}
-
-	return setupAuxiliaryQPgradient( );
-}
-
-
-/*
- *	s h a l l R e f a c t o r i s e
- */
-BooleanType QProblemB::shallRefactorise( const Bounds* const guessedBounds ) const
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	/* always refactorise if Hessian is not known to be positive definite */
-	if ( ( hessianType == HST_SEMIDEF ) || ( hessianType == HST_INDEF ) )
-		return BT_TRUE;
-
-	/* 1) Determine number of bounds that have same status
-	 *    in guessed AND current bounds.*/
-	int_t differenceNumber = 0;
-
-	for( i=0; i<nV; ++i )
-		if ( guessedBounds->getStatus( i ) != bounds.getStatus( i ) )
-			++differenceNumber;
-
-	/* 2) Decide wheter to refactorise or not. */
-	if ( 2*differenceNumber > guessedBounds->getNFX( ) )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *	a d d B o u n d
- */
-returnValue QProblemB::addBound(	int_t number, SubjectToStatus B_status,
-									BooleanType updateCholesky
-									)
-{
-	int_t i, j;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* Perform cholesky updates only if QProblemB has been initialised! */
-	if ( getStatus( ) == QPS_PREPARINGAUXILIARYQP )
-	{
-		/* UPDATE INDICES */
-		if ( bounds.moveFreeToFixed( number,B_status ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_ADDBOUND_FAILED );
-
-		return SUCCESSFUL_RETURN;
-	}
-
-
-	/* I) PERFORM CHOLESKY UPDATE: */
-	if ( ( updateCholesky == BT_TRUE ) &&
-		 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-	{
-		/* 1) Index of variable to be added within the list of free variables. */
-		int_t number_idx = bounds.getFree( )->getIndex( number );
-
-		real_t c, s, nu;
-
-		/* 2) Use row-wise Givens rotations to restore upper triangular form of R. */
-		for( i=number_idx+1; i<nFR; ++i )
-		{
-			computeGivens( RR(i-1,i),RR(i,i), RR(i-1,i),RR(i,i),c,s );
-			nu = s/(1.0+c);
-
-			for( j=(1+i); j<nFR; ++j ) /* last column of R is thrown away */
-				applyGivens( c,s,nu,RR(i-1,j),RR(i,j), RR(i-1,j),RR(i,j) );
-		}
-
-		/* 3) Delete <number_idx>th column and ... */
-		for( i=0; i<nFR-1; ++i )
-			for( j=number_idx+1; j<nFR; ++j )
-				RR(i,j-1) = RR(i,j);
-		/* ... last column of R. */
-		for( i=0; i<nFR; ++i )
-			RR(i,nFR-1) = 0.0;
-	}
-
-	/* II) UPDATE INDICES */
-	tabularOutput.idxAddB = number;
-	if ( bounds.moveFreeToFixed( number,B_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_ADDBOUND_FAILED );
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e B o u n d
- */
-returnValue QProblemB::removeBound(	int_t number,
-									BooleanType updateCholesky
-									)
-{
-	int_t i;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* save index sets and decompositions for flipping bounds strategy */
-	if ( options.enableFlippingBounds == BT_TRUE )
-		flipper.set( &bounds,R );
-
-	/* I) UPDATE INDICES */
-	tabularOutput.idxRemB = number;
-	if ( bounds.moveFixedToFree( number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-	/* Perform cholesky updates only if QProblemB has been initialised! */
-	if ( getStatus( ) == QPS_PREPARINGAUXILIARYQP )
-		return SUCCESSFUL_RETURN;
-
-
-	/* II) PERFORM CHOLESKY UPDATE */
-	if ( ( updateCholesky == BT_TRUE ) &&
-		 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-	{
-		int_t* FR_idx;
-		bounds.getFree( )->getNumberArray( &FR_idx );
-
-		/* 1) Calculate new column of cholesky decomposition. */
-		real_t* rhs = new real_t[nFR+1];
-		real_t* r   = new real_t[nFR];
-
-		real_t r0;
-		switch ( hessianType )
-		{
-			case HST_ZERO: /* TODO: Code can/should? never get here!! */
-				if ( usingRegularisation( ) == BT_FALSE )
-					r0 = 0.0;
-				else
-					r0 = regVal;
-				for( i=0; i<nFR; ++i )
-					rhs[i] = 0.0;
-				break;
-
-			case HST_IDENTITY:
-				r0 = 1.0;
-				for( i=0; i<nFR; ++i )
-					rhs[i] = 0.0;
-				break;
-
-			default:
-				H->getRow(number, bounds.getFree(), 1.0, rhs);
-				r0 = H->diag(number);
-				break;
-		}
-
-		if ( backsolveR( rhs,BT_TRUE,BT_TRUE,r ) != SUCCESSFUL_RETURN )
-		{
-			delete[] rhs; delete[] r;
-			return THROWERROR( RET_REMOVEBOUND_FAILED );
-		}
-
-		for( i=0; i<nFR; ++i )
-			r0 -= r[i]*r[i];
-
-		/* 2) Store new column into R. */
-		for( i=0; i<nFR; ++i )
-			RR(i,nFR) = r[i];
-
-		if ( options.enableFlippingBounds == BT_TRUE )
-		{
-			if ( r0 > options.epsFlipping )
-				RR(nFR,nFR) = getSqrt( r0 );
-			else
-			{
-				hessianType = HST_SEMIDEF;
-
-				flipper.get( &bounds,R );
-				bounds.flipFixed(number);
-
-				switch (bounds.getStatus(number))
-				{
-					case ST_LOWER: lb[number] = ub[number]; break;
-					case ST_UPPER: ub[number] = lb[number]; break;
-					default: delete[] rhs; delete[] r; return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-
-			}
-		}
-		else
-		{
-			if ( r0 > ZERO )
-				RR(nFR,nFR) = getSqrt( r0 );
-			else
-			{
-				delete[] rhs; delete[] r;
-
-				hessianType = HST_SEMIDEF;
-				return THROWERROR( RET_HESSIAN_NOT_SPD );
-			}
-		}
-
-		delete[] rhs; delete[] r;
-	}
-
-	if ( ( hessianType == HST_ZERO ) && ( options.enableFlippingBounds == BT_TRUE ) )
-	{
-		flipper.get( &bounds,R );
-		bounds.flipFixed(number);
-
-		switch (bounds.getStatus(number))
-		{
-			case ST_LOWER: lb[number] = ub[number]; break;
-			case ST_UPPER: ub[number] = lb[number]; break;
-			default: return THROWERROR( RET_MOVING_BOUND_FAILED );
-		}
-
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	p r i n t I t e r a t i o n
- */
-returnValue QProblemB::printIteration( 	int_t iter,
-										int_t BC_idx,	SubjectToStatus BC_status, real_t homotopyLength,
-										BooleanType isFirstCall
-										)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	/* consistency check */
-	if ( iter < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	int_t i;
-	int_t nV = getNV();
-	real_t stat, bfeas, bcmpl;
-	real_t *grad = 0;
-
-	char myPrintfString[MAX_STRING_LENGTH];
-	char info[MAX_STRING_LENGTH];
-	const char excStr[] = " ef";
-
-	switch ( options.printLevel )
-	{
-		case PL_DEBUG_ITER:
-			grad = new real_t[nV];
-			stat = bfeas = bcmpl = 0.0;
-
-			/* stationarity */
-			for (i = 0; i < nV; i++) grad[i] = g[i] - y[i];
-			H->times(1, 1.0, x, nV, 1.0, grad, nV);
-			for (i = 0; i < nV; i++) if (getAbs(grad[i]) > stat) stat = getAbs(grad[i]);
-
-			/* feasibility */
-			for (i = 0; i < nV; i++) if (lb[i] - x[i] > bfeas) bfeas = lb[i] - x[i];
-			for (i = 0; i < nV; i++) if (x[i] - ub[i] > bfeas) bfeas = x[i] - ub[i];
-
-			/* complementarity */
-			for (i = 0; i < nV; i++) if (y[i] > +EPS && getAbs((lb[i] - x[i])*y[i]) > bcmpl) bcmpl = getAbs((lb[i] - x[i])*y[i]);
-			for (i = 0; i < nV; i++) if (y[i] < -EPS && getAbs((ub[i] - x[i])*y[i]) > bcmpl) bcmpl = getAbs((ub[i] - x[i])*y[i]);
-
-			if ( (iter % 10 == 0) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "\n%5s %4s %4s %9s %9s %9s %9s %9s\n",
-						"iter", "addB", "remB", "hom len", "tau", "stat", "bfeas", "bcmpl");
-			}
-			myPrintf( myPrintfString );
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d ",(int)iter );
-			myPrintf( myPrintfString );
-
-			if (tabularOutput.idxAddB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxAddB) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			if (tabularOutput.idxRemB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxRemB) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%9.2e %9.2e %9.2e %9.2e %9.2e\n",
-					homotopyLength, tau, stat, bfeas, bcmpl);
-			myPrintf( myPrintfString );
-
-			delete[] grad;
-			break;
-
-		case PL_TABULAR:
-			if ( (iter % 10 == 0) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "\n%5s %6s %6s %9s %9s\n",
-						"iter", "addB", "remB", "hom len", "tau");
-				myPrintf( myPrintfString );
-			}
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d ",(int)iter );
-			myPrintf( myPrintfString );
-
-			if (tabularOutput.idxAddB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxAddB), excStr[tabularOutput.excAddB]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			if (tabularOutput.idxRemB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxRemB), excStr[tabularOutput.excRemB]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%9.2e %9.2e\n", homotopyLength, tau);
-			myPrintf( myPrintfString );
-			break;
-
-		case PL_MEDIUM:
-			/* 1) Print header at first iteration. */
- 			if ( ( iter == 0 ) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH,"\n\n#################   qpOASES  --  QP NO. %3.0d   ##################\n\n",(int)count );
-				myPrintf( myPrintfString );
-
-				myPrintf( "    Iter   |    StepLength    |       Info       |   nFX    \n" );
-				myPrintf( " ----------+------------------+------------------+--------- \n" );
-			}
-
-			/* 2) Print iteration line. */
-			if ( BC_status == ST_UNDEFINED )
-			{
-				if ( hessianType == HST_ZERO )
-					snprintf( info,3,"LP" );
-				else
-					snprintf( info,3,"QP" );
-
-				if ( isFirstCall == BT_TRUE )
-					snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d   |   %1.6e   |    %s SOLVED     |  %4.1d   \n", (int)iter,tau,info,(int)getNFX( ) );
-				else
-					snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d*  |   %1.6e   |    %s SOLVED     |  %4.1d   \n", (int)iter,tau,info,(int)getNFX( ) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				if ( BC_status == ST_INACTIVE )
-					snprintf( info,8,"REM BND" );
-				else
-					snprintf( info,8,"ADD BND" );
-
-				snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d   |   %1.6e   |   %s %4.1d   |  %4.1d   \n", (int)iter,tau,info,(int)BC_idx,(int)getNFX( ) );
-				myPrintf( myPrintfString );
-			}
-			break;
-
-		default:
-			/* nothing to display */
-			break;
-	}
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/SQProblem.cpp b/extlibs/qpOASES-3.2.0/src/SQProblem.cpp
deleted file mode 100644
index a787c70..0000000
--- a/extlibs/qpOASES-3.2.0/src/SQProblem.cpp
+++ /dev/null
@@ -1,553 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/SQProblem.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the SQProblem class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming
- *	with varying matrices.
- */
-
-
-#include <qpOASES/SQProblem.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	S Q P r o b l e m
- */
-SQProblem::SQProblem( ) : QProblem( )
-{
-}
-
-
-/*
- *	S Q P r o b l e m
- */
-SQProblem::SQProblem( int_t _nV, int_t _nC, HessianType _hessianType ) : QProblem( _nV,_nC,_hessianType )
-{
-}
-
-
-/*
- *	S Q P r o b l e m
- */
-SQProblem::SQProblem( const SQProblem& rhs ) : QProblem( rhs )
-{
-}
-
-
-/*
- *	~ S Q P r o b l e m
- */
-SQProblem::~SQProblem( )
-{
-}
-
-
-/*
- *	o p e r a t o r =
- */
-SQProblem& SQProblem::operator=( const SQProblem& rhs )
-{
-	if ( this != &rhs )
-	{
-		QProblem::operator=( rhs );
-	}
-
-	return *this;
-}
-
-
-
-/*
- * h o t s t a r t
- */
-returnValue SQProblem::hotstart(	SymmetricMatrix *H_new, const real_t* const g_new, Matrix *A_new,
-									const real_t* const lb_new, const real_t* const ub_new,
-									const real_t* const lbA_new, const real_t* const ubA_new,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-									)
-{
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED );
-	}
-
-
-	real_t starttime = 0.0;
-	real_t auxTime = 0.0;
-
-    if ( cputime != 0 )
-        starttime = getCPUtime( );
-
-
-	/* I) UPDATE QP MATRICES AND VECTORS */
-	if ( setupNewAuxiliaryQP( H_new,A_new,lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-
-	/* II) PERFORM USUAL HOMOTOPY */
-
-	/* Allow only remaining CPU time for usual hotstart. */
-	if ( cputime != 0 )
-	{
-		auxTime = getCPUtime( ) - starttime;
-		*cputime -= auxTime;
-	}
-
-	returnValue returnvalue = QProblem::hotstart(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-													nWSR,cputime,
-													guessedBounds,guessedConstraints
-													);
-	
-	if ( cputime != 0 )
-		*cputime += auxTime;
-
-	return returnvalue;
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue SQProblem::hotstart(	const real_t* const H_new, const real_t* const g_new, const real_t* const A_new,
-									const real_t* const lb_new, const real_t* const ub_new,
-									const real_t* const lbA_new, const real_t* const ubA_new,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-									)
-{
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED );
-	}
-
-	/* start runtime measurement */
-	real_t starttime = 0.0;
-    if ( cputime != 0 )
-        starttime = getCPUtime( );
-
-
-	/* I) UPDATE QP MATRICES AND VECTORS */
-	if ( setupNewAuxiliaryQP( H_new,A_new,lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-
-	/* II) PERFORM USUAL HOMOTOPY */
-
-	/* Allow only remaining CPU time for usual hotstart. */
-	if ( cputime != 0 )
-		*cputime -= getCPUtime( ) - starttime;
-
-	returnValue returnvalue = QProblem::hotstart(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-													nWSR,cputime,
-													guessedBounds,guessedConstraints
-													);
-
-
-	/* stop runtime measurement */
-	if ( cputime != 0 )
-		*cputime = getCPUtime( ) - starttime;
-
-	return returnvalue;
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue SQProblem::hotstart(	const char* const H_file, const char* const g_file, const char* const A_file,
-									const char* const lb_file, const char* const ub_file,
-									const char* const lbA_file, const char* const ubA_file,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-									)
-{
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	returnValue returnvalue;
-
-	/* consistency checks */
-	if ( ( H_file == 0 ) || ( g_file == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( nC > 0 ) && ( A_file == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Load new QP matrices from files. */
-	real_t* H_new  = new real_t[nV*nV];
-	real_t* A_new  = new real_t[nC*nV];
-
-	if ( readFromFile( H_new, nV,nV, H_file ) != SUCCESSFUL_RETURN )
-	{
-		delete[] A_new;
-		delete[] H_new;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	if ( readFromFile( A_new, nC,nV, A_file ) != SUCCESSFUL_RETURN )
-	{
-		delete[] A_new;
-		delete[] H_new;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	/* 2) Load new QP vectors from files. */
-	real_t* g_new   = new real_t[nV];
-	real_t* lb_new  = ( lb_file != 0 )  ? new real_t[nV] : 0;
-	real_t* ub_new  = ( ub_file != 0 )  ? new real_t[nV] : 0;
-	real_t* lbA_new = ( lbA_file != 0 ) ? new real_t[nC] : 0;
-	real_t* ubA_new = ( ubA_file != 0 ) ? new real_t[nC] : 0;
-
-	returnvalue = loadQPvectorsFromFile(	g_file,lb_file,ub_file,lbA_file,ubA_file,
-											g_new,lb_new,ub_new,lbA_new,ubA_new
-											);
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		if ( ubA_file != 0 )
-			delete[] ubA_new;
-		if ( lbA_file != 0 )
-			delete[] lbA_new;
-		if ( ub_file != 0 )
-			delete[] ub_new;
-		if ( lb_file != 0 )
-			delete[] lb_new;
-		delete[] g_new;
-		delete[] A_new;
-		delete[] H_new;
-
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	/* 3) Actually perform hotstart. */
-	returnvalue = hotstart(	H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new,
-							nWSR,cputime,
-							guessedBounds,guessedConstraints
-							);
-
-	if ( ubA_file != 0 )
-		delete[] ubA_new;
-	if ( lbA_file != 0 )
-		delete[] lbA_new;
-	if ( ub_file != 0 )
-		delete[] ub_new;
-	if ( lb_file != 0 )
-		delete[] lb_new;
-	delete[] g_new;
-	delete[] A_new;
-	delete[] H_new;
-
-	return returnvalue;
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue SQProblem::hotstart(	const real_t* const g_new,
-									const real_t* const lb_new, const real_t* const ub_new,
-									const real_t* const lbA_new, const real_t* const ubA_new,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-									)
-{
-	/* Call to hotstart function for fixed QP matrices. */
-	return QProblem::hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,cputime, guessedBounds,guessedConstraints );
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue SQProblem::hotstart(	const char* const g_file,
-									const char* const lb_file, const char* const ub_file,
-									const char* const lbA_file, const char* const ubA_file,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-									)
-{
-	/* Call to hotstart function for fixed QP matrices. */
-	return QProblem::hotstart( g_file,lb_file,ub_file,lbA_file,ubA_file, nWSR,cputime, guessedBounds,guessedConstraints );
-}
-
-
-
-#ifdef __MATLAB__
-returnValue SQProblem::resetMatrixPointers( )
-{
-	H = 0;
-	A = 0;
-
-	return SUCCESSFUL_RETURN;
-}
-#endif
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	s e t u p N e w A u x i l i a r y Q P
- */
-returnValue SQProblem::setupNewAuxiliaryQP(	SymmetricMatrix *H_new, Matrix *A_new,
-											const real_t *lb_new, const real_t *ub_new, const real_t *lbA_new, const real_t *ubA_new
-											)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-	returnValue returnvalue;
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED );
-	}
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* I) SETUP NEW QP MATRICES AND VECTORS: */
-	/* 1) Shift constraints' bounds vectors by (A_new - A)'*x_opt to ensure
-	 *    that old optimal solution remains feasible for new QP data. */
-	/*    Firstly, shift by -A'*x_opt and ... */
-	if ( nC > 0 )
-	{
-		if ( A_new == 0 )
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-
-		for ( i=0; i<nC; ++i )
-		{
-			lbA[i] = -Ax_l[i];
-			ubA[i] =  Ax_u[i];
-		}
-
-		/* Set constraint matrix as well as ... */
-		setA( A_new );
-
-		/* ... secondly, shift by +A_new'*x_opt. */
-		for ( i=0; i<nC; ++i )
-		{
-			lbA[i] += Ax[i];
-			ubA[i] += Ax[i];
-		}
-
-		/* update constraint products. */
-		for ( i=0; i<nC; ++i )
-		{
-			Ax_u[i] = ubA[i] - Ax[i];
-			Ax_l[i] = Ax[i] - lbA[i];
-		}
-	}
-
-	/* 2) Set new Hessian matrix, determine Hessian type and
-	 *    regularise new Hessian matrix if necessary. */
-	/* a) Setup new Hessian matrix and determine its type. */
-	if ( H_new != 0 )
-	{
-		setH( H_new );
-
-		hessianType = HST_UNKNOWN;
-		if ( determineHessianType( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* b) Regularise new Hessian if necessary. */
-		if ( ( hessianType == HST_ZERO ) ||
-			 ( hessianType == HST_SEMIDEF ) ||
-			 ( usingRegularisation( ) == BT_TRUE ) )
-		{
-			regVal = 0.0; /* reset previous regularisation */
-
-			if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-		}
-	}
-	else
-	{
-		/* if no Hessian is specified, keep previous trivial Hessian (HST_ZERO or HST_IDENTITY),
-		   otherwise abort */
-		if ( H != 0 )
-			return THROWERROR( RET_NO_HESSIAN_SPECIFIED );
-	}
-
-	/* 3) Setup QP gradient. */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-
-	/* II) SETUP WORKING SETS AND MATRIX FACTORISATIONS: */
-	/* 1) Make a copy of current bounds/constraints ... */
-	Bounds      oldBounds      = bounds;
-	Constraints oldConstraints = constraints;
-
-    /* we're trying to find an active set with positive definite null
-     * space Hessian twice:
-     * - first for the current active set including all equalities
-     * - second after moving all inactive variables to a bound
-     *   (depending on Options). This creates an empty null space and
-     *   is guaranteed to succeed. Thus this loop will exit after n_try=1.
-     */
-    int_t n_try;
-    for (n_try = 0; n_try < 2; ++n_try) {
-
-        if (n_try > 0) {
-            // the current active set leaves an indefinite null space Hessian
-            // move all inactive variables to a bound, creating an empty null space
-            for (int_t ii = 0; ii < nV; ++ii)
-                if (oldBounds.getStatus (ii) == ST_INACTIVE)
-                    oldBounds.setStatus (ii, options.initialStatusBounds);
-        }
-
-        /*    ... reset them ... */
-        bounds.init( nV );
-        constraints.init( nC );
-
-        /*    ... and set them up afresh. */
-        if ( setupSubjectToType(lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN )
-            return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-        if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-            return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-        if ( constraints.setupAllInactive( ) != SUCCESSFUL_RETURN )
-            return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-        /* 2) Setup TQ factorisation. */
-        if ( setupTQfactorisation( ) != SUCCESSFUL_RETURN )
-            return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		// check for equalities that have become bounds ...
-		for (int_t ii = 0; ii < nC; ++ii) {
-			if (oldConstraints.getType (ii) == ST_EQUALITY && constraints.getType (ii) == ST_BOUNDED) {
-				if (oldConstraints.getStatus (ii) == ST_LOWER && y[nV+ii] < 0.0)
-					oldConstraints.setStatus (ii, ST_UPPER);
-				else if (oldConstraints.getStatus (ii) == ST_UPPER && y[nV+ii] > 0.0)
-					oldConstraints.setStatus (ii, ST_LOWER);
-			}
-		}
-
-		// ... and do the same also for the bounds!
-		for (int_t ii = 0; ii < nV; ++ii) {
-			if (oldBounds.getType(ii) == ST_EQUALITY
-					&& bounds.getType(ii) == ST_BOUNDED) {
-				if (oldBounds.getStatus(ii) == ST_LOWER && y[ii] < 0.0)
-					oldBounds.setStatus(ii, ST_UPPER);
-				else if (oldBounds.getStatus(ii) == ST_UPPER && y[ii] > 0.0)
-					oldBounds.setStatus(ii, ST_LOWER);
-			}
-		}
-
-        /* 3) Setup old working sets afresh (updating TQ factorisation). */
-        if ( setupAuxiliaryWorkingSet( &oldBounds,&oldConstraints,BT_TRUE ) != SUCCESSFUL_RETURN )
-            return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-        /* Factorise projected Hessian
-        * this now handles all special cases (no active bounds/constraints, no nullspace) */
-        returnvalue = computeProjectedCholesky( );
-
-        /* leave the loop if decomposition was successful, i.e. we have
-         * found an active set with positive definite null space Hessian */
-        if ( returnvalue == SUCCESSFUL_RETURN )
-            break;
-    }
-
-    /* adjust lb/ub if we changed the old active set in the second try
-     */
-    if (n_try > 0) {
-		// as per setupAuxiliaryQPbounds assumptions ... oh the troubles
-		for (int_t ii = 0; ii < nC; ++ii)
-			Ax_l[ii] = Ax_u[ii] = Ax[ii];
-        setupAuxiliaryQPbounds( &bounds, &constraints, BT_FALSE );
-	}
-
-	status = QPS_AUXILIARYQPSOLVED;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p N e w A u x i l i a r y Q P
- */
-returnValue SQProblem::setupNewAuxiliaryQP(	const real_t* const H_new, const real_t* const A_new,
-											const real_t *lb_new, const real_t *ub_new, const real_t *lbA_new, const real_t *ubA_new
-											)
-{
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	DenseMatrix *dA = 0;
-	SymDenseMat *sH = 0;
-
-	if ( A_new != 0 )
-	{
-		dA = new DenseMatrix(nC, nV, nV, (real_t*) A_new);
-	}
-	else
-	{
-		if ( nC > 0 )
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( H_new != 0 )
-		sH = new SymDenseMat(nV, nV, nV, (real_t*) H_new);
-
-	returnValue returnvalue = setupNewAuxiliaryQP( sH,dA, lb_new,ub_new,lbA_new,ubA_new );
-
-	if ( H_new != 0 )
-		freeHessian = BT_TRUE;
-	freeConstraintMatrix = BT_TRUE;
-
-	return returnvalue;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/SQProblemSchur.cpp b/extlibs/qpOASES-3.2.0/src/SQProblemSchur.cpp
deleted file mode 100644
index e70aa4b..0000000
--- a/extlibs/qpOASES-3.2.0/src/SQProblemSchur.cpp
+++ /dev/null
@@ -1,3626 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2014 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/SQProblemSchur.cpp
- *	\author Andreas Waechter and Dennis Janka, based on QProblem.cpp by Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2012-2015
- *
- *	Implementation of the SQProblemSchur class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming.
- *	This implementation uses a Schur complement approach to solve the linear
- *	systems.
- */
-
-#include <qpOASES/SQProblemSchur.hpp>
-
-
-#ifndef __MATLAB__
-# include <cstdarg>
-void MyPrintf(const char* pformat, ... )
-{
-  va_list ap;
-  va_start(ap, pformat);
-
-  vfprintf(stdout, pformat, ap);
-
-  va_end(ap);
-}
-#else
-# include <mex.h>
-# define MyPrintf mexPrintf
-#endif
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	Q P r o b l e m
- */
-SQProblemSchur::SQProblemSchur( ) : SQProblem( )
-{
-#ifdef SOLVER_MA57
-	sparseSolver = new Ma57SparseSolver();
-#elif defined SOLVER_MA27
-	sparseSolver = new Ma27SparseSolver();
-#elif defined SOLVER_NONE
-	sparseSolver = new DummySparseSolver();
-#endif
-
-	nSmax = 0;
-	nS = -1;
-	S = 0;
-	Q_ = 0;
-	R_ = 0;
-	detS = 0.0;
-	rcondS = 0.0;
-	schurUpdateIndex = 0;
-	schurUpdate = 0;
-	numFactorizations = 0;
-
-	M_physicallength = 0;
-	M_vals = 0;
-	M_ir = 0;
-	M_jc = 0;
-}
-
-
-/*
- *	Q P r o b l e m
- */
-SQProblemSchur::SQProblemSchur( int_t _nV, int_t _nC, HessianType _hessianType, int_t maxSchurUpdates ) : SQProblem( _nV,_nC,_hessianType )
-{
-	/* We use the variables Q and R to store the QR factorization of S.
-	 * T is not required. */
-	delete [] R; R = 0;
-	delete [] Q; Q = 0;
-	delete [] T; T = 0;
-
-	/* The interface to the sparse linear solver.  In the long run,
-	   different linear solvers might be optionally chosen. */
-#ifdef SOLVER_MA57
-	sparseSolver = new Ma57SparseSolver();
-#elif defined SOLVER_MA27
-	sparseSolver = new Ma27SparseSolver();
-#elif defined SOLVER_NONE
-	sparseSolver = new DummySparseSolver();
-#endif
-
-	nSmax = maxSchurUpdates;
-	nS = -1;
-	if ( nSmax > 0 )
-	{
-		S = new real_t[nSmax*nSmax];
-		schurUpdateIndex = new int_t[nSmax];
-		schurUpdate = new SchurUpdateType[nSmax];
-		Q_ = new real_t[nSmax*nSmax];
-		R_ = new real_t[nSmax*nSmax];
-		M_physicallength = 10*nSmax;  /* TODO: Decide good default. */
-		M_vals = new real_t[M_physicallength];
-		M_ir = new sparse_int_t[M_physicallength];
-		M_jc = new sparse_int_t[nSmax+1];
-		detS = 1.0;
-		rcondS = 1.0;
-	}
-	else
-	{
-		S = 0;
-		Q_ = 0;
-		R_ = 0;
-		detS = 0.0;
-		rcondS = 0.0;
-		schurUpdateIndex = 0;
-		schurUpdate = 0;
-		M_physicallength = 0;
-		M_vals = 0;
-		M_ir = 0;
-		M_jc = 0;
-	}
-	numFactorizations = 0;
-}
-
-
-/*
- *	Q P r o b l e m
- */
-SQProblemSchur::SQProblemSchur( const SQProblemSchur& rhs ) : SQProblem( rhs )
-{
-#ifdef SOLVER_MA57
-	sparseSolver = new Ma57SparseSolver();
-#elif defined SOLVER_MA27
-	sparseSolver = new Ma27SparseSolver();
-#elif defined SOLVER_NONE
-	sparseSolver = new DummySparseSolver();
-#endif
-	copy( rhs );
-}
-
-
-/*
- *	~ Q P r o b l e m
- */
-SQProblemSchur::~SQProblemSchur( )
-{
-	delete sparseSolver;
-
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-SQProblemSchur& SQProblemSchur::operator=( const SQProblemSchur& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		SQProblem::operator=( rhs );
-		copy( rhs );
-	}
-	return *this;
-}
-
-
-/*
- *	r e s e t
- */
-returnValue SQProblemSchur::reset( )
-{
-	/* AW: We probably want to avoid resetting factorization in QProblem */
-	if ( SQProblem::reset( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_RESET_FAILED );
-
-	sparseSolver->reset();
-	nS = -1;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue SQProblemSchur::clear( )
-{
-	nSmax = 0;
-	nS = -1;
-	detS = 0.0;
-	rcondS = 0.0;
-	numFactorizations = 0;
-	delete [] S; S=0;
-	delete [] Q_; Q_=0;
-	delete [] R_; R_=0;
-	delete [] schurUpdateIndex; schurUpdateIndex=0;
-	delete [] schurUpdate; schurUpdate=0;
-	M_physicallength = 0;
-	delete [] M_vals; M_vals=0;
-	delete [] M_ir; M_ir=0;
-	delete [] M_jc; M_jc=0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue SQProblemSchur::copy(	const SQProblemSchur& rhs
-									)
-{
-	int_t i, j, length;
-
-	*sparseSolver = *(rhs.sparseSolver);
-
-	nS = rhs.nS;
-	nSmax = rhs.nSmax;
-	if ( nSmax > 0 )
-	{
-		detS = rhs.detS;
-		rcondS = rhs.rcondS;
-		S = new real_t[nSmax*nSmax];
-		Q_ = new real_t[nSmax*nSmax];
-		R_ = new real_t[nSmax*nSmax];
-		schurUpdateIndex = new int_t[nSmax];
-		schurUpdate = new SchurUpdateType[nSmax];
-
-		if ( nS>0 )
-		{
-			for ( i=0; i<nS; i++)
-				for ( j=0; j<nS; j++)
-				{
-					S[i*nSmax + j] = rhs.S[i*nSmax + j];
-					Q_[i*nSmax + j] = rhs.Q_[i*nSmax + j];
-					R_[i*nSmax + j] = rhs.R_[i*nSmax + j];
-				}
-
-			memcpy( schurUpdateIndex, rhs.schurUpdateIndex, ((unsigned int)nS)*sizeof(int_t));
-			memcpy( schurUpdate, rhs.schurUpdate, ((unsigned int)nS)*sizeof(SchurUpdateType));
-		}
-
-		M_physicallength = rhs.M_physicallength;
-		if ( M_physicallength>0 )
-		{
-			M_vals = new real_t[M_physicallength];
-			M_ir = new sparse_int_t[M_physicallength];
-			M_jc = new sparse_int_t[nSmax+1];
-
-			if ( nS>0 )
-			{
-				memcpy(M_jc, rhs.M_jc, ((unsigned int)(nS+1))*sizeof(sparse_int_t));
-				length = M_jc[nS];
-				memcpy(M_vals, rhs.M_vals, ((unsigned int)length)*sizeof(real_t));
-				memcpy(M_ir, rhs.M_ir, ((unsigned int)length)*sizeof(sparse_int_t));
-			}
-			else if ( nS==0 )
-				M_jc[0] = rhs.M_jc[0];
-		}
-	}
-	else
-	{
-		S = 0;
-		Q_ = 0;
-		R_ = 0;
-		detS = 0.0;
-		rcondS = 0.0;
-		schurUpdateIndex = 0;
-		schurUpdate = 0;
-		M_physicallength = 0;
-		M_vals = 0;
-		M_ir = 0;
-		M_jc = 0;
-	}
-	numFactorizations = rhs.numFactorizations;
-
-	boundsFreeStart = rhs.boundsFreeStart;
-	constraintsActiveStart = rhs.constraintsActiveStart;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P
- */
-returnValue SQProblemSchur::setupAuxiliaryQP(	SymmetricMatrix *H_new,
-												Matrix *A_new,
-												const real_t *lb_new,
-												const real_t *ub_new,
-												const real_t *lbA_new,
-												const real_t *ubA_new
-												)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-	returnValue returnvalue;
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED );
-	}
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* I) SETUP NEW QP MATRICES AND VECTORS: */
-	/* 1) Shift constraints' bounds vectors by (A_new - A)'*x_opt to ensure
-	 *    that old optimal solution remains feasible for new QP data. */
-	/*    Firstly, shift by -A'*x_opt and ... */
-	if ( nC > 0 )
-	{
-		if ( A_new == 0 )
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-
-		for ( i=0; i<nC; ++i )
-		{
-			lbA[i] = -Ax_l[i];
-			ubA[i] =  Ax_u[i];
-		}
-
-		/* Set constraint matrix as well as ... */
-		setA( A_new );
-
-		/* ... secondly, shift by +A_new'*x_opt. */
-		for ( i=0; i<nC; ++i )
-		{
-			lbA[i] += Ax[i];
-			ubA[i] += Ax[i];
-		}
-
-		/* update constraint products. */
-		for ( i=0; i<nC; ++i )
-		{
-			Ax_u[i] = ubA[i] - Ax[i];
-			Ax_l[i] = Ax[i] - lbA[i];
-		}
-	}
-
-	/* 2) Set new Hessian matrix,determine Hessian type and
-	 *    regularise new Hessian matrix if necessary. */
-	/* a) Setup new Hessian matrix and determine its type. */
-	if ( H_new != 0 )
-	{
-		setH( H_new );
-
-		hessianType = HST_UNKNOWN;
-		if ( determineHessianType( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* b) Regularise new Hessian if necessary. */
-		if ( ( hessianType == HST_ZERO ) ||
-			 ( hessianType == HST_SEMIDEF ) ||
-			 ( usingRegularisation( ) == BT_TRUE ) )
-		{
-			regVal = 0.0; /* reset previous regularisation */
-
-			if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-		}
-	}
-	else
-	{
-		if ( H != 0 )
-			return THROWERROR( RET_NO_HESSIAN_SPECIFIED );
-	}
-
-	/* 3) Setup QP gradient. */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	/* II) SETUP WORKING SET AND MATRIX FACTORISATION: */
-
-	/* 1) Check if current active set is linearly independent and has the correct inertia */
-	returnvalue = resetSchurComplement( BT_FALSE );
-	int_t neig = sparseSolver->getNegativeEigenvalues( );
-
-	if ( returnvalue == SUCCESSFUL_RETURN && neig == getNAC( ) )
-	{
-		/* a) This means the proposed working set is linearly independent and
-		 *    leaves no zero curvature exposed in the nullspace and can be used to start QP solve. */
-		if ( options.printLevel == PL_HIGH )
-			MyPrintf( "In hotstart for new matrices, old working set is linearly independent and has correct inertia.\n");
-
-		status = QPS_AUXILIARYQPSOLVED;
-		return SUCCESSFUL_RETURN;
-	}
-	else if ( returnvalue == SUCCESSFUL_RETURN && neig > getNAC( ) )
-	{
-		/* b) KKT matrix has too many negative eigenvalues. Try to correct the inertia by adding bounds (reduce nullspace dimension). */
-		if ( options.printLevel == PL_HIGH )
-			MyPrintf( "WARNING: In hotstart for new matrices, reduced Hessian for initial working set has %i negative eigenvalues, should be %i.\n", neig, getNAC( ) );
-
-		/* If enabling inertia correction is disabled, exit here */
-		if ( options.enableInertiaCorrection )
-		{
-			returnvalue = correctInertia();
-			if ( returnvalue == SUCCESSFUL_RETURN )
-			{
-				status = QPS_AUXILIARYQPSOLVED;
-				return SUCCESSFUL_RETURN;
-			}
-		}
-		else
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-
-	/* 2) If inertia correction has failed or factorization yielded some other error,
-	 *    try to rebuild the active set with all simple bounds set according to initialStatusBounds
-	 *    (Note: in exact arithmetic, this cannot happen) */
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "WARNING: hotstart for old active set failed. Trying to rebuild a working set.\n");
-
-	Bounds      oldBounds      = bounds;
-	Constraints oldConstraints = constraints;
-
-	/* Move all inactive variables to a bound */
-	for ( i=0; i<nV; i++ )
-	{
-		#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-		if ( bounds.getType( i ) == ST_EQUALITY )
-		{
-			if ( oldBounds.setStatus( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-		}
-		else
-		#endif
-		{
-			if ( oldBounds.getStatus( i ) == ST_INACTIVE )
-				if ( oldBounds.setStatus( i, options.initialStatusBounds ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-		}
-	}
-
-	/* Set all equalities active */
-	#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-	for( i=0; i<nC; ++i )
-	{
-		if ( constraints.getType( i ) == ST_EQUALITY )
-			if ( oldConstraints.setStatus( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-	#endif
-
-	/* Set all inequalities inactive */
-	for( i=0; i<nC; ++i )
-	{
-		if ( constraints.getType( i ) != ST_EQUALITY )
-			if ( oldConstraints.setStatus( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-
-	/* Reset bounds and constraints */
-	bounds.init( nV );
-	constraints.init( nC );
-
-	if ( setupSubjectToType(lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	if ( constraints.setupAllInactive( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	/* Setup working sets afresh. */
-	if ( setupAuxiliaryWorkingSet( &oldBounds,&oldConstraints,BT_TRUE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	/* adjust lb/ub */
-	for (int_t ii = 0; ii < nC; ++ii)
-		Ax_l[ii] = Ax_u[ii] = Ax[ii];
-	setupAuxiliaryQPbounds (&bounds, &constraints, BT_FALSE);
-
-	status = QPS_AUXILIARYQPSOLVED;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y W o r k i n g S e t
- */
-returnValue SQProblemSchur::setupAuxiliaryWorkingSet(	const Bounds* const auxiliaryBounds,
-														const Constraints* const auxiliaryConstraints,
-														BooleanType setupAfresh
-														)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	/* consistency checks */
-	if ( auxiliaryBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-			if ( ( bounds.getStatus( i ) == ST_UNDEFINED ) || ( auxiliaryBounds->getStatus( i ) == ST_UNDEFINED ) )
-				return THROWERROR( RET_UNKNOWN_BUG );
-	}
-	else
-	{
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( auxiliaryConstraints != 0 )
-	{
-		for( i=0; i<nC; ++i )
-			if ( ( constraints.getStatus( i ) == ST_UNDEFINED ) || ( auxiliaryConstraints->getStatus( i ) == ST_UNDEFINED ) )
-				return THROWERROR( RET_UNKNOWN_BUG );
-	}
-	else
-	{
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* I.) REMOVE INEQUALITY BOUNDS/CONSTRAINTS */
-
-	/* I.1) Remove inequality bounds that are active now but shall be
-	 *      inactive or active at the other bound according to auxiliaryBounds */
-	for( i=0; i<nV; ++i )
-	{
-		if ( ( bounds.getStatus( i ) == ST_LOWER ) && ( auxiliaryBounds->getStatus( i ) != ST_LOWER ) )
-			if ( bounds.moveFixedToFree( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-		if ( ( bounds.getStatus( i ) == ST_UPPER ) && ( auxiliaryBounds->getStatus( i ) != ST_UPPER ) )
-			if ( bounds.moveFixedToFree( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-	}
-
-	/* I.2.) Remove inequality constraints that are active now but shall be
-	 *       inactive or active at the other bound according to auxiliaryConstraints */
-	for( i=0; i<nC; ++i )
-	{
-		if ( ( constraints.getStatus( i ) == ST_LOWER ) && ( auxiliaryConstraints->getStatus( i ) != ST_LOWER ) )
-			if ( constraints.moveActiveToInactive( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-		if ( ( constraints.getStatus( i ) == ST_UPPER ) && ( auxiliaryConstraints->getStatus( i ) != ST_UPPER ) )
-			if ( constraints.moveActiveToInactive( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-	}
-
-	/* II.) ADD BOUNDS/CONSTRAINTS */
-
-	/* II.1.) Add bounds according to auxiliaryBounds */
-	for( i=0; i<nV; ++i )
-	{
-		if ( ( bounds.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryBounds->getStatus( i ) != ST_INACTIVE ) )
-			if ( bounds.moveFreeToFixed( i, auxiliaryBounds->getStatus( i ) ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-	}
-
-	/* II.2.) Add constraints according to auxiliaryConstraints */
-	for( i=0; i<nC; ++i )
-	{
-		if ( ( constraints.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryConstraints->getStatus( i ) != ST_INACTIVE ) )
-			if ( constraints.moveInactiveToActive( i,auxiliaryConstraints->getStatus( i ) ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-	}
-
-	/* III) FACTORIZATION */
-
-	/* III.1.) Factorize (resolves linear dependency) */
-	if( resetSchurComplement( BT_FALSE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-	/* III.2.) Check if inertia is correct. If so, we now have a linearly independent working set with a pos def reduced Hessian */
-	int_t neig = sparseSolver->getNegativeEigenvalues( );
-	if ( neig == getNAC( ) )
-	{
-		/* We now have a linearly independent working set with a pos def reduced Hessian.
-		 * We need to correct the QP bounds and gradient after this. */
-		return SUCCESSFUL_RETURN;
-	}
-
-	/* IV.) INERTIA CORRECTION IF NECESSARY */
-
-	/* We now have a fresh factorization and can start the usual inertia correction routine */
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "WARNING: In setupAuxiliaryWorkingSet: Initial working set reduced Hessian has %i negative eigenvalues, should be %i.\n", neig, getNAC( ) );
-
-	if ( options.enableInertiaCorrection == BT_TRUE )
-		return correctInertia( );
-	else
-		return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-}
-
-
-/*
- *	c h o l e s k y D e c o m p o s i t i o n P r o j e c t e d
- */
-returnValue SQProblemSchur::computeProjectedCholesky( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o m p u t e I n i t i a l C h o l e s k y
- */
-returnValue SQProblemSchur::computeInitialCholesky( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p T Q f a c t o r i s a t i o n
- */
-returnValue SQProblemSchur::setupTQfactorisation( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a d d C o n s t r a i n t
- */
-returnValue SQProblemSchur::addConstraint(	int_t number, 
-											SubjectToStatus C_status,
-											BooleanType updateCholesky,
-											BooleanType ensureLI
-											)
-{
-	int_t idxDeleted = -1;
-
-	/* consistency checks */
-	if ( constraints.getStatus( number ) != ST_INACTIVE )
-		return THROWERROR( RET_CONSTRAINT_ALREADY_ACTIVE );
-
-	if ( ( constraints.getNC( ) - getNAC( ) ) == constraints.getNUC( ) )
-		return THROWERROR( RET_ALL_CONSTRAINTS_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-
-	/* I) ENSURE LINEAR INDEPENDENCE OF THE WORKING SET,
-	 *    i.e. remove a constraint or bound if linear dependence occurs. */
-	if ( ensureLI == BT_TRUE )
-	{
-		returnValue ensureLIreturnvalue = addConstraint_ensureLI( number,C_status );
-
-		switch ( ensureLIreturnvalue )
-		{
-			case SUCCESSFUL_RETURN:
-				break;
-
-			case RET_LI_RESOLVED:
-				break;
-
-			case RET_ENSURELI_FAILED_NOINDEX:
-				return RET_ADDCONSTRAINT_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_FAILED_CYCLING:
-				return RET_ADDCONSTRAINT_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_DROPPED:
-				return SUCCESSFUL_RETURN;
-
-			default:
-				return THROWERROR( RET_ENSURELI_FAILED );
-		}
-	}
-
-	/* IV) UPDATE INDICES */
-	tabularOutput.idxAddC = number;
-	if ( constraints.moveInactiveToActive( number,C_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-
-	/* Also update the Schur complement. */
-
-	/* First check if this constraint had been removed before. In that
-	   case delete this constraint from the Schur complement. */
-	bool found = false;
-	for ( int_t i=0; i<nS; i++ )
-	{
-		if ( schurUpdate[i] == SUT_ConRemoved && number == schurUpdateIndex[i] )
-		{
-			if ( deleteFromSchurComplement( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-			found = true;
-			idxDeleted = i;
-			break;
-		}
-	}
-	if ( !found )
-	{
-		if ( nS < 0 || nS==nSmax )
-		{
-			/* The schur complement has become too large, reset. */
-			/* Correct inertia if necessary. */
-			returnValue retval = resetSchurComplement( BT_TRUE );
-			if ( retval != SUCCESSFUL_RETURN )
-			{
-				if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-					MyPrintf( "In addConstraint: KKT matrix singular when resetting Schur complement\n" );
-				else if ( options.printLevel == PL_HIGH )
-					MyPrintf( "In addConstraint, resetSchurComplement failed with retval = %d\n", retval);
-				return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-			}
-			found = true;
-		}
-		else
-		{
-			/* If the constraint was not yet in Schur complement, add it now. */
-			int_t nFRStart = boundsFreeStart.getLength();
-			int_t* FR_idxStart;
-			boundsFreeStart.getNumberArray( &FR_idxStart );
-
-			sparse_int_t* MNpos = new sparse_int_t[nFRStart+nS]; // This is an overestimate
-			real_t* MNvals = new real_t[nFRStart+nS];
-
-			int_t* irn = new int_t[nFRStart+nS];
-			int_t* jcn = new int_t[nFRStart+nS];
-			real_t* vals = new real_t[nFRStart+nS];
-			int_t* icolsNumber = new int_t[nFRStart+nS];
-			int_t* icolsSIdx = new int_t[nS];
-
-			for ( int_t i=0; i<nFRStart; i++)
-				icolsNumber[i] = FR_idxStart[i];
-
-			int_t icolsLength = nFRStart;
-			for ( int_t i=0; i<nS; i++)
-				if ( schurUpdate[i] == SUT_VarFreed )
-				{
-					icolsNumber[icolsLength] = schurUpdateIndex[i];
-					icolsSIdx[icolsLength-nFRStart] = i;
-					icolsLength++;
-				}
-
-			if ( constraintProduct != 0 )
-			{
-				MyPrintf( "In SQProblemSchur::addConstraint, constraintProduct not yet implemented.\n");
-				return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-			}
-			int_t numNonzerosA;
-			A->getSparseSubmatrix( 1, &number, icolsLength, icolsNumber, 0, 0, numNonzerosA, irn, jcn, vals );
-			delete [] irn;
-
-			int_t numNonzerosM = 0;
-			int_t numNonzerosN = 0;
-			for ( int_t i=0; i<numNonzerosA; i++ )
-				if ( jcn[i] < nFRStart )
-				{
-					MNpos[numNonzerosM] = jcn[i];
-					MNvals[numNonzerosM] = vals[i];
-					numNonzerosM++;
-				}
-				else
-				{
-					MNpos[nFRStart+numNonzerosN] = icolsSIdx[jcn[i]-nFRStart];
-					MNvals[nFRStart+numNonzerosN] = vals[i];
-					numNonzerosN++;
-				}
-
-			returnValue returnvalue = addToSchurComplement( number, SUT_ConAdded, numNonzerosM, MNpos, MNvals, numNonzerosN, MNpos+nFRStart, MNvals+nFRStart, 0.0 );
-
-			delete [] icolsSIdx;
-			delete [] icolsNumber;
-			delete [] vals;
-			delete [] jcn;
-			delete [] MNvals;
-			delete [] MNpos;
-
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-
-			found = true;
-		}
-	}
-
-	if ( !found )
-		return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-
-	updateSchurQR( idxDeleted );
-
-	/* If reciprocal of condition number becomes to small, refactorize KKT matrix */
-	if( rcondS < options.rcondSMin )
-	{
-		returnValue retval = resetSchurComplement( BT_TRUE );
-		if ( retval != SUCCESSFUL_RETURN )
-		{
-			if ( retval == RET_KKT_MATRIX_SINGULAR  && options.printLevel == PL_HIGH )
-				MyPrintf( "In addConstraint: KKT matrix singular when resetting Schur complement\n" );
-			else if ( options.printLevel == PL_HIGH )
-				MyPrintf( "In addConstraint, resetSchurComplement failed with retval = %d\n", retval);
-			return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	a d d C o n s t r a i n t _ c h e c k L I
- */
-returnValue SQProblemSchur::addConstraint_checkLI( int_t number )
-{
-	/* Get space for the multipliers xi in linear independence test */
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	real_t *xiC = new real_t[nAC];
-	real_t *xiB = new real_t[nFX];
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addConstraint_checkLISchur( number, xiC, xiB );
-
-	delete [] xiB;
-	delete [] xiC;
-
-	return returnvalueCheckLI;
-}
-
-
-/*
- *	a d d C o n s t r a i n t _ c h e c k L I S c h u r
- */
-returnValue SQProblemSchur::addConstraint_checkLISchur( int_t number, real_t* xiC, real_t* xiB )
-{
-	returnValue returnvalue = RET_LINEARLY_DEPENDENT;
-
-	int_t ii;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nC  = getNC( );
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	int_t *FR_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	/* For the Schur complement version we only use options.enableFullLITests = TRUE */
-	{
-		/*
-		 * expensive LI test. Backsolve with refinement using special right
-		 * hand side. This gives an estimate for what should be considered
-		 * "zero". We then check linear independence relative to this estimate.
-		 */
-
-		int_t *FX_idx, *AC_idx, *IAC_idx;
-
-		real_t *delta_g   = new real_t[nV];
-		real_t *delta_xFX = new real_t[nFX];
-		real_t *delta_xFR = new real_t[nFR];
-		real_t *delta_yAC = xiC;
-		real_t *delta_yFX = xiB;
-
-		bounds.getFixed( )->getNumberArray( &FX_idx );
-		constraints.getActive( )->getNumberArray( &AC_idx );
-		constraints.getInactive( )->getNumberArray( &IAC_idx );
-
-		int_t dim = (nC>nV)?nC:nV;
-		real_t *nul = new real_t[dim];
-		for (ii = 0; ii < dim; ++ii)
-			nul[ii]=0.0;
-
-		A->getRow (number, 0, 1.0, delta_g);
-
-		returnValue dsdreturnvalue = determineStepDirection ( delta_g,
-											  nul, nul, nul, nul,
-											  BT_FALSE, BT_FALSE,
-											  delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		if (dsdreturnvalue!=SUCCESSFUL_RETURN)
-			returnvalue = dsdreturnvalue;
-
-		delete[] nul;
-
-		/* compute the weight in inf-norm */
-		real_t weight = 0.0;
-		for (ii = 0; ii < nAC; ++ii)
-		{
-			real_t a = getAbs (delta_yAC[ii]);
-			if (weight < a) weight = a;
-		}
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_yFX[ii]);
-			if (weight < a) weight = a;
-		}
-
-		/* look at the "zero" in a relative inf-norm */
-		real_t zero = 0.0;
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_xFX[ii]);
-			if (zero < a) zero = a;
-		}
-		for (ii = 0; ii < nFR; ++ii)
-		{
-			real_t a = getAbs (delta_xFR[ii]);
-			if (zero < a) zero = a;
-		}
-
-		/* relative test against zero in inf-norm */
-		if (zero > options.epsLITests * weight)
-			returnvalue = RET_LINEARLY_INDEPENDENT;
-
-		delete[] delta_xFR;
-		delete[] delta_xFX;
-		delete[] delta_g;
-
-	}
-	return THROWINFO( returnvalue );
-}
-
-
-/*
- *	a d d C o n s t r a i n t _ e n s u r e L I
- */
-returnValue SQProblemSchur::addConstraint_ensureLI( int_t number, SubjectToStatus C_status )
-{
-	/* Get space for the multipliers xi in linear independence test */
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	real_t *xiC = new real_t[nAC];
-	real_t *xiB = new real_t[nFX];
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addConstraint_checkLISchur( number, xiC, xiB );
-
-	if ( returnvalueCheckLI == RET_INDEXLIST_CORRUPTED )
-	{
-		delete [] xiB;
-		delete [] xiC;
-		return THROWERROR( RET_ENSURELI_FAILED );
-	}
-
-	if ( returnvalueCheckLI == RET_LINEARLY_INDEPENDENT )
-	{
-		delete [] xiB;
-		delete [] xiC;
-		return SUCCESSFUL_RETURN;
-	}
-
- 	/* II) NEW BOUND IS LINEARLY DEPENDENT: */
-	/* 1) Coefficients of linear combination, have already been computed, but we need to correct the sign.  */
-	int_t i, ii;
-
-	if ( C_status != ST_LOWER )
-	{
-		for( i=0; i<nAC; ++i )
-			xiC[i] = -xiC[i];
-		for( i=0; i<nFX; ++i )
-			xiB[i] = -xiB[i];
-	}
-
-	int_t nV  = getNV( );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	real_t* num = new real_t[nV];
-
-	real_t y_min = options.maxDualJump;
-	int_t y_min_number = -1;
-	int_t y_min_number_bound = -1;
-	BooleanType y_min_isBound = BT_FALSE;
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	/* III) DETERMINE CONSTRAINT/BOUND TO BE REMOVED. */
-
-	/* 1) Constraints. */
-	for( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-		num[i] = y[nV+ii];
-	}
-
-	performRatioTest (nAC, AC_idx, &constraints, num, xiC, options.epsNum, options.epsDen, y_min, y_min_number);
-
-	/* 2) Bounds. */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-	}
-
-	performRatioTest (nFX, FX_idx, &bounds, num, xiB, options.epsNum, options.epsDen, y_min, y_min_number_bound);
-
-	if ( y_min_number_bound >= 0 )
-	{
-		y_min_number = y_min_number_bound;
-		y_min_isBound = BT_TRUE;
-	}
-
-	#ifndef __XPCTARGET__
-	/* setup output preferences */
-	char messageString[80];
-	#endif
-
-	/* IV) REMOVE CONSTRAINT/BOUND FOR RESOLVING LINEAR DEPENDENCE: */
-	if ( y_min_number >= 0 )
-	{
-		/* Update Lagrange multiplier... */
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			y[nV+ii] -= y_min * xiC[i];
-		}
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			y[ii] -= y_min * xiB[i];
-		}
-
-		/* ... also for newly active constraint... */
-		if ( C_status == ST_LOWER )
-			y[nV+number] = y_min;
-		else
-			y[nV+number] = -y_min;
-
-		/* ... and for constraint to be removed. */
-		if ( y_min_isBound == BT_TRUE )
-		{
-			#ifndef __XPCTARGET__
-			snprintf( messageString,80,"bound no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeBound( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemB = 1;
-
-			y[y_min_number] = 0.0;
-		}
-		else
-		{
-			#ifndef __XPCTARGET__
-			snprintf( messageString,80,"constraint no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeConstraint( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemC = 1;
-
-			y[nV+y_min_number] = 0.0;
-		}
-	}
-	else
-	{
-		if (options.enableDropInfeasibles == BT_TRUE) {
-			/* dropping of infeasible constraints according to drop priorities */
-			returnvalue = dropInfeasibles (number, C_status, BT_FALSE, xiB, xiC);
-		}
-		else
-		{
-			/* no constraint/bound can be removed => QP is infeasible! */
-			returnvalue = RET_ENSURELI_FAILED_NOINDEX;
-			setInfeasibilityFlag( returnvalue );
-		}
-	}
-
-farewell:
-	delete[] num;
-	delete [] xiB;
-	delete [] xiC;
-
-	getGlobalMessageHandler( )->throwInfo( RET_LI_RESOLVED,0,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-
-	return (returnvalue != SUCCESSFUL_RETURN) ? THROWERROR (returnvalue) : returnvalue;
-}
-
-
-/*
- *	a d d B o u n d
- */
-returnValue SQProblemSchur::addBound(	int_t number,
-										SubjectToStatus B_status,
-										BooleanType updateCholesky,
-										BooleanType ensureLI
-										)
-{
-	int_t idxDeleted = -1;
-
-	/* consistency checks */
-	if ( bounds.getStatus( number ) != ST_INACTIVE )
-		return THROWERROR( RET_BOUND_ALREADY_ACTIVE );
-
-	if ( getNFR( ) == bounds.getNUV( ) )
-		return THROWERROR( RET_ALL_BOUNDS_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-
-	/* I) ENSURE LINEAR INDEPENDENCE OF THE WORKING SET,
-	 *    i.e. remove a constraint or bound if linear dependence occurs. */
-	if ( ensureLI == BT_TRUE )
-	{
-		returnValue ensureLIreturnvalue = addBound_ensureLI( number,B_status );
-
-		switch ( ensureLIreturnvalue )
-		{
-			case SUCCESSFUL_RETURN:
-				break;
-
-			case RET_LI_RESOLVED:
-				break;
-
-			case RET_ENSURELI_FAILED_NOINDEX:
-				return RET_ADDBOUND_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_FAILED_CYCLING:
-				return RET_ADDBOUND_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_DROPPED:
-				return SUCCESSFUL_RETURN;
-
-			default:
-				return THROWERROR( RET_ENSURELI_FAILED );
-		}
-	}
-
-	/* II) UPDATE INDICES */
-	tabularOutput.idxAddB = number;
-	if ( bounds.moveFreeToFixed( number,B_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_ADDBOUND_FAILED );
-
-	/* Also update the Schur complement. */
-
-	/* First check if this variable had been freed before. In that
-	   case delete this variable from the Schur complement. */
-	bool found = false;
-	for ( int_t i=0; i<nS; i++ )
-	{
-		if ( schurUpdate[i] == SUT_VarFreed && number == schurUpdateIndex[i] )
-		{
-			if ( deleteFromSchurComplement( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_ADDBOUND_FAILED );
-			found = true;
-			idxDeleted = i;
-			break;
-		}
-	}
-	if ( !found )
-	{
-		if ( nS < 0 || nS==nSmax )
-		{
-			/* The schur complement has become too large, reset. */
-			/* Correct inertia if necessary. */
-			returnValue retval = resetSchurComplement( BT_TRUE );
-			if ( retval != SUCCESSFUL_RETURN )
-			{
-				if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-					MyPrintf( "In addBound: KKT matrix singular when resetting Schur complement\n" );
-				else if ( options.printLevel == PL_HIGH )
-					MyPrintf( "In addBound, resetSchurComplement failed with retval = %d\n", retval);
-				return THROWERROR( RET_ADDBOUND_FAILED );
-			}
-			found = true;
-		}
-		else
-		{
-			/* If the variable was not yet in Schur complement, add it now. */
-			int_t nFRStart = boundsFreeStart.getLength();
-			int_t* FR_idxStart;
-			boundsFreeStart.getNumberArray( &FR_idxStart );
-			for ( int_t i=0; i<nFRStart; i++ )
-				if ( FR_idxStart[i] == number )
-				{
-					real_t one = 1.0;
-					sparse_int_t pos = i;
-					if ( addToSchurComplement( number, SUT_VarFixed, 1, &pos, &one, 0, 0, 0, 0.0 ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_ADDBOUND_FAILED );
-					found = true;
-					break;
-				}
-		}
-	}
-
-	if ( !found )
-		return THROWERROR( RET_ADDBOUND_FAILED );
-
-	updateSchurQR( idxDeleted );
-
-	/* If reciprocal of condition number becomes to small, refactorize KKT matrix */
-	if( rcondS < options.rcondSMin )
-	{
-		returnValue retval = resetSchurComplement( BT_TRUE );
-		if ( retval != SUCCESSFUL_RETURN )
-		{
-			if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-				MyPrintf( "In addBound: KKT matrix singular when resetting Schur complement\n" );
-			else if ( options.printLevel == PL_HIGH )
-				MyPrintf( "In addBound, resetSchurComplement failed with retval = %d\n", retval);
-			return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a d d B o u n d _ c h e c k L I
- */
-returnValue SQProblemSchur::addBound_checkLI( int_t number )
-{
-	/* Get space for the multipliers xi in linear independence test */
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	real_t *xiC = new real_t[nAC];
-	real_t *xiB = new real_t[nFX];
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addBound_checkLISchur( number, xiC, xiB );
-
-	delete [] xiB;
-	delete [] xiC;
-
-	return returnvalueCheckLI;
-}
-
-/*
- *	a d d B o u n d _ c h e c k L I S c h u r
- */
-returnValue SQProblemSchur::addBound_checkLISchur( int_t number, real_t* xiC, real_t* xiB )
-{
-	returnValue returnvalue = RET_LINEARLY_DEPENDENT;
-
-
-	int_t ii;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nC  = getNC( );
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	int_t *FR_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	/* For the Schur complement version we only use options.enableFullLITests = TRUE */
-	{
-		/*
-		 * expensive LI test. Backsolve with refinement using special right
-		 * hand side. This gives an estimate for what should be considered
-		 * "zero". We then check linear independence relative to this estimate.
-		 */
-
-		real_t *delta_g   = new real_t[nV];
-		real_t *delta_xFX = new real_t[nFX];
-		real_t *delta_xFR = new real_t[nFR];
-		real_t *delta_yAC = xiC;
-		real_t *delta_yFX = xiB;
-
-		for (ii = 0; ii < nV; ++ii)
-			delta_g[ii] = 0.0;
-		delta_g[number] = 1.0;
-
-		int_t dim = (nC>nV)?nC:nV;
-		real_t *nul = new real_t[dim];
-		for (ii = 0; ii < dim; ++ii)
-			nul[ii]=0.0;
-
-		returnValue dsdReturnValue = determineStepDirection (
-				delta_g, nul, nul, nul, nul, BT_FALSE, BT_FALSE,
-				delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		if (dsdReturnValue != SUCCESSFUL_RETURN)
-			returnvalue = dsdReturnValue;
-
-		/* compute the weight in inf-norm */
-		real_t weight = 0.0;
-		for (ii = 0; ii < nAC; ++ii)
-		{
-			real_t a = getAbs (delta_yAC[ii]);
-			if (weight < a) weight = a;
-		}
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_yFX[ii]);
-			if (weight < a) weight = a;
-		}
-
-		/* look at the "zero" in a relative inf-norm */
-		real_t zero = 0.0;
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_xFX[ii]);
-			if (zero < a) zero = a;
-		}
-		for (ii = 0; ii < nFR; ++ii)
-		{
-			real_t a = getAbs (delta_xFR[ii]);
-			if (zero < a) zero = a;
-		}
-
-		/* relative test against zero in inf-norm */
-		if (zero > options.epsLITests * weight)
-			returnvalue = RET_LINEARLY_INDEPENDENT;
-
-		delete[] nul;
-		delete[] delta_xFR;
-		delete[] delta_xFX;
-		delete[] delta_g;
-
-	}
-	return THROWINFO( returnvalue );
-}
-
-
-/*
- *	a d d B o u n d _ e n s u r e L I
- */
-returnValue SQProblemSchur::addBound_ensureLI( int_t number, SubjectToStatus B_status )
-{
-	/* Get space for the multipliers xi in linear independence test */
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	real_t *xiC = new real_t[nAC];
-	real_t *xiB = new real_t[nFX];
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addBound_checkLISchur( number, xiC, xiB );
-
-	if ( returnvalueCheckLI == RET_INDEXLIST_CORRUPTED )
-	{
-		delete [] xiB;
-		delete [] xiC;
-		return THROWERROR( RET_ENSURELI_FAILED );
-	}
-
-	if ( returnvalueCheckLI == RET_LINEARLY_INDEPENDENT )
-	{
-		delete [] xiB;
-		delete [] xiC;
-		return SUCCESSFUL_RETURN;
-	}
-
- 	/* II) NEW BOUND IS LINEARLY DEPENDENT: */
-	/* 1) Coefficients of linear combination, have already been computed, but we need to correct the sign.  */
-	int_t i, ii;
-
-	if ( B_status != ST_LOWER )
-	{
-		for( i=0; i<nAC; ++i )
-			xiC[i] = -xiC[i];
-		for( i=0; i<nFX; ++i )
-			xiB[i] = -xiB[i];
-	}
-
-	int_t nV  = getNV( );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	real_t* num = new real_t[nV];
-
-	real_t y_min = options.maxDualJump;
-	int_t y_min_number = -1;
-	int_t y_min_number_bound = -1;
-	BooleanType y_min_isBound = BT_FALSE;
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	/* III) DETERMINE CONSTRAINT/BOUND TO BE REMOVED. */
-
-	/* 1) Constraints. */
-	for( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-		num[i] = y[nV+ii];
-	}
-
-	performRatioTest( nAC,AC_idx,&constraints, num,xiC, options.epsNum, options.epsDen, y_min,y_min_number );
-
-	/* 2) Bounds. */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-	}
-
-	performRatioTest( nFX,FX_idx,&bounds, num,xiB, options.epsNum, options.epsDen, y_min,y_min_number_bound );
-
-	if ( y_min_number_bound >= 0 )
-	{
-		y_min_number = y_min_number_bound;
-		y_min_isBound = BT_TRUE;
-	}
-
-	/* IV) REMOVE CONSTRAINT/BOUND FOR RESOLVING LINEAR DEPENDENCE: */
-	char messageString[80];
-
-	if ( y_min_number >= 0 )
-	{
-		/* Update Lagrange multiplier... */
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			y[nV+ii] -= y_min * xiC[i];
-		}
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			y[ii] -= y_min * xiB[i];
-		}
-
-		/* ... also for newly active bound ... */
-		if ( B_status == ST_LOWER )
-			y[number] = y_min;
-		else
-			y[number] = -y_min;
-
-		/* ... and for bound to be removed. */
-		if ( y_min_isBound == BT_TRUE )
-		{
-			#ifndef __XPCTARGET__
-			snprintf( messageString,80,"bound no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeBound( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemB = 1;
-
-			y[y_min_number] = 0.0;
-		}
-		else
-		{
-			#ifndef __XPCTARGET__
-			snprintf( messageString,80,"constraint no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeConstraint( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemC = 1;
-
-			y[nV+y_min_number] = 0.0;
-		}
-	}
-	else
-	{
-		if (options.enableDropInfeasibles == BT_TRUE) {
-			/* dropping of infeasible constraints according to drop priorities */
-			returnvalue = dropInfeasibles (number, B_status, BT_TRUE, xiB, xiC);
-		}
-		else
-		{
-			/* no constraint/bound can be removed => QP is infeasible! */
-			returnvalue = RET_ENSURELI_FAILED_NOINDEX;
-			setInfeasibilityFlag( returnvalue );
-		}
-	}
-
-farewell:
-	delete[] num;
-	delete[] xiB;
-	delete[] xiC;
-
-	getGlobalMessageHandler( )->throwInfo( RET_LI_RESOLVED,0,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-
-	return (returnvalue != SUCCESSFUL_RETURN) ? THROWERROR (returnvalue) : returnvalue;
-}
-
-
-
-/*
- *	r e m o v e C o n s t r a i n t
- */
-returnValue SQProblemSchur::removeConstraint(	int_t number,
-												BooleanType updateCholesky,
-												BooleanType allowFlipping,
-												BooleanType ensureNZC
-												)
-{
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	int_t sModType = 0;
-	int_t idxDeleted = -1;
-	SubjectToStatus oldStatus;
-	real_t oldDet, newDet;
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* some definitions */
-	int_t nAC = getNAC( );
-	int_t number_idx = constraints.getActive( )->getIndex( number );
-
-	int_t addIdx;
-	BooleanType addBoundNotConstraint;
-	SubjectToStatus addStatus;
-	BooleanType exchangeHappened = BT_FALSE;
-
-
-	/* consistency checks */
-	if ( constraints.getStatus( number ) == ST_INACTIVE )
-		return THROWERROR( RET_CONSTRAINT_NOT_ACTIVE );
-
-	if ( ( number_idx < 0 ) || ( number_idx >= nAC ) )
-		return THROWERROR( RET_CONSTRAINT_NOT_ACTIVE );
-
-	/* N) PERFORM ZERO CURVATURE TEST. */
-	if (ensureNZC == BT_TRUE)
-	{
-		returnvalue = ensureNonzeroCurvature(BT_FALSE, number, exchangeHappened, addBoundNotConstraint, addIdx, addStatus);
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return returnvalue;
-	}
-
-	/* save old constraint status and determinant of old S for flipping strategy */
-	oldStatus = constraints.getStatus( number );
-	oldDet = detS;
-
-	/* I) UPDATE INDICES */
-	tabularOutput.idxRemC = number;
-	if ( constraints.moveActiveToInactive( number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-
-	/* Also update the Schur complement. */
-
-	/* First check if this constraint had been added before. In that
-	   case delete this constraint from the Schur complement. */
-	bool found = false;
-	for ( int_t i=0; i<nS; i++ )
-	{
-		if ( schurUpdate[i] == SUT_ConAdded && number == schurUpdateIndex[i] )
-		{
-			if ( deleteFromSchurComplement( i, BT_TRUE ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-			found = true;
-			idxDeleted = i;
-			sModType = 2;
-			break;
-		}
-	}
-	if ( !found )
-	{
-		if ( nS < 0 || nS==nSmax )
-		{
-			/* The schur complement has become too large, reset. */
-			/* Don't check inertia here, may be corrected later! */
-			returnValue retval = resetSchurComplement( BT_FALSE );
-			if ( retval != SUCCESSFUL_RETURN )
-			{
-				if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-					MyPrintf( "In removeConstraint: KKT matrix singular when resetting Schur complement\n" );
-				else if ( options.printLevel == PL_HIGH )
-					MyPrintf( "In removeConstraint, resetSchurComplement failed with retval = %d\n", retval);
-				return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-			}
-			found = true;
-			sModType = 3;
-		}
-		else
-		{
-			/* If the constraint was not yet in Schur complement, add it now. */
-			int_t nFRStart = boundsFreeStart.getLength();
-			int_t nACStart = constraintsActiveStart.getLength();
-			int_t* AC_idxStart;
-			constraintsActiveStart.getNumberArray( &AC_idxStart );
-
-			for ( int_t i=0; i<nACStart; i++ )
-				if ( AC_idxStart[i] == number )
-				{
-					real_t one = 1.0;
-					sparse_int_t pos = nFRStart+i;
-					if ( addToSchurComplement( number, SUT_ConRemoved, 1, &pos, &one, 0, 0, 0, 0.0 ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-					found = true;
-					break;
-				}
-
-			sModType = 1;
-		}
-	}
-
-	if ( !found )
-		return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-
-	/* Now we have a new Schur complement (might be smaller, larger, or empty). Update QR factorization. */
-
-	/* Flipping bounds strategy */
-	if ( ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) && ( exchangeHappened == BT_FALSE ) )
-	{
-		if ( sModType == 1 )
-		{/* Case 1: We added a row and column to S. */
-
-			/* Check if a direction of negative curvature showed up, i.e. determinants have THE SAME sign */
-			newDet = calcDetSchur( idxDeleted );
-
-			if ( oldDet * newDet > 0 )
-			{
-				hessianType = HST_SEMIDEF;
-
-				/* Restore old S */
-				nS--;
-
-				/* Flip bounds */
-				tabularOutput.idxAddC = number;
-				tabularOutput.excAddC = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						constraints.moveInactiveToActive( number, ST_UPPER );
-						ubA[number] = lbA[number];
-						Ax_l[number] = -Ax_u[number];
-						break;
-					case ST_UPPER:
-						constraints.moveInactiveToActive( number, ST_LOWER );
-						lbA[number] = ubA[number];
-						Ax_u[number] = -Ax_l[number];
-						break;
-					default:
-						return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-				}
-			}
-			else
-			{/* Determinants have the correct sign, compute QR of new (larger) S */
-				updateSchurQR( idxDeleted );
-			}
-		}
-		else if ( sModType == 2 )
-		{/* Case 2: We deleted a row and column of S. */
-
-			/* Check if a direction of negative curvature showed up, i.e. determinants have DIFFERENT signs */
-			newDet = calcDetSchur( idxDeleted );
-
-			if ( oldDet * newDet < 0.0 )
-			{
-				hessianType = HST_SEMIDEF;
-
-				/* Restore old S */
-				undoDeleteFromSchurComplement( idxDeleted );
-
-				/* Flip bounds */
-				tabularOutput.idxAddC = number;
-				tabularOutput.excAddC = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						constraints.moveInactiveToActive( number, ST_UPPER );
-						ubA[number] = lbA[number];
-						Ax_l[number] = -Ax_u[number];
-						break;
-					case ST_UPPER:
-						constraints.moveInactiveToActive( number, ST_LOWER );
-						lbA[number] = ubA[number];
-						Ax_u[number] = -Ax_l[number];
-						break;
-					default:
-						return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-				}
-			}
-			else
-			{/* Determinants have the correct sign, compute QR of new (smaller) S */
-				updateSchurQR( idxDeleted );
-			}
-		}
-		else if ( sModType == 3 )
-		{/* Case 3: S was reset. */
-
-			/* Check inertia of new factorization given by the sparse solver: must be ( nFR, nAC, 0 ) */
-			int_t neig = sparseSolver->getNegativeEigenvalues( );
-			if( neig > getNAC( ) ) // Wrong inertia!
-			{
-				/* Flip bounds and update Schur complement */
-				tabularOutput.idxAddC = number;
-				tabularOutput.excAddC = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						ubA[number] = lbA[number];
-						Ax_l[number] = -Ax_u[number];
-						addConstraint( number, ST_UPPER, BT_TRUE, BT_FALSE );
-						break;
-					case ST_UPPER:
-						lbA[number] = ubA[number];
-						Ax_u[number] = -Ax_l[number];
-						addConstraint( number, ST_LOWER, BT_TRUE, BT_FALSE );
-						break;
-					default:
-						return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-				}
-			}
-
-			/* Check if flipping deleted the negative eigenvalue */
-			if( correctInertia( ) )
-				return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-		}
-		else
-		{/* None of the three cases happened */
-			return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-		}
-	}
-	else
-	{/* No flipping strategy, update QR factorization of S */
-		updateSchurQR( idxDeleted );
-	}
-
-	/* If reciprocal of condition number becomes to small, refactorize KKT matrix */
-	if( rcondS < options.rcondSMin )
-	{
-		returnValue retval = resetSchurComplement( BT_TRUE );
-		if ( retval != SUCCESSFUL_RETURN )
-		{
-			if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-				MyPrintf( "In removeConstraint: KKT matrix singular when resetting Schur complement\n" );
-			else if ( options.printLevel == PL_HIGH )
-				MyPrintf( "In removeConstraint, resetSchurComplement failed with retval = %d\n", retval);
-			return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-		}
-	}
-
-	if ( exchangeHappened == BT_TRUE )
-	{
-		/* add bound or constraint */
-
-		if ( addBoundNotConstraint )
-		{
-			addBound(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddB = 1;
-		}
-		else
-		{
-			addConstraint(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddC = 1;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e B o u n d
- */
-returnValue SQProblemSchur::removeBound(	int_t number,
-											BooleanType updateCholesky,
-											BooleanType allowFlipping,
-											BooleanType ensureNZC
-											)
-{
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-	int_t addIdx;
-	BooleanType addBoundNotConstraint;
-	SubjectToStatus addStatus;
-	BooleanType exchangeHappened = BT_FALSE;
-
-	int_t sModType = 0;
-	int_t idxDeleted = -1;
-	SubjectToStatus oldStatus;
-	real_t oldDet, newDet;
-
-	/* consistency checks */
-	if ( bounds.getStatus( number ) == ST_INACTIVE )
-		return THROWERROR( RET_BOUND_NOT_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )           )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* N) PERFORM ZERO CURVATURE TEST. */
-	if (ensureNZC == BT_TRUE)
-	{
-		returnvalue = ensureNonzeroCurvature(BT_TRUE, number, exchangeHappened, addBoundNotConstraint, addIdx, addStatus);
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return returnvalue;
-	}
-
-	/* save old bound status and determinant of old S for flipping strategy */
-	oldStatus = bounds.getStatus( number );
-	oldDet = detS;
-
-	/* I) UPDATE INDICES */
-	tabularOutput.idxRemB = number;
-	if ( bounds.moveFixedToFree( number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-	/* Also update the Schur complement. */
-
-	/* First check if this variable had been fixed before. In that
-	   case delete this variable from the Schur complement. */
-	bool found = false;
-	for ( int_t i=0; i<nS; i++ )
-	{
-		if ( schurUpdate[i] == SUT_VarFixed && number == schurUpdateIndex[i] )
-		{
-			if ( deleteFromSchurComplement( i, BT_TRUE ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_REMOVEBOUND_FAILED );
-			found = true;
-			idxDeleted = i;
-			sModType = 2;
-			break;
-		}
-	}
-	if ( !found )
-	{
-		if ( nS < 0 || nS==nSmax )
-		{
-			/* The schur complement has become too large, reset. */
-			/* Don't correct inertia here, may be corrected by flipping bounds! */
-			returnValue retval = resetSchurComplement( BT_FALSE );
-			if ( retval != SUCCESSFUL_RETURN )
-			{
-				if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH  )
-					MyPrintf( "In removeBound: KKT matrix singular when resetting Schur complement\n" );
-				else if ( options.printLevel == PL_HIGH )
-					MyPrintf( "In removeBound, resetSchurComplement failed with retval = %d\n", retval);
-				return THROWERROR( RET_REMOVEBOUND_FAILED );
-			}
-			found = true;
-			sModType = 3;
-		}
-		else
-		{
-			/* If the variable was not yet in Schur complement, add it now. */
-			int_t nFRStart = boundsFreeStart.getLength();
-			int_t nACStart = constraintsActiveStart.getLength();
-			int_t* FR_idxStart;
-			boundsFreeStart.getNumberArray( &FR_idxStart );
-			int_t* AC_idxStart;
-			constraintsActiveStart.getNumberArray( &AC_idxStart );
-
-			int_t numNonzerosM = 0;
-			sparse_int_t* Mpos = new sparse_int_t[nFRStart+nACStart+nS]; // This is an overestimate
-			real_t* Mvals = new real_t[nFRStart+nACStart+nS];
-			int_t numNonzerosN = 0;
-			sparse_int_t* Npos = new sparse_int_t[nFRStart+nACStart+nS]; // This is an overestimate
-			real_t* Nvals = new real_t[nFRStart+nACStart+nS];
-			real_t N_diag;
-
-			int_t* irn = new int_t[nFRStart+nACStart+nS+1];
-			int_t* jcn = new int_t[nFRStart+nACStart+nS+1];
-			real_t* vals = new real_t[nFRStart+nACStart+nS+1];
-			int_t iLength;
-			int_t* iNumber = new int_t[nFRStart+nACStart+nS+1];
-			int_t numNonzeros;
-			int_t* iSIdx = new int_t[nS];
-
-			/* First the Hessian part. */
-			real_t regularisation = options.epsRegularisation;
-			switch ( hessianType )
-			{
-				case HST_ZERO:
-					N_diag = regularisation;
-					break;
-
-				case HST_IDENTITY:
-					N_diag = 1.0 + regularisation;
-					break;
-
-				default:
-					N_diag = regularisation;
-					for ( int_t i=0; i<nFRStart; i++ )
-						iNumber[i] = FR_idxStart[i];
-					iLength = nFRStart;
-					for ( int_t i=0; i<nS; i++ )
-						if ( schurUpdate[i] == SUT_VarFreed )
-						{
-							iNumber[iLength] = schurUpdateIndex[i];
-							iSIdx[iLength-nFRStart] = i;
-							iLength++;
-						}
-					iNumber[iLength++] = number;
-
-					H->getSparseSubmatrix( iLength, iNumber, 1, &number, 0, 0, numNonzeros, irn, jcn, vals );
-
-					for ( int_t i=0; i<numNonzeros; i++ )
-					{
-						if ( irn[i] < nFRStart )
-						{
-							Mpos[numNonzerosM] = irn[i];
-							Mvals[numNonzerosM] = vals[i];
-							numNonzerosM++;
-						}
-						else if ( irn[i] != iLength-1 )
-						{
-							Npos[numNonzerosN] = iSIdx[irn[i] - nFRStart];
-							Nvals[numNonzerosN] = vals[i];
-							numNonzerosN++;
-						}
-						else
-							N_diag += vals[i];
-					}
-					break;
-			}
-
-			if ( constraintProduct != 0 )
-			{
-				MyPrintf( "In SQProblemSchur::removeBound, constraintProduct not yet implemented.\n");
-				return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-			}
-
-			for ( int_t i=0; i<nACStart; i++ )
-				iNumber[i] = AC_idxStart[i];
-			iLength = nACStart;
-			for ( int_t i=0; i<nS; i++ )
-				if ( schurUpdate[i] == SUT_ConAdded )
-				{
-					iNumber[iLength] = schurUpdateIndex[i];
-					iSIdx[iLength-nACStart] = i;
-					iLength++;
-				}
-
-			A->getSparseSubmatrix( iLength, iNumber, 1, &number, 0, 0, numNonzeros, irn, jcn, vals );
-
-			for ( int_t i=0; i<numNonzeros; i++ )
-			{
-				if ( irn[i] < nACStart )
-				{
-					Mpos[numNonzerosM] = irn[i] + nFRStart;
-					Mvals[numNonzerosM] = vals[i];
-					numNonzerosM++;
-				}
-				else
-				{
-					Npos[numNonzerosN] = iSIdx[irn[i] - nACStart];
-					Nvals[numNonzerosN] = vals[i];
-					numNonzerosN++;
-				}
-			}
-
-			delete [] iSIdx;
-			delete [] iNumber;
-			delete [] vals;
-			delete [] jcn;
-			delete [] irn;
-
-			returnvalue = addToSchurComplement( number, SUT_VarFreed, numNonzerosM, Mpos, Mvals, numNonzerosN, Npos, Nvals, N_diag );
-
-			delete [] Mvals;
-			delete [] Mpos;
-			delete [] Nvals;
-			delete [] Npos;
-
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-			found = true;
-			sModType = 1;
-		}
-	}
-
-	if ( !found )
-		return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-	/* Now we have a new Schur complement (might be smaller, larger, or empty). Update QR factorization. */
-
-	/* Flipping bounds strategy */
-	if ( ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) && ( exchangeHappened == BT_FALSE ) )
-	{
-		if ( sModType == 1 )
-		{/* Case 1: We added a row and column to S. */
-
-			/* Check if a direction of negative curvature showed up, i.e. determinants have THE SAME sign */
-			newDet = calcDetSchur( idxDeleted );
-
-			if ( oldDet * newDet > 0.0 )
-			{
-				hessianType = HST_SEMIDEF;
-
-				/* Restore old S */
-				nS--;
-
-				/* Flip bounds */
-				tabularOutput.idxAddB = number;
-				tabularOutput.excAddB = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						bounds.moveFreeToFixed( number, ST_UPPER );
-						ub[number] = lb[number];
-						break;
-					case ST_UPPER:
-						bounds.moveFreeToFixed( number, ST_LOWER );
-						lb[number] = ub[number];
-						break;
-					default:
-						return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-			}
-			else
-			{/* Determinants have the correct sign, compute QR of new (larger) S */
-				updateSchurQR( idxDeleted );
-			}
-		}
-		else if ( sModType == 2 )
-		{/* Case 2: We deleted a row and column of S. */
-
-			/* Check if a direction of negative curvature showed up, i.e. determinants have DIFFERENT signs */
-			newDet = calcDetSchur( idxDeleted );
-
-			if ( oldDet * newDet < 0.0 )
-			{
-				hessianType = HST_SEMIDEF;
-
-				/* Restore old S */
-				undoDeleteFromSchurComplement( idxDeleted );
-
-				/* Flip bounds */
-				tabularOutput.idxAddB = number;
-				tabularOutput.excAddB = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						bounds.moveFreeToFixed( number, ST_UPPER );
-						ub[number] = lb[number];
-						break;
-					case ST_UPPER:
-						bounds.moveFreeToFixed( number, ST_LOWER );
-						lb[number] = ub[number];
-						break;
-					default:
-						return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-			}
-			else
-			{/* Determinants have the correct sign, compute QR of new (smaller) S */
-				updateSchurQR( idxDeleted );
-			}
-		}
-		else if ( sModType == 3 )
-		{/* Case 3: S was reset. */
-
-			/* Check inertia of new factorization given by the sparse solver: must be ( nFR, nAC, 0 ) */
-			int_t neig = sparseSolver->getNegativeEigenvalues( );
-			if( neig > getNAC( ) ) // Wrong inertia, flip bounds!
-			{
-				/* Flip bounds and update Schur complement */
-				tabularOutput.idxAddB = number;
-				tabularOutput.excAddB = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						ub[number] = lb[number];
-						addBound( number, ST_UPPER, BT_TRUE, BT_FALSE );
-						break;
-					case ST_UPPER:
-						lb[number] = ub[number];
-						addBound( number, ST_LOWER, BT_TRUE, BT_FALSE );
-						break;
-					default:
-						return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-			}
-
-			/* Check if flipping deleted the negative eigenvalue */
-			if( correctInertia( ) )
-				return THROWERROR( RET_REMOVEBOUND_FAILED );
-		}
-		else
-		{/* None of the three cases happened */
-			return THROWERROR( RET_REMOVEBOUND_FAILED );
-		}
-	}
-	else
-	{/* No flipping strategy, update QR factorization of S */
-		updateSchurQR( idxDeleted );
-	}
-
-	/* If reciprocal of condition number becomes to small, refactorize KKT matrix */
-	if( rcondS < options.rcondSMin )
-	{
-		returnValue retval = resetSchurComplement( BT_TRUE );
-		if ( retval != SUCCESSFUL_RETURN )
-		{
-			if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-				MyPrintf( "In removeBound: KKT matrix singular when resetting Schur complement\n" );
-			else if ( options.printLevel == PL_HIGH )
-				MyPrintf( "In removeBound, resetSchurComplement failed with retval = %d\n", retval);
-			return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-		}
-	}
-
-	if ( exchangeHappened == BT_TRUE )
-	{
-		/* add bound or constraint */
-
-		if ( addBoundNotConstraint )
-		{
-			addBound(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddB = 1;
-		}
-		else
-		{
-			addConstraint(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddC = 1;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p T Q f a c t o r i s a t i o n
- */
-returnValue SQProblemSchur::backsolveT( const real_t* const b, BooleanType transposed, real_t* const a ) const
-{
-	return THROWERROR( RET_UNKNOWN_BUG );
-}
-
-
-/*
- *	b a c k s o l v e R
- */
-returnValue SQProblemSchur::backsolveR(	const real_t* const b, BooleanType transposed, real_t* const a 	) const
-{
-	return THROWERROR( RET_UNKNOWN_BUG );
-}
-
-
-/*
- *	b a c k s o l v e R
- */
-returnValue SQProblemSchur::backsolveR(	const real_t* const b, BooleanType transposed, BooleanType removingBound, real_t* const a ) const
-{
-	return THROWERROR( RET_UNKNOWN_BUG );
-}
-
-
-/*
- *	c a l c D e t S c h u r
- */
-real_t SQProblemSchur::calcDetSchur( int_t idxDel )
-{
-	if ( nS <= 0 )
-		return 1.0;
-
-	real_t newDet;
-	int_t i, j;
-	real_t c, s, nu;
-
-	/* Case 1: S has been bordered by one row and column */
-	if( idxDel < 0 )
-	{
-		/* Do a solve with the old S to check determinant of new (bordered) S */
-		real_t *temp1 = new real_t[nS-1];
-		real_t *temp2 = new real_t[nS-1];
-		for( i=0; i<nS-1; i++ )
-			temp1[i] = S[i + (nS-1)*nSmax];
-		backsolveSchurQR( nS-1, temp1, 1, temp2 );
-
-		newDet = S[(nS-1) + (nS-1)*nSmax];
-		for( i=0; i<nS-1; i++ )
-			newDet -= temp1[i]*temp2[i];
-		newDet *= detS;
-		delete [] temp1;
-		delete [] temp2;
-	}
-	/* Case 2: row and column idxDel have been deleted from S */
-	else
-	{
-		const int_t dim = nS+1;
-		real_t *tempR = new real_t[dim*(dim-1)];
-		real_t *tempColQ = new real_t[dim];
-
-		/* Copy current R without column idxDel*/
-		for( j=0; j<idxDel; j++ )
-			for( i=0; i<dim; i++ )
-				tempR[i+j*dim] = R_[i+j*nSmax];
-		for( j=idxDel; j<dim-1; j++ )
-			for( i=0; i<dim; i++ )
-				tempR[i+j*dim] = R_[i+(j+1)*nSmax];
-		/* Copy row idxDel of Q */
-		for( j=0; j<dim; j++ )
-			tempColQ[j] = Q_[idxDel+j*nSmax];
-
-		/* Bring tempR to triangular form with nS-idxDel Givens rotations */
-		for ( i=idxDel; i<nS; i++ )
-		{
-			computeGivens( tempR[i+i*dim], tempR[(i+1)+i*dim], tempR[i+i*dim], tempR[(i+1)+i*dim], c, s );
-			nu = s/(1.0+c);
-			/// \todo I think we do not need to transform all columns of R, i+3 or so should be sufficient
-			for ( j=i+1; j<nS; j++ )
-				applyGivens( c, s, nu, tempR[i+j*dim], tempR[(i+1)+j*dim], tempR[i+j*dim], tempR[(i+1)+j*dim] );
-
-			/* Simultaneously transform relevant column of Q**T */
-			applyGivens( c, s, nu, tempColQ[i], tempColQ[i+1], tempColQ[i], tempColQ[i+1] );
-		}
-
-		/* Delete row: nS Givens rotations to transform last column (and row!) of (old) Q**T to getAbs((nS+1)-th unity vector) */
-		for ( i=nS; i>0; i-- )
-		{
-			computeGivens( tempColQ[nS], tempColQ[i-1], tempColQ[nS], tempColQ[i-1], c, s );
-			nu = s/(1.0+c);
-
-			/* Simultaneously transform diagonal elements of R (coldim is already one less than Q) */
-			applyGivens( c, s, nu, tempR[nS+(i-1)*dim], tempR[(i-1)+(i-1)*dim], tempR[nS+(i-1)*dim], tempR[(i-1)+(i-1)*dim] );
-		}
-
-		/* Note that we implicitly did a row permutation of Q.
-		 * If we did an  odd permutation AND deleted a positive unity vector or
-		 * if we did an even permutation AND deleted a negative unity vector, then det(Q)=-1
-		 * ->Change signs of first column of Q and first row of R */
-		if ( (( (nS - idxDel) % 2 == 1 ) && ( tempColQ[nS] > 0.0 )) ||
-			(( (nS - idxDel) % 2 == 0 ) && ( tempColQ[nS] < 0.0 )) )
-		{
-			tempR[0] = -tempR[0];
-		}
-
-		newDet = 1.0;
-		//for( i=0; i<nS; i++ )
-			//newDet *= tempR[i+i*dim];
-		for( i=0; i<nS; i++ )
-			if( tempR[i+i*dim] < 0.0 ) newDet = -newDet;
-		delete [] tempR;
-		delete [] tempColQ;
-	}
-
-	return newDet;
-}
-
-
-/*
- *	u p d a t e S c h u r Q R
- */
-returnValue SQProblemSchur::updateSchurQR( int_t idxDel )
-{
-	int_t i, j;
-	real_t c, s, nu;
-
-	if ( nS <= 0 )
-	{
-		detS = 1.0;
-		rcondS = 1.0;
-		return SUCCESSFUL_RETURN;
-	}
-
-	/* Case 1: S has been bordered by one row and column */
-	if ( idxDel < 0 )
-	{
-		/* I: Augment Q**T by nS-th unity vector (row and column) */
-		for ( i=0; i<nS; i++ )
-		{
-			Q_[i+(nS-1)*nSmax] = 0.0;
-			Q_[(nS-1)+i*nSmax] = 0.0;
-		}
-		Q_[(nS-1)+(nS-1)*nSmax] = 1.0;
-
-		/* IIa: Augment rows of R by last row of S */
-		for ( i=0; i<nS; i++ )
-			R_[(nS-1)+i*nSmax] = S[(nS-1)+i*nSmax];
-
-		/* IIb: Augment columns of R by Q**T * S[nS,:] */
-		for ( i=0; i<nS; i++ )
-		{
-			R_[i+(nS-1)*nSmax] = 0.0;
-			for ( j=0; j<nS; j++ )
-				R_[i+(nS-1)*nSmax] += Q_[j+i*nSmax] * S[j+(nS-1)*nSmax];
-		}
-
-		/* III: Restore triangular form of R by nS-1 Givens rotations */
-		for ( i=0; i<nS-1; i++ )
-		{
-			computeGivens( R_[i+i*nSmax], R_[(nS-1)+i*nSmax], R_[i+i*nSmax], R_[(nS-1)+i*nSmax], c, s );
-			nu = s/(1.0+c);
-			for ( j=i+1; j<nS; j++ )
-				applyGivens( c, s, nu, R_[i+j*nSmax], R_[(nS-1)+j*nSmax], R_[i+j*nSmax], R_[(nS-1)+j*nSmax] );
-
-			/* Simultaneously transform Q**T */
-			for ( j=0; j<nS; j++ )
-				applyGivens( c, s, nu, Q_[j+i*nSmax], Q_[j+(nS-1)*nSmax], Q_[j+i*nSmax], Q_[j+(nS-1)*nSmax] );
-		}
-	}
-	/* Case 2: row and column idxDel have been deleted from S */
-	else
-	{
-		/* I: Delete column idxDel of R */
-		for ( j=idxDel; j<nS; j++ )
-			for ( i=0; i<nS+1; i++ )
-				R_[i+j*nSmax] = R_[i+(j+1)*nSmax];
-
-		/* II: Bring R back to triangular form with nS-idxDel Givens rotations */
-		for ( i=idxDel; i<nS; i++ )
-		{
-			computeGivens( R_[i+i*nSmax], R_[(i+1)+i*nSmax], R_[i+i*nSmax], R_[(i+1)+i*nSmax], c, s );
-			nu = s/(1.0+c);
-			for ( j=i+1; j<nS; j++ )
-				applyGivens( c, s, nu, R_[i+j*nSmax], R_[(i+1)+j*nSmax], R_[i+j*nSmax], R_[(i+1)+j*nSmax] );
-
-			/* Simultaneously transform (old) Q**T (coldim is one larger)*/
-			for ( j=0; j<nS+1; j++ )
-				applyGivens( c, s, nu, Q_[j+i*nSmax], Q_[j+(i+1)*nSmax], Q_[j+i*nSmax], Q_[j+(i+1)*nSmax] );
-		}
-
-		/* III: Permute rows of Q: move row idxDel to position nS */
-		real_t temp;
-		for ( j=0; j<nS+1; j++ )
-		{
-			temp = Q_[idxDel+j*nSmax];
-			for ( i=idxDel; i<nS; i++ )
-				Q_[i+j*nSmax] = Q_[(i+1)+j*nSmax];
-			Q_[nS+j*nSmax] = temp;
-		}
-
-		/* IV: Delete row: nS Givens rotations to transform last column (and row!) of (old) Q**T to getAbs((nS+1)-th unity vector) */
-		for ( i=nS; i>0; i-- )
-		{
-			computeGivens( Q_[nS+nS*nSmax], Q_[nS+(i-1)*nSmax], Q_[nS+nS*nSmax], Q_[nS+(i-1)*nSmax], c, s );
-			nu = s/(1.0+c);
-			for ( j=0; j<nS; j++ )
-				applyGivens( c, s, nu, Q_[j+nS*nSmax], Q_[j+(i-1)*nSmax], Q_[j+nS*nSmax], Q_[j+(i-1)*nSmax] );
-
-			/* Simultaneously transform R (coldim is already one less than Q) */
-			for ( j=i-1; j<nS; j++ )
-				applyGivens( c, s, nu, R_[nS+j*nSmax], R_[(i-1)+j*nSmax], R_[nS+j*nSmax], R_[(i-1)+j*nSmax] );
-		}
-
-		/* If we did an  odd permutation AND deleted a positive unity vector or
-		 * if we did an even permutation AND deleted a negative unity vector, then det(Q)=-1
-		 * ->Change signs of first column of Q and first row of R s.t. we always maintain det(Q)=1 */
-		if ( (( (nS - idxDel) % 2 == 1 ) && ( Q_[nS+nS*nSmax] > 0.0 )) ||
-			(( (nS - idxDel) % 2 == 0 ) && ( Q_[nS+nS*nSmax] < 0.0 )) )
-		{
-			for ( i=0; i<nS+1; i++ )
-				Q_[i] = -Q_[i];
-			for ( i=0; i<nS; i++ )
-				R_[i*nSmax] = -R_[i*nSmax];
-		}
-	}
-
-	/* Compute determinant */
-	detS = 1.0;
-	//for ( i=0; i<nS; i++ )
-		//detS *= R_[i+i*nSmax];
-	for ( i=0; i<nS; i++ )
-		if( R_[i+i*nSmax] < 0.0 ) detS = -detS;
-
-	/* Estimate condition number of R (= condition number of S)*/
-	real_t *WORK;
-	unsigned long N = (unsigned long)nS;
-	unsigned long LDA = (unsigned long)nSmax;
-	unsigned long *IWORK;
-	long INFO = 0;
-	IWORK = new unsigned long[N];
-	WORK = new real_t[3*N];
-	TRCON( "1", "U", "N", &N, R_, &LDA, &rcondS, WORK, IWORK, &INFO );
-	if ( INFO != 0 )
-	{
-		MyPrintf( "TRCON returns INFO = %d\n",(int)INFO );
-	}
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "1/cond(S) = %23.16e.\n", rcondS );
-
-	delete[] IWORK;
-	delete[] WORK;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	b a c k s o l v e S c h u r Q R
- */
-returnValue SQProblemSchur::backsolveSchurQR( int_t dimS, const real_t* const rhs, int_t dimRhs, real_t* const sol )
-{
-	if( dimS < 1 || dimRhs < 1 )
-		return SUCCESSFUL_RETURN;
-
-	if( dimRhs > 1 )
-	{
-		MyPrintf("backsolve not implemented for dimRhs = %d\n", dimRhs);
-		return RET_QR_FACTORISATION_FAILED;
-	}
-
-	int_t i, j;
-	long INFO = 0;
-	unsigned long NRHS = 1;
-	unsigned long M = (unsigned long)dimS;
-	unsigned long LDA = (unsigned long)nSmax;
-	unsigned long LDC = (unsigned long)dimS;
-
-	for( i=0; i<dimS; i++ )
-		sol[i] = 0.0;
-
-	/* Compute sol = Q**T * rhs */
-	for( i=0; i<dimS; i++ )
-		for( j=0; j<dimS; j++ )
-			sol[i] += Q_[j+i*nSmax] * rhs[j];
-
-	/* Solve Rx = sol */
-	TRTRS( "U", "N", "N", &M, &NRHS, R_, &LDA, sol, &LDC, &INFO );
-	if ( INFO != 0 )
-	{
-		MyPrintf("TRTRS returns INFO = %d\n", INFO);
-		return RET_QR_FACTORISATION_FAILED;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SQProblemSchur::stepCalcRhs(	int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx, real_t& rhs_max, 
-											const real_t* const delta_g, const real_t* const delta_lbA, const real_t* const delta_ubA,
-											const real_t* const delta_lb, const real_t* const delta_ub,
-											BooleanType Delta_bC_isZero, BooleanType Delta_bB_isZero,
-											real_t* const delta_xFX, real_t* const delta_xFR,
-											real_t* const delta_yAC, real_t* const delta_yFX
-											)
-{
-	int_t i, ii;
-	returnValue retval;
-
-	if ( nS < 0 )
-	{
-		retval = resetSchurComplement( BT_FALSE );
-		if (retval != SUCCESSFUL_RETURN)
-		{
-			MyPrintf( "In SQProblemSchur::stepCalcRhs, resetSchurComplement returns %d\n", retval);
-			return THROWERROR( retval );
-		}
-	}
-
-	/* tempA and tempB hold the residuals in gFR and bA (= lbA or ubA)
-	 * delta_xFR, delta_yAC hold the steps that get refined */
-	for ( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		tempA[i] = delta_g[ii];
-		delta_xFR[i] = 0.0;
-	}
-	for ( i=0; i<nAC; ++i )
-		delta_yAC[i] = 0.0;
-	if ( Delta_bC_isZero == BT_FALSE )
-	{
-		for ( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			if ( constraints.getStatus( ii ) == ST_LOWER )
-				tempB[i] = delta_lbA[ii];
-			else
-				tempB[i] = delta_ubA[ii];
-		}
-	}
-	else
-	{
-		for ( i=0; i<nAC; ++i )
-			tempB[i] = 0.0;
-	}
-	if ( ( hessianType != HST_IDENTITY ) && ( hessianType != HST_ZERO ) )
-	{
-		/* tempA becomes RHS for reduced augmented system, gFR+H_FX*delta_xFR */
-		H->times(bounds.getFree(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, tempA, nFR);
-	}
-	/* tempB becomes RHS for reduced augmented system, bA-A_CX*delta_xFR */
-	A->times(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, tempB, nAC);
-
-	/* If iterative refinement is requested, compute max-norm of RHS for termination test. */
-	rhs_max = 0.0;
-	if ( options.numRefinementSteps > 0 )
-	{
-		for ( i=0; i<nFR; i++ )
-			rhs_max = getMax(rhs_max, getAbs(tempA[i]));
-		for ( i=0; i<nAC; i++ )
-			rhs_max = getMax(rhs_max, getAbs(tempB[i]));
-	}
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::stepCalcReorder(int_t nFR, int_t nAC, int_t* FR_idx, int_t* AC_idx, int_t nFRStart, int_t nACStart, int_t* FR_idxStart, int_t* AC_idxStart, int_t* FR_iSort, int_t* FR_iSortStart, int_t* AC_iSort, int_t* AC_iSortStart, real_t* rhs)
-{
-	int_t i, ii;
-	/* Reorder information for the new to the old free variables. */
-	i = 0;
-	ii = 0;
-	while ( ii < nFRStart )
-	{
-		if ( i == nFR )
-			rhs[FR_iSortStart[ii++]] = 0.0;
-		else
-		{
-			int_t idx = FR_idx[FR_iSort[i]];
-			int_t idxStart = FR_idxStart[FR_iSortStart[ii]];
-
-			if ( idx == idxStart )
-				rhs[FR_iSortStart[ii++]] = -tempA[FR_iSort[i++]];
-			else if ( idx < idxStart )
-				i++;
-			else
-				rhs[FR_iSortStart[ii++]] = 0.0;
-		}
-	}
-	/* Reorder information for the new to the old active constraints. */
-	i = 0;
-	ii = 0;
-	while ( ii < nACStart )
-	{
-		if ( i == nAC )
-			rhs[nFRStart+AC_iSortStart[ii++]] = 0.0;
-		else
-		{
-			int_t idx = AC_idx[AC_iSort[i]];
-			int_t idxStart = AC_idxStart[AC_iSortStart[ii]];
-
-			if ( idx == idxStart )
-				rhs[nFRStart+AC_iSortStart[ii++]] = tempB[AC_iSort[i++]];
-			else if ( idx < idxStart )
-				i++;
-			else
-				rhs[nFRStart+AC_iSortStart[ii++]] = 0.0;
-		}
-	}
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::stepCalcBacksolveSchur( int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx, int_t dim, real_t* rhs, real_t* sol )
-{
-	returnValue retval;
-	int_t i, ii;
-
-	real_t* q = new real_t[nS];
-
-	/* Compute extra compoments of the RHS */
-	for ( ii=0; ii<nS; ii++ )
-	{
-		int_t idx = schurUpdateIndex[ii];
-		switch ( schurUpdate[ii] ) // TODO: All the loops below could be done faster by binary search or so
-		{
-			case SUT_VarFixed:
-				q[ii] = 0.0;
-				break;
-
-			case SUT_VarFreed:
-				/* Find index of freed variable */
-				for( i=0; i<nFR; ++i )
-					if ( FR_idx[i] == idx )
-					{
-						q[ii] = -tempA[i];
-						break;
-					}
-				break;
-
-			case SUT_ConAdded:
-				/* Find index of added constraint */
-				for( i=0; i<nAC; ++i )
-					if ( AC_idx[i] == idx )
-					{
-						q[ii] = tempB[i];
-						break;
-					}
-				break;
-
-			case SUT_ConRemoved:
-				q[ii] = 0.0;
-				break;
-
-			default:
-				return THROWERROR( RET_UNKNOWN_BUG );
-		}
-	}
-
-	/* compute q = M^T K^{-1} r - q */
-	computeMTransTimes(1.0, sol, -1.0, q);
-
-	/* Solve linear system with Schur complement. */
-	real_t* p = new real_t[nS];
-	backsolveSchurQR( nS, q, 1, p );
-
-	computeMTimes(-1.0, p, 1.0, rhs);
-
-	retval = sparseSolver->solve(dim, rhs, sol);
-	if (retval != SUCCESSFUL_RETURN)
-	{
-		MyPrintf( "sparseSolver->solve (second time) failed.\n");
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED); // TODO: Different return code
-	}
-
-	/* Transfer extra compoments of the Schur complement solution to the correct place. */
-	for ( ii=0; ii<nS; ii++ )
-	{
-		int_t idx = schurUpdateIndex[ii];
-		switch ( schurUpdate[ii] ) // TODO: All the loops below could be done faster by binary search or so
-		{
-			case SUT_VarFixed:
-				break;
-
-			case SUT_VarFreed:
-				/* Find index of freed variable */
-				for( i=0; i<nFR; ++i )
-					if ( FR_idx[i] == idx )
-					{
-						delta_xFR_TMP[i] = p[ii];
-						break;
-					}
-				break;
-
-			case SUT_ConAdded:
-				/* Find index of added constraint */
-				for( i=0; i<nAC; ++i )
-					if ( AC_idx[i] == idx )
-					{
-						delta_yAC_TMP[i] = -p[ii];
-						break;
-					}
-				break;
-
-			case SUT_ConRemoved:
-				break;
-
-			default:
-				return THROWERROR( RET_UNKNOWN_BUG );
-		}
-	}
-
-	delete [] p;
-	delete [] q;
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::stepCalcReorder2(int_t nFR, int_t nAC, int_t* FR_idx, int_t* AC_idx, int_t nFRStart, int_t nACStart, int_t* FR_idxStart, int_t* AC_idxStart, int_t* FR_iSort, int_t* FR_iSortStart, int_t* AC_iSort, int_t* AC_iSortStart, real_t* sol, real_t* const delta_xFR, real_t* const delta_yAC)
-{
-	int_t i, ii;
-			i = 0;
-			ii = 0;
-			while ( ii < nFRStart && i < nFR )
-			{
-				int_t idx = FR_idx[FR_iSort[i]];
-				int_t idxStart = FR_idxStart[FR_iSortStart[ii]];
-
-				if ( idx == idxStart )
-					delta_xFR_TMP[FR_iSort[i++]] = sol[FR_iSortStart[ii++]];
-				else if ( idx < idxStart )
-					i++;
-				else
-					ii++;
-			}
-			/* Transfer Schur complement solution for the active constraint multipliers to the correct places */
-			i = 0;
-			ii = 0;
-			while ( ii < nACStart && i < nAC )
-			{
-				int_t idx = AC_idx[AC_iSort[i]];
-				int_t idxStart = AC_idxStart[AC_iSortStart[ii]];
-
-				if ( idx == idxStart )
-					delta_yAC_TMP[AC_iSort[i++]] = -sol[nFRStart+AC_iSortStart[ii++]];
-				else if ( idx < idxStart )
-					i++;
-				else
-					ii++;
-			}
-
-			/* refine the solution found so far */
-			for ( i=0; i<nFR; ++i )
-				delta_xFR[i] += delta_xFR_TMP[i];
-			for ( i=0; i<nAC; ++i )
-				delta_yAC[i] += delta_yAC_TMP[i];
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::stepCalcResid(int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx, BooleanType Delta_bC_isZero, real_t* const delta_xFX, real_t* const delta_xFR, real_t* const delta_yAC, const real_t* const delta_g, const real_t* const delta_lbA, const real_t* const delta_ubA, real_t& rnrm)
-{
-	int_t i, ii;
-				/* compute residuals in tempA and tempB, and max-norm */
-				for ( i=0; i<nFR; ++i )
-				{
-					ii = FR_idx[i];
-					tempA[i] = delta_g[ii];
-				}
-
-				switch ( hessianType )
-				{
-					case HST_ZERO:
-						break;
-
-					case HST_IDENTITY:
-						for ( i=0; i<nFR; ++i )
-							tempA[i] += delta_xFR[i];
-						break;
-
-					default:
-						H->times(bounds.getFree(), bounds.getFree(),  1, 1.0, delta_xFR, nFR, 1.0, tempA, nFR);
-						H->times(bounds.getFree(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, tempA, nFR);
-						break;
-				}
-
-				for ( i=0; i<nFR; ++i )
-					tempA[i] += options.epsRegularisation*delta_xFR[i];
-
-				A->transTimes(constraints.getActive(), bounds.getFree(), 1, -1.0, delta_yAC, nAC, 1.0, tempA, nFR);
-				rnrm = 0.0;
-				for ( i=0; i<nFR; ++i )
-					if (rnrm < getAbs (tempA[i]))
-						rnrm = getAbs (tempA[i]);
-
-				if (!Delta_bC_isZero)
-				{
-					for ( i=0; i<nAC; ++i )
-					{
-						ii = AC_idx[i];
-						if ( constraints.getStatus( ii ) == ST_LOWER )
-							tempB[i] = delta_lbA[ii];
-						else
-							tempB[i] = delta_ubA[ii];
-					}
-				}
-				else
-				{
-					for ( i=0; i<nAC; ++i )
-						tempB[i] = 0.0;
-				}
-
-				A->times(constraints.getActive(), bounds.getFree(), 1, -1.0, delta_xFR, nFR, 1.0, tempB, nAC);
-
-				A->times(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, tempB, nAC);
-				for ( i=0; i<nAC; ++i )
-					if (rnrm < getAbs (tempB[i]))
-						rnrm = getAbs (tempB[i]);
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::stepCalcDeltayFx(int_t nFR, int_t nFX, int_t nAC, int_t* FX_idx, const real_t* const delta_g, real_t* const delta_xFX, real_t* const delta_xFR, real_t* const delta_yAC, real_t* const delta_yFX)
-{
-	int_t i;
-		for( i=0; i<nFX; ++i )
-			delta_yFX[i] = delta_g[FX_idx[i]];
-
-		A->transTimes(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_yAC, nAC, 1.0, delta_yFX, nFX);
-
-		if ( hessianType == HST_ZERO )
-		{
-		  // TODO: if ( usingRegularisation( ) == BT_TRUE )
-				for( i=0; i<nFX; ++i )
-					delta_yFX[i] += options.epsRegularisation*delta_xFX[i];
-		}
-		else if ( hessianType == HST_IDENTITY )
-		{
-			for( i=0; i<nFX; ++i )
-				delta_yFX[i] += delta_xFX[i];
-		}
-		else
-		{
-			H->times(bounds.getFixed(), bounds.getFree(), 1, 1.0, delta_xFR, nFR, 1.0, delta_yFX, nFX);
-			H->times(bounds.getFixed(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, delta_yFX, nFX);
-		}
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::determineStepDirection(	const real_t* const delta_g, const real_t* const delta_lbA, const real_t* const delta_ubA,
-												const real_t* const delta_lb, const real_t* const delta_ub,
-												BooleanType Delta_bC_isZero, BooleanType Delta_bB_isZero,
-												real_t* const delta_xFX, real_t* const delta_xFR,
-												real_t* const delta_yAC, real_t* const delta_yFX
-												)
-{
-	returnValue retval = determineStepDirection2(	delta_g, delta_lbA, delta_ubA, delta_lb, delta_ub,
-													Delta_bC_isZero, Delta_bB_isZero, delta_xFX, delta_xFR,
-													delta_yAC, delta_yFX
-													);
-
-	if ( retval == RET_QR_FACTORISATION_FAILED )
-	{
-		retval = resetSchurComplement( BT_FALSE );
-		if (retval != SUCCESSFUL_RETURN)
-		{
-			MyPrintf( "In SQProblem::determineStepDirection, resetSchurComplement returns %d\n", retval);
-			return THROWERROR( retval );
-		}
-		retval = determineStepDirection2(	delta_g, delta_lbA, delta_ubA, delta_lb, delta_ub,
-													Delta_bC_isZero, Delta_bB_isZero, delta_xFX, delta_xFR,
-													delta_yAC, delta_yFX
-													);
-	}
-	return retval;
-}
-
-/*
- *	d e t e r m i n e S t e p D i r e c t i o n
- */
-returnValue SQProblemSchur::determineStepDirection2(	const real_t* const delta_g, const real_t* const delta_lbA, const real_t* const delta_ubA,
-												const real_t* const delta_lb, const real_t* const delta_ub,
-												BooleanType Delta_bC_isZero, BooleanType Delta_bB_isZero,
-												real_t* const delta_xFX, real_t* const delta_xFR,
-												real_t* const delta_yAC, real_t* const delta_yFX
-												)
-{
-	/* The linear system to be solved here is this:
-
-	   / H_FF  H_FX  A_CF^T  0 \ /  delta_xFR \   / -delta_g_F \
-	   | H_XF  H_XX  A_CX^T  I | |  delta_xFX |   | -delta_g_X |
-	   | A_CF  A_CX    0     0 | | -delta_yAC | = |  delta_bA  |  <-- active entries of delta_lbA and delta_ubA with corresponding sign
-	   \  0     I      0     0 / \ -delta_yFX /   \  delta_bX  /  <-- fixed entries of delta_lb and delta_ub with corresponding sign
-
-	*/
-
-
-	int_t i, ii, r;
-
-	returnValue retval;
-
-  //int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-
-	int_t* FR_idx;
-	int_t* FX_idx;
-	int_t* AC_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-
-	/* I) DETERMINE delta_xFX (this is exact, does not need refinement) */
-	if ( Delta_bB_isZero == BT_FALSE )
-	{
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-
-			if ( bounds.getStatus( ii ) == ST_LOWER )
-				delta_xFX[i] = delta_lb[ii];
-			else
-				delta_xFX[i] = delta_ub[ii];
-		}
-	}
-	else
-	{
-		for( i=0; i<nFX; ++i )
-			delta_xFX[i] = 0.0;
-	}
-
-	if ( nFR+nAC>0 ) {
-		real_t rhs_max = 0.0;
-		retval = stepCalcRhs( nFR, nFX, nAC, FR_idx, FX_idx, AC_idx, rhs_max, delta_g, delta_lbA, delta_ubA,
-							  delta_lb, delta_ub, Delta_bC_isZero, Delta_bB_isZero, delta_xFX, delta_xFR,
-							  delta_yAC, delta_yFX );
-
-		if (retval != SUCCESSFUL_RETURN)
-			return retval;
-		int_t nFRStart = boundsFreeStart.getLength();
-		int_t nACStart = constraintsActiveStart.getLength();
-
-		int_t* FR_iSort;
-		int_t* AC_iSort;
-		bounds.getFree( )->getISortArray( &FR_iSort );
-		constraints.getActive( )->getISortArray( &AC_iSort );
-
-		int_t* FR_idxStart;
-		int_t* AC_idxStart;
-		boundsFreeStart.getNumberArray( &FR_idxStart );
-		constraintsActiveStart.getNumberArray( &AC_idxStart );
-
-		int_t* FR_iSortStart;
-		int_t* AC_iSortStart;
-		boundsFreeStart.getISortArray( &FR_iSortStart );
-		constraintsActiveStart.getISortArray( &AC_iSortStart );
-
-		int_t dim = nFRStart + nACStart;
-		real_t* rhs = new real_t[dim];
-		real_t* sol = new real_t[dim];
-
-		/* Iterative refinement loop for delta_xFR, delta_yAC */
-		for ( r=0; r<=options.numRefinementSteps; ++r )
-		{
-		  retval = stepCalcReorder(nFR, nAC, FR_idx, AC_idx, nFRStart, nACStart, FR_idxStart, AC_idxStart, FR_iSort, FR_iSortStart, AC_iSort, AC_iSortStart, rhs);
-			if (retval != SUCCESSFUL_RETURN)
-				return retval;
-
-			retval = sparseSolver->solve(dim, rhs, sol);
-
-			if (retval != SUCCESSFUL_RETURN)
-			{
-				MyPrintf( "sparseSolver->solve (first time) failed.\n");
-				return THROWERROR(RET_MATRIX_FACTORISATION_FAILED); // TODO: Different return code
-			}
-
-			if ( nS > 0 )
-			{
-				retval = stepCalcBacksolveSchur( nFR, nFX, nAC, FR_idx, FX_idx, AC_idx, dim, rhs, sol );
-				if (retval != SUCCESSFUL_RETURN)
-					return retval;
-			}
-
-			/* Transfer Schur complement solution for the free variables to the correct places */
-			retval = stepCalcReorder2(nFR, nAC, FR_idx, AC_idx, nFRStart, nACStart, FR_idxStart, AC_idxStart, FR_iSort, FR_iSortStart, AC_iSort, AC_iSortStart, sol, delta_xFR, delta_yAC);
-			if (retval != SUCCESSFUL_RETURN)
-				return retval;
-
-			if ( r < options.numRefinementSteps ) // TODO: use "<" to avoid computation in last round
-			{
-				real_t rnrm;
-				retval = stepCalcResid(nFR, nFX, nAC, FR_idx, FX_idx, AC_idx, Delta_bC_isZero, delta_xFX, delta_xFR, delta_yAC, delta_g, delta_lbA, delta_ubA, rnrm);
-				if (retval != SUCCESSFUL_RETURN)
-					return retval;
-
-				/* early termination of residual norm small enough */
-				if ( options.printLevel == PL_HIGH )
-					MyPrintf( "In iterative refinement (iter %d) rnrm = %e and epsIterRef*rhs_max = %e.\n", r, rnrm, options.epsIterRef*rhs_max);
-
-				if ( rnrm <= options.epsIterRef*rhs_max )
-					break;
-			}
-
-		}
-
-		delete [] sol;
-		delete [] rhs;
-	}
-
-	/* IV) DETERMINE delta_yFX */
-	if ( nFX > 0 )
-	{
-		retval = stepCalcDeltayFx(nFR, nFX, nAC, FX_idx, delta_g, delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		if (retval != SUCCESSFUL_RETURN)
-			return retval;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::resetSchurComplement( BooleanType allowInertiaCorrection )
-{
-	int_t j;
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "Resetting Schur complement.\n");
-
-	nS = 0;
-	detS = 1.0;
-	rcondS = 1.0;
-	boundsFreeStart = *bounds.getFree();
-	constraintsActiveStart = *constraints.getActive();
-
-	if ( nSmax > 0 )
-		M_jc[0] = 0;
-
-	int_t dim = nFR+nAC;
-	// Count the number of nonzeros
-	int_t numNonzeros;
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			numNonzeros = 0;
-			break;
-
-		case HST_IDENTITY:
-			numNonzeros = nFR;
-			break;
-
-		default:
-			H->getSparseSubmatrix( bounds.getFree(), bounds.getFree(), 1, 1, numNonzeros, 0, 0, 0, BT_TRUE);
-			break;
-	}
-	// TODO: For now, we regularize every time
-	if (options.epsRegularisation > 0.0)
-		numNonzeros += nFR;
-
-	int_t numNonzerosA;
-
-	if ( constraintProduct != 0 )
-	{
-		MyPrintf( "In SQProblemSchur::determineStepDirection, constraintProduct not yet implemented.\n");
-		return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-	}
-	A->getSparseSubmatrix( constraints.getActive(), bounds.getFree(), nFR+1, 1, numNonzerosA, 0, 0, 0, BT_FALSE);
-	numNonzeros += numNonzerosA;
-
-	// Get the values
-	real_t* avals = new real_t[numNonzeros];
-	int_t* irn = new int_t[numNonzeros];
-	int_t* jcn = new int_t[numNonzeros];
-	numNonzeros = 0;
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			break;
-
-		case HST_IDENTITY:
-			numNonzeros += nFR;
-			for (j = 0; j<nFR; j++)
-			{
-				irn[j] = j+1;
-				jcn[j] = j+1;
-				avals[j] = 1.0;
-			}
-			break;
-
-		default:
-			H->getSparseSubmatrix( bounds.getFree(), bounds.getFree(), 1, 1, numNonzeros, irn, jcn, avals, BT_TRUE);
-			break;
-	}
-
-	// For now, we regularize every time
-	if (options.epsRegularisation > 0.0)
-	{
-		for (j = 0; j<nFR; j++)
-		{
-			irn[numNonzeros] = j+1;
-			jcn[numNonzeros] = j+1;
-			avals[numNonzeros++] = options.epsRegularisation;
-		}
-	}
-
-	A->getSparseSubmatrix( constraints.getActive(), bounds.getFree(), nFR+1, 1, numNonzerosA, irn+numNonzeros, jcn+numNonzeros, avals+numNonzeros, BT_FALSE);
-	numNonzeros += numNonzerosA;
-
-	// Call the linear solver
-	sparseSolver->reset();
-	returnValue retval = sparseSolver->setMatrixData(dim, numNonzeros, irn, jcn, avals);
-	delete [] jcn;
-	delete [] irn;
-	delete [] avals;
-	
-	if (retval != SUCCESSFUL_RETURN)
-		return THROWERROR(RET_NO_SPARSE_SOLVER);
-
-	// Factorize the matrix for later backsolves
-	retval = sparseSolver->factorize();
-	numFactorizations++;
-
-	// If matrix is singular, add bounds/remove constraints according to zero pivots
-	if (retval == RET_KKT_MATRIX_SINGULAR)
-	{
-		if( repairSingularWorkingSet( ) == SUCCESSFUL_RETURN )
-			return resetSchurComplement( allowInertiaCorrection );
-		else
-			return RET_KKT_MATRIX_SINGULAR;
-	}
-
-	// If matrix has wrong inertia, add bounds until inertia is correct
-	if (retval == SUCCESSFUL_RETURN && allowInertiaCorrection)
-	{
-		int_t neig = sparseSolver->getNegativeEigenvalues( );
-		if( neig > getNAC( ) )
-		{
-			if ( options.printLevel == PL_HIGH )
-				MyPrintf( "WARNING: After new factorization, reduced Hessian has %i negative eigenvalues, should be %i.\n", neig, getNAC( ) );
-
-			retval = correctInertia();
-		}
-	}
-
-	if (retval != SUCCESSFUL_RETURN)
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-
-	nS = 0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::computeMTimes( real_t alpha, const real_t* const x_, real_t beta, real_t* const y_ )
-{
-	if ( isEqual( alpha, -1.0 ) == BT_FALSE || isEqual( beta, 1.0 ) == BT_FALSE )
-		return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-
-	int_t i, j;
-
-	for ( j=0; j<nS; j++ )
-	{
-		const real_t xval = x_[j];
-		for ( i=M_jc[j]; i<M_jc[j+1]; i++)
-			y_[M_ir[i]] -= M_vals[i]*xval;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::computeMTransTimes( real_t alpha, const real_t* const x_, real_t beta, real_t* const y_ )
-{
-	if ( isEqual( alpha, 1.0 ) == BT_FALSE || ( isZero( beta ) == BT_FALSE && isEqual( beta, -1.0 ) == BT_FALSE ) )
-		return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-
-	int_t i, j;
-
-	if ( isZero( beta ) == BT_TRUE )
-	{
-		for ( j=0; j<nS; j++ )
-		{
-			y_[j] = 0.0;
-			for ( i=M_jc[j]; i<M_jc[j+1]; i++)
-				y_[j] += M_vals[i]*x_[M_ir[i]];
-		}
-	}
-	else
-	{
-		for ( j=0; j<nS; j++ )
-		{
-			y_[j] = -y_[j];
-			for ( i=M_jc[j]; i<M_jc[j+1]; i++)
-				y_[j] += M_vals[i]*x_[M_ir[i]];
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::addToSchurComplement( int_t number, SchurUpdateType update, int_t numNonzerosM, const sparse_int_t* Mpos, const real_t* const Mvals, int_t numNonzerosN, const sparse_int_t* Npos, const real_t* const Nvals, real_t N_diag )
-{
-	int_t i;
-
-	int_t nFRStart = boundsFreeStart.getLength();
-	int_t nACStart = constraintsActiveStart.getLength();
-
-	real_t* new_Scol = new real_t[nS];
-
-	int_t dim = nFRStart + nACStart;
-	real_t* rhs = new real_t[dim];
-	real_t* sol = new real_t[dim];
-
-	for ( i=0; i<dim; i++ )
-		rhs[i] = 0.0;
-
-	for ( i=0; i<numNonzerosM; i++ )
-		rhs[Mpos[i]] = Mvals[i];
-
-	returnValue retval = sparseSolver->solve(dim, rhs, sol);
-	if (retval != SUCCESSFUL_RETURN)
-	{
-		MyPrintf( "sparseSolver->solve in SQProblemSchur::addToSchurComplement failed.\n");
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED); // TODO: Different return code
-	}
-
-	computeMTransTimes(1.0, sol, 0.0, new_Scol);
-
-	/* Take care of off-diagonal elements in N. */
-	for ( i=0; i<numNonzerosN; i++ )
-		new_Scol[Npos[i]] -= Nvals[i];
-
-	real_t sdiag = -N_diag;
-	for ( i=0; i<numNonzerosM; i++ )
-		sdiag += Mvals[i] * sol[Mpos[i]];
-
-	/* Now augment S */
-	for ( i=0; i<nS; i++)
-		S[nS*nSmax + i] = new_Scol[i];
-	for ( i=0; i<nS; i++)
-		S[i*nSmax + nS] = new_Scol[i];
-	S[nS*nSmax + nS] = sdiag;
-
-	schurUpdateIndex[nS] = number;
-	schurUpdate[nS] = update;
-
-	/* Augment M matrix.  */
-	if ( M_physicallength < M_jc[nS] + numNonzerosM )
-	{
-		/* If necessary, allocate more memory for M. */
-		int_t M_physicallength_new = getMax(2*M_physicallength, M_physicallength + 2*numNonzerosM);
-		real_t* M_vals_new = new real_t[M_physicallength_new];
-		sparse_int_t* M_ir_new = new sparse_int_t[M_physicallength_new];
-		memcpy( M_vals_new, M_vals, ((unsigned int)(M_jc[nS]))*sizeof(real_t) );
-		memcpy( M_ir_new, M_ir, ((unsigned int)(M_jc[nS]))*sizeof(sparse_int_t) );
-		M_physicallength = M_physicallength_new;
-		delete [] M_vals;
-		delete [] M_ir;
-		M_vals = M_vals_new;
-		M_ir = M_ir_new;
-	}
-
-	for ( i=0; i<numNonzerosM; i++ )
-	{
-		M_vals[M_jc[nS] + i] = Mvals[i];
-		M_ir[M_jc[nS] + i] = Mpos[i];
-	}
-	M_jc[nS+1] = M_jc[nS] + numNonzerosM;
-
-	nS++;
-
-	delete [] sol;
-	delete [] rhs;
-	delete [] new_Scol;
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "added index %d with update type %d to Schur complement.  nS = %d\n", number, update, nS);
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SQProblemSchur::deleteFromSchurComplement( int_t idx, BooleanType allowUndo )
-{
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "deleting entry %d with idx = %d and type %d from Schur complement.", idx, schurUpdateIndex[idx], schurUpdate[idx]);
-
-	if ( idx != nS-1 )
-	{
-		real_t *temp_vals = NULL;
-		int_t *temp_ir = NULL;
-		int_t schurUpdateIndexTemp = -1;
-		SchurUpdateType schurUpdateTemp = SUT_UNDEFINED;
-
-		/* temporarily save the column of S to be deleted */
-		if( allowUndo == BT_TRUE )
-		{
-			temp_vals = new real_t[nS];
-			for ( int_t i=0; i<nS; i++ )
-				temp_vals[i] = S[idx*nSmax + i];
-
-			schurUpdateIndexTemp = schurUpdateIndex[idx];
-			schurUpdateTemp = schurUpdate[idx];
-		}
-
-		/* Shift rows and columns >idx of S by one to the upper left */
-		for ( int_t i=0; i<idx; i++ )
-			for ( int_t j=idx+1; j<nS; j++ )
-				S[i*nSmax + j-1] = S[i*nSmax + j];
-		for ( int_t i=idx+1; i<nS; i++ )
-		{
-			for ( int_t j=0; j<idx; j++ )
-				S[(i-1)*nSmax + j] = S[i*nSmax + j];
-			for ( int_t j=idx+1; j<nS; j++ )
-				S[(i-1)*nSmax + j-1] = S[i*nSmax + j];
-		}
-		for ( int_t i=idx+1; i<nS; i++ )
-		{
-			schurUpdateIndex[i-1] = schurUpdateIndex[i];
-			schurUpdate[i-1] = schurUpdate[i];
-		}
-
-		/* Store deleted row/column in the last row/column of S, can retrieve it from there later */
-		if( allowUndo == BT_TRUE )
-		{
-			for ( int_t i=0; i<nS; i++ )
-			{
-				S[(nS-1)*nSmax + i] = temp_vals[i];
-				S[i*nSmax + (nS-1)] = temp_vals[i];
-			}
-			schurUpdateIndex[nS-1] = schurUpdateIndexTemp;
-			schurUpdate[nS-1] = schurUpdateTemp;
-			delete[] temp_vals;
-		}
-
-		/* temporarily save the (sparse) column of M to be deleted */
-		int_t numEntries = M_jc[idx+1] - M_jc[idx];
-		if( allowUndo == BT_TRUE )
-		{
-			temp_ir = new int_t[numEntries];
-			temp_vals = new real_t[numEntries];
-
-			for ( int_t i=M_jc[idx]; i<M_jc[idx+1]; i++ )
-			{
-				temp_ir[i-M_jc[idx]] = M_ir[i];
-				temp_vals[i-M_jc[idx]] = M_vals[i];
-			}
-		}
-
-		/* Shift all columns >idx one to the left */
-		for ( int_t i=M_jc[idx+1]; i<M_jc[nS]; i++ )
-		{
-			M_ir[i-numEntries] = M_ir[i];
-			M_vals[i-numEntries] = M_vals[i];
-		}
-		for ( int_t i=idx; i<nS; i++ )
-			M_jc[i] = M_jc[i+1] - numEntries;
-
-		/* Store deleted column of M in the last column, can retrieve it from there later */
-		if( allowUndo == BT_TRUE )
-		{
-			for ( int_t i=M_jc[nS-1]; i<M_jc[nS]; i++ )
-			{
-				M_ir[i] = temp_ir[i-M_jc[nS-1]];
-				M_vals[i] = temp_vals[i-M_jc[nS-1]];
-			}
-
-			delete[] temp_ir;
-			delete[] temp_vals;
-		}
-	}
-
-	nS--;
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "  nS = %d\n", nS);
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SQProblemSchur::undoDeleteFromSchurComplement( int_t idx )
-{
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "undo deletion of entry %d with idx = %d and type %d from Schur complement. nS = %i\n", idx, schurUpdateIndex[nS-1], schurUpdate[nS-1],nS+1);
-
-	if ( idx != nS )
-	{
-		real_t *temp_vals;
-		int_t *temp_ir;
-		int_t schurUpdateIndexTemp = -1;
-		SchurUpdateType schurUpdateTemp = SUT_UNDEFINED;
-
-		/* temporarily save the last column of S */
-		temp_vals = new real_t[nS+1];
-		for ( int_t i=0; i<nS+1; i++ )
-			temp_vals[i] = S[i+nS*nSmax];
-
-		schurUpdateIndexTemp = schurUpdateIndex[nS];
-		schurUpdateTemp = schurUpdate[nS];
-
-		/* Shift rows and columns =>idx of S by one to the lower right */
-		for ( int_t i=idx-1; i>-1; i-- )
-			for ( int_t j=nS-1; j>idx-1; j-- )
-				S[(j+1)+i*nSmax] = S[j+i*nSmax];
-		for ( int_t i=nS-1; i>idx-1; i-- )
-		{
-			for ( int_t j=idx-1; j>-1; j-- )
-				S[j+(i+1)*nSmax] = S[j+i*nSmax];
-			for ( int_t j=nS-1; j>idx-1; j-- )
-				S[(j+1)+(i+1)*nSmax] = S[j+i*nSmax];
-		}
-		for ( int_t i=nS-1; i>idx-1; i-- )
-		{
-			schurUpdateIndex[i+1] = schurUpdateIndex[i];
-			schurUpdate[i+1] = schurUpdate[i];
-		}
-
-		/* Insert stored row/column of S at position idx */
-		for ( int_t i=0; i<nS+1; i++ )
-		{
-			S[idx*nSmax + i] = temp_vals[i];
-			S[i*nSmax + idx] = temp_vals[i];
-		}
-		schurUpdateIndex[idx] = schurUpdateIndexTemp;
-		schurUpdate[idx] = schurUpdateTemp;
-		delete[] temp_vals;
-
-		/* temporarily save the last (sparse) column of M */
-		int_t numEntries = M_jc[nS+1] - M_jc[nS];
-		temp_ir = new int_t[numEntries];
-		temp_vals = new real_t[numEntries];
-		for ( int_t i=M_jc[nS]; i<M_jc[nS+1]; i++ )
-		{
-			temp_ir[i-M_jc[nS]] = M_ir[i];
-			temp_vals[i-M_jc[nS]] = M_vals[i];
-		}
-
-		/* Shift all columns =>idx one to the right */
-		for ( int_t i=M_jc[nS]-1; i>M_jc[idx]-1; i-- )
-		{
-			M_ir[i+numEntries] = M_ir[i];
-			M_vals[i+numEntries] = M_vals[i];
-		}
-		for ( int_t i=nS; i>idx-1; i-- )
-			M_jc[i+1] = M_jc[i] + numEntries;
-
-		/* Insert stored column of M at position idx */
-		for ( int_t i=M_jc[idx]; i<M_jc[idx+1]; i++ )
-		{
-			M_ir[i] = temp_ir[i-M_jc[idx]];
-			M_vals[i] = temp_vals[i-M_jc[idx]];
-		}
-
-		delete[] temp_ir;
-		delete[] temp_vals;
-	}
-
-	nS++;
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "  nS = %d\n", nS);
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::correctInertia( )
-{
-	SubjectToStatus B_status;
-	real_t oldDetS;
-	int_t nFR = getNFR( );
-	int_t k, number, neig, nAdded;
-	int_t *freeBoundIdx = new int_t[nFR];
-	int_t *numberarray;
-
-	/* method may only be called after refactorization or if one bound/constraint
-	 * has been added, i.e. when a bound has flipped after refactorization */
-	if( nS != 0 && nS != 1 )
-		return THROWERROR( RET_INERTIA_CORRECTION_FAILED );
-	neig = sparseSolver->getNegativeEigenvalues( );
-
-	/* if a bound flipped, check if it did in fact remove a negative eigenvalue */
-	if( nS == 1 && detS < 0 )
-		neig--;
-
-	/* if this method is triggered after flipping bounds, inertia is now probably correct */
-	if( neig == getNAC( ) )
-		return SUCCESSFUL_RETURN;
-
-	/* get bound numbers in the order in which they are in the non-basis */
-	bounds.getFree()->getNumberArray( &numberarray );
-	for( k=0; k<nFR; k++ )
-		freeBoundIdx[k] = numberarray[k];
-
-	k = 0;
-	nAdded = getNFR( );
-	while ( neig > getNAC( ) && k < nFR )
-	{
-		oldDetS = detS;
-
-		/* If it's linearly independent, fix the next free variable at the nearest bound */
-		number = freeBoundIdx[k];
-		if( addBound_checkLI( number ) == RET_LINEARLY_INDEPENDENT )
-		{
-			/* This is just heuristics: we need the bound which gives correct multiplier sign */
-			if ( x[number] - lb[number] < ub[number] - x[number] )
-				B_status = ST_LOWER;
-			else
-				B_status = ST_UPPER;
-
-			/* Update Schur complement */
-			if( addBound( number, B_status, BT_TRUE, BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				if ( options.printLevel == PL_HIGH )
-					MyPrintf("In correctInertia: Adding bound[%i] = %i failed!\n", k, number );
-				return THROWERROR( RET_INERTIA_CORRECTION_FAILED );
-			}
-
-			/* Adjust bounds */
-			if ( B_status == ST_LOWER )
-				lb[number] = x[number];
-			else
-				ub[number] = x[number];
-		}
-		else
-		{
-			if ( options.printLevel == PL_HIGH )
-				MyPrintf("bound[%i] = %i is linearly dependent. Do not add.\n", k, number );
-			k++;
-			continue;
-		}
-
-		/* Case 1: Schur complement has been reset, check inertia of new factorization */
-		if( nS == 0 )
-			neig = sparseSolver->getNegativeEigenvalues( );
-		/* Case 2: Schur complement has grown, check if determinant changed sign */
-		else if( oldDetS * detS < 0 )
-			neig--;
-		/* NB: Case 3: (Schur complement has shrunk) cannot happen here:
-		 * This method is called after a factorization reset or after ONE bound has been added */
-
-		k++;
-	}
-	nAdded -= getNFR( );
-
-	delete[] freeBoundIdx;
-
-	/* if there are still too many negative eigenvalues, exit */
-	if( neig > getNAC( ) )
-	{
-		if ( options.printLevel == PL_HIGH )
-			MyPrintf( "Added %i bounds but KKT matrix still has %i negative eigenvalues, should be %i.\n", nAdded, neig, getNAC( ) );
-		return THROWERROR( RET_INERTIA_CORRECTION_FAILED );
-	}
-	else
-	{
-		if ( options.printLevel == PL_HIGH )
-			MyPrintf( "After adding %i bounds, reduced Hessian has correct inertia.\n", nAdded, neig );
-		return SUCCESSFUL_RETURN;
-	}
-}
-
-
-returnValue SQProblemSchur::repairSingularWorkingSet( )
-{
-	int_t k, number;
-	SubjectToStatus B_status;
-	int_t rank = sparseSolver->getRank( );
-	int_t nFR = getNFR( );
-	int_t defect = nFR + getNAC( ) - rank;
-
-	/* Rank detection not supported by linear solver */
-	if ( rank < 0 )
-		return RET_KKT_MATRIX_SINGULAR;
-
-	/* Consistency check */
-	if ( defect <= 0 )
-		return RET_UNKNOWN_BUG;
-
-	/* Determine zero pivots */
-	int_t *zeroPivots = new int_t[defect];
-	sparseSolver->getZeroPivots( zeroPivots );
-
-	/* Determination of zero pivots not supported by linear solver */
-	if ( zeroPivots == 0 )
-		return RET_KKT_MATRIX_SINGULAR;
-
-	/* We assume implicitly that pivots are sorted in ascending order */
-	/// \todo make sure that this is so.
-	/* Remove the one with the highest index first so not to mess up index lists */
-	int_t bndsAdded = 0;
-	for ( k=defect-1; k>-1; k-- )
-	{
-		/* Zero curvature in the Hessian: add a bound */
-		if ( zeroPivots[k] < nFR )
-		{
-			number = bounds.getFree()->getNumber( zeroPivots[k] );
-
-			if ( options.printLevel == PL_HIGH )
-				MyPrintf( "WARNING: KKT matrix singular! Add bound %i before refactorization.\n", number);
-
-			/* This is just heuristics: we need the bound which gives correct multiplier sign */
-			if ( x[number] - lb[number] < ub[number] - x[number] )
-				B_status = ST_LOWER;
-			else
-				B_status = ST_UPPER;
-
-			/* Here we do not need to update the Schur complement because KKT matrix is factorized afterwards */
-			if ( bounds.moveFreeToFixed( number, B_status ) != SUCCESSFUL_RETURN )
-				return RET_ADDBOUND_FAILED;
-
-			/* Adjust bounds */
-			if ( B_status == ST_LOWER )
-				lb[number] = x[number];
-			else
-				ub[number] = x[number];
-
-			bndsAdded++;
-		}
-		/* Linearly dependent row in the Jacobian: remove a constraint */
-		else
-		{
-			number = constraints.getActive()->getNumber( zeroPivots[k]-nFR );
-			if ( options.printLevel == PL_HIGH )
-				MyPrintf( "WARNING: KKT matrix singular! Removing constraint %i before refactorization.\n", number);
-
-			if ( constraints.moveActiveToInactive( number ) != SUCCESSFUL_RETURN )
-				return RET_REMOVECONSTRAINT_FAILED;
-
-			// AW: If this is an equality constraint, it is now inactive and
-			// will not be considered in the step computation which leads to
-			// violation of that constraint in the future. Here, I try to
-			// fix this by simply making this constraint no longer an
-			// equality.
-			// TODO: This is probably also necessary for bound constraints
-			if ( constraints.getType(number) == ST_EQUALITY )
-			{
-				if ( options.printLevel == PL_HIGH )
-					MyPrintf( "WARNING: Making this constraint no longer an equality.\n");
-				constraints.setType( number, ST_BOUNDED );
-			}
-
-			/* Adjust dual variable */
-			y[number] = 0.0;
-		}
-	}
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "WARNING: KKT matrix singular! Removed %i constraints and added %i bounds before refactorization.\n",
-					defect-bndsAdded, bndsAdded );
-
-	delete[] zeroPivots;
-
-	return SUCCESSFUL_RETURN;
-}
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/SolutionAnalysis.cpp b/extlibs/qpOASES-3.2.0/src/SolutionAnalysis.cpp
deleted file mode 100644
index ee69d7d..0000000
--- a/extlibs/qpOASES-3.2.0/src/SolutionAnalysis.cpp
+++ /dev/null
@@ -1,681 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/SolutionAnalysis.cpp
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Implementation of the SolutionAnalysis class designed to perform
- *	additional analysis after solving a QP with qpOASES.
- *
- */
-
-
-#include <qpOASES/extras/SolutionAnalysis.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	S o l u t i o n A n a l y s i s
- */
-SolutionAnalysis::SolutionAnalysis( )
-{
-
-}
-
-
-/*
- *	S o l u t i o n A n a l y s i s
- */
-SolutionAnalysis::SolutionAnalysis( const SolutionAnalysis& rhs )
-{
-
-}
-
-
-/*
- *	~ S o l u t i o n A n a l y s i s
- */
-SolutionAnalysis::~SolutionAnalysis( )
-{
-
-}
-
-
-/*
- *	o p e r a t o r =
- */
-SolutionAnalysis& SolutionAnalysis::operator=( const SolutionAnalysis& rhs )
-{
-	if ( this != &rhs )
-	{
-
-	}
-
-	return *this;
-}
-
-
-
-/*
- *	g e t K k t V i o l a t i o n
- */
-real_t SolutionAnalysis::getKktViolation(	QProblemB* const qp,
-											real_t* const maxStat, real_t* const maxFeas, real_t* const maxCmpl
-											) const
-{
-	int_t i;
-	int_t nV = qp->getNV();
-
-	if ( qp == 0 )
-		return INFTY;
-
-	/* setup Hessian matrix array (or pass NULL pointer) */
-	real_t* H_ptr = 0;
-	BooleanType hasIdentityHessian = BT_FALSE;
-
-	switch( qp->getHessianType() )
-	{
-		case HST_ZERO:
-			break;
-
-		case HST_IDENTITY:
-			hasIdentityHessian = BT_TRUE;
-			break;
-
-		default:
-			H_ptr = qp->H->full();
-			if ( qp->usingRegularisation() == BT_TRUE )
-				for( i=0; i<nV; ++i )
-					H_ptr[i*nV+i] -= qp->regVal;
-	}
-
-	real_t* workingSetB = new real_t[nV];
-	qp->getWorkingSetBounds( workingSetB );
-
-	/* determine maximum KKT violation */
-	real_t maxKktViolation=0.0, stat=0.0, feas=0.0, cmpl=0.0;
-
-	returnValue returnvalue = REFER_NAMESPACE_QPOASES getKktViolation(	nV,
-																		H_ptr,qp->g,
-																		qp->lb,qp->ub,
-																		qp->x,qp->y,
-																		stat,feas,cmpl,
-																		workingSetB,hasIdentityHessian
-																		);
-	if ( workingSetB != 0 )
-		delete[] workingSetB;
-
-	if ( H_ptr != 0 )
-		delete[] H_ptr;
-
-	if ( returnvalue != SUCCESSFUL_RETURN )
-		THROWERROR( returnvalue );
-
-	/* assign return values */
-	if ( maxStat != 0 )
-		*maxStat = stat;
-
-	if ( maxFeas != 0 )
-		*maxFeas = feas;
-
-	if ( maxCmpl != 0 )
-		*maxCmpl = cmpl;
-
-	maxKktViolation = getMax( maxKktViolation,stat );
-	maxKktViolation = getMax( maxKktViolation,feas );
-	maxKktViolation = getMax( maxKktViolation,cmpl );
-
-	return maxKktViolation;
-}
-
-
-/*
- *	g e t K k t V i o l a t i o n
- */
-real_t SolutionAnalysis::getKktViolation(	QProblem* const qp,
-											real_t* const maxStat, real_t* const maxFeas, real_t* const maxCmpl
-											) const
-{
-	int_t i;
-	int_t nV = qp->getNV();
-	int_t nC = qp->getNC();
-
-	if ( qp == 0 )
-		return INFTY;
-
-	/* setup Hessian matrix array (or pass NULL pointer) */
-	real_t* H_ptr = 0;
-	BooleanType hasIdentityHessian = BT_FALSE;
-
-	switch( qp->getHessianType() )
-	{
-		case HST_ZERO:
-			break;
-
-		case HST_IDENTITY:
-			hasIdentityHessian = BT_TRUE;
-			break;
-
-		default:
-			H_ptr = qp->H->full();
-			if ( qp->usingRegularisation() == BT_TRUE )
-				for( i=0; i<nV; ++i )
-					H_ptr[i*nV+i] -= qp->regVal;
-	}
-
-	/* setup constraint matrix array */
-	real_t* A_ptr = qp->A->full();
-
-	real_t* workingSetB = new real_t[nV];
-	qp->getWorkingSetBounds( workingSetB );
-
-	real_t* workingSetC = new real_t[nC];
-	qp->getWorkingSetConstraints( workingSetC );
-
-	/* determine maximum KKT violation */
-	real_t maxKktViolation=0.0, stat=0.0, feas=0.0, cmpl=0.0;
-
-	returnValue returnvalue = REFER_NAMESPACE_QPOASES getKktViolation(	nV,nC,
-																		H_ptr,qp->g,A_ptr,
-																		qp->lb,qp->ub,qp->lbA,qp->ubA,
-																		qp->x,qp->y,
-																		stat,feas,cmpl,
-																		workingSetB,workingSetC,hasIdentityHessian
-																		);
-
-	if ( workingSetC != 0 )
-		delete[] workingSetC;
-
-	if ( workingSetB != 0 )
-		delete[] workingSetB;
-
-	if ( A_ptr != 0 )
-		delete[] A_ptr;
-
-	if ( H_ptr != 0 )
-		delete[] H_ptr;
-
-	if ( returnvalue != SUCCESSFUL_RETURN )
-		THROWERROR( returnvalue );
-
-	/* assign return values */
-	if ( maxStat != 0 )
-		*maxStat = stat;
-
-	if ( maxFeas != 0 )
-		*maxFeas = feas;
-
-	if ( maxCmpl != 0 )
-		*maxCmpl = cmpl;
-
-	maxKktViolation = getMax( maxKktViolation,stat );
-	maxKktViolation = getMax( maxKktViolation,feas );
-	maxKktViolation = getMax( maxKktViolation,cmpl );
-
-	return maxKktViolation;
-}
-
-
-/*
- *	g e t K k t V i o l a t i o n
- */
-real_t SolutionAnalysis::getKktViolation(	SQProblem* const qp,
-											real_t* const maxStat, real_t* const maxFeas, real_t* const maxCmpl
-											) const
-{
-	return getKktViolation( (QProblem*)qp, maxStat,maxFeas,maxCmpl );
-}
-
-
-
-/*
- *	g e t V a r i a n c e C o v a r i a n c e
- */
-returnValue SolutionAnalysis::getVarianceCovariance(	QProblemB* const qp,
-														const real_t* const g_b_bA_VAR, real_t* const Primal_Dual_VAR
-														) const
-{
-	return THROWERROR( RET_NOT_YET_IMPLEMENTED );
-}
-
-
-/*
- *	g e t V a r i a n c e C o v a r i a n c e
- */
-returnValue SolutionAnalysis::getVarianceCovariance(	QProblem* qp,
-														const real_t* const g_b_bA_VAR, real_t* const Primal_Dual_VAR
-														) const
-{
-
-  /* DEFINITION OF THE DIMENSIONS nV AND nC:
-   * --------------------------------------- */
-  int_t nV  = qp->getNV( );                      /* dimension of x / the bounds */
-  int_t nC  = qp->getNC( );                      /* dimension of the constraints */
-  int_t dim = 2*nV+nC;                           /* dimension of input and output */
-                                               /* variance-covariance matrix */
-  int_t run1, run2, run3;                        /* simple run variables (for loops). */
-
-
-  /* ALLOCATION OF MEMORY:
-   * --------------------- */
-  real_t* delta_g_cov    = new real_t[nV];     /* a covariance-vector of g */
-  real_t* delta_lb_cov   = new real_t[nV];     /* a covariance-vector of lb */
-  real_t* delta_ub_cov   = new real_t[nV];     /* a covariance-vector of ub */
-  real_t* delta_lbA_cov  = new real_t[nC];     /* a covariance-vector of lbA */
-  real_t* delta_ubA_cov  = new real_t[nC];     /* a covariance-vector of ubA */
-
-  returnValue returnvalue;                     /* the return value */
-  BooleanType Delta_bC_isZero = BT_FALSE;      /* (just use FALSE here) */
-  BooleanType Delta_bB_isZero = BT_FALSE;      /* (just use FALSE here) */
-
-
-
-  /* ASK FOR THE NUMBER OF FREE AND FIXED VARIABLES:
-   * (ASSUMES THAT ACTIVE SET IS CONSTANT FOR THE
-   *  VARIANCE-COVARIANCE EVALUATION)
-   * ----------------------------------------------- */
-  int_t nFR, nFX, nAC;
-
-  nFR = qp->getNFR( );
-  nFX = qp->getNFX( );
-  nAC = qp->getNAC( );
-
-
-  /* ASK FOR THE CORRESPONDING INDEX ARRAYS:
-   * --------------------------------------- */
-  int_t *FR_idx, *FX_idx, *AC_idx;
-
-  if ( qp->bounds.getFree( )->getNumberArray( &FR_idx ) != SUCCESSFUL_RETURN )
-       return THROWERROR( RET_HOTSTART_FAILED );
-
-  if ( qp->bounds.getFixed( )->getNumberArray( &FX_idx ) != SUCCESSFUL_RETURN )
-       return THROWERROR( RET_HOTSTART_FAILED );
-
-  if ( qp->constraints.getActive( )->getNumberArray( &AC_idx ) != SUCCESSFUL_RETURN )
-       return THROWERROR( RET_HOTSTART_FAILED );
-
-
-
-  /* INTRODUCE VARIABLES TO MEASURE THE REACTION OF THE QP-SOLUTION TO
-   * THE VARIANCE-COVARIANCE DISTURBANCE:
-   * ----------------------------------------------------------------- */
-  real_t *delta_xFR = new real_t[nFR];
-  real_t *delta_xFX = new real_t[nFX];
-  real_t *delta_yAC = new real_t[nAC];
-  real_t *delta_yFX = new real_t[nFX];
-
-  real_t* K             = new real_t[dim*dim];  /* matrix to store */
-                                                /* an intermediate */
-                                                /* result. */
-
-  /* SOME INITIALIZATIONS:
-   * --------------------- */
-  for( run1 = 0; run1 < dim*dim; run1++ ){
-    K              [run1] = 0.0;
-    Primal_Dual_VAR[run1] = 0.0;
-  }
-
-
-  /* ================================================================= */
-
-  /* FIRST MATRIX MULTIPLICATION (OBTAINS THE INTERMEDIATE RESULT
-   *  K := [ ("ACTIVE" KKT-MATRIX OF THE QP)^(-1) * g_b_bA_VAR ]^T )
-   * THE EVALUATION OF THE INVERSE OF THE KKT-MATRIX OF THE QP
-   * WITH RESPECT TO THE CURRENT ACTIVE SET
-   * USES THE EXISTING CHOLESKY AND TQ-DECOMPOSITIONS. FOR DETAILS
-   * cf. THE (protected) FUNCTION determineStepDirection. */
-
-  for( run3 = 0; run3 < dim; run3++ ){
-
-
-    for( run1 = 0; run1 < nV; run1++ ){
-      delta_g_cov  [run1]   = g_b_bA_VAR[run3*dim+run1];
-      delta_lb_cov [run1]   = g_b_bA_VAR[run3*dim+nV+run1];         /*  LINE-WISE LOADING OF THE INPUT */
-      delta_ub_cov [run1]   = g_b_bA_VAR[run3*dim+nV+run1];         /*  VARIANCE-COVARIANCE            */
-    }
-    for( run1 = 0; run1 < nC; run1++ ){
-      delta_lbA_cov [run1]  = g_b_bA_VAR[run3*dim+2*nV+run1];
-      delta_ubA_cov [run1]  = g_b_bA_VAR[run3*dim+2*nV+run1];
-    }
-
-
-    /* EVALUATION OF THE STEP:
-     * ------------------------------------------------------------------------------ */
-
-    returnvalue = qp->determineStepDirection( delta_g_cov, delta_lbA_cov, delta_ubA_cov, delta_lb_cov, delta_ub_cov,
-                                              Delta_bC_isZero, Delta_bB_isZero, delta_xFX,delta_xFR,
-                                              delta_yAC,delta_yFX );
-
-    /* ------------------------------------------------------------------------------ */
-
-
-    /* STOP THE ALGORITHM IN THE CASE OF NO SUCCESFUL RETURN:
-     * ------------------------------------------------------ */
-    if ( returnvalue != SUCCESSFUL_RETURN ){
-
-      delete[] delta_g_cov;
-      delete[] delta_lb_cov;
-      delete[] delta_ub_cov;
-      delete[] delta_lbA_cov;
-      delete[] delta_ubA_cov;
-      delete[] delta_xFR;
-      delete[] delta_xFX;
-      delete[] delta_yAC;
-      delete[] delta_yFX;
-      delete[] K;
-
-      THROWERROR( RET_STEPDIRECTION_DETERMINATION_FAILED );
-      return returnvalue;
-    }
-
-
-
-    for( run1=0; run1<nFR; run1++ ){
-      run2                  = FR_idx[run1];
-      K[run3*dim+run2]      = delta_xFR[run1];
-    }                                                               /*  LINE WISE                  */
-    for( run1=0; run1<nFX; run1++ ){                                /*  STORAGE OF THE QP-REACTION */
-      run2                  = FX_idx[run1];                         /*  (uses the index list)      */
-      K[run3*dim+run2]      = delta_xFX[run1];
-      K[run3*dim+nV+run2]   = delta_yFX[run1];
-    }
-    for( run1=0; run1<nAC; run1++ ){
-      run2                  = AC_idx[run1];
-      K[run3*dim+2*nV+run2] = delta_yAC[run1];
-    }
-
-  }
-
-
-  /* ================================================================= */
-
-  /* SECOND MATRIX MULTIPLICATION (OBTAINS THE FINAL RESULT
-   * Primal_Dual_VAR := ("ACTIVE" KKT-MATRIX OF THE QP)^(-1) * K )
-   * THE APPLICATION OF THE KKT-INVERSE IS AGAIN REALIZED
-   * BY USING THE PROTECTED FUNCTION
-   * determineStepDirection */
-
-  for( run3 = 0; run3 < dim; run3++ ){
-
-    for( run1 = 0; run1 < nV; run1++ ){
-      delta_g_cov  [run1]   = K[run3+     run1*dim];
-      delta_lb_cov [run1]   = K[run3+(nV+run1)*dim];                /*  ROW WISE LOADING OF THE */
-      delta_ub_cov [run1]   = K[run3+(nV+run1)*dim];                /*  INTERMEDIATE RESULT K   */
-    }
-    for( run1 = 0; run1 < nC; run1++ ){
-      delta_lbA_cov [run1]  = K[run3+(2*nV+run1)*dim];
-      delta_ubA_cov [run1]  = K[run3+(2*nV+run1)*dim];
-    }
-
-
-    /* EVALUATION OF THE STEP:
-     * ------------------------------------------------------------------------------ */
-
-    returnvalue = qp->determineStepDirection( delta_g_cov, delta_lbA_cov, delta_ubA_cov, delta_lb_cov, delta_ub_cov,
-                                              Delta_bC_isZero, Delta_bB_isZero, delta_xFX,delta_xFR,
-                                              delta_yAC,delta_yFX);
-
-
-    /* ------------------------------------------------------------------------------ */
-
-
-    /* STOP THE ALGORITHM IN THE CASE OF NO SUCCESFUL RETURN:
-     * ------------------------------------------------------ */
-    if ( returnvalue != SUCCESSFUL_RETURN ){
-
-      delete[] delta_g_cov;
-      delete[] delta_lb_cov;
-      delete[] delta_ub_cov;
-      delete[] delta_lbA_cov;
-      delete[] delta_ubA_cov;
-      delete[] delta_xFR;
-      delete[] delta_xFX;
-      delete[] delta_yAC;
-      delete[] delta_yFX;
-      delete[] K;
-
-      THROWERROR( RET_STEPDIRECTION_DETERMINATION_FAILED );
-      return returnvalue;
-    }
-
-
-
-    for( run1=0; run1<nFR; run1++ ){
-      run2                                = FR_idx[run1];
-      Primal_Dual_VAR[run3+run2*dim]      = delta_xFR[run1];
-    }
-    for( run1=0; run1<nFX; run1++ ){                                 /*  ROW-WISE STORAGE */
-      run2                  = FX_idx[run1];                          /*  OF THE RESULT.   */
-      Primal_Dual_VAR[run3+run2*dim     ]   = delta_xFX[run1];
-      Primal_Dual_VAR[run3+(nV+run2)*dim]   = delta_yFX[run1];
-    }
-    for( run1=0; run1<nAC; run1++ ){
-      run2                                  = AC_idx[run1];
-      Primal_Dual_VAR[run3+(2*nV+run2)*dim] = delta_yAC[run1];
-    }
-
-  }
-
-
-  /* DEALOCATE MEMORY:
-   * ----------------- */
-
-  delete[] delta_g_cov;
-  delete[] delta_lb_cov;
-  delete[] delta_ub_cov;
-  delete[] delta_lbA_cov;
-  delete[] delta_ubA_cov;
-  delete[] delta_xFR;
-  delete[] delta_xFX;
-  delete[] delta_yAC;
-  delete[] delta_yFX;
-  delete[] K;
-
-  return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t V a r i a n c e C o v a r i a n c e
- */
-returnValue SolutionAnalysis::getVarianceCovariance(	SQProblem* const qp,
-														const real_t* const g_b_bA_VAR, real_t* const Primal_Dual_VAR
-														) const
-{
-	/* Call QProblem variant. */
-	return getVarianceCovariance( (QProblem*)qp,g_b_bA_VAR,Primal_Dual_VAR );
-}
-
-
-/*
- *	c h e c k C u r v a t u r e O n S e t S
- */
-returnValue SolutionAnalysis::checkCurvatureOnStronglyActiveConstraints( SQProblem* qp )
-{
-  printf("checkCurvatureOnStronglyActiveConstraints( SQProblem* qp ) not yet implemented for standard qpOASES!\n");
-  return RET_INERTIA_CORRECTION_FAILED;
-}
-
-
-/*
- *	c h e c k C u r v a t u r e O n S t r o n g l y A c t i v e C o n s t r a i n t s
- */
-returnValue SolutionAnalysis::checkCurvatureOnStronglyActiveConstraints( SQProblemSchur* qp )
-{
-  real_t eps = 1.0e-16;
-  returnValue ret;
-  Bounds saveBounds;
-  QProblemStatus saveStatus;
-  int_t k, neig, nAC, nFX, *FX_idx;
-
-  nFX = qp->getNFX( );
-  nAC = qp->getNAC( );
-
-  // If no bounds are active reduced Hessian is positive definite (otherwise qpOASES wouldnt have finished)
-  if( nFX == 0 )
-    return SUCCESSFUL_RETURN;
-
-  // Get active bounds (deep copy)
-  qp->getBounds( saveBounds );
-  saveBounds.getFixed( )->getNumberArray( &FX_idx );
-
-  // We have to change the status to modify the active set
-  saveStatus = qp->getStatus();
-  qp->status = QPS_PERFORMINGHOMOTOPY;
-
-  // If a variable is active now but has not been in the previous major iteration remove it
-  for( k=0; k<nFX; k++ )
-    if( getAbs(qp->x[FX_idx[k]]) > eps )
-      if ( qp->bounds.moveFixedToFree( FX_idx[k] ) != SUCCESSFUL_RETURN )
-	return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-  // Do a new factorization and check the inertia
-  ret = qp->resetSchurComplement( BT_FALSE );
-  neig = qp->sparseSolver->getNegativeEigenvalues( );
-  if( ret == SUCCESSFUL_RETURN && neig != nAC )
-    ret = RET_INERTIA_CORRECTION_FAILED;
-
-  // Add all bounds that have been removed
-  for( k=0; k<nFX; k++ )
-    if( qp->bounds.getStatus( FX_idx[k] ) == ST_INACTIVE )
-      qp->bounds.moveFreeToFixed( FX_idx[k], saveBounds.getStatus( FX_idx[k] ) );
-
-  qp->status = saveStatus;
-  return ret;
-}
-
-
-//int_t SolutionAnalysis::checkCurvatureOnStronglyActiveConstraints( SQProblemSchur* qp )
-//{
-  //real_t eps = 1.0e-16;
-  //real_t oldDet, newDet;
-  //int_t oldNS;
-  //returnValue ret;
-  //Bounds saveBounds;
-  //QProblemStatus saveStatus;
-  //int_t nFX, *FX_idx;
-  //int_t k, fail, neig, rmCnt, nAC;
-
-  //// Get active bounds (deep copy)
-  //nFX = qp->getNFX( );
-  //nAC = qp->getNAC( );
-  //qp->getBounds( saveBounds );
-  //saveBounds.getFixed( )->getNumberArray( &FX_idx );
-
-  //// If no bounds are active reduced Hessian is positive definite (otherwise qpOASES wouldnt have finished)
-  //if( nFX == 0 )
-    //return 0;
-
-  //// We have to modify the status to call removeBound()
-  //saveStatus = qp->getStatus();
-  //qp->status = QPS_PERFORMINGHOMOTOPY;
-
-  //// If a variable is active but was not active in the previous major iteration
-  //// remove it to see if a negative eigenvalue appears
-  //rmCnt = 0;
-  //fail = 0;
-  //for( k=0; k<nFX; k++ )
-    //if( getAbs(qp->x[FX_idx[k]]) > eps )
-    //{
-      //oldDet = qp->detS;
-      //oldNS = qp->nS;
-
-      //ret = qp->removeBound( FX_idx[k], BT_TRUE, BT_FALSE, BT_FALSE );
-      //if( ret != SUCCESSFUL_RETURN )
-      //{
-	//fail = 1;
-	//break;
-      //}
-
-      //newDet = qp->detS;
-      //rmCnt++;
-
-      //// Case 1: S has grown by 1 row and column
-      //if( qp->nS == oldNS + 1 )
-      //{
-	//// If the determinant does not change sign, then S has gained a positive eigenvalue.
-	//// That means there is a negative eigenvalue in the (extended) reduced Hessian!
-	//if ( ( oldDet <= 0.0 && newDet <= 0.0 ) || ( oldDet >= 0.0 && newDet >= 0.0 ) )
-	//{
-	  //fail = 1;
-	  //break;
-	//}
-      //}
-      //// Case 2: S has shrunk by 1 row and column
-      //else if( qp->nS == oldNS - 1 )
-      //{
-	//// If the determinant changes sign, then S has lost a negative eigenvalue.
-	//// That means there is a negative eigenvalue in the (extended) reduced Hessian!
-	//if ( ( oldDet <= 0.0 && newDet > 0.0 ) || ( oldDet >= 0.0 && newDet < 0.0 ) )
-	//{
-	  //fail = 1;
-	  //break;
-	//}
-      //}
-      //// Case 3: S was reset
-      //else if( qp->nS == 0 )
-      //{
-	//// Check inertia of KKT matrix
-	//neig = qp->sparseSolver->getNegativeEigenvalues( );
-	//if( neig > nAC )
-	//{
-	  //fail = 1;
-	  //break;
-	//}
-      //}
-      //else
-	//printf("ERROR!\n");
-    //}
-
-  //// If test is successful, add all bounds that have been removed
-  //// If not, don't bother with that because we will discard this QP object anyway
-  //if( fail == 0 )
-    //for( k=0; k<nFX; k++ )
-    //{
-      //ret = qp->addBound( FX_idx[k], saveBounds.getStatus( FX_idx[k] ), BT_TRUE, BT_FALSE );
-      //if( ret != SUCCESSFUL_RETURN && ret != RET_BOUND_ALREADY_ACTIVE )
-	//printf( "addBound() in checkCurvatureOnStronglyActiveConstraints(): %s\n", getGlobalMessageHandler()->getErrorCodeMessage( ret ) );
-    //}
-
-  //qp->status = saveStatus;
-  //return fail;
-//}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/SparseSolver.cpp b/extlibs/qpOASES-3.2.0/src/SparseSolver.cpp
deleted file mode 100644
index defba5e..0000000
--- a/extlibs/qpOASES-3.2.0/src/SparseSolver.cpp
+++ /dev/null
@@ -1,1103 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *
- *	Copyright (C) 2012 by Andreas Waechter. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/SparseSolver.cpp
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- *
- *	Interfaces to sparse linear solvers that are used in a Schur-complement
- *	implementation in qpOASES.
- */
-
-
-#include <qpOASES/SparseSolver.hpp>
-
-#ifndef __MATLAB__
-# include <cstdarg>
-void MyPrintf(const char* pformat, ... );
-#else
-# include <mex.h>
-# define MyPrintf mexPrintf
-#endif
-
-//#define __DEBUG_ITER__
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- ****************************************************************************/
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-SparseSolver::SparseSolver( )
-{
-}
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-SparseSolver::SparseSolver( const SparseSolver& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ S p a r s e S o l v e r B a s e
- */
-SparseSolver::~SparseSolver( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-SparseSolver& SparseSolver::operator=( const SparseSolver& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-/*
- *	r e s e t
- */
-returnValue SparseSolver::reset( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	g e t N e g a t i v e E i g e n v a l u e s
- */
-int_t SparseSolver::getNegativeEigenvalues( )
-{
-	return -1;
-}
-
-/*
- *	g e t R a n k
- */
-int_t SparseSolver::getRank( )
-{
-	return -1;
-}
-
-/*
- *	g e t Z e r o P i v o t s
- */
-returnValue SparseSolver::getZeroPivots( int_t *&zeroPivots )
-{
-	if ( zeroPivots ) delete[] zeroPivots;
-	zeroPivots = 0;
-	return SUCCESSFUL_RETURN;
-}
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue SparseSolver::clear( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue SparseSolver::copy( 	const SparseSolver& rhs
-									)
-{
-	return SUCCESSFUL_RETURN;
-}
-
-#ifdef SOLVER_MA27
-
-/*****************************************************************************
- *****************************************************************************
- *****************************************************************************
- *  M A 2 7 S P A R E S E S O L V E R                                        *
- *****************************************************************************
- *****************************************************************************
- *****************************************************************************/
-
-#define MA27ID ma27id_
-#define MA27AD ma27ad_
-#define MA27BD ma27bd_
-#define MA27CD ma27cd_
-
-extern "C" {
-  void MA27ID(fint* ICNTL, double* CNTL);
-  void MA27AD(fint *N, fint *NZ, const fint *IRN, const fint* ICN,
-                               fint *IW, fint* LIW, fint* IKEEP, fint *IW1,
-                               fint* NSTEPS, fint* IFLAG, fint* ICNTL,
-                               double* CNTL, fint *INFO, double* OPS);
-  void MA27BD(fint *N, fint *NZ, const fint *IRN, const fint* ICN,
-                               double* A, fint* LA, fint* IW, fint* LIW,
-                               fint* IKEEP, fint* NSTEPS, fint* MAXFRT,
-                               fint* IW1, fint* ICNTL, double* CNTL,
-                               fint* INFO);
-  void MA27CD(fint *N, double* A, fint* LA, fint* IW,
-                               fint* LIW, double* W, fint* MAXFRT,
-                               double* RHS, fint* IW1, fint* NSTEPS,
-                               fint* ICNTL, double* CNTL);
-}
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- ****************************************************************************/
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-Ma27SparseSolver::Ma27SparseSolver( ) : SparseSolver()
-{
-	a_ma27 = 0;
-	irn_ma27 = 0;
-	jcn_ma27 = 0;
-	iw_ma27 = 0;
-	ikeep_ma27 = 0;
-	clear( );
-
-	/* Set default options for MA27 */
-	MA27ID(icntl_ma27, cntl_ma27);
-	icntl_ma27[0] = 0;       // Suppress error messages
-	icntl_ma27[1] = 0;       // Suppress diagnostic messages
-	cntl_ma27[0] = 1e-8;     // Set pivot tolerance
-}
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-Ma27SparseSolver::Ma27SparseSolver( const Ma27SparseSolver& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ S p a r s e S o l v e r B a s e
- */
-Ma27SparseSolver::~Ma27SparseSolver( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Ma27SparseSolver& Ma27SparseSolver::operator=( const SparseSolver& rhs )
-{
-	const Ma27SparseSolver* ma27_rhs = dynamic_cast<const Ma27SparseSolver*>(&rhs);
-	if (!ma27_rhs)
-	{
-		fprintf(getGlobalMessageHandler()->getOutputFile(),"Error in Ma27SparseSolver& Ma27SparseSolver::operator=( const SparseSolver& rhs )\n");
-		throw; // TODO: More elegant exit?
-	}
-	if ( this != ma27_rhs )
-	{
-		clear( );
-		SparseSolver::operator=( rhs );
-		copy( *ma27_rhs );
-	}
-
-	return *this;
-}
-
-/*
- *	s e t M a t r i x D a t a
- */
-returnValue Ma27SparseSolver::setMatrixData( int_t dim_,
-						   int_t numNonzeros_,
-						   const int_t* const irn,
-						   const int_t* const jcn,
-						   const real_t* const avals
-						   )
-{
-	reset( );
-	dim = dim_;
-	numNonzeros = numNonzeros_;
-
-	if ( numNonzeros_ > 0 )
-	{
-		a_ma27 = new double[numNonzeros_];
-		irn_ma27 = new fint[numNonzeros_];
-		jcn_ma27 = new fint[numNonzeros_];
-
-		numNonzeros=0;
-		for (int_t i=0; i<numNonzeros_; ++i)
-			if ( avals[i] != 0 )
-			{
-				a_ma27[numNonzeros] = avals[i];
-				irn_ma27[numNonzeros] = irn[i];
-				jcn_ma27[numNonzeros] = jcn[i];
-				numNonzeros++;
-			}
-	}
-	else
-	{
-		numNonzeros = 0;
-		a_ma27 = 0;
-		irn_ma27 = 0;
-		jcn_ma27 = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	f a c t o r i z e
- */
-returnValue Ma27SparseSolver::factorize( )
-{
-	if ( dim == 0 )
-	{
-		have_factorization = true;
-		neig = 0;
-		rank = 0;
-		return SUCCESSFUL_RETURN;
-	}
-
-	/******************************************
-	 * Call MA27AD for symbolic factorization *
-	******************************************/
-
-	// Overstimation factor for LIW (20% recommended in MA27 documentation)
-	const double LiwFact = 2.0;   // This is 200% overestimation
-	liw_ma27 = (fint)(LiwFact*(double(2*numNonzeros+3*dim+1)));
-	iw_ma27 = new fint[liw_ma27];
-
-	ikeep_ma27 = new fint[3*dim];
-
-	fint iflag_ma27 = 0;
-	double ops_ma27;
-	fint info_ma27[20];
-	fint* iw1_ma27 = new fint[2*dim];
-	MA27AD(&dim, &numNonzeros, irn_ma27, jcn_ma27, iw_ma27, &liw_ma27, ikeep_ma27,
-                            iw1_ma27, &nsteps_ma27, &iflag_ma27, icntl_ma27, cntl_ma27,
-                            info_ma27, &ops_ma27);
-
-	/* Receive some information from MA27AD */
-	fint iflag = info_ma27[0];   // Information flag
-	fint ierror = info_ma27[1];  // Error flag
-	fint nrlnec = info_ma27[4];  // recommended value for la
-	fint nirnec = info_ma27[5];  // recommended value for liw
-	if (iflag != 0)
-	{
-		MyPrintf("MA27AD returns iflag = %d with ierror = %d\n", iflag, ierror);
-		delete [] iw1_ma27;
-		clear( );
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-	}
-
-	/* Allocate memory for actual factorization */
-	delete [] iw_ma27;
-	double liw_init_factor = 5.0; // This could be an option.
-	liw_ma27 = (fint)(liw_init_factor * (double)(nirnec));
-	iw_ma27 = new fint[liw_ma27];
-
-	double la_init_factor = 20.0; // This could be an option.
-	la_ma27 = getMax(numNonzeros,(fint)(la_init_factor * (double)(nrlnec)));
-	double* a_new = new double[la_ma27];
-	for (int_t i=0; i<numNonzeros; ++i)
-		a_new[i] = a_ma27[i];
-	delete [] a_ma27;
-	a_ma27 = a_new;
-
-    /*******************************************
-	 * Call MA27BD for numerical factorization *
-     *******************************************/
-
-	MA27BD(&dim, &numNonzeros, irn_ma27, jcn_ma27, a_ma27,
-		   &la_ma27, iw_ma27, &liw_ma27, ikeep_ma27, &nsteps_ma27,
-		   &maxfrt_ma27, iw1_ma27, icntl_ma27, cntl_ma27, info_ma27);
-
-	delete [] iw1_ma27;
-	/* Receive some information from MA27BD */
-	iflag = info_ma27[0];   // Information flag
-	ierror = info_ma27[1];  // Error flag
-	neig = info_ma27[14];   // Number of negative eigenvalues
-	if (iflag == 3)
-	{
-		rank = info_ma27[1];
-		return RET_KKT_MATRIX_SINGULAR;
-	}
-	else if (iflag == -5)
-	{ //DJ: I think this is more severe. Can this actually happen?
-		rank = -1;
-		return RET_KKT_MATRIX_SINGULAR;
-	}
-	else if (iflag != 0)
-	{
-		MyPrintf("MA27BD returns iflag = %d with ierror = %d\n", iflag, ierror);
-		clear( );
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-	}
-	else
-		rank = dim;
-
-	have_factorization = true;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s o l v e
- */
-returnValue Ma27SparseSolver::solve( int_t dim_,
-					   const real_t* const rhs,
-					   real_t* const sol
-					   )
-{
-	/* consistency check */
-	if ( dim_ != dim )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( !have_factorization )
-	{
-	  MyPrintf("Factorization not called before solve in Ma27SparseSolver::solve.\n");
-	  return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( dim == 0 )
-		return SUCCESSFUL_RETURN;
-
-	/* Call MA27CD to solve the system */
-	double* w_ma27 = new double[maxfrt_ma27];
-	fint* iw1_ma27 = new fint[nsteps_ma27];
-
-	/* MA27CD overwrites rhs */
-	for (int_t i=0; i<dim; ++i) sol[i] = rhs[i];
-	MA27CD(&dim, a_ma27, &la_ma27, iw_ma27, &liw_ma27, w_ma27, &maxfrt_ma27,
-		   sol, iw1_ma27, &nsteps_ma27, icntl_ma27, cntl_ma27);
-
-	delete [] iw1_ma27;
-	delete [] w_ma27;
-
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	r e s e t
- */
-returnValue Ma27SparseSolver::reset( )
-{
-	/* AW: We probably want to avoid resetting factorization in QProblem */
-	if ( SparseSolver::reset( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_RESET_FAILED );
-
-	clear( );
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	g e t N e g a t i v e E i g e n v a l u e s
- */
-int_t Ma27SparseSolver::getNegativeEigenvalues( )
-{
-	if( !have_factorization )
-		return -1;
-	else
-		return neig;
-}
-
-/*
- *	g e t R a n k
- */
-int_t Ma27SparseSolver::getRank( )
-{
-	return rank;
-}
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Ma27SparseSolver::clear( )
-{
-	delete [] a_ma27;
-	delete [] irn_ma27;
-	delete [] jcn_ma27;
-	delete [] iw_ma27;
-	delete [] ikeep_ma27;
-
-	dim = -1;
-	numNonzeros = -1;
-	neig = -1;
-	rank = -1;
-	la_ma27 = -1;
-	a_ma27 = 0;
-	irn_ma27 = 0;
-	jcn_ma27 = 0;
-
-	liw_ma27 = -1;
-	iw_ma27 = 0;
-	ikeep_ma27 = 0;
-	nsteps_ma27 = -1;
-	maxfrt_ma27 = -1;
-
-	have_factorization = false;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Ma27SparseSolver::copy( 	const Ma27SparseSolver& rhs
-										)
-{
-	dim = rhs.dim;
-	numNonzeros = rhs.numNonzeros;
-	la_ma27 = rhs.la_ma27;
-	if ( rhs.a_ma27 != 0 )
-	{
-	  if (rhs.have_factorization)
-		{
-		  a_ma27 = new double[la_ma27];
-		  memcpy( a_ma27,rhs.a_ma27,la_ma27*sizeof(double) );
-		}
-	  else
-		{
-		  a_ma27 = new double[numNonzeros];
-		  memcpy( a_ma27,rhs.a_ma27,numNonzeros*sizeof(double) );
-		}
-	}
-	else
-		a_ma27 = 0;
-
-	if ( rhs.irn_ma27 != 0 )
-	{
-		irn_ma27 = new fint[numNonzeros];
-		memcpy( irn_ma27,rhs.irn_ma27,numNonzeros*sizeof(fint) );
-	}
-	else
-		irn_ma27 = 0;
-
-	if ( rhs.jcn_ma27 != 0 )
-	{
-		jcn_ma27 = new fint[numNonzeros];
-		memcpy( jcn_ma27,rhs.jcn_ma27,numNonzeros*sizeof(fint) );
-	}
-	else
-		jcn_ma27 = 0;
-
-	for ( int_t i=0; i<30; ++i)
-		icntl_ma27[i] = rhs.icntl_ma27[i];
-
-	for ( int_t i=0; i<5; ++i)
-		cntl_ma27[i] = rhs.cntl_ma27[i];
-
-	liw_ma27 = rhs.liw_ma27;
-
-	if ( rhs.iw_ma27 != 0 )
-	{
-		iw_ma27 = new fint[liw_ma27];
-		memcpy( iw_ma27,rhs.iw_ma27,liw_ma27*sizeof(fint) );
-	}
-	else
-		iw_ma27 = 0;
-
-	if ( rhs.ikeep_ma27 != 0 )
-	{
-		ikeep_ma27 = new fint[3*dim];
-		memcpy( ikeep_ma27,rhs.ikeep_ma27,3*dim*sizeof(fint) );
-	}
-	else
-		ikeep_ma27 = 0;
-
-	nsteps_ma27 = rhs.nsteps_ma27;
-	maxfrt_ma27 = rhs.maxfrt_ma27;
-
-	have_factorization = rhs.have_factorization;
-	neig = rhs.neig;
-	rank = rhs.rank;
-
-	return SUCCESSFUL_RETURN;
-}
-
-#endif // SOLVER_MA27
-
-#ifdef SOLVER_MA57
-
-/*****************************************************************************
- *****************************************************************************
- *****************************************************************************
- *  M A 5 7 S P A R E S E S O L V E R                                        *
- *****************************************************************************
- *****************************************************************************
- *****************************************************************************/
-
-#define MA57ID ma57id_
-#define MA57AD ma57ad_
-#define MA57BD ma57bd_
-#define MA57CD ma57cd_
-
-extern "C"
-{
-	/*
-	*  MA57ID -- Initialize solver.
-	*/
-	extern void  MA57ID (
-		double	*cntl,
-		fint		*icntl);
-
-	/*
-	*  MA57AD -- Symbolic Factorization.
-	*/
-	extern void  MA57AD (
-		fint		*n,		/* Order of matrix. */
-		fint		*ne,	/* Number of entries. */
-		const fint	*irn,	/* Matrix nonzero row structure */
-		const fint	*jcn,	/* Matrix nonzero column structure */
-		fint		*lkeep,	/* Workspace for the pivot order of lenght 3*n */
-		fint		*keep,	/* Workspace for the pivot order of lenght 3*n */
-							/* Automatically iflag = 0; ikeep pivot order iflag = 1 */
-		fint		*iwork,	/* Integer work space. */
-		fint		*icntl,	/* Integer Control parameter of length 30*/
-		fint		*info,	/* Statistical Information; Integer array of length 20 */
-		double		*rinfo);/* Double Control parameter of length 5 */
-
-	/*
-	* MA57BD -- Numerical Factorization.
-	*/
-	extern void  MA57BD (
-		fint	*n,			/* Order of matrix. */
-		fint	*ne,		/* Number of entries. */
-		double	*a,			/* Numerical values. */
-		double	*fact,		/* Entries of factors. */
-		fint	*lfact,		/* Length of array `fact'. */
-		fint	*ifact,		/* Indexing info for factors. */
-		fint	*lifact,	/* Length of array `ifact'. */
-		fint	*lkeep,		/* Length of array `keep'. */
-		fint	*keep,		/* Integer array. */
-		fint	*iwork,		/* Workspace of length `n'. */
-		fint	*icntl,		/* Integer Control parameter of length 20. */
-		double	*cntl,		/* Double Control parameter of length 5. */
-		fint	*info,		/* Statistical Information; Integer array of length 40. */
-		double	*rinfo);	/* Statistical Information; Real array of length 20. */
-
-	/*
-	* MA57CD -- Solution.
-	*/
-	extern void  MA57CD (
-		fint	*job,		/* Solution job.  Solve for... */
-							/* JOB <= 1:  A */
-							/* JOB == 2:  PLP^t */
-							/* JOB == 3:  PDP^t */
-							/* JOB >= 4:  PL^t P^t */
-		fint	*n,			/* Order of matrix. */
-		double	*fact,		/* Entries of factors. */
-		fint	*lfact,		/* Length of array `fact'. */
-		fint	*ifact,		/* Indexing info for factors. */
-		fint	*lifact,	/* Length of array `ifact'. */
-		fint	*nrhs,		/* Number of right hand sides. */
-		double	*rhs,		/* Numerical Values. */
-		fint	*lrhs,		/* Leading dimensions of `rhs'. */
-		double	*work,		/* Real workspace. */
-		fint	*lwork,		/* Length of `work', >= N*NRHS. */
-		fint	*iwork,		/* Integer array of length `n'. */
-		fint	*icntl,		/* Integer Control parameter array of length 20. */
-		fint	*info);		/* Statistical Information; Integer array of length 40. */
-}
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- ****************************************************************************/
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-Ma57SparseSolver::Ma57SparseSolver( ) : SparseSolver()
-{
-	a_ma57 = 0;
-	irn_ma57 = 0;
-	jcn_ma57 = 0;
-	fact_ma57 = 0;
-	ifact_ma57 = 0;
-	pivots = 0;
-	clear( );
-
-	/* Set default options for MA57 */
-	MA57ID( cntl_ma57, icntl_ma57 );
-
-	icntl_ma57[0] = -1;			// Suppress error messages
-	icntl_ma57[1] = -1;			// Suppress warning messages
-	icntl_ma57[2] = -1;			// Suppress monitoring messages
-	//icntl_ma57[4] = 4;		// Print everything (for debugging)
-	icntl_ma57[15] = 1;			// Place small pivots at the end of the factorization (default: 0)
-
-	/// \todo good default values?
-	//cntl_ma57[1] = 5.0e-16;	// Pivots smaller than this are treated as zero and are placed at the end of the factorization (default: 1e-20)
-	//cntl_ma57[0] = 0.5;		// Set pivot tolerance: Higher values = more stable but slower/less sparse (default: 0.01, max 0.5)
-}
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-Ma57SparseSolver::Ma57SparseSolver( const Ma57SparseSolver& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ S p a r s e S o l v e r B a s e
- */
-Ma57SparseSolver::~Ma57SparseSolver( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Ma57SparseSolver& Ma57SparseSolver::operator=( const SparseSolver& rhs )
-{
-	const Ma57SparseSolver* ma57_rhs = dynamic_cast<const Ma57SparseSolver*>(&rhs);
-	if (!ma57_rhs)
-	{
-		fprintf(getGlobalMessageHandler()->getOutputFile(),"Error in Ma57SparseSolver& Ma57SparseSolver::operator=( const SparseSolver& rhs )\n");
-		throw; // TODO: More elegant exit?
-	}
-	if ( this != ma57_rhs )
-	{
-		clear( );
-		SparseSolver::operator=( rhs );
-		copy( *ma57_rhs );
-	}
-
-	return *this;
-}
-
-/*
- *	s e t M a t r i x D a t a
- */
-returnValue Ma57SparseSolver::setMatrixData(	int_t dim_,
-												int_t numNonzeros_,
-												const int_t* const irn,
-												const int_t* const jcn,
-												const real_t* const avals
-												)
-{
-	reset( );
-	dim = dim_;
-	numNonzeros = numNonzeros_;
-
-	if ( numNonzeros_ > 0 )
-	{
-		a_ma57 = new double[numNonzeros_];
-		irn_ma57 = new fint[numNonzeros_];
-		jcn_ma57 = new fint[numNonzeros_];
-
-		numNonzeros=0;
-		for (int_t i=0; i<numNonzeros_; ++i)
-			if ( isZero(avals[i]) == BT_FALSE )
-			{
-				a_ma57[numNonzeros] = avals[i];
-				irn_ma57[numNonzeros] = irn[i];
-				jcn_ma57[numNonzeros] = jcn[i];
-				numNonzeros++;
-			}
-	}
-	else
-	{
-		numNonzeros = 0;
-		a_ma57 = 0;
-		irn_ma57 = 0;
-		jcn_ma57 = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	f a c t o r i z e
- */
-returnValue Ma57SparseSolver::factorize( )
-{
-	if ( dim == 0 )
-	{
-		have_factorization = true;
-		neig = 0;
-		rank = 0;
-		return SUCCESSFUL_RETURN;
-	}
-
-	/******************************************
-	 * Call MA57AD for symbolic factorization *
-	******************************************/
-
-	fint lkeep_ma57 = 5*dim + numNonzeros + getMax(numNonzeros,dim) + 42;
-	fint *keep_ma57 = new fint[lkeep_ma57];
-	fint *iwork_ma57 = new fint[5*dim];
-
-	fint info_ma57[40];
-	double rinfo_ma57[20];
-
-	MA57AD(&dim, &numNonzeros, irn_ma57, jcn_ma57, &lkeep_ma57, keep_ma57,
-			iwork_ma57, icntl_ma57, info_ma57, rinfo_ma57);
-
-	/* Receive some information from MA57AD */
-	fint iflag = info_ma57[0];   // Information flag
-	fint ierror = info_ma57[1];  // Error flag
-	if (iflag != 0)
-	{
-		MyPrintf("MA57AD returns iflag = %d with ierror = %d\n", iflag, ierror);
-		delete [] keep_ma57;
-		delete [] iwork_ma57;
-		clear( );
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-	}
-
-	/* Allocate memory for actual factorization */
-	double lfact_factor = 10.0; // This could be an option
-
-	lfact_ma57 = (fint)(lfact_factor * (double)(info_ma57[8]));
-	fact_ma57 = new double[lfact_ma57];
-
-	lifact_ma57 = (fint)(lfact_factor * (double)(info_ma57[9]));
-	ifact_ma57 = new int_t[lifact_ma57];
-
-    /*******************************************
-	 * Call MA57BD for numerical factorization *
-     *******************************************/
-
-	MA57BD(	&dim, &numNonzeros, a_ma57, fact_ma57, &lfact_ma57,
-			ifact_ma57, &lifact_ma57, &lkeep_ma57, keep_ma57,
-			iwork_ma57, icntl_ma57, cntl_ma57, info_ma57, rinfo_ma57 );
-
-	delete [] iwork_ma57;
-	delete [] keep_ma57;
-
-	/* Receive some information from MA57BD */
-	iflag = info_ma57[0];   // Information flag
-	ierror = info_ma57[1];  // Error flag
-	neig = info_ma57[23];   // Number of negative eigenvalues
-	rank = info_ma57[24];   // Rank of matrix
-
-	/* Read pivot sequence (see MA57UD source code) */
-	pivots = new fint[dim];
-	fint nrows, ncols;
-	fint nblk = ifact_ma57[2];
-	int_t iwpos = 3; // = 4-1
-    int_t k, kk, count = 0;
-    for ( k=0; k<nblk; k++ )
-    {
-        ncols = ifact_ma57[iwpos];
-        nrows = ifact_ma57[iwpos+1];
-
-        for ( kk=0; kk<nrows; kk++ )
-            pivots[count++] = ifact_ma57[iwpos+2+kk]-1; //convert Fortran to C indices!
-
-        iwpos = iwpos+ncols+2;
-    }
-
-	if (iflag == 4)
-	{
-		//MyPrintf("dim = %i, rank = %i. Pivots: ", dim, rank);
-		//for( k=rank; k<dim; k++ )
-			//MyPrintf("%i ", pivots[k]);
-		//MyPrintf("\n");
-
-		return RET_KKT_MATRIX_SINGULAR;
-	}
-	else if (iflag != 0)
-	{
-		MyPrintf("MA57BD returns iflag = %d with ierror = %d\n", iflag, ierror);
-		clear( );
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-	}
-
-	have_factorization = true;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s o l v e
- */
-returnValue Ma57SparseSolver::solve(	int_t dim_,
-										const real_t* const rhs,
-										real_t* const sol
-										)
-{
-	/* consistency check */
-	if ( dim_ != dim )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( !have_factorization )
-	{
-	  MyPrintf("Factorization not called before solve in Ma57SparseSolver::solve.\n");
-	  return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( dim == 0 )
-		return SUCCESSFUL_RETURN;
-
-	/* Call MA57CD to solve the system */
-	fint job_ma57 = 1;
-	fint nrhs_ma57 = 1;
-	fint lrhs_ma57 = dim;
-	fint info_ma57[40];
-
-	fint lwork_ma57 = dim*nrhs_ma57;
-	double* work_ma57 = new double[lwork_ma57];
-	fint* iwork_ma57 = new fint[dim];
-
-	/* MA57CD overwrites rhs */
-	for (int_t i=0; i<dim; ++i) sol[i] = rhs[i];
-	MA57CD(&job_ma57, &dim, fact_ma57, &lfact_ma57, ifact_ma57, &lifact_ma57,
-			&nrhs_ma57, sol, &lrhs_ma57, work_ma57, &lwork_ma57, iwork_ma57,
-			icntl_ma57, info_ma57);
-
-	delete [] work_ma57;
-	delete [] iwork_ma57;
-
-	fint iflag = info_ma57[0];   // Information flag
-	fint ierror = info_ma57[1];  // Error flag
-	if (iflag != 0)
-	{
-		MyPrintf("MA57CD returns iflag = %d with ierror = %d\n", iflag, ierror);
-		clear( );
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	r e s e t
- */
-returnValue Ma57SparseSolver::reset( )
-{
-	/* AW: We probably want to avoid resetting factorization in QProblem */
-	if ( SparseSolver::reset( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_RESET_FAILED );
-
-	clear( );
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	g e t N e g a t i v e E i g e n v a l u e s
- */
-int_t Ma57SparseSolver::getNegativeEigenvalues( )
-{
-	if( !have_factorization )
-		return -1;
-	else
-		return neig;
-}
-
-/*
- *	g e t R a n k
- */
-int_t Ma57SparseSolver::getRank( )
-{
-	return rank;
-}
-
-/*
- *	g e t Z e r o P i v o t s
- */
-returnValue Ma57SparseSolver::getZeroPivots( int_t *&zeroPivots )
-{
-	for ( int_t k=0; k<dim-rank; k++ )
-		zeroPivots[k] = pivots[rank+k];
-
-	return SUCCESSFUL_RETURN;
-}
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Ma57SparseSolver::clear( )
-{
-	delete [] a_ma57;
-	delete [] irn_ma57;
-	delete [] jcn_ma57;
-	delete [] fact_ma57;
-	delete [] ifact_ma57;
-	delete [] pivots;
-
-	dim = -1;
-	numNonzeros = -1;
-	neig = -1;
-	rank = -1;
-	pivots = 0;
-
-	a_ma57 = 0;
-	irn_ma57 = 0;
-	jcn_ma57 = 0;
-
-	fact_ma57 = 0;
-	lfact_ma57 = -1;
-	ifact_ma57 = 0;
-	lifact_ma57 = -1;
-
-	have_factorization = false;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Ma57SparseSolver::copy( 	const Ma57SparseSolver& rhs
-										)
-{
-	dim = rhs.dim;
-	numNonzeros = rhs.numNonzeros;
-	neig = rhs.neig;
-	rank = rhs.rank;
-	have_factorization = rhs.have_factorization;
-
-	if ( rhs.a_ma57 != 0 )
-	{
-		a_ma57 = new double[numNonzeros];
-		memcpy( a_ma57,rhs.a_ma57,numNonzeros*sizeof(double) );
-	}
-	else
-		a_ma57 = 0;
-
-	if ( rhs.irn_ma57 != 0 )
-	{
-		irn_ma57 = new fint[numNonzeros];
-		memcpy( irn_ma57,rhs.irn_ma57,numNonzeros*sizeof(fint) );
-	}
-	else
-		irn_ma57 = 0;
-
-	if ( rhs.jcn_ma57 != 0 )
-	{
-		jcn_ma57 = new fint[numNonzeros];
-		memcpy( jcn_ma57,rhs.jcn_ma57,numNonzeros*sizeof(fint) );
-	}
-	else
-		jcn_ma57 = 0;
-
-	for ( int_t i=0; i<30; ++i)
-		icntl_ma57[i] = rhs.icntl_ma57[i];
-
-	for ( int_t i=0; i<5; ++i)
-		cntl_ma57[i] = rhs.cntl_ma57[i];
-
-	lfact_ma57 = rhs.lfact_ma57;
-	if ( rhs.fact_ma57 != 0 )
-	{
-		fact_ma57 = new double[lfact_ma57];
-		memcpy( fact_ma57,rhs.fact_ma57,lfact_ma57*sizeof(double) );
-	}
-	else
-		fact_ma57 = 0;
-
-	lifact_ma57 = rhs.lifact_ma57;
-	if ( rhs.ifact_ma57 != 0 )
-	{
-		ifact_ma57 = new fint[lifact_ma57];
-		memcpy( ifact_ma57,rhs.ifact_ma57,lifact_ma57*sizeof(fint) );
-	}
-	else
-		ifact_ma57 = 0;
-
-	if ( have_factorization )
-	{
-		pivots = new fint[dim];
-		memcpy( pivots, rhs.pivots, dim*sizeof(fint) );
-	}
-	else
-		pivots = 0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-#endif // SOLVER_MA57
-
-
-#ifdef SOLVER_NONE
-
-returnValue DummySparseSolver::setMatrixData( 	int_t dim, /**< Dimension of the linear system. */
-												int_t numNonzeros, /**< Number of nonzeros in the matrix. */
-												const int_t* const airn, /**< Row indices for each matrix entry. */
-												const int_t* const acjn, /**< Column indices for each matrix entry. */
-												const real_t* const avals /**< Values for each matrix entry. */
-												)
-{
-	return THROWERROR(RET_NO_SPARSE_SOLVER);
-}
-
-returnValue DummySparseSolver::factorize( )
-{
-	return THROWERROR(RET_NO_SPARSE_SOLVER);
-}
-
-returnValue DummySparseSolver::solve(	int_t dim, /**< Dimension of the linear system. */
-										const real_t* const rhs, /**< Values for the right hand side. */
-										real_t* const sol /**< Solution of the linear system. */
-										)
-{
-	return THROWERROR(RET_NO_SPARSE_SOLVER);
-}
-
-#endif // SOLVER_NONE
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/SubjectTo.cpp b/extlibs/qpOASES-3.2.0/src/SubjectTo.cpp
deleted file mode 100644
index b41475f..0000000
--- a/extlibs/qpOASES-3.2.0/src/SubjectTo.cpp
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/SubjectTo.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the SubjectTo class designed to manage working sets of
- *	constraints and bounds within a QProblem.
- */
-
-
-#include <qpOASES/SubjectTo.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	S u b j e c t T o
- */
-SubjectTo::SubjectTo( )
-{
-	type   = 0;
-	status = 0;
-
-	init( );
-}
-
-
-/*
- *	S u b j e c t T o
- */
-SubjectTo::SubjectTo( int_t _n )
-{
-	type   = 0;
-	status = 0;
-
-	init( _n );
-}
-
-
-/*
- *	S u b j e c t T o
- */
-SubjectTo::SubjectTo( const SubjectTo& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ S u b j e c t T o
- */
-SubjectTo::~SubjectTo( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-SubjectTo& SubjectTo::operator=( const SubjectTo& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-/*
- *	i n i t
- */
-returnValue SubjectTo::init(	int_t _n
-								)
-{
-	int_t i;
-
-	if ( _n < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	clear( );
-
-	n = _n;
-	noLower = BT_TRUE;
-	noUpper = BT_TRUE;
-
-	if ( n > 0 )
-	{
-		type   = new SubjectToType[n];
-		status = new SubjectToStatus[n];
-
-		for( i=0; i<n; ++i )
-		{
-			type[i]   = ST_UNKNOWN;
-			status[i] = ST_UNDEFINED;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue SubjectTo::clear( )
-{
-	if ( type != 0 )
-	{
-		delete[] type;
-		type = 0;
-	}
-
-	if ( status != 0 )
-	{
-		delete[] status;
-		status = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue SubjectTo::copy(	const SubjectTo& rhs
-								)
-{
-	int_t i;
-
-	n = rhs.n;
-	noLower = rhs.noLower;
-	noUpper = rhs.noUpper;
-
-	if ( rhs.n != 0 )
-	{
-		type   = new SubjectToType[n];
-		status = new SubjectToStatus[n];
-
-		for( i=0; i<n; ++i )
-		{
-			type[i]   = rhs.type[i];
-			status[i] = rhs.status[i];
-		}
-	}
-	else
-	{
-		type   = 0;
-		status = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a d d I n d e x
- */
-returnValue SubjectTo::addIndex(	Indexlist* const indexlist,
-									int_t newnumber, SubjectToStatus newstatus
-									)
-{
-	if ( status != 0 )
-	{
-		/* consistency check */
-		if ( status[newnumber] == newstatus )
-			return THROWERROR( RET_INDEX_ALREADY_OF_DESIRED_STATUS );
-
-		status[newnumber] = newstatus;
-	}
-	else
-		return THROWERROR( RET_ADDINDEX_FAILED );
-
-	if ( indexlist != 0 )
-	{
-		if ( indexlist->addNumber( newnumber ) == RET_INDEXLIST_EXCEEDS_MAX_LENGTH )
-			return THROWERROR( RET_ADDINDEX_FAILED );
-	}
-	else
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e I n d e x
- */
-returnValue SubjectTo::removeIndex(	Indexlist* const indexlist,
-									int_t removenumber
-									)
-{
-	if ( status != 0 )
-		status[removenumber] = ST_UNDEFINED;
-	else
-		return THROWERROR( RET_REMOVEINDEX_FAILED );
-
-	if ( indexlist != 0 )
-	{
-		if ( indexlist->removeNumber( removenumber ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_REMOVEINDEX_FAILED );
-	}
-	else
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s w a p I n d e x
- */
-returnValue SubjectTo::swapIndex(	Indexlist* const indexlist,
-									int_t number1, int_t number2
-									)
-{
-	/* consistency checks */
-	if ( status != 0 )
-	{
-		if ( status[number1] != status[number2] )
-			return THROWERROR( RET_SWAPINDEX_FAILED );
-	}
-	else
-		return THROWERROR( RET_SWAPINDEX_FAILED );
-
-	if ( number1 == number2 )
-	{
-		THROWWARNING( RET_NOTHING_TO_DO );
-		return SUCCESSFUL_RETURN;
-	}
-
-	if ( indexlist != 0 )
-	{
-		if ( indexlist->swapNumbers( number1,number2 ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SWAPINDEX_FAILED );
-	}
-	else
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/Utils.cpp b/extlibs/qpOASES-3.2.0/src/Utils.cpp
deleted file mode 100644
index 68fb0d9..0000000
--- a/extlibs/qpOASES-3.2.0/src/Utils.cpp
+++ /dev/null
@@ -1,1061 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Utils.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches (thanks to Eckhard Arnold)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of some utility functions for working with qpOASES.
- */
-
-
-#include <math.h>
-
-#if defined(__WIN32__) || defined(WIN32)
-  #include <windows.h>
-#elif defined(LINUX) || defined(__LINUX__)
-  #include <sys/stat.h>
-  #include <sys/time.h>
-#endif
-
-#ifdef __MATLAB__
-  #include "mex.h"
-#endif
-
-#ifdef __SCILAB__
-  #include <scilab/sciprint.h>
-#endif
-
-
-#include <qpOASES/Utils.hpp>
-
-
-#ifdef __NO_SNPRINTF__
-#if (!defined(_MSC_VER)) || defined(__DSPACE__) || defined(__XPCTARGET__)
-/* If snprintf is not available, provide an empty implementation. */
-int snprintf( char* s, size_t n, const char* format, ... )
-{
-	if ( n > 0 )
-		s[0] = '\0';
-
-	return 0;
-}
-#endif
-#endif /* __NO_SNPRINTF__ */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*
- *	p r i n t
- */
-returnValue print( const real_t* const v, int_t n, const char* name )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Print vector name. */
-	if ( name != 0 )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH,"%s = \n", name );
-		myPrintf( myPrintfString );
-	}
-
-	/* Print vector data. */
-	for( i=0; i<n; ++i )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH," %.16e\t", v[i] );
-		myPrintf( myPrintfString );
-	}
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue print(	const real_t* const v, int_t n, const int_t* const V_idx, const char* name )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Print vector name. */
-	if ( name != 0 )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH,"%s = \n", name );
-		myPrintf( myPrintfString );
-	}
-
-	/* Print a permuted vector data. */
-	for( i=0; i<n; ++i )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH," %.16e\t", v[ V_idx[i] ] );
-		myPrintf( myPrintfString );
-	}
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue print( const real_t* const M, int_t nrow, int_t ncol, const char* name )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Print matrix name. */
-	if ( name != 0 )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH,"%s = \n", name );
-		myPrintf( myPrintfString );
-	}
-
-	/* Print a matrix data as a collection of row vectors. */
-	for( i=0; i<nrow; ++i )
-		print( &(M[i*ncol]), ncol );
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue print(	const real_t* const M, int_t nrow, int_t ncol, const int_t* const ROW_idx, const int_t* const COL_idx, const char* name )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Print matrix name. */
-	if ( name != 0 )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH,"%s = \n", name );
-		myPrintf( myPrintfString );
-	}
-
-	/* Print a permuted matrix data as a collection of permuted row vectors. */
-	for( i=0; i<nrow; ++i )
-		print( &( M[ ROW_idx[i]*ncol ] ), ncol, COL_idx );
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue print( const int_t* const index, int_t n, const char* name )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Print indexlist name. */
-	if ( name != 0 )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH,"%s = \n", name );
-		myPrintf( myPrintfString );
-	}
-
-	/* Print a indexlist data. */
-	for( i=0; i<n; ++i )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH," %d\t", (int)(index[i]) );
-		myPrintf( myPrintfString );
-	}
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	m y P r i n t f
- */
-returnValue myPrintf( const char* s )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-
-		if ( s == 0 )
-			return RET_INVALID_ARGUMENTS;
-
-		#ifdef __MATLAB__
-			mexPrintf( s );
-		#else
-			#ifdef __SCILAB__
-				sciprint( s );
-			#else
-				FILE* outputfile = getGlobalMessageHandler( )->getOutputFile( );
-				if ( outputfile == 0 )
-					return THROWERROR( RET_NO_GLOBAL_MESSAGE_OUTPUTFILE );
-				fprintf( outputfile, "%s", s );
-			#endif /* __SCILAB__ */
-		#endif /* __MATLAB__ */
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t C o p y r i g h t N o t i c e
- */
-returnValue printCopyrightNotice( )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-		#ifndef __XPCTARGET__
-		#ifndef __DSPACE__
-		#ifndef __NO_COPYRIGHT__
-		myPrintf( "\nqpOASES -- An Implementation of the Online Active Set Strategy.\nCopyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,\nChristian Kirches et al. All rights reserved.\n\nqpOASES is distributed under the terms of the \nGNU Lesser General Public License 2.1 in the hope that it will be \nuseful, but WITHOUT ANY WARRANTY; without even the implied warranty \nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. \nSee the GNU Lesser General Public License for more details.\n\n" );
-		#endif /* __NO_COPYRIGHT__ */
-		#endif /* __DSPACE__ */
-		#endif /* __XPCTARGET__ */
-	#endif /* __SUPPRESSANYOUTPUT__ */
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e a d F r o m F i l e
- */
-returnValue readFromFile(	real_t* data, int_t nrow, int_t ncol,
-							const char* datafilename
-							)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i, j;
-	real_t float_data;
-	FILE* datafile;
-
-	/* 1) Open file. */
-	if ( ( datafile = fopen( datafilename, "r" ) ) == 0 )
-	{
-		char errstr[MAX_STRING_LENGTH];
-		snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-		return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-	}
-
-	/* 2) Read data from file. */
-	for( i=0; i<nrow; ++i )
-	{
-		for( j=0; j<ncol; ++j )
-		{
-			#ifdef __USE_SINGLE_PRECISION__
-			if ( fscanf( datafile, "%f ", &float_data ) == 0 )
-			#else
-			if ( fscanf( datafile, "%lf ", &float_data ) == 0 )
-			#endif /* __USE_SINGLE_PRECISION__ */
-			{
-				fclose( datafile );
-				char errstr[MAX_STRING_LENGTH];
-				snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-				return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_READ_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			}
-			data[i*ncol + j] = ( (real_t) float_data );
-		}
-	}
-
-	/* 3) Close file. */
-	fclose( datafile );
-
-	return SUCCESSFUL_RETURN;
-
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	r e a d F r o m F i l e
- */
-returnValue readFromFile(	real_t* data, int_t n,
-							const char* datafilename
-							)
-{
-	return readFromFile( data, n, 1, datafilename );
-}
-
-
-
-/*
- *	r e a d F r o m F i l e
- */
-returnValue readFromFile(	int_t* data, int_t n,
-							const char* datafilename
-							)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	FILE* datafile;
-
-	/* 1) Open file. */
-	if ( ( datafile = fopen( datafilename, "r" ) ) == 0 )
-	{
-		char errstr[MAX_STRING_LENGTH];
-		snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-		return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-	}
-
-	/* 2) Read data from file. */
-	for( i=0; i<n; ++i )
-	{
-		#ifdef __USE_LONG_INTEGERS__
-		if ( fscanf( datafile, "%ld\n", &(data[i]) ) == 0 )
-		#else
-		if ( fscanf( datafile, "%d\n", &(data[i]) ) == 0 )
-		#endif
-		{
-			fclose( datafile );
-			char errstr[MAX_STRING_LENGTH];
-			snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-			return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_READ_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		}
-	}
-
-	/* 3) Close file. */
-	fclose( datafile );
-
-	return SUCCESSFUL_RETURN;
-
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	w r i t e I n t o F i l e
- */
-returnValue writeIntoFile(	const real_t* const data, int_t nrow, int_t ncol,
-							const char* datafilename, BooleanType append
-							)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i, j;
-	FILE* datafile;
-
-	/* 1) Open file. */
-	if ( append == BT_TRUE )
-	{
-		/* append data */
-		if ( ( datafile = fopen( datafilename, "a" ) ) == 0 )
-		{
-			char errstr[MAX_STRING_LENGTH];
-			snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-			return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		}
-	}
-	else
-	{
-		/* do not append data */
-		if ( ( datafile = fopen( datafilename, "w" ) ) == 0 )
-		{
-			char errstr[MAX_STRING_LENGTH];
-			snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-			return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		}
-	}
-
-	/* 2) Write data into file. */
-	for( i=0; i<nrow; ++i )
-	{
-		for( j=0; j<ncol; ++j )
-		 	fprintf( datafile, "%.16e ", data[i*ncol+j] );
-
-		fprintf( datafile, "\n" );
-	}
-
-	/* 3) Close file. */
-	fclose( datafile );
-
-	return SUCCESSFUL_RETURN;
-
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	w r i t e I n t o F i l e
- */
-returnValue writeIntoFile(	const real_t* const data, int_t n,
-							const char* datafilename, BooleanType append
-							)
-{
-	return writeIntoFile( data,1,n,datafilename,append );
-}
-
-
-/*
- *	w r i t e I n t o F i l e
- */
-returnValue writeIntoFile(	const int_t* const integer, int_t n,
-							const char* datafilename, BooleanType append
-							)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-
-	FILE* datafile;
-
-	/* 1) Open file. */
-	if ( append == BT_TRUE )
-	{
-		/* append data */
-		if ( ( datafile = fopen( datafilename, "a" ) ) == 0 )
-		{
-			char errstr[MAX_STRING_LENGTH];
-			snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-			return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		}
-	}
-	else
-	{
-		/* do not append data */
-		if ( ( datafile = fopen( datafilename, "w" ) ) == 0 )
-		{
-			char errstr[MAX_STRING_LENGTH];
-			snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-			return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		}
-	}
-
-	/* 2) Write data into file. */
-	for( i=0; i<n; ++i )
-		fprintf( datafile, "%d\n",(int)(integer[i]) );
-
-	/* 3) Close file. */
-	fclose( datafile );
-
-	return SUCCESSFUL_RETURN;
-
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	w r i t e I n t o M a t F i l e
- */
-returnValue writeIntoMatFile(	FILE* const matFile,
-								const real_t* const data, int_t nRows, int_t nCols, const char* name
-								)
-{
-	/*  Note, this code snippet has been inspired from the document
-	 *  "Matlab(R) MAT-file Format, R2013b" by MathWorks */
-
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	if ( ( matFile == 0 ) || ( data == 0 ) || ( nRows < 0 ) || ( nCols < 0 ) || ( name == 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	MatMatrixHeader var;
-
-	// setup variable header
-	var.numericFormat = 0000;  /* IEEE Little Endian - reserved - double precision (64 bits) - numeric full matrix */
-	var.nRows         = nRows; /* number of rows */
-	var.nCols         = nCols; /* number of columns */
-	var.imaginaryPart = 0;     /* no imaginary part */
-	var.nCharName     = (long)(strlen(name))+1; /* matrix name length */
-
-	/* write variable header to mat file */
-	if ( fwrite( &var, sizeof(MatMatrixHeader),1,  matFile ) < 1 )
-		return RET_UNABLE_TO_WRITE_FILE;
-
-	if ( fwrite( name, sizeof(char),(unsigned long)(var.nCharName), matFile ) < 1 )
-		return RET_UNABLE_TO_WRITE_FILE;
-
-	int_t ii, jj;
-	double curData;
-
-	for ( ii=0; ii<nCols; ++ii )
-		for ( jj=0; jj<nRows; ++jj )
-		{
-			curData = (real_t)data[jj*nCols+ii];
-			if ( fwrite( &curData, sizeof(double),1, matFile ) < 1 )
-				return RET_UNABLE_TO_WRITE_FILE;
-		}
-
-	return SUCCESSFUL_RETURN;
-
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	w r i t e I n t o M a t F i l e
- */
-returnValue writeIntoMatFile(	FILE* const matFile,
-								const int_t* const data, int_t nRows, int_t nCols, const char* name
-								)
-{
-	real_t* realData = new real_t[nRows*nCols];
-
-	int_t ii, jj;
-
-	for ( ii=0; ii<nRows; ++ii )
-		for ( jj=0; jj<nCols; ++jj )
-			realData[ ii*nCols+jj ] = (real_t) data[ ii*nCols+jj ];
-
-	returnValue returnvalue = writeIntoMatFile( matFile,realData,nRows,nCols,name );
-	delete[] realData;
-
-	return returnvalue;
-}
-
-
-/*
- *	g e t C P U t i m e
- */
-real_t getCPUtime( )
-{
-	real_t current_time = -1.0;
-
-	#if defined(__WIN32__) || defined(WIN32)
-	LARGE_INTEGER counter, frequency;
-	QueryPerformanceFrequency(&frequency);
-	QueryPerformanceCounter(&counter);
-	current_time = ((real_t) counter.QuadPart) / ((real_t) frequency.QuadPart);
-	#elif defined(LINUX) || defined(__LINUX__)
-	struct timeval theclock;
-	gettimeofday( &theclock,0 );
-	current_time =  1.0*(real_t) theclock.tv_sec + 1.0e-6* (real_t) theclock.tv_usec;
-	#endif
-
-	return current_time;
-}
-
-
-/*
- *	g e t N o r m
- */
-real_t getNorm( const real_t* const v, int_t n, int_t type )
-{
-	int_t i;
-
-	real_t norm = 0.0;
-
-	switch ( type )
-	{
-		case 2:
-			for( i=0; i<n; ++i )
-				norm += v[i]*v[i];
-			return getSqrt( norm );
-
-		case 1:
-			for( i=0; i<n; ++i )
-				norm += getAbs( v[i] );
-			return norm;
-
-		default:
-			THROWERROR( RET_INVALID_ARGUMENTS );
-			return -INFTY;
-	}
-}
-
-
-/*
- *	g e t K k t V i o l a t i o n
- */
-returnValue getKktViolation(	int_t nV, int_t nC,
-								const real_t* const H, const real_t* const g, const real_t* const A,
-								const real_t* const lb, const real_t* const ub, const real_t* const lbA, const real_t* const ubA,
-								const real_t* const x, const real_t* const y,
-								real_t& stat, real_t& feas, real_t& cmpl,
-								const real_t* const workingSetB, const real_t* const workingSetC, BooleanType hasIdentityHessian
-								)
-{
-	/* Tolerance for dual variables considered zero. */
-	const real_t dualActiveTolerance = 1.0e3 * EPS;
-
-	int_t i, j;
-	real_t sum, prod;
-
-	/* Initialize residuals */
-	stat = feas = cmpl = 0.0;
-
-	/* check stationarity */
-	for (i = 0; i < nV; i++)
-	{
-		/* g term and variable bounds dual term */
-		if ( g != 0 )
-			sum = g[i] - y[i];
-		else
-			sum = 0.0 - y[i];
-
-		/* H*x term */
-		if ( H != 0 )
-			for (j = 0; j < nV; j++) sum += H[i*nV+j] * x[j];
-		else
-		{
-			if ( hasIdentityHessian == BT_TRUE )
-				for (j = 0; j < nV; j++) sum += x[j];
-		}
-
-		/* A'*y term */
-		if ( A != 0 )
-			for (j = 0; j < nC; j++) sum -= A[j*nV+i] * y[nV+j];
-
-		/* update stat */
-		if (getAbs(sum) > stat) stat = getAbs(sum);
-	}
-
-	/* check primal feasibility and complementarity of bounds */
-	/* feasibility */
-	for (i = 0; i < nV; i++)
-	{
-		if ( lb != 0 )
-			if (lb[i] - x[i] > feas)
-				feas = lb[i] - x[i];
-
-		if ( ub != 0 )
-			if (x[i] - ub[i] > feas)
-				feas = x[i] - ub[i];
-	}
-
-	/* complementarity */
-	if ( workingSetB == 0 )
-	{
-		for (i = 0; i < nV; i++)
-		{
-			prod = 0.0;
-
-			/* lower bound */
-			if ( lb != 0 )
-				if (y[i] > dualActiveTolerance)
-					prod = (x[i] - lb[i]) * y[i];
-
-			/* upper bound */
-			if ( ub != 0 )
-				if (y[i] < -dualActiveTolerance)
-					prod = (x[i] - ub[i]) * y[i];
-
-			if (getAbs(prod) > cmpl) cmpl = getAbs(prod);
-		}
-	}
-	else
-	{
-		for (i = 0; i < nV; i++)
-		{
-			prod = 0.0;
-
-			/* lower bound */
-			if ( lb != 0 )
-			{
-				if ( isEqual(workingSetB[i],-1.0) == BT_TRUE )
-					prod = (x[i] - lb[i]) * y[i];
-			}
-
-			/* upper bound */
-			if ( ub != 0 )
-			{
-				if ( isEqual(workingSetB[i],1.0) == BT_TRUE )
-					prod = (x[i] - ub[i]) * y[i];
-			}
-
-			if (getAbs(prod) > cmpl) cmpl = getAbs(prod);
-		}
-	}
-
-	/* check primal feasibility and complementarity of constraints */
-	for (i = 0; i < nC; i++)
-	{
-		/* compute sum = (A*x)_i */
-		sum = 0.0;
-		if ( A != 0 )
-			for (j = 0; j < nV; j++)
-				sum += A[i*nV+j] * x[j];
-
-		/* feasibility */
-		if ( lbA != 0 )
-			if (lbA[i] - sum > feas)
-				feas = lbA[i] - sum;
-
-		if ( ubA != 0 )
-			if (sum - ubA[i] > feas)
-				feas = sum - ubA[i];
-
-		/* complementarity */
-		prod = 0.0;
-
-		/* lower bound */
-		if ( lbA != 0 )
-		{
-			if ( workingSetC == 0 )
-			{
-				if (y[nV+i] > dualActiveTolerance)
-					prod = (sum - lbA[i]) * y[nV+i];
-			}
-			else
-			{
-				if ( isEqual(workingSetC[i],-1.0) == BT_TRUE )
-					prod = (sum - lbA[i]) * y[nV+i];
-			}
-		}
-
-		/* upper bound */
-		if ( ubA != 0 )
-		{
-			if ( workingSetC == 0 )
-			{
-				if (y[nV+i] < -dualActiveTolerance)
-					prod = (sum - ubA[i]) * y[nV+i];
-			}
-			else
-			{
-				if ( isEqual(workingSetC[i],1.0) == BT_TRUE )
-					prod = (sum - ubA[i]) * y[nV+i];
-			}
-		}
-
-		if (getAbs(prod) > cmpl) cmpl = getAbs(prod);
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t K k t V i o l a t i o n
- */
-returnValue getKktViolation(	int_t nV,
-								const real_t* const H, const real_t* const g,
-								const real_t* const lb, const real_t* const ub,
-								const real_t* const x, const real_t* const y,
-								real_t& stat, real_t& feas, real_t& cmpl,
-								const real_t* const workingSetB, BooleanType hasIdentityHessian
-								)
-{
-	return getKktViolation(	nV,0,
-							H,g,0,lb,ub,0,0,
-							x,y,
-							stat,feas,cmpl,
-							workingSetB,0,hasIdentityHessian
-							);
-}
-
-
-/*
- *	c o n v e r t B o o l e a n T y p e T o S t r i n g
- */
-returnValue convertBooleanTypeToString( BooleanType value, char* const string )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	if ( value == BT_FALSE )
-		snprintf( string,20,"BT_FALSE" );
-	else
-		snprintf( string,20,"BT_TRUE" );
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o n v e r t S u b j e c t T o S t a t u s T o S t r i n g
- */
-returnValue convertSubjectToStatusToString( SubjectToStatus value, char* const string )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	switch( value )
-	{
-		case ST_INACTIVE:
-			snprintf( string,20,"ST_INACTIVE" );
-			break;
-
-		case ST_LOWER:
-			snprintf( string,20,"ST_LOWER" );
-			break;
-
-		case ST_UPPER:
-			snprintf( string,20,"ST_UPPER" );
-			break;
-
-		case ST_UNDEFINED:
-			snprintf( string,20,"ST_UNDEFINED" );
-			break;
-
-		case ST_INFEASIBLE_LOWER:
-			snprintf( string,20,"ST_INFEASIBLE_LOWER" );
-			break;
-
-		case ST_INFEASIBLE_UPPER:
-			snprintf( string,20,"ST_INFEASIBLE_UPPER" );
-			break;
-
-		default:
-			snprintf( string,20,"<invalid value>" );
-			break;
-	}
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o n v e r t P r i n t L e v e l T o S t r i n g
- */
-returnValue convertPrintLevelToString( PrintLevel value, char* const string )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	switch( value )
-	{
-		case PL_NONE:
-			snprintf( string,20,"PL_NONE" );
-			break;
-
-		case PL_LOW:
-			snprintf( string,20,"PL_LOW" );
-			break;
-
-		case PL_MEDIUM:
-			snprintf( string,20,"PL_MEDIUM" );
-			break;
-
-		case PL_HIGH:
-			snprintf( string,20,"PL_HIGH" );
-			break;
-
-		case PL_TABULAR:
-			snprintf( string,20,"PL_TABULAR" );
-			break;
-
-		case PL_DEBUG_ITER:
-			snprintf( string,20,"PL_DEBUG_ITER" );
-			break;
-
-		default:
-			snprintf( string,20,"<invalid value>" );
-			break;
-	}
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t S i m p l e S t a t u s
- */
-int_t getSimpleStatus(	returnValue returnvalue,
-						BooleanType doPrintStatus
-						)
-{
-	int_t simpleStatus = -1;
-
-	/* determine simple status from returnvalue */
-	switch ( returnvalue )
-	{
-		case SUCCESSFUL_RETURN:
-			simpleStatus = 0;
-			break;
-
-		case RET_MAX_NWSR_REACHED:
-			simpleStatus = 1;
-			break;
-
-		case RET_INIT_FAILED_INFEASIBILITY:
-		case RET_HOTSTART_STOPPED_INFEASIBILITY:
-			simpleStatus = -2;
-			break;
-
-		case RET_INIT_FAILED_UNBOUNDEDNESS:
-		case RET_HOTSTART_STOPPED_UNBOUNDEDNESS:
-			simpleStatus = -3;
-			break;
-
-		default:
-			simpleStatus = -1;
-			break;
-	}
-
-	if ( doPrintStatus == BT_TRUE )
-	{
-		VisibilityStatus vsInfo = getGlobalMessageHandler( )->getInfoVisibilityStatus( );
-		getGlobalMessageHandler( )->setInfoVisibilityStatus( VS_VISIBLE );
-		getGlobalMessageHandler( )->setErrorCount( -1 );
-
-		int_t retValNumber = (int_t)RET_SIMPLE_STATUS_P0 - simpleStatus;
-		THROWINFO( (returnValue)retValNumber );
-
-		getGlobalMessageHandler( )->setInfoVisibilityStatus( vsInfo );
-	}
-
-	return simpleStatus;
-}
-
-
-/*
- *	n o r m a l i s e C o n s t r a i n t s
- */
-returnValue normaliseConstraints(	int_t nV, int_t nC,
-									real_t* A, real_t* lbA, real_t* ubA,
-									int_t type
-									)
-{
-	int_t ii, jj;
-	real_t curNorm;
-
-	if ( ( nV <= 0 ) || ( nC <= 0 ) || ( A == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	for( ii=0; ii<nC; ++ii )
-	{
-		/* get row norm */
-		curNorm = getNorm( &(A[ii*nV]),nV,type );
-
-		if ( curNorm > EPS )
-		{
-			/* normalise if norm is positive */
-			for( jj=0; jj<nV; ++jj )
-				A[ii*nV + jj] /= curNorm;
-
-			if ( lbA != 0 ) lbA[ii] /= curNorm;
-			if ( ubA != 0 ) ubA[ii] /= curNorm;
-		}
-		else
-		{
-			/* if row norm is (close to) zero, kind of erase constraint */
-			if ( type == 1 )
-			{
-				for( jj=0; jj<nV; ++jj )
-					A[ii*nV + jj] = 1.0 / ((real_t)nV);
-			}
-			else
-			{
-				/* assume type == 2 */
-				for( jj=0; jj<nV; ++jj )
-					A[ii*nV + jj] = 1.0 / getSqrt((real_t)nV);
-			}
-
-			if ( lbA != 0 ) lbA[ii] = -INFTY;
-			if ( ubA != 0 ) ubA[ii] =  INFTY;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-#ifdef __DEBUG__
-/*
- *	g d b _ p r i n t m at
- */
-extern "C" void gdb_printmat(const char *fname, real_t *M, int_t n, int_t m, int_t ldim)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i, j;
-	FILE *fid;
-
-	fid = fopen(fname, "wt");
-	if (!fid)
-	{
-		perror("Error opening file: ");
-		return;
-	}
-
-	for (i = 0; i < n; i++)
-	{
-		for (j = 0; j < m; j++)
-			fprintf(fid, " %23.16e", M[j*ldim+i]);
-		fprintf(fid, "\n");
-	}
-	fclose(fid);
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-#endif /* __DEBUG__ */
-
-
-
-#if defined(__DSPACE__) || defined(__XPCTARGET__) || defined(__C_WRAPPER__)
-/*
- *	_ _ c x a _ p u r e _ v i r t u a l
- */
-void __cxa_pure_virtual( void )
-{
-	/* put your customized implementation here! */
-}
-#endif /* __DSPACE__ || __XPCTARGET__ || __C_WRAPPER__ */
-
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/c/Makefile b/extlibs/qpOASES-3.2.0/testing/c/Makefile
deleted file mode 100644
index 54ca481..0000000
--- a/extlibs/qpOASES-3.2.0/testing/c/Makefile
+++ /dev/null
@@ -1,78 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/c/Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014-2015
-##
-
-
-
-include ../../make.mk
-
-##
-##	flags
-##
-
-IFLAGS      =  -I. \
-               -I${IDIR} \
-			   -I${TOP}/interfaces/c
-
-QPOASES_TEST_EXES = \
-	${BINDIR}/test_c_example1${EXE} \
-	${BINDIR}/test_c_example1a${EXE} \
-	${BINDIR}/test_c_example1b${EXE}
-
-
-##
-##	targets
-##
-
-all: ${QPOASES_TEST_EXES}
-
-${BINDIR}/%${EXE}: %.${OBJEXT} ${LINK_DEPENDS_WRAPPER}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK_WRAPPER} ${LINK_LIBRARIES_WRAPPER}
-
-
-clean:
-	@${ECHO} "Cleaning up (testing/cpp)"
-	@${RM} -f *.${OBJEXT} ${QPOASES_TEST_EXES}
-
-clobber: clean
-
-
-${LINK_DEPENDS_WRAPPER}:
-	@cd ../..; ${MAKE} -s c_wrapper
-
-%.${OBJEXT}: %.c
-	@${ECHO} "Creating" $@
-	@${CC} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1.c b/extlibs/qpOASES-3.2.0/testing/c/test_c_example1.c
deleted file mode 100644
index 801418e..0000000
--- a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1.c
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/c/test_c_example1.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using QProblem class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-	int_t nWSR;
-	qpOASES_Options options;
-	
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	real_t obj;
-	int_t status;
-
-	qpOASES_Options_init( &options,0 );
-	options.printLevel = PL_MEDIUM;
-
-
-	QProblem_setup(	2,1,HST_UNKNOWN );
-
-	/* Solve first QP. */
-	nWSR = 10;
-	QProblem_init(	H,g,A,lb,ub,lbA,ubA,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	QProblem_hotstart(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-	
-	QProblem_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1a.c b/extlibs/qpOASES-3.2.0/testing/c/test_c_example1a.c
deleted file mode 100644
index afe78ba..0000000
--- a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1a.c
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/c/test_c_example1a.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using SQProblem class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-	int_t nWSR;
-
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	real_t obj;
-	int_t status;
-
-	qpOASES_Options options;
-	qpOASES_Options_init( &options,0 );
-
-	
-	SQProblem_setup( 2,1,HST_UNKNOWN );
-	
-	/* Solve first QP. */
-	nWSR = 10;
-	SQProblem_init(	H,g,A,lb,ub,lbA,ubA,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	SQProblem_hotstart(	H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-	
-	SQProblem_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1b.c b/extlibs/qpOASES-3.2.0/testing/c/test_c_example1b.c
deleted file mode 100644
index b57fefc..0000000
--- a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1b.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/c/test_example1b.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using QProblemB class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-
-	int_t nWSR;
-	qpOASES_Options options;
-
-	real_t xOpt[2];
-	real_t yOpt[2];
-	real_t obj;
-	int_t status;
-
-	qpOASES_Options_init( &options,0 );
-	/*options.enableFlippingBounds = 0; */
-	options.initialStatusBounds = ST_INACTIVE;
-	options.numRefinementSteps = 1;
-	options.enableCholeskyRefactorisation = 1;
-
-
-	QProblemB_setup( 2,HST_UNKNOWN );
-
-	/* Solve first QP. */
-	nWSR = 10;
-	QProblemB_init(	H,g,lb,ub,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	QProblemB_hotstart(	g_new,lb_new,ub_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1], obj );
-
-	
-	QProblemB_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/checkForMemoryLeaks b/extlibs/qpOASES-3.2.0/testing/checkForMemoryLeaks
deleted file mode 100755
index 0224769..0000000
--- a/extlibs/qpOASES-3.2.0/testing/checkForMemoryLeaks
+++ /dev/null
@@ -1,109 +0,0 @@
-#!/usr/bin/env bash
-
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/checkForMemoryLeaks
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014-2015
-
-# defining colors for output
-red='\e[0;31m'
-green='\e[0;32m'
-NC='\e[0m' # No Color
-
-# runs valgrind on a number of examples to detect possible memory leaks
-
-function callValgrind {
-	echo -n "Checking for memory leaks in $2 $3... "
-
-	valgrind --tool=memcheck --leak-check=yes --error-exitcode=42 -q $2 $3 > dummy.txt;
-	retVal=$?;
-	rm -rf dummy.txt;
-
-	if [ $retVal == 42 ]; then
-		echo -e "${red}failed!${NC}"
-		counter=$[counter+1];
-	else
-		if [ $retVal == 99 ]; then
-			echo "problem data missing!"
-		else
-			echo -e "${green}passed!${NC}"
-		fi
-	fi
-}
-
-
-cd ..;
-make examples testing;
-cd testing;
-
-counter=0;
-
-# run examples in /examples
-callValgrind $counter ../bin/example1;
-callValgrind $counter ../bin/example1a;
-callValgrind $counter ../bin/example1b;
-callValgrind $counter ../bin/example2;
-callValgrind $counter ../bin/example3;
-callValgrind $counter ../bin/example3b;
-callValgrind $counter ../bin/example4;
-callValgrind $counter ../bin/example5;
-callValgrind $counter ../bin/exampleLP;
-callValgrind $counter ../bin/qrecipe;
-callValgrind $counter ../bin/qrecipeSchur;
-
-# run examples in /testing ...
-callValgrind $counter ../bin/test_matrices;
-callValgrind $counter ../bin/test_matrices2;
-callValgrind $counter ../bin/test_indexlist;
-callValgrind $counter ../bin/test_example6;
-callValgrind $counter ../bin/test_example7;
-callValgrind $counter ../bin/test_infeasible1;
-callValgrind $counter ../bin/test_sebastien1;
-callValgrind $counter ../bin/test_vanBarelsUnboundedQP;
-callValgrind $counter ../bin/test_janick1;
-callValgrind $counter ../bin/test_janick2;
-callValgrind $counter ../bin/test_constraintProduct1;
-callValgrind $counter ../bin/test_constraintProduct2;
-callValgrind $counter ../bin/test_guessedWS1;
-callValgrind $counter ../bin/test_externalChol1;
-callValgrind $counter ../bin/test_runAllOqpExamples;
-
-
-# ... including testbench with different settings
-callValgrind $counter ../bin/test_bench Odd; # default dense
-callValgrind $counter ../bin/test_bench Ods; # default sparse
-callValgrind $counter ../bin/test_bench Omd; # MPC dense
-callValgrind $counter ../bin/test_bench Ors; # reliable dense
-
-
-if [ $counter == 0 ]; then
-	echo -e "${green}All available tests passed successfully!${NC}"
-else
-	echo -e "${red}$counter test(s) failed!${NC}"
-	exit 1
-fi
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/Makefile b/extlibs/qpOASES-3.2.0/testing/cpp/Makefile
deleted file mode 100644
index 6f62d1c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/Makefile
+++ /dev/null
@@ -1,136 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/cpp/Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-
-include ../../make.mk
-
-##
-##	flags
-##
-
-IFLAGS      =  -I. \
-               -I${IDIR}
-
-QPOASES_TEST_EXES = \
-	${BINDIR}/test_bench${EXE} \
-	${BINDIR}/test_matrices${EXE} \
-	${BINDIR}/test_matrices2${EXE} \
-	${BINDIR}/test_matrices3${EXE} \
-	${BINDIR}/test_indexlist${EXE} \
-	${BINDIR}/test_example1${EXE} \
-	${BINDIR}/test_example1a${EXE} \
-	${BINDIR}/test_example1b${EXE} \
-	${BINDIR}/test_example2${EXE} \
-	${BINDIR}/test_example4${EXE} \
-	${BINDIR}/test_example5${EXE} \
-	${BINDIR}/test_example6${EXE} \
-	${BINDIR}/test_example7${EXE} \
-	${BINDIR}/test_exampleLP${EXE} \
-	${BINDIR}/test_qrecipe${EXE} \
-	${BINDIR}/test_qrecipeSchur${EXE} \
-	${BINDIR}/test_infeasible1${EXE} \
-	${BINDIR}/test_hs268${EXE} \
-	${BINDIR}/test_gradientShift${EXE} \
-	${BINDIR}/test_runAllOqpExamples${EXE} \
-	${BINDIR}/test_sebastien1${EXE} \
-	${BINDIR}/test_vanBarelsUnboundedQP${EXE} \
-	${BINDIR}/test_janick1${EXE} \
-	${BINDIR}/test_janick2${EXE} \
-	${BINDIR}/test_constraintProduct1${EXE} \
-	${BINDIR}/test_constraintProduct2${EXE} \
-	${BINDIR}/test_guessedWS1${EXE} \
-	${BINDIR}/test_externalChol1${EXE}
-
-
-##
-##	targets
-##
-
-all: ${QPOASES_TEST_EXES}
-
-runTests: ${QPOASES_TEST_EXES}
-	@cd .. && ./runUnitTests && ./checkForMemoryLeaks && cd cpp
-
-${BINDIR}/%${EXE}: %.${OBJEXT} ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/test_matrices2${EXE}: test_matrices2.${OBJEXT} test_qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/test_matrices3${EXE}: test_matrices3.${OBJEXT} test_qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/test_qrecipe${EXE}: test_qrecipe.${OBJEXT} test_qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/test_qrecipeSchur${EXE}: test_qrecipeSchur.${OBJEXT} test_qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-
-clean:
-	@${ECHO} "Cleaning up (testing/cpp)"
-	@${RM} -f *.${OBJEXT} ${QPOASES_TEST_EXES}
-
-clobber: clean
-
-
-${LINK_DEPENDS}:
-	@cd ../..; ${MAKE} -s src
-
-test_matrices2.${OBJEXT}: test_matrices2.cpp test_qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-test_matrices3.${OBJEXT}: test_matrices3.cpp test_qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-test_qrecipe.${OBJEXT}: test_qrecipe.cpp test_qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-test_qrecipeSchur.${OBJEXT}: test_qrecipeSchur.cpp test_qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-%.${OBJEXT}: %.cpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/data/fetch_cpp_data b/extlibs/qpOASES-3.2.0/testing/cpp/data/fetch_cpp_data
deleted file mode 100755
index 5e10392..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/data/fetch_cpp_data
+++ /dev/null
@@ -1,34 +0,0 @@
-#!/usr/bin/env bash
-
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/cpp/data/fetch_cpp_data
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014
-
-
-svn export https://projects.coin-or.org/svn/qpOASES/misc/testingdata/cpp . --force
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_bench.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_bench.cpp
deleted file mode 100644
index dc03fc9..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_bench.cpp
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_bench.cpp
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2010-2015
- *
- *	Unit test running all benchmark examples stored in problems directory.
- */
-
-
-
-#include <dirent.h>
-#include <cstring>
-#include <cstdlib>
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Run benchmark examples. */
-int main( int argc, char *argv[] )
-{
-	USING_NAMESPACE_QPOASES
-	#ifdef __USE_SINGLE_PRECISION__
-	const real_t TOL = 5e-2;
-	#else
-	const real_t TOL = 1e-5;
-	#endif
-
-	/* 1) Define benchmark arguments. */
-	BooleanType isSparse = BT_FALSE;
-	//BooleanType isSparse = BT_TRUE;
-	Options options;
- 	options.setToDefault();
-	//options.setToMPC();
-	//options.setToReliable();
-	options.printLevel = PL_LOW;
-	//options.printLevel = PL_MEDIUM;
-	//options.printLevel = PL_TABULAR;
-	//options.enableFarBounds = BT_FALSE;
-
-// 	options.initialStatusBounds = ST_LOWER;
-	//options.numRegularisationSteps = 1;
-	//options.epsRegularisation = 1.0e3 * EPS;
- 	
-	//options.enableFlippingBounds = BT_FALSE;
-	//options.enableFlippingBounds = BT_FALSE;
-	//options.enableRamping = BT_TRUE;
-	//options.enableFarBounds = BT_FALSE;
-	//options.enableNZCTests = BT_FALSE;
-	//options.epsNZCTests = 1.0e4 * EPS;
-	//options.epsFlipping = 1.0e5 * EPS;
-	//options.enableFullLITests = BT_TRUE;
- 	//options.enableDriftCorrection = 1;
- 	//options.enableEqualities = BT_TRUE;
-	//options.enableEqualities = BT_FALSE;
- 	//options.epsNum = -1.0e3 * EPS;
- 	//options.epsDen =  1.0e3 * EPS;
-
-
-	int_t nWSR;
-	real_t maxCPUtime; /* seconds */
-	real_t maxStationarity = 0.0, maxFeasibility = 0.0, maxComplementarity = 0.0;
-	real_t avgStationarity = 0.0, avgFeasibility = 0.0, avgComplementarity = 0.0;
-
-	int_t scannedDir = 0;
-	int_t nfail = 0, npass = 0;
-	int_t nproblems, i;
-	struct dirent **namelist;
-	char resstr[MAX_STRING_LENGTH], oqpProblem[MAX_STRING_LENGTH];
-	char *problem;
-	returnValue returnvalue;
-
-	int_t expectedNumSolvedProblems = 44;
-	real_t expectedAvgStationarity    = TOL;
-	real_t expectedAvgFeasibility     = TOL;
-	real_t expectedAvgComplementarity = TOL;
-
-	
-	if ( argv[argc-1][0] == 'O' )
-	{
-		if ( strlen(argv[argc-1]) != 3 )
-		{
-			fprintf( stdout,"ERROR (testbench): Invalid options passed!\n" );
-			return TEST_DATA_NOT_FOUND;
-		}
-		
-		fprintf( stdout,"Analysing passed options:  " );
-		switch ( argv[argc-1][1] )
-		{
-			case 'd':
-				fprintf( stdout,"default options, " );
-				options.setToDefault();
-				if ( argv[argc-1][2] == 's' )
-				{
-					expectedNumSolvedProblems  = 44;
-					expectedAvgStationarity    = 1e-9;
-					expectedAvgFeasibility     = 1e-9;
-					expectedAvgComplementarity = 5e-7;
-				}
-				else
-				{
-					expectedNumSolvedProblems  = 44;
-					expectedAvgStationarity    = 5e-10;
-					expectedAvgFeasibility     = 5e-10;
-					expectedAvgComplementarity = 5e-8;
-				}
-				break;
-				
-			case 'r':
-				fprintf( stdout,"reliable options, " );
-				options.setToReliable();
-				if ( argv[argc-1][2] == 's' )
-				{
-					expectedNumSolvedProblems  = 44;
-					expectedAvgStationarity    = 2e-9;
-					expectedAvgFeasibility     = 2e-11;
-					expectedAvgComplementarity = 3e-9;
-				}
-				else
-				{
-					expectedNumSolvedProblems  = 44;
-					expectedAvgStationarity    = 2e-9;
-					expectedAvgFeasibility     = 2e-9;
-					expectedAvgComplementarity = 3e-7;
-				}
-				break;
-				
-			case 'm':
-				fprintf( stdout,"MPC options, " );
-				options.setToMPC();
-				if ( argv[argc-1][2] == 's' )
-				{
-					expectedNumSolvedProblems  = 42;
-					expectedAvgStationarity    = 2e-8;
-					expectedAvgFeasibility     = 1e-8;
-					expectedAvgComplementarity = 2e-7;
-				}
-				else
-				{
-					expectedNumSolvedProblems  = 42;
-					expectedAvgStationarity    = 3e-8;
-					expectedAvgFeasibility     = 1e-8;
-					expectedAvgComplementarity = 5e-8;
-				}
-				break;
-				
-			default:
-				fprintf( stdout,"ERROR (testbench): Invalid options passed!\n" );
-				return TEST_DATA_NOT_FOUND;
-		}
-		
-		switch ( argv[argc-1][2] )
-		{
-			case 's':
-				fprintf( stdout,"sparse QP data\n" );
-				isSparse = BT_TRUE;
-				break;
-				
-			case 'd':
-				fprintf( stdout,"dense QP data\n" );
-				isSparse = BT_FALSE;
-				break;
-				
-			default:
-				fprintf( stdout,"ERROR (testbench): Invalid options passed!\n" );
-				return TEST_DATA_NOT_FOUND;
-		}
-		options.printLevel = PL_NONE;
-		//options.enableFlippingBounds = BT_FALSE;
-		
-		nproblems = argc-2;
-	}
-	else
-	{
-		nproblems = argc-1;
-	}
-
-	
-	if (nproblems == 0)
-	{
-		/* 2a) Scan problem directory */
-		nproblems = scandir("../testing/cpp/data/problems", &namelist, NULL, alphasort);
-		if (nproblems <= 0)
-		{
-			myPrintf( "No test problems found!\n" );
-			return TEST_DATA_NOT_FOUND;
-		}
-		scannedDir = 1;
-	}
-	else
-	{
-		/* 2b) Use problem list given by arguments */
-		scannedDir = 0;
-	}
-
-	/* 3) Run benchmark. */
-	printf("%10s %9s %9s %9s %6s  %-12s\n", "problem", "stat",
-			"feas", "compl", "nWSR", "result");
-	for (i = 0; i < nproblems; i++)
-	{
-		if (scannedDir)
-		{
-			/* skip special directories and zip file cuter.*bz2 */
-			if (namelist[i]->d_name[0] == '.' || namelist[i]->d_name[0] == 'c')
-			{
-				free(namelist[i]);
-				continue;
-			}
-			problem = namelist[i]->d_name;
-		}
-		else
-		{
-			problem = argv[i+1];
-		}
-
-		fprintf(stdFile, "%-10s ", problem);
-		fflush(stdFile);
-
-		snprintf(oqpProblem, MAX_STRING_LENGTH, "../testing/cpp/data/problems/%s/", problem);
-		maxCPUtime = 300.0;
-		nWSR = 2500;
-
-		returnvalue = runOqpBenchmark(	oqpProblem, isSparse, options,
-										nWSR, maxCPUtime, maxStationarity, maxFeasibility, maxComplementarity 
-										);
-		if (returnvalue	== SUCCESSFUL_RETURN
-				&& maxStationarity < TOL
-				&& maxFeasibility < TOL
-				&& maxComplementarity < TOL)
-		{
-			npass++;
-			
-			avgStationarity    += maxStationarity;
-			avgFeasibility     += maxFeasibility;
-			avgComplementarity += maxComplementarity;
-
-			strncpy(resstr, "pass", MAX_STRING_LENGTH);
-		}
-		else
-		{
-			if ( returnvalue == RET_BENCHMARK_ABORTED )
-				return TEST_DATA_NOT_FOUND;
-
-			nfail++;
-			snprintf (resstr, MAX_STRING_LENGTH, "fail (%d)",(int)returnvalue);
-		}
-		fprintf(stdFile, "%9.2e %9.2e %9.2e %6d  %-12s\n", maxStationarity,
-				maxFeasibility, maxComplementarity, (int)nWSR, resstr);
-
-		if (scannedDir) free(namelist[i]);
-	}
-	if (scannedDir) free(namelist);
-
-	avgStationarity    /= npass;
-	avgFeasibility     /= npass;
-	avgComplementarity /= npass;
-
-
-	/* 4) Print results. */
-	printf( "\n\n" );
-	printf( "Testbench results:\n" );
-	printf( "======================\n\n" );
-	printf( "Pass:  %3d\n",(int)npass );
-	printf( "Fail:  %3d\n",(int)nfail );
-	printf( "Ratio: %5.1f%%\n", 100.0 * (real_t)npass / (real_t)(npass+nfail) );
-	printf( "\n" );
-
-	QPOASES_TEST_FOR_TRUE( npass >= expectedNumSolvedProblems );
-
-
-	printf( "avg. stat:  %e\n", avgStationarity    );
-	printf( "avg. feas:  %e\n", avgFeasibility     );
-	printf( "avg. cmpl:  %e\n", avgComplementarity );
-
-	QPOASES_TEST_FOR_TOL( avgStationarity,    expectedAvgStationarity    );
-	QPOASES_TEST_FOR_TOL( avgFeasibility,     expectedAvgFeasibility     );
-	QPOASES_TEST_FOR_TOL( avgComplementarity, expectedAvgComplementarity );
-
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct1.cpp
deleted file mode 100644
index 1c95dd6..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct1.cpp
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_constraintProduct1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Another example for testing qpOASES using the possibility to specify 
- *	user-defined constraint product function.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-
-USING_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Example illustrating the use of the \a ConstraintProduct class.
- *
- *	Example illustrating the use of the \a ConstraintProduct class.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.1
- *	\date 2007-2015
- */
-class MpcConstraintProduct : public ConstraintProduct
-{
-	public:
-		/** Default constructor. */
-		MpcConstraintProduct( ) {};
-
-		/** Constructor. */
-		MpcConstraintProduct(	int_t _nV,
-								int_t _nC,
-								int_t _diagOffset,
-								real_t* _A
-								)
-		{
-			nV = _nV;
-			nC = _nC;
-			diagOffset = _diagOffset;
-			A  = _A;
-		};
-
-		/** Copy constructor (flat copy). */
-		MpcConstraintProduct(	const MpcConstraintProduct& rhs
-								)
-		{
-			nV = rhs.nV;
-			nC = rhs.nC;
-			diagOffset = rhs.diagOffset;
-			A  = rhs.A;
-		};
-
-		/** Destructor. */
-		virtual ~MpcConstraintProduct( ) {};
-		
-		/** Assignment operator (flat copy). */
-		MpcConstraintProduct& operator=(	const MpcConstraintProduct& rhs
-											)
-		{
-			if ( this != &rhs )
-			{
-				nV = rhs.nV;
-				nC = rhs.nC;
-				diagOffset = rhs.diagOffset;
-				A  = rhs.A;
-			}
-			else
-				return *this;
-		};
-
-		virtual int_t operator() (	int_t constrIndex,
-									const real_t* const x,
-									real_t* const constrValue
-									) const
-		{
-			int_t i;
-			int_t maxI = (int_t)(((real_t)constrIndex) * ((real_t)nV) / ((real_t)nC)) + diagOffset;
-			maxI = getMin( maxI,nV );
-
-			constrValue[0] = 0.0;
-
-			for( i=0; i<maxI; ++i )
-				constrValue[0] += A[constrIndex*nV + i] * x[i];
-
-			return 0;
-		};
-
-	protected:
-		int_t nV;			/**< Number of variables. */
-		int_t nC;			/**< Number of constraints. */
-		int_t diagOffset;	/**< ... */
-		real_t* A;			/**< Pointer to full constraint matrix (typically not needed!). */
-		
-};
-
-
-
-/**	Example for qpOASES main function using the possibility to specify 
- *	user-defined constraint product function. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t nQP, nV, nC, nEC;
-	real_t *H, *g, *A, *lb, *ub, *lbA, *ubA;
-	real_t cputime;
-
-	real_t xOpt[1000];
-	real_t yOpt[1000];
-	real_t xOptCP[1000+1000];
-	real_t yOptCP[1000+1000];
-	
-	const char* path = "./cpp/data/oqp/chain80w/";
-	int_t k = 10; //th problem
-	
-		
-	if ( readOqpDimensions(	path, nQP,nV,nC,nEC ) != SUCCESSFUL_RETURN )
-		return TEST_DATA_NOT_FOUND;
-	
-	readOqpData(	path, nQP,nV,nC,nEC,
-					&H,&g,&A,&lb,&ub,&lbA,&ubA,
-					0,0,0
-					);
-	
-	Options myOptions;
-	//myOptions.setToMPC();
-	myOptions.printLevel = PL_LOW;
-
-	int_t nWSR = 500;
-	cputime = 20.0;
-	QProblem qp( nV,nC );
-	qp.setOptions( myOptions );
-	qp.init( H,&(g[k*nV]),A,&(lb[k*nV]),&(ub[k*nV]),&(lbA[k*nC]),&(ubA[k*nC]),nWSR,&cputime );
-	qp.getPrimalSolution( xOpt );
-	qp.getDualSolution( yOpt );
-	printf( "cputime without constraintProduct: %.3ems\n", cputime*1000.0 );
-	
-
-	nWSR = 500;
-	cputime = 20.0;
-	MpcConstraintProduct myCP( nV,nC,2,A );
-	QProblem qpCP( nV,nC );
-	qpCP.setOptions( myOptions );
-	qpCP.setConstraintProduct( &myCP );
-	qpCP.init( H,&(g[k*nV]),A,&(lb[k*nV]),&(ub[k*nV]),&(lbA[k*nC]),&(ubA[k*nC]),nWSR,&cputime );
-	qpCP.getPrimalSolution( xOptCP );
-	qpCP.getDualSolution( yOptCP );
-	printf( "cputime with    constraintProduct: %.3ems\n", cputime*1000.0 );
-	
-	delete[] ubA;
-	delete[] lbA;
-	delete[] ub;
-	delete[] lb;
-	delete[] A;
-	delete[] g;
-	delete[] H;
-
-	for( int ii=0; ii<nV; ++ii )
-		QPOASES_TEST_FOR_NEAR( xOptCP[ii],xOpt[ii] );
-
-	for( int ii=0; ii<nV+nC; ++ii )
-		QPOASES_TEST_FOR_NEAR( yOptCP[ii],yOpt[ii] );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct2.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct2.cpp
deleted file mode 100644
index 8ae27cb..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct2.cpp
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_constraintProduct2.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Another example for testing qpOASES using the possibility to specify 
- *	user-defined constraint product function.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-
-USING_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Example illustrating the use of the \a ConstraintProduct class.
- *
- *	Example illustrating the use of the \a ConstraintProduct class.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.1
- *	\date 2007-2015
- */
-class MpcConstraintProduct : public ConstraintProduct
-{
-	public:
-		/** Default constructor. */
-		MpcConstraintProduct( ) {};
-
-		/** Constructor. */
-		MpcConstraintProduct(	int_t _nV,
-								int_t _nC,
-								int_t _diagOffset,
-								real_t* _A
-								)
-		{
-			nV = _nV;
-			nC = _nC;
-			diagOffset = _diagOffset;
-			A  = _A;
-		};
-
-		/** Copy constructor (flat copy). */
-		MpcConstraintProduct(	const MpcConstraintProduct& rhs
-								)
-		{
-			nV = rhs.nV;
-			nC = rhs.nC;
-			diagOffset = rhs.diagOffset;
-			A  = rhs.A;
-		};
-
-		/** Destructor. */
-		virtual ~MpcConstraintProduct( ) {};
-		
-		/** Assignment operator (flat copy). */
-		MpcConstraintProduct& operator=(	const MpcConstraintProduct& rhs
-										)
-		{
-			if ( this != &rhs )
-			{
-				nV = rhs.nV;
-				nC = rhs.nC;
-				diagOffset = rhs.diagOffset;
-				A  = rhs.A;
-			}
-			else
-				return *this;
-		};
-
-		virtual int_t operator() (	int_t constrIndex,
-									const real_t* const x,
-									real_t* const constrValue
-									) const
-		{
-			int_t i;
-			int_t maxI = (int_t)(((real_t)constrIndex) * ((real_t)nV) / ((real_t)nC)) + diagOffset;
-			maxI = getMin( maxI,nV );
-
-			constrValue[0] = 0.0;
-
-			for( i=0; i<maxI; ++i )
-				constrValue[0] += A[constrIndex*nV + i] * x[i];
-
-			return 0;
-		};
-
-	protected:
-		int_t nV;			/**< Number of variables. */
-		int_t nC;			/**< Number of constraints. */
-		int_t diagOffset;	/**< ... */
-		real_t* A;			/**< Pointer to full constraint matrix (typically not needed!). */
-		
-};
-
-
-/**	Example for qpOASES main function using the possibility to specify 
- *	user-defined constraint product function. */
-int main( )
-{
-	int_t nQP, nV, nC, nEC;
-	real_t *H, *g, *A, *lb, *ub, *lbA, *ubA;
-	real_t cputime;
-	
-	real_t xOpt[1000];
-	real_t yOpt[1000];
-	real_t xOptCP[1000+1000];
-	real_t yOptCP[1000+1000];
-		
-	const char* path = "./cpp/data/oqp/diesel/";
-	int_t k = 200; //th problem
-	
-	
-	if ( readOqpDimensions(	path, nQP,nV,nC,nEC ) != SUCCESSFUL_RETURN )
-		return TEST_DATA_NOT_FOUND;
-
-	readOqpData(	path, nQP,nV,nC,nEC,
-					&H,&g,&A,&lb,&ub,&lbA,&ubA,
-					0,0,0
-					);
-	
-	Options myOptions;
-	myOptions.setToMPC();
-	myOptions.printLevel = PL_LOW;
-	
-	int_t nWSR = 500;
-	cputime = 10.0;
-	QProblem qp( nV,nC );
-	qp.setOptions( myOptions );
-	qp.init( H,&(g[k*nV]),A,&(lb[k*nV]),&(ub[k*nV]),&(lbA[k*nC]),&(ubA[k*nC]),nWSR,&cputime );
-	qp.getPrimalSolution( xOpt );
-	qp.getDualSolution( yOpt );
-	printf( "cputime without constraintProduct: %.3ems\n", cputime*1000.0 );
-	
-	
-	nWSR = 500;
-	cputime = 10.0;
-	MpcConstraintProduct myCP( nV,nC,1,A );
-	QProblem qpCP( nV,nC );
-	qpCP.setOptions( myOptions );
-	qpCP.setConstraintProduct( &myCP );
-	qpCP.init( H,&(g[k*nV]),A,&(lb[k*nV]),&(ub[k*nV]),&(lbA[k*nC]),&(ubA[k*nC]),nWSR,&cputime );
-	qpCP.getPrimalSolution( xOptCP );
-	qpCP.getDualSolution( yOptCP );
-	printf( "cputime without constraintProduct: %.3ems\n", cputime*1000.0 );
-	
-	delete[] ubA;
-	delete[] lbA;
-	delete[] ub;
-	delete[] lb;
-	delete[] A;
-	delete[] g;
-	delete[] H;
-	
-	for( int_t ii=0; ii<nV; ++ii )
-		QPOASES_TEST_FOR_NEAR( xOptCP[ii],xOpt[ii] );
-
-	for( int_t ii=0; ii<nV+nC; ++ii )
-		QPOASES_TEST_FOR_NEAR( yOptCP[ii],yOpt[ii] );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example1.cpp
deleted file mode 100644
index 9c32536..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1.cpp
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES (using QProblem class).
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up QProblem object. */
-	QProblem example( 2,1 );
-
-	Options options;
-	example.setOptions( options );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1a.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example1a.cpp
deleted file mode 100644
index 925307d..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1a.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example1a.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES using the SQProblem class.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the SQProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up SQProblem object. */
-	SQProblem example( 2,1 );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1b.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example1b.cpp
deleted file mode 100644
index 05a6d98..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1b.cpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example1b.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES using the QProblemB class.
- */
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the QProblemB class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-
-
-	/* Setting up QProblemB object. */
-	QProblemB example( 2 );
-
-	Options options;
-	//options.enableFlippingBounds = BT_FALSE;
-	options.initialStatusBounds = ST_INACTIVE;
-	options.numRefinementSteps = 1;
-	options.enableCholeskyRefactorisation = 1;
-	example.setOptions( options );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,lb,ub, nWSR,0 );
-// 	printf( "\nnWSR = %d\n\n", nWSR );
-
-	real_t xOpt[2];
-	real_t yOpt[2];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new, nWSR,0 );
-// 	printf( "\nnWSR = %d\n\n", nWSR );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example2.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example2.cpp
deleted file mode 100644
index 9caf502..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example2.cpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example2.cpp
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Very simple example for testing qpOASES in combination
- *  with the SolutionAnalysis class.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the SolutionAnalysis class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up SQProblem object and solution analyser. */
-	SQProblem example( 2,1 );
-	SolutionAnalysis analyser;
-
-	/* Solve first QP ... */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	/* ... and analyse it. */
-	real_t maxKktViolation = analyser.getKktViolation( &example );
-    printf( "maxKktViolation: %e\n", maxKktViolation );
-
-	QPOASES_TEST_FOR_TOL( maxKktViolation,1e-15 );
-
-
-	/* Solve second QP ... */
-	nWSR = 10;
-	example.hotstart( H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-	/* ... and analyse it. */
-	maxKktViolation = analyser.getKktViolation( &example );
-    printf( "maxKktViolation: %e\n", maxKktViolation );
-
-	QPOASES_TEST_FOR_TOL( maxKktViolation,1e-15 );
-
-
-//  ------------ VARIANCE-COVARIANCE EVALUATION --------------------
-
-        real_t *Var              = new real_t[5*5];
-        real_t *Primal_Dual_Var  = new real_t[5*5];
-
-        int_t run1, run2;
-        for( run1 = 0; run1 < 5*5; run1++ )
-            Var[run1] = 0.0;
-
-        Var[0] = 1.0;
-        Var[6] = 1.0;
-
-//                  (  1   0   0   0   0   )
-//                  (  0   1   0   0   0   )
-//     Var     =    (  0   0   0   0   0   )
-//                  (  0   0   0   0   0   )
-//                  (  0   0   0   0   0   )
-
-
-        analyser.getVarianceCovariance( &example, Var,Primal_Dual_Var );
-
-        printf("\nPrimal_Dual_VAR = \n");
-        for( run1 = 0; run1 < 5; run1++ ){
-          for( run2 = 0; run2 < 5; run2++ ){
-            printf(" %10f", Primal_Dual_Var[run1*5+run2]);
-          }
-          printf("\n");
-        }
-
-        delete[] Primal_Dual_Var;
-        delete[] Var;
-
-		QPOASES_TEST_FOR_NEAR( Primal_Dual_Var[3*5+3], 26.0 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example4.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example4.cpp
deleted file mode 100644
index 98b320c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example4.cpp
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example4.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2009-2015
- *
- *	Very simple example for testing qpOASES (using the possibility to specify 
- *	user-defined constraint product function).
- */
-
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "../../examples/example4CP.cpp"
-#include <qpOASES/UnitTesting.hpp>
-
-
-/**	Example for qpOASES main function using the possibility to specify 
- *	user-defined constraint product function. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t i,j;
-
-	/* Setup data of first QP... */
-	real_t H[7*7];
-	real_t A[50*7];
-	real_t g[7];
-	real_t lbA[50];
-
-	/*	    ( 1.0 0.5 |                    )
-	 *	    ( 0.5 2.0 |                    )
-	 *	    ( --------+------------------- )
-	 *	H = (         | 1e-6               )
-	 *	    (         |      1e-6          )
-	 *	    (         |           ...      )
-	 *	    (         |               1e-6 ) */
-	for( i=0; i<7*7; ++i )
-		H[i] = 0.0;
-	for( i=2; i<7; ++i )
-		H[i*7+i] = 1.0e-6;
-	H[0] = 1.0;
-	H[1] = 0.5;
-	H[7] = 0.5;
-	H[8] = 2.0;
-
-	/*	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x | ...             )
-	 *	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x |     1.0         )
-	 *	A = ( x.x x.x |     ...         )
-	 *	    ( x.x x.x |     1.0         )
-	 *	    ( x.x x.x |         ...     )
-	 *	    ( x.x x.x |             1.0 )
-	 *	    ( x.x x.x |             ... )
-	 *	    ( x.x x.x |             1.0 ) */
-	for( i=0; i<50*7; ++i )
-		A[i] = 0.0;
-	for( i=0; i<50; ++i )
-	{
-		for( j=0; j<2; ++j )
-			A[i*7+j] = (real_t)rand() / (real_t)RAND_MAX;
-
-		A[i*7 + (i/10)+2] = 1.0;
-	}
-
-	/*	    ( -1.0 )
-	 *	    ( -0.5 )
-	 *	    ( ---- )
-	 *	g = (      )
-	 *	    (      )
-	 *	    (      )
-	 *	    (      ) */
-	for( i=0; i<7; ++i )
-		g[i] = 0.0;
-	g[0] = -1.0;
-	g[1] = -0.5;
-
-	for( i=0; i<50; ++i )
-		lbA[i] = 1.0;
-
-	/* ... and setting up user-defined constraint product function. */
-	MyConstraintProduct myCP( 7,50,A );
-
-
-	/* Setting up QProblem object and set construct product function. */
-	QProblem exampleCP( 7,50 );
-	exampleCP.setPrintLevel( PL_NONE );
-	
-	exampleCP.setConstraintProduct( &myCP );
-
-
-	/* Solve first QP. */
-	real_t cputime = 1.0;
-	int_t nWSR = 100;
-	exampleCP.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-
-
-	/* Solve second QP using a modified gradient. */
-	g[0] = -2.0;
-	g[1] =  0.5;
-
-	cputime = 1.0;
-	nWSR = 100;
-	exampleCP.hotstart( g,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of second QP. */
-	real_t xOptCP[7];
-	real_t yOptCP[7+50];
-	exampleCP.getPrimalSolution( xOptCP );
-	exampleCP.getDualSolution( yOptCP );
-	printf( "\nxOpt = [ %e, %e, %e ... ];  objVal = %e\n", xOptCP[0],xOptCP[1],xOptCP[2],exampleCP.getObjVal() );
-	printf( "CPU time:  %.3f microseconds\n\n", cputime*1.0e6 ); 
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzerCP;
-
-	analyzerCP.getKktViolation( &exampleCP, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-	
-	
-	/* Do the same without specifying constraint product. */
-	QProblem example( 7,50 );
-	example.setPrintLevel( PL_NONE );
-	
-	/* Solve first QP. */
-	g[0] = -1.0;
-	g[1] = -0.5;
-	
-	cputime = 1.0;
-	nWSR = 100;
-	example.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-	
-	/* Solve second QP using a modified gradient. */
-	g[0] = -2.0;
-	g[1] =  0.5;
-
-	cputime = 1.0;
-	nWSR = 100;
-	example.hotstart( g,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[7];
-	real_t yOpt[7+50];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e, %e ... ];  objVal = %e\n", xOpt[0],xOpt[1],xOpt[2],example.getObjVal() );
-	printf( "CPU time:  %.3f microseconds\n\n", cputime*1.0e6 ); 
-
-	/* Compute KKT tolerances */
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	for( int_t ii=0; ii<7; ++ii )
-		QPOASES_TEST_FOR_NEAR( xOptCP[ii],xOpt[ii] );
-
-	for( int_t ii=0; ii<7+50; ++ii )
-		QPOASES_TEST_FOR_NEAR( yOptCP[ii],yOpt[ii] );
-
-	QPOASES_TEST_FOR_NEAR( exampleCP.getObjVal(),example.getObjVal() );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example5.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example5.cpp
deleted file mode 100644
index 452cdda..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example5.cpp
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example5.cpp
- *	\author Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2011-2015
- *
- *	Very simple example for testing qpOASES (using the possibility to
- *  compute the local linear feedback law)
- */
-
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "../../examples/example4CP.cpp"
-#include <qpOASES/UnitTesting.hpp>
-
-
-/**	Example for qpOASES main function using the possibility to specify
- *	user-defined constraint product function. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t i,j,jj;
-	real_t d = 0.0;
-
-	/* Setup data of first QP... */
-	real_t H[7*7];
-	real_t A[50*7];
-	real_t g[7];
-	real_t lbA[50];
-
-	/*	    ( 1.0 0.5 |                    )
-	 *	    ( 0.5 2.0 |                    )
-	 *	    ( --------+------------------- )
-	 *	H = (         | 1e-6               )
-	 *	    (         |      1e-6          )
-	 *	    (         |           ...      )
-	 *	    (         |               1e-6 ) */
-	for( i=0; i<7*7; ++i )
-		H[i] = 0.0;
-	for( i=2; i<7; ++i )
-		H[i*7+i] = 1.0e-6;
-	H[0] = 1.0;
-	H[1] = 0.5;
-	H[7] = 0.5;
-	H[8] = 2.0;
-
-	/*	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x | ...             )
-	 *	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x |     1.0         )
-	 *	A = ( x.x x.x |     ...         )
-	 *	    ( x.x x.x |     1.0         )
-	 *	    ( x.x x.x |         ...     )
-	 *	    ( x.x x.x |             1.0 )
-	 *	    ( x.x x.x |             ... )
-	 *	    ( x.x x.x |             1.0 ) */
-	for( i=0; i<50*7; ++i )
-		A[i] = 0.0;
-	for( i=0; i<50; ++i )
-	{
-		for( j=0; j<2; ++j )
-			A[i*7+j] = (real_t)rand() / (real_t)RAND_MAX;
-
-		A[i*7 + (i/10)+2] = 1.0;
-	}
-
-	/*	    ( -1.0 )
-	 *	    ( -0.5 )
-	 *	    ( ---- )
-	 *	g = (      )
-	 *	    (      )
-	 *	    (      )
-	 *	    (      ) */
-	for( i=0; i<7; ++i )
-		g[i] = 0.0;
-	g[0] = -1.0;
-	g[1] = -0.5;
-
-	for( i=0; i<50; ++i )
-		lbA[i] = 1.0;
-
-	/* ... and setting up user-defined constraint product function. */
-	MyConstraintProduct myCP( 7,50,A );
-
-
-	/* Setting up QProblem object and set construct product function. */
-	QProblem example( 7,50 );
-	example.setConstraintProduct( &myCP );
-
-
-	/* Solve first QP. */
-	real_t cputime = 1.0;
-	int_t nWSR = 100;
-	example.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of QP. */
-	real_t xOpt[7], yOpt[7+50];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-
-
-	/* Compute local linear feedback law */
-	const int_t n_rhs = 7+7+50;
-	real_t g_in[7*n_rhs];
-	real_t b_in[7*n_rhs];
-	real_t bA_in[50*n_rhs];
-	real_t x_out[7*n_rhs];
-	real_t y_out[(7+50)*n_rhs];
-
-	int_t ii;
-	memset (g_in, 0, sizeof (g_in));
-	memset (b_in, 0, sizeof (b_in));
-	memset (bA_in, 0, sizeof (bA_in));
-
-	for ( ii = 0; ii < 7; ++ii )
-		g_in[ii*7 + ii] = 1.0;
-	for ( ii = 0; ii < 7; ++ii )
-		b_in[(ii+7)*7 + ii] = 1.0;
-	for ( ii = 0; ii < 50; ++ii )
-		bA_in[(ii+14)*50 + ii] = 1.0;
-
-	example.solveCurrentEQP ( n_rhs, g_in, b_in, b_in, bA_in, bA_in, x_out, y_out );
-
-	/* Verify validity of local feedback law by perturbation and hot starts */
-	real_t perturb = 1.0e-6;
-	real_t nrm = 0.0;
-	for ( ii = 0; ii < n_rhs; ++ii )
-	{
-		for ( jj = 0; jj < 7; ++jj )
-			g_in[ii*7 + jj] = g[jj] + g_in[ii*7+jj]*perturb;
-		for ( jj = 0; jj < 50; ++jj )
-			bA_in[ii*50 + jj] = lbA[jj] + bA_in[ii*50+jj]*perturb;
-
-		nWSR = 100;
-		example.hotstart( &g_in[ii*7],0,0,&bA_in[ii*50],0, nWSR, 0 );
-
-		real_t xPer[7], yPer[7+50];
-		example.getPrimalSolution( xPer );
-		example.getDualSolution( yPer );
-
-		for ( jj = 0; jj < 7; ++jj )
-		{
-			d = getAbs (x_out[ii*7+jj]*perturb - (xPer[jj]-xOpt[jj]) );
-			if (nrm < d) nrm=d;
-		}
-		for ( jj = 0; jj < 7+50; ++jj )
-		{
-			d = getAbs (y_out[ii*(7+50)+jj]*perturb - (yPer[jj]-yOpt[jj]) );
-			if (nrm < d) nrm=d;
-		}
-	}
-	printf ("Maximum perturbation over all directions: %e\n", nrm);
-
-	QPOASES_TEST_FOR_TOL( nrm,1e-15 );
-
-
-	/* // print feedback matrix
-	for (ii = 0; ii < n_rhs; ++ii)
-	{
-		printf ("x: ");
-		for (jj = 0; jj < 7; ++jj )
-			printf ("%8.2e ", x_out[ii*7+jj]);
-		printf (" y: ");
-		for (jj = 0; jj < 7+50; ++jj )
-			printf ("%8.2e ", y_out[ii*(7+50)+jj]);
-		printf("\n");
-	}
-*/
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example6.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example6.cpp
deleted file mode 100644
index d85c0aa..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example6.cpp
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example6.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Example that caused troubles in an earlier release.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[5*5] = {	1.224642131370767e+01, 2.908638763113702e+00, 0.0, 0.0, 0.0,
-						2.908638763113702e+00, 2.497106275003180e+00, 0.0, 0.0, 0.0,
-						0.0, 0.0, 1.0, 0.0, 0.0,
-						0.0, 0.0, 0.0, 5.158460640334052e-02, 4.723556059962540e-02,
-						0.0, 0.0, 0.0, 4.723556059962540e-02, 4.325317843302175e-02 };
-	real_t A[2*5] = { 	-1.404358970692652e+00, -2.556613491156063e+00, 3.202524559238066e+00, -1.0, 0.0,
-						6.587910295430314e-01, -5.349454475937998e-01, 4.391976356955536e-01, 0.0, -1.0 };
-	real_t g[5] = { 	2.474135331302147e+01,
-						5.857286430296258e+00,
-						2.359382646348721e-01,
-						1.721047069188781e-01,
-						1.575947337774199e-01 };
-	real_t lb[5] = { -10.0, -10.0, -10.0, -10.0, -10.0 };
-	real_t ub[5] = {  10.0,  10.0,  10.0,  10.0,  10.0 };
-	real_t lbA[2] = { 1.643135416077167e+00, 1.056813028189597e+00 };
-	real_t ubA[2] = { 1.643135416077167e+00, 1.056813028189597e+00 };
-
-	/* Setting up QProblem object. */
-	QProblem example( 5,2 );
-
-	Options options;
- 	//options.enableFlippingBounds = BT_FALSE;
-	//options.enableEqualities = BT_TRUE;
-	//options.initialStatusBounds = ST_INACTIVE;
-	example.setOptions( options );
-	example.setPrintLevel( PL_NONE );
-	
-	/* Solve first QP. */
-	returnValue retVal;
-	int_t simpleStatus = -1;
-
-	int_t nWSR = 10;
-	retVal = example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-	simpleStatus = getSimpleStatus( retVal,BT_TRUE );
-
-	QPOASES_TEST_FOR_TRUE( simpleStatus == 0 );
-
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[5];
-	real_t yOpt[5+2];
-	
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e, ... ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-14 );
-	QPOASES_TEST_FOR_TOL( feas,1e-14 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example7.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example7.cpp
deleted file mode 100644
index cd026cc..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example7.cpp
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example7.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Example that caused troubles in an earlier release.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	real_t H[5*5] = {0.8514828085899353, -0.15739890933036804, -0.081726007163524628, -0.530426025390625, 0.16773293912410736, -0.15739890933036804, 1.1552412509918213, 0.57780224084854126, -0.0072606131434440613, 0.010559185408055782, -0.081726007163524628, 0.57780224084854126, 0.28925251960754395, 5.324830453901086e-006, -3.0256599075073609e-006, -0.530426025390625, -0.0072606131434440613, 5.324830453901086e-006, 0.35609596967697144, -0.15124998986721039, 0.16773293912410736, 0.010559185408055782, -3.0256599075073609e-006, -0.15124998986721039, 0.15129712224006653};
-	real_t g[5] = {0.30908384919166565, 0.99325823783874512, 0.49822014570236206, -0.26309865713119507, 0.024296050891280174};
-	real_t A[5*5] =   {1,0,0,0,0,
-					   0,1,0,0,0,
-					   0,0,1,0,0,              
-					   0,0,0,1,0,
-					   0,0,0,0,1};
-	real_t lb[5] = {-0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359938621520996};
-	real_t ub[5] = { 0.052359879016876221, 0.052359879016876221, 0.052359879016876221, 0, 0};
-	real_t lbA[5] = {-0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359938621520996};
-	real_t ubA[5] = {0.052359879016876221, 0.052359879016876221, 0.052359879016876221, 0, 0};
-
-	/* Setting up QProblem object. */
-	QProblem example( 5,5 );
-
-	/* Solve first QP. */
-	int_t nWSR = 100;
-	returnValue retVal = example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-	printf( "nWSR = %d,  retVal = %d (%s)\n", (int)nWSR,retVal,getGlobalMessageHandler( )->getErrorCodeMessage(retVal) );
-	
-	
-	real_t sol[5]    = {0};
-	real_t yOpt[5+5] = {0};
-	example.getPrimalSolution(sol);
-	example.getDualSolution(yOpt);
-	
-	printf("l1 = %f, l2 = %f, l3 = %f, l4 = %f, l5 = %f\n",(float) lb[0], (float) lb[1], (float) lb[2], (float) lb[3], (float) lb[4]);
-	printf("x1 = %f, x2 = %f, x3 = %f, x4 = %f, x5 = %f\n",(float) sol[0], (float) sol[1], (float) sol[2], (float) sol[3], (float) sol[4]);
-	printf("u1 = %f, u2 = %f, u3 = %f, u4 = %f, u5 = %f\n",(float) ub[0], (float) ub[1], (float) ub[2], (float) ub[3], (float) ub[4]);
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_exampleLP.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_exampleLP.cpp
deleted file mode 100644
index 5057746..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_exampleLP.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_exampleLP.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Very simple example for solving a LP sequence using qpOASES.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function solving LPs. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	real_t tol = 1e-14;
-
-	/* Setup data of first LP. */
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second LP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up QProblem object with zero Hessian matrix. */
-	QProblem example( 2,1,HST_ZERO );
-
-	Options options;
- 	/*options.setToMPC();*/
-	example.setOptions( options );
-
-	/* Solve first LP. */
-	int_t nWSR = 10;
-	example.init( 0,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-	printf( "%d\n",example.getHessianType() );
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,tol );
-	QPOASES_TEST_FOR_TOL( feas,tol );
-	QPOASES_TEST_FOR_TOL( cmpl,tol );
-
-
-	/* Solve second LP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-
-	/* Get and print solution of second LP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,tol );
-	QPOASES_TEST_FOR_TOL( feas,tol );
-	QPOASES_TEST_FOR_TOL( cmpl,tol );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_externalChol1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_externalChol1.cpp
deleted file mode 100644
index eb32987..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_externalChol1.cpp
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_externalChol1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2015
- *
- *	Very simple example for testing qpOASES using the QProblem class
- *	and providing a pre-computed Cholesky factor of the Hessian matrix.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-	
-	real_t R[2*2] = { sqrt(1.0), 0.0, 0.0, sqrt(0.5) };
-
-
-	/* Setting up QProblem object. */
-	QProblem example( 2,1 );
-
-	Options options;
-	example.setOptions( options );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0, 0,0,0,0, R );
-
-	/* Get and print solution of first QP. */
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-	
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-
-	example.printOptions();
-	/*example.printProperties();*/
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_gradientShift.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_gradientShift.cpp
deleted file mode 100644
index 200b093..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_gradientShift.cpp
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2009 by Hans Joachim Ferreau et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_gradientShift.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Simple test case which caused troubles in version 2.0.
- */
-
- 
-
-#include <math.h>
-#include <iostream>
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Running simple test case which caused troubles in version 2.0. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	
-	real_t H[2*2] 	= { 0.055944055944055944,0, 0, 0 };
-	real_t A[1*2] 	= { 0.70514808036997589, -1 };
-	//real_t g[2]	= { -15.830543073928741, 0};
-	real_t g[2]		= { 0, 0 };
-	real_t lb[2]	= { 137.00242299940646, 154.0 };
-	real_t ub[2]	= { 282.19008595111382, 198.98579740786641};
-	real_t lbA[1]	= {0.0};
-	real_t ubA[1]	= {0.0};
-	
-	real_t gStart=-16.4;
- 
-	/* Setting up QProblem object. */
-	QProblem example( 2,1 );
-	Options options;
-	options.setToMPC();
-	options.printLevel = REFER_NAMESPACE_QPOASES PL_NONE;
-	example.setOptions( options );
-	
-	returnValue ret;
-	int_t nWSR = 10;
-	real_t Xopt[2]={0.0,0.0};
-	//fprintf(stdFile, "g[0]\t,\tReturn code\n");
-	int_t errorCount=0;
-	int_t i=0;
-	real_t granularity=0.00001;
-	g[0]=gStart;
-	for( i=0; i< 70000; i++)
-	{
-
-		g[0] += granularity;
-		/* Solve first QP. */
-		nWSR = 10;
-		ret= example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-		if (ret != SUCCESSFUL_RETURN)
-		{
-			//fprintf(stdFile, "%f\t,\t%d\n",g[0],ret);
-			errorCount++;
-		}
-		//fprintf(stdFile, "%f\t,\t%d\n",g[0],ret);
-	}
-	example.printProperties();
-	fprintf( stdFile, "#Number of optimizer runs: %d\n",(int)i );
-	fprintf( stdFile, "#g[0] test interval: %f < g[0] < %f\n",gStart,g[0] );
-	fprintf( stdFile, "#Granularity: %f\n",granularity);
-	real_t errorPercent = real_t(errorCount)/real_t(i)*100.0;
-	fprintf( stdFile, "#Number of errors (error): %d (%f)\n",(int)errorCount,errorPercent );
-
-	example.getPrimalSolution(Xopt);
-	fprintf( stdFile,"#Optimization primary result : LD=%f BD=%f\n",Xopt[0], Xopt[1]);
-
-	real_t Yopt[3]={0.0,0.0,0.0};
-	example.getDualSolution(Yopt);
-	fprintf( stdFile,"#Optimization dual result : %f %f %f8\n",Yopt[0], Yopt[1], Yopt[2]);
-
-	int_t Nc=0;
-	Nc=example.getNC();
-	fprintf( stdFile,"#Number of constraints : %d\n",(int)Nc );
-
-	int_t Nec=0;
-	Nec=example.getNEC();
-	fprintf( stdFile,"#Number of equality constraints : %d\n",(int)Nec );
-
-	int_t Nac=0;
-	Nac=example.getNAC();
-	fprintf( stdFile,"#Number of active constraints : %d\n",(int)Nac );
-
-	int_t Niac=0;
-	Niac=example.getNIAC();
-	fprintf( stdFile,"#Number of inactive constraints : %d\n",(int)Niac );
-
-	QPOASES_TEST_FOR_TRUE( errorCount == 0 )
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_guessedWS1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_guessedWS1.cpp
deleted file mode 100644
index 61cb9ad..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_guessedWS1.cpp
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_guessedWS1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using QProblem class).
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[4*4] = { 1.0, 0.0, 0.0, 0.5, 
-	                  0.0, 1.0, 0.0, 0.0,
-	                  0.0, 0.0, 1.0, 0.0,
-	                  0.5, 0.0, 0.0, 1.0 };
-	real_t A[3*4] = { 1.0, 1.0, 0.0, 0.0,
-	                  1.0, 1.0, 1.0, 0.0,
-	                  1.0, 1.0, 1.0, 1.0 };
-	real_t g[4] = { 1.5, 1.0, -1.0, -1.0 };
-	real_t lb[4] = { 0.5, -2.0, 0.0, 0.0 };
-	real_t ub[4] = { 1.0, 2.0, 1.0, 0.5 };
-	real_t lbA[3] = { -1.0, -1.0, -1.0 };
-	real_t ubA[3] = { 0.0, 0.25, 1.0 };
-
-	
-
-	/* Setting up QProblem object. */
-	QProblem example( 4,3 );
-
-	Options options;
-	example.setOptions( options );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[4];
-	real_t yOpt[4+3];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	print( xOpt,4,"xOpt" );
-	print( yOpt,4+3,"yOpt" );
-	printf( "objVal = %e\n\n", example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-	/* Solve first QP again (with optimal guess for working set). */
-	Bounds prevBounds;
-	Constraints prevConstraints;
-	
-	example.getBounds( prevBounds );
-	example.getConstraints( prevConstraints );
-
-	nWSR = 10;
-	example.hotstart( g,lb,ub,lbA,ubA, nWSR,0,&prevBounds,&prevConstraints );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	print( xOpt,4,"xOpt" );
-	print( yOpt,4+3,"yOpt" );
-	printf( "objVal = %e\n\n", example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-	/* Solve first QP again (with inaccurate guess for working set). */
-	prevBounds.print();
-	prevBounds.rotate(1);
-	//prevBounds.moveFixedToFree(0);
-	prevBounds.print();
-
-	prevConstraints.print();
-	//prevConstraints.moveInactiveToActive(0,ST_LOWER);
-	prevConstraints.moveActiveToInactive(1);
-	prevConstraints.print();
-
-	nWSR = 10;
-	example.hotstart( g,lb,ub,lbA,ubA, nWSR,0,&prevBounds,&prevConstraints );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	print( xOpt,4,"xOpt" );
-	print( yOpt,4+3,"yOpt" );
-	printf( "objVal = %e\n\n", example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_hs268.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_hs268.cpp
deleted file mode 100644
index eb0a3f7..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_hs268.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_hs268.cpp
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2010-2015
- *
- *	Unit test running all benchmark examples stored in problems directory.
- */
-
-
-
-#include <dirent.h>
-#include <cstring>
-#include <cstdlib>
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Run benchmark examples. */
-int main( int argc, char *argv[] )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* 1) Define benchmark arguments. */
-	BooleanType isSparse = BT_FALSE;
-	//BooleanType isSparse = BT_TRUE;
-	Options options;
- 	options.setToDefault();
-	//options.setToMPC();
-	//options.setToReliable();
-	//options.printLevel = PL_LOW;
-	//options.printLevel = PL_MEDIUM;
-	options.printLevel = PL_TABULAR;
-
-
-	int_t nWSR;
-	int_t npass = 0;
-	real_t maxCPUtime; /* seconds */
-	real_t maxStationarity = 0.0, maxFeasibility = 0.0, maxComplementarity = 0.0;
-
-	char oqpProblem[MAX_STRING_LENGTH];
-	char problem[] = "HS268";
-	returnValue returnvalue;
-
-	
-	/* 3) Run benchmark. */
-	fprintf(stdFile, "%-10s ", problem);
-	fflush(stdFile);
-
-	snprintf(oqpProblem, MAX_STRING_LENGTH, "../testing/cpp/data/problems/%s/", problem);
-	maxCPUtime = 100.0;
-	nWSR = 100;
-
-	returnvalue = runOqpBenchmark(	oqpProblem, isSparse, options,
-									nWSR, maxCPUtime, maxStationarity, maxFeasibility, maxComplementarity 
-									);
-
-	if(returnvalue == SUCCESSFUL_RETURN) {
-		npass += 1;
-	}
-
-	QPOASES_TEST_FOR_TRUE( npass >= 1 );
-
-	printf( "\n" );
-	printf( "stat:  %e\n", maxStationarity    );
-	printf( "feas:  %e\n", maxFeasibility     );
-	printf( "cmpl:  %e\n", maxComplementarity );
-
-	QPOASES_TEST_FOR_TOL( maxStationarity,    1e-11 );
-	QPOASES_TEST_FOR_TOL( maxFeasibility,     1e-14 );
-	QPOASES_TEST_FOR_TOL( maxComplementarity, 1e-14 );
-
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_indexlist.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_indexlist.cpp
deleted file mode 100644
index 9c80f92..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_indexlist.cpp
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_indexlist.cpp
- *	\author Andreas Potschka, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2010-2015
- *
- *	Unit test for Indexlist class.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Test Indexlist sorting */
-int main()
-{
-	USING_NAMESPACE_QPOASES
-
-	Indexlist il(10);
-	int_t i, *numbers;
-
-	il.addNumber(1);
-	il.addNumber(3);
-	il.addNumber(5);
-	il.addNumber(2);
-	il.addNumber(4);
-	il.addNumber(0);
-	il.addNumber(7);
-	il.addNumber(6);
-	il.addNumber(8);
-	il.addNumber(9);
-
-	il.getNumberArray(&numbers);
-	fprintf(stdFile, "Unsorted numbers: ");
-	for (i = 0; i < 10; i++)
-		fprintf(stdFile, " %2d", (int)(numbers[i]) );
-	fprintf(stdFile, "\n");
-
-	fprintf(stdFile, "Unsorted index of number 0: %3d\n", (int)(il.getIndex(0)) );
-
-	QPOASES_TEST_FOR_TRUE( il.getIndex(0) == 5 )
-
-	il.removeNumber(5);
-	fprintf(stdFile, "Unsorted index of (removed) number 5: %3d\n", (int)(il.getIndex(5)) );
-
-	QPOASES_TEST_FOR_TRUE( il.getIndex(5) == -1 )
-
-	il.getNumberArray(&numbers);
-	fprintf(stdFile, "Unsorted numbers: ");
-	for (i = 0; i < 9; i++)
-		fprintf(stdFile, " %2d", (int)(numbers[i]) );
-	fprintf(stdFile, "\n");
-
-	il.swapNumbers(2, 7);
-
-	il.getNumberArray(&numbers);
-	fprintf(stdFile, "Unsorted numbers: ");
-	for (i = 0; i < 9; i++)
-		fprintf(stdFile, " %2d", (int)(numbers[i]) );
-	fprintf(stdFile, "\n");
-
-	QPOASES_TEST_FOR_TRUE( numbers[2] == 7 )
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_infeasible1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_infeasible1.cpp
deleted file mode 100644
index 85289e9..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_infeasible1.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_infeasible1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2015
- *
- *	Example to test occurence of infeasible QP.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[5*5] = {	1.224642131370767e+01, 2.908638763113702e+00, 0.0, 0.0, 0.0,
-						2.908638763113702e+00, 2.497106275003180e+00, 0.0, 0.0, 0.0,
-						0.0, 0.0, 1.0, 0.0, 0.0,
-						0.0, 0.0, 0.0, 5.158460640334052e-02, 4.723556059962540e-02,
-						0.0, 0.0, 0.0, 4.723556059962540e-02, 4.325317843302175e-02 };
-	real_t A[2*5] = { 	-1.404358970692652e+00, -2.556613491156063e+00, 3.202524559238066e+00, -1.0, 0.0,
-						6.587910295430314e-01, -5.349454475937998e-01, 4.391976356955536e-01, 0.0, -1.0 };
-	real_t g[5] = { 	2.474135331302147e+01,
-						5.857286430296258e+00,
-						2.359382646348721e-01,
-						1.721047069188781e-01,
-						1.575947337774199e-01 };
-	real_t lb[5] = {   5.0,  5.0,    8.0,   9.0,   5.0 };
-	real_t ub[5] = {  10.0,  10.0,  10.0,  10.0,  10.0 };
-	real_t lbA[2] = { 1.643135416077167e+00, 1.056813028189597e+00 };
-	real_t ubA[2] = { 1.643135416077167e+00, 1.056813028189597e+00 };
-
-	/* Setting up QProblem object. */
-	QProblem example( 5,2 );
-
-	Options options;
- 	//options.enableFlippingBounds = BT_FALSE;
-	//options.enableEqualities = BT_TRUE;
-	//options.initialStatusBounds = ST_INACTIVE;
-	example.setOptions( options );
-	example.setPrintLevel( PL_NONE );
-	
-	/* Solve first QP. */
-	returnValue retVal;
-	int_t simpleStatus = -1;
-
-	int_t nWSR = 10;
-	retVal = example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-	simpleStatus = getSimpleStatus( retVal,BT_TRUE );
-
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[5];
-	real_t yOpt[5+2];
-	
-	printf( "getPrimalSolution = %d\n", example.getPrimalSolution( xOpt ) );
-	printf( "getDualSolution   = %d\n", example.getDualSolution( yOpt ) );
-	printf( "\nxOpt = [ %e, %e, %e, %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],xOpt[2],xOpt[3],xOpt[4],example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	
-	getKktViolation( 5,2, H,g,A,lb,ub,lbA,ubA, xOpt,yOpt, stat,feas,cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-	
-	QPOASES_TEST_FOR_TRUE( simpleStatus == -2 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_janick1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_janick1.cpp
deleted file mode 100644
index ea69968..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_janick1.cpp
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_janick1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- *
- *	Example that causes troubles when hotstarting.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-#include <stdio.h>
-
-
-//#define __MAKE_POS_DEF__
-#undef __MAKE_POS_DEF__
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t nWSR = 100;
-	/* Setting up QProblem object. */
-	SQProblem example( 11,3 );
-
-	Options options;
-	options.setToFast();
-	//options.setToDefault();
-	//options.initialStatusBounds = qpOASES::ST_INACTIVE;
-	example.setOptions( options );
-
-
-	/* Setup data of first QP. */
-	real_t H[11*11] = {
-	6.20100988531485e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-7.43268431723266e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 5.41188294952735e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304826562310e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.01000000000000e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-7.43268431723266e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304826562310e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.73544778892019e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+01
-	};
-	real_t g[11] =	{
-	-1.28196485091041e-07,	 1.13322235104306e-08,	 4.52417455660281e-06,	 1.95881304363781e-07,	 1.61991589634459e-06,	 2.69786724710014e-09,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.18185813270785e+02,	 9.58903285459640e-06,	 3.82276791847511e-06
-	};
-	real_t zLow[11] =	{
-	-1.07876236159966e+01,	-1.00000000002784e+12,	-1.00000000000000e+12,	 0.00000000000000e+00,	-7.00000000000000e+00,	-2.60479553037772e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-4.50000000000000e+01,	-1.00000000000000e+12
-	};
-	real_t zUpp[11] =	{
-	9.99999999989212e+11,	 9.99999999972157e+11,	 1.00000000000000e+12,	 4.68471854329546e+01,	 7.00000000000000e+00,	 9.99999999997395e+11,	 1.00000000000000e+12,	 1.00000000000000e+12,	 0.00000000000000e+00,	 4.50000000000000e+01,	 1.00000000000000e+12
-	};
-	real_t D[11*3] =	{
-	1.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-1.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-1.00000000000000e-02,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00
-	};
-	real_t dLow[3] =	{
-	-1.00000000000000e+12,	-1.00000000000000e+12,	-1.00000000000000e+12
-	};
-	real_t dUpp[3] =	{
-	2.12376384003361e-01,	 4.78762361599664e+00,	 8.95204469622285e-01
-	};
-
-	#ifdef __MAKE_POS_DEF__
-	H[9*11+9] += 30;
-	#endif
-	returnValue status = example.init( H,g,D,zLow,zUpp,dLow,dUpp, nWSR );
-	printf("\nqpOASES_status = %d\n", (int)status );
-
-	/* Get and print solution of first QP. */
-	real_t xOpt[11];
-	real_t yOpt[11+3];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf("first QP:\n");
-	for (int_t ii =0; ii<11; ++ii )	{
-		printf("x[%d] = %.3e\n", (int)ii, xOpt[ii]);
-	}
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "\nstat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-9 );
-	QPOASES_TEST_FOR_TOL( feas,1e-7 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-
-	nWSR = 100;
-
-	/* Setup data of second QP. */
-	real_t H2[11*11] = {
-	6.20100988531485e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-7.43268433147671e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 5.41188294952735e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304827446359e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.01000000000000e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-7.43268433147671e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304827446359e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.73544778550554e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+01
-	};
-	real_t g2[11] =	{
-	-6.57752219998813e-04,	 3.61759517784935e-04,	-7.51224940044046e-05,	 6.01232615232452e-04,	 1.23562395380546e-04,	 4.59040118744990e-05,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.18185813270785e+02,	 3.38813178901720e-21,	 0.00000000000000e+00
-	};
-	real_t zLow2[11] =	{
-	-2.41857058824735e-08,	-2.77410094895458e-10,	-9.90563843681406e-09,	-3.85694249871449e-08,	 4.50633213817586e-14,	-2.22044604925031e-15,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-4.49999952054836e+01,	-1.00000000000000e+12
-	};
-	real_t zUpp2[11] =	{
-	-2.41857058824735e-08,	-2.77410094895458e-10,	-9.90563843681406e-09,	-3.85694249871449e-08,	 4.50633213817586e-14,	-2.22044604925031e-15,	 1.00000000000000e+12,	 1.00000000000000e+12,	 0.00000000000000e+00,	 4.50000047945164e+01,	 1.00000000000000e+12,
-	};
-	real_t D2[11*3] =	{
-	1.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-1.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-1.00000000000000e-02,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00
-	};
-	real_t dLow2[3] =	{
-	-1.00000000000000e+12,	-1.00000000000000e+12,	-1.00000000000000e+12
-	};
-	real_t dUpp2[3] =	{
-	2.12376363329877e-01,	 4.78762363667012e+00,	 8.95204496600957e-01
-	};
-	#ifdef __MAKE_POS_DEF__
-	H2[9*11+9] += 30;
-	#endif
-
-
-	status = example.hotstart( H2,g2,D2,zLow2,zUpp2,dLow2,dUpp2, nWSR );
-	printf("qpOASES_status = %d\n", (int)status );
-
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf("second QP:\n");
-	for (int_t ii =0; ii<11; ++ii )	{
-		printf("x[%d] = %.3e\n", (int)ii, xOpt[ii]);
-	}
-
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-9 );
-	QPOASES_TEST_FOR_TOL( feas,1e-7 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-12 );
-
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_janick2.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_janick2.cpp
deleted file mode 100644
index c1c6b5e..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_janick2.cpp
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_janick2.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- *
- *	Example that causes troubles when hotstarting.
- */
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-#include <stdio.h>
-
-#define __MAKE_POS_DEF__
-// #undef __MAKE_POS_DEF__
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t nWSR = 100;
-	/* Setting up QProblem object. */
-	SQProblem example( 11,3 );
-
-	Options options;
-	options.setToFast();
-// 	options.setToDefault();
-	options.initialStatusBounds = REFER_NAMESPACE_QPOASES ST_INACTIVE;
-
-	//options.terminationTolerance = 1.e-12;
-	options.initialStatusBounds = REFER_NAMESPACE_QPOASES ST_INACTIVE;
-	//options.enableFarBounds = REFER_NAMESPACE_QPOASES BT_FALSE;
-	//options.enableRegularisation = REFER_NAMESPACE_QPOASES BT_FALSE;
-
-	example.setOptions( options );
-
-
-	/* Setup data of first QP. */
-	real_t H[11*11] = {
-	 6.20100988531485e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-7.43268431723266e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 5.41188294952735e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304826562310e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.01000000000000e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-7.43268431723266e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304826562310e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.73544778892019e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+01,
-	};
-	real_t g[11] =	{
-//	 9.13378607947379e-07,
-//	 0.00000000000000e+00,
-//	 0.00000000000000e+00,
-//	-1.12448469735682e-06,
-//	 0.00000000000000e+00,
-//	 0.00000000000000e+00,
-//	 0.00000000000000e+00,
-//	 0.00000000000000e+00,
-//	-1.18185650936822e+02,
-//	 0.00000000000000e+00,
-//	 0.00000000000000e+00,
-	 -6.93766478421491e-04,
-	  3.84943289898669e-04,
-	 -3.63779116055460e-05,
-	  6.38114176725135e-04,
-	  1.85797765355698e-04,
-	  6.21922122437904e-05,
-	  0.00000000000000e+00,
-	  0.00000000000000e+00,
-	 -1.18185758699839e+02,
-	  1.54357580390960e-05,
-	  5.39852809009711e-06,
-	};
-	real_t zLow[11] =	{
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	-4.50000000000000e+01,
-	-1.00000000000000e+12,
-	};
-	real_t zUpp[11] =	{
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 1.00000000000000e+12,
-	 1.00000000000000e+12,
-	 0.00000000000000e+00,
-	 4.50000000000000e+01,
-	 1.00000000000000e+12,
-	};
-	real_t D[11*3] =	{
-	 1.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-1.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-1.00000000000000e-02,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	};
-	real_t dLow[3] =	{
-	-1.00000000000000e+12,
-	-1.00000000000000e+12,
-	-1.00000000000000e+12,
-	};
-	real_t dUpp[3] =	{
-	 2.12376384003361e-01,
-	 4.78762361599664e+00,
-	 8.95204469622285e-01,
-	};
-
-
-	#ifdef __MAKE_POS_DEF__
-// 	H[9*11+9] += 30;
-	H[8*11+8] += 30;
-	#endif
-	returnValue status = example.init( H,g,D,zLow,zUpp,dLow,dUpp, nWSR );
-	printf("qpOASES_status = %d\n", (int)status );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[11];
-	real_t yOpt[11+3];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf("first QP:\n");
-	for (int_t ii =0; ii<11; ++ii )	{
-		printf("x[%d] = %.3e\n", (int)ii, xOpt[ii]);
-	}
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "\nstat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-9 );
-	QPOASES_TEST_FOR_TOL( feas,1e-7 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	nWSR = 100;
-
-	/* Setup data of second QP. */
-	real_t H2[11*11] = {
-	 6.20101055067033e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-3.84861780549400e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-7.43268533746787e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-3.84861780549400e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 5.41188396792859e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304896387257e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.01000000000000e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-7.43268533746787e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304896387257e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.73544780086860e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+01,
-	};
-	real_t g2[11] =	{
-	-8.92227256391600e-08,
-	 6.89531726031141e-08,
-	-1.91970120006650e-07,
-	 1.77206607789402e-07,
-	-3.83145267945144e-09,
-	-1.88284265021358e-08,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	-1.18185657392775e+02,
-	 1.45337027424899e-17,
-	-6.04156175796480e-20,
-	};
-	real_t zLow2[11] =	{
-	-1.07876236566374e+01,
-	-1.00000000002784e+12,
-	-1.00000000000000e+12,
-	-8.30554585107279e-08,
-	-7.00000003695781e+00,
-	-2.60479531522807e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	-4.50000000018062e+01,
-	-1.00000000000000e+12,
-	};
-	real_t zUpp2[11] =	{
-	 9.99999999989212e+11,
-	 9.99999999972157e+11,
-	 1.00000000000000e+12,
-	 4.68471853498991e+01,
-	 6.99999996304219e+00,
-	 9.99999999997395e+11,
-	 1.00000000000000e+12,
-	 1.00000000000000e+12,
-	 0.00000000000000e+00,
-	 4.49999999981938e+01,
-	 1.00000000000000e+12,
-	};
-	real_t D2[11*3] =	{
-	 1.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-1.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-1.00000000000000e-02,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	};
-	real_t dLow2[3] =	{
-	-1.00000000000000e+12,
-	-1.00000000000000e+12,
-	-1.00000000000000e+12,
-	};
-	real_t dUpp2[3] =	{
-	 2.12376343362616e-01,
-	 4.78762365663739e+00,
-	 8.95204684771929e-01,
-	};
-	#ifdef __MAKE_POS_DEF__
-	H2[8*11+8] += 30;
-// 	H2[9*11+9] += 30;
-	#endif
-
-
-	status = example.hotstart( H2,g2,D2,zLow2,zUpp2,dLow2,dUpp2, nWSR );
-	printf("qpOASES_status = %d\n", (int)status );
-
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf("second QP:\n");
-	for (int_t ii =0; ii<11; ++ii )	{
-		printf("x[%d] = %.3e\n", (int)ii, xOpt[ii]);
-	}
-	
-	printf( "\nQP objective value: %.3e\n", example.getObjVal() );
-
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "\nstat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-9 );
-	QPOASES_TEST_FOR_TOL( feas,1e-7 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices.cpp
deleted file mode 100644
index a5c2339..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices.cpp
+++ /dev/null
@@ -1,903 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_matrices.cpp
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2010-2015
- *
- *	Unit test for Matrix classes.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-
-/** Compare deviations when computing dot product. */
-int sumOfSquares()
-{
-	int_t i;
-
-	/* sum of first n squares */
-	const int_t N = 100;
-	real_t *av = new real_t[N];
-	real_t *aTv = new real_t[N];
-	real_t *bv = new real_t[N];
-	real_t c;
-
-	for (i = 0; i < N; i++) av[i] = i+1.0;
-	for (i = 0; i < N; i++) aTv[i] = i+1.0;
-	for (i = 0; i < N; i++) bv[i] = i+1.0;
-
-	DenseMatrix a(1, N, N, av);
-	DenseMatrix aT(N, 1, 1, aTv);
-
-	a.times(1, 1.0, bv, N, 0.0, &c, 1);
-	real_t err = c - (1.0/6.0)*N*(N+1)*(2*N+1);
-	fprintf(stdFile, "Dot product; Error in sum of first %d squares: %9.2e\n", (int)N, err );
-	
-	aT.transTimes(1, 1.0, bv, N, 0.0, &c, 1);
-	real_t errT = c - (1.0/6.0)*N*(N+1)*(2*N+1);
-	fprintf(stdFile, "Transpose; Error in sum of first %d squares: %9.2e\n", (int)N, errT);
-
-	delete[] bv;
-	aT.free ();	// or delete[] aTv;
-	a.free (); // or delete[] av;
-
-	QPOASES_TEST_FOR_TOL( err ,1e-10 )
-	QPOASES_TEST_FOR_TOL( errT,1e-10 )
-	
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying Hilbert matrix with its inverse. */
-int hilbert()
-{
-	int_t i, j;
-	real_t d, err;
-
-	/* permuted 4x4 Hilbert matrix, row major format */
-	real_t _Av[] = {1.0/3.0, 1.0, 0.5, 0.25,
-		0.25, 0.5, 1.0/3.0, 0.2,
-		0.2, 1.0/3.0, 0.25, 1.0/6.0,
-		1.0/6.0, 0.25, 0.2, 1.0/7.0};
-	/* and its inverse, column major format */
-	real_t Bv[] = {240, 16, -120, -140,
-		-2700, -120, 1200, 1680,
-		6480, 240, -2700, -4200,
-		-4200, -140, 1680, 2800};
-
-	/* result */
-	real_t *Av = new real_t[4*4];
-	real_t *Cv = new real_t[4*4];
-
-	DenseMatrix A(4, 4, 4, Av);
-
-	for (i = 0; i < 16; i++) Av[i] = _Av[i];
-
-	A.times(4, 1.0, Bv, 4, 0.0, Cv, 4);
-
-	err = 0.0;
-	for (j = 0; j < 4; j++)
-	{
-		for (i = 0; i < 4; i++)
-		{
-			d = getAbs(Cv[j*4+i] - static_cast<real_t>(i == j));
-			if (d > err) err = d;
-		}
-	}
-	fprintf(stdFile, "Hilbert; Deviation from identity: %9.2e\n", err);
-
-	delete[] Cv;
-	A.free ();	// or delete[] Av;
-
-	QPOASES_TEST_FOR_TOL( err,1e-12 )
-	
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying sub-matrices. */
-int submatrix()
-{
-	int_t i, j;
-	real_t d, err;
-
-	/* 2x3 transposed submatrix */
-	real_t _Asubv[] = {1.0/3.0, 0.25,
-		1.0, 0.5,
-		0.5, 1.0/3.0,
-		0.25, 0.2};
-	real_t Bsubv[] = {240, 16, -120, -140,
-		-2700, -120, 1200, 1680};
-	real_t Csubv[2*2];
-
-	real_t *Asubv = new real_t[2*4];
-
-	for (i = 0; i < 8; i++) Asubv[i] = _Asubv[i];
-
-	DenseMatrix Asub(4, 2, 2, Asubv);
-
-	Asub.transTimes(2, 1.0, Bsubv, 4, 0.0, Csubv, 2);
-
-	err = 0.0;
-	for (j = 0; j < 2; j++)
-	{
-		for (i = 0; i < 2; i++)
-		{
-			d = getAbs(Csubv[j*2+i] - static_cast<real_t>(i == j));
-			if (d > err) err = d;
-		}
-	}
-	fprintf(stdFile, "Submatrix transpose; Deviation from identity: %9.2e\n", err);
-	
-	Asub.free ();	// or delete[] Asubv;
-
-	QPOASES_TEST_FOR_TOL( err,1e-13 )
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying dense sub-matrices via index lists. */
-int indexDenseSubmatrix()
-{
-	/* dense submatrices via index lists */
-	const int_t M = 20, N = 15, K = 5;
-	int_t i, j, k, m, n;
-	Indexlist rows(N), cols(N);
-	int_t *rNum, *cNum;
-	real_t err=0.0, errT=0.0;
-	real_t *Av, *X, *Y, *x, *y, *xc, *yc;
-
-	// prepare index lists
-	m = (M-3)/4;
-	n = (N-3)/4;
-	for (i = 0; i < m; i++) { rows.addNumber(M-1 - 2*i); rows.addNumber(2*i); }
-	for (i = 0; i < n; i++) { cols.addNumber(N-1 - 2*i); cols.addNumber(2*i); }
-	m *= 2;
-	n *= 2;
-
-	rows.getNumberArray(&rNum);
-	fprintf(stdFile, "Rows: ");
-	for (i = 0; i < m; i++) fprintf(stdFile, " %2d", (int)(rNum[i]) );
-	fprintf(stdFile, "\n");
-
-	cols.getNumberArray(&cNum);
-	fprintf(stdFile, "Cols: ");
-	for (i = 0; i < n; i++) fprintf(stdFile, " %2d", (int)(cNum[i]) );
-	fprintf(stdFile, "\n");
-
-	// prepare input matrices
-	Av = new real_t[M*N];
-	X = new real_t[n*K];
-	Y = new real_t[m*K];
-	x = new real_t[n*K];
-	y = new real_t[m*K];
-	xc = new real_t[n*K];
-	yc = new real_t[m*K];
-
-	DenseMatrix A(M, N, N, Av);
-	for (i = 0; i < M*N; i++) Av[i] = -0.5*N*M + (real_t)i;
-	for (i = 0; i < n*K; i++) X[i] = 1.0 / (real_t)(i+1);
-	for (i = 0; i < m*K; i++) Y[i] = 1.0 / (real_t)(i+1);
-
-	// multiply
-	A.times(&rows, &cols, K, 1.0, X, n, 0.0, y, m);
-
-	// check result
-	for (j = 0; j < m; j++)
-	{
-		for (k = 0; k < K; k++)
-		{
-			yc[j+k*m] = -y[j+k*m];
-			for (i = 0; i < n; i++)
-				yc[j+k*m] += Av[cNum[i]+rNum[j]*N] * X[i+k*n];
-			if (getAbs(yc[j+k*m]) > err) err = getAbs(yc[j+k*m]);
-		}
-	}
-	fprintf(stdFile, "Indexlist submatrix; error: %9.2e\n", err);
-
-	// transpose multiply
-	A.transTimes(&rows, &cols, K, 1.0, Y, m, 0.0, x, n);
-
-	// check result
-	errT = 0.0;
-	for (j = 0; j < n; j++)
-	{
-		for (k = 0; k < K; k++)
-		{
-			xc[j+k*n] = -x[j+k*n];
-			for (i = 0; i < m; i++)
-				xc[j+k*n] += Av[cNum[j]+rNum[i]*N] * Y[i+k*m];
-			if (getAbs(xc[j+k*n]) > errT) errT = getAbs(xc[j+k*n]);
-		}
-	}
-	fprintf(stdFile, "Indexlist transpose submatrix; error: %9.2e\n", errT);
-
-	// check result
-
-	// clean up
-	delete[] yc;
-	delete[] xc;
-	delete[] y;
-	delete[] x;
-	delete[] Y;
-	delete[] X;
-	A.free ();	// or delete[] Av;
-
-	QPOASES_TEST_FOR_TOL( err ,1e-13 )
-	QPOASES_TEST_FOR_TOL( errT,1e-14 )
-
-	return TEST_PASSED;
-}
-
-
-/** Obtain column of sparse matrix. */
-int spGetCol()
-{
-	long j, i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[4];
-	real_t *val = new real_t[10];
-	real_t *col = new real_t[4];
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  6 ]
-	 *  [  1  0  7 ]
-	 *  [  2  0  8 ]
-	 *  [  0  4  9 ]
-	 *  [  0  5 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 5; jc[3] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; ir[3] = 3; ir[4] = 4;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; ir[8] = 3; ir[9] = 4;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix A(5, 3, ir, jc, val);
-
-	Indexlist rows(4);
-
-	rows.addNumber(2);
-	rows.addNumber(4);
-	rows.addNumber(3);
-	rows.addNumber(0);
-
-	/* Indexed matrix:
-	 *
-	 *  [  2  0  8 ]
-	 *  [  0  5 10 ]
-	 *  [  0  4  9 ]
-	 *  [  0  3  6 ]
-	 */
-
-	for (j = 0; j < 3; j++)
-	{
-		fprintf(stdFile, "Column %ld:\n", j);
-		A.getCol( (int_t)j, &rows, 1.0, col );
-		for (i = 0; i < 4; i++)
-			fprintf(stdFile, " %3.0f\n", col[i]);
-	}
-				
-	delete[] col;
-	A.free ();	// or delete[] val,jc,ir;
-
-	return TEST_PASSED;
-}
-
-
-/** Obtain row of sparse matrix. */
-int spGetRow()
-{
-	long j, i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[6];
-	real_t *val = new real_t[10];
-	real_t *row = new real_t[4];
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  4  6  0 ]
-	 *  [  1  0  0  7  9 ]
-	 *  [  2  0  5  8 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 3; jc[3] = 5; jc[4] = 8; jc[5] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; 
-	ir[3] = 0; ir[4] = 2;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; 
-	ir[8] = 1; ir[9] = 2;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix A(3, 4, ir, jc, val);
-
-	Indexlist cols(4);
-
-	cols.addNumber(2);
-	cols.addNumber(4);
-	cols.addNumber(3);
-	cols.addNumber(1);
-
-	/* Indexed matrix:
-	 *
-	 * [  4  0  6  3 ]
-	 * [  0  9  7  0 ]
-	 * [  5 10  8  0 ]
-	 */
-
-	for (j = 0; j < 3; j++)
-	{
-		A.getRow( (int_t)j, &cols, 1.0, row );
-		for (i = 0; i < 4; i++)
-			fprintf(stdFile, " %3.0f", row[i]);
-		fprintf(stdFile, "\n");
-	}
-				
-	delete[] row;
-	A.free ();
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying sparse matrix. */
-int spTimes()
-{
-	long i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[6];
-	real_t *val = new real_t[10];
-
-	real_t *x = new real_t[5*2];
-	real_t *y = new real_t[3*2];
-
-	real_t Ax[] = {-23, -11, -26, 42, 74, 99};
-	real_t ATy[] = {-63, -69, -222, -423, -359, 272, 126, 663, 1562, 1656};
-	real_t err=0.0, errT=0.0;
-
-	for (i = 0; i < 10; i++) x[i] = -4.0 + (double)i;
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  4  6  0 ]
-	 *  [  1  0  0  7  9 ]
-	 *  [  2  0  5  8 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 3; jc[3] = 5; jc[4] = 8; jc[5] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; 
-	ir[3] = 0; ir[4] = 2;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; 
-	ir[8] = 1; ir[9] = 2;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix A(3, 5, ir, jc, val);	// reference to ir, jc, val
-
-	A.times(2, 1.0, x, 5, 0.0, y, 3);
-	
-	for (i = 0; i < 6; i++)
-		if (getAbs(y[i] - Ax[i]) > err) err = getAbs(y[i] - Ax[i]);
-	fprintf(stdFile, "Error in sparse A*x: %9.2e\n", err);
-
-	A.transTimes(2, 1.0, y, 3, 0.0, x, 5);
-
-	errT = 0.0;
-	for (i = 0; i < 10; i++)
-		if (getAbs(x[i] - ATy[i]) > errT) errT = getAbs(x[i] - ATy[i]);
-	fprintf(stdFile, "Error in sparse A'*x: %9.2e\n", errT);
-
-	A.free ();	// or delete[] val,ir,jc
-	delete[] y;
-	delete[] x;
-
-	QPOASES_TEST_FOR_TOL( err ,1e-15 )
-	QPOASES_TEST_FOR_TOL( errT,1e-15 )
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying sparse matrix via index lists. */
-int spIndTimes()
-{
-	const long N = 4;
-	long i, j;
-	long nRows = 2 * N + 1;
-	long nCols = N;
-	long nnz = 3 * N;
-	sparse_int_t *ir = new sparse_int_t[nnz];
-	sparse_int_t *jc = new sparse_int_t[nCols+1];
-	real_t *val = new real_t[nnz];
-	real_t *xc = new real_t[3*2];
-	real_t *yc = new real_t[4*2];
-	real_t Ax[] = {0.31, 0.05, 0.06, 0.30, 0.76, 0.20, 0.24, 0.60};
-	real_t ATy[] = {0.278, 0.000, 0.548, 0.776, 0.000, 1.208};
-	real_t err=0.0, errT=0.0;
-
-	Indexlist rows(4), cols(3), allcols( (int_t)nCols );
-
-	rows.addNumber(2);
-	rows.addNumber(4);
-	rows.addNumber(3);
-	rows.addNumber(0);
-
-	cols.addNumber(1);
-	cols.addNumber(3);
-	cols.addNumber(0);
-
-	for (i = 0; i < nCols; i++) 
-		allcols.addNumber( (int_t)i );
-
-	// build test matrix
-	for (i = 0; i <= N; i++) jc[i] = (sparse_int_t)(3*i);
-	for (j = 0; j < N; j++) 
-		for (i = 0; i < 3; i++)
-		{
-			ir[j*3+i] = (sparse_int_t)(2*j + i);
-			val[j*3+i] = 1.0 - 0.1 * (double)(j*3+i);
-		}
-	SparseMatrix A( (int_t)nRows, (int_t)nCols, ir, jc, val );
-
-	fprintf(stdFile, "Test matrix A =\n");
-	for (j = 0; j < nRows; j++)
-	{
-		A.getRow( (int_t)j, &allcols, 1.0, xc );
-		for (i = 0; i < nCols; i++)
-			fprintf(stdFile, "%6.2f", xc[i]);
-		fprintf(stdFile, "\n");
-	}
-
-	for (i = 0; i < 6; i++)
-		xc[i] = (1.0 + (double)i) * 0.1;
-
-	A.times(&rows, &cols, 2, 1.0, xc, 3, 0.0, yc, 4, BT_TRUE);
-
-	for (i = 0; i < 8; i++)
-		if (getAbs(yc[i] - Ax[i]) > err)
-			err = getAbs(yc[i] - Ax[i]);
-	fprintf(stdFile, "Error in sparse indexed A*x: %9.2e\n", err);
-
-	A.transTimes(&rows, &cols, 2, 1.0, yc, 4, 0.0, xc, 3);
-	errT = 0.0;
-	for (i = 0; i < 6; i++)
-		if (getAbs(xc[i] - ATy[i]) > errT)
-			errT = getAbs(xc[i] - ATy[i]);
-	fprintf(stdFile, "Error in sparse indexed A'*y: %9.2e\n", errT);
-
-	delete[] xc;
-	delete[] yc;
-	A.free ();
-
-	QPOASES_TEST_FOR_TOL( err ,1e-15 )
-	QPOASES_TEST_FOR_TOL( errT,1e-15 )
-
-	return TEST_PASSED;
-}
-
-
-/** Obtain column of sparse row matrix. */
-int sprGetCol()
-{
-	long j, i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[4];
-	real_t *val = new real_t[10];
-	real_t *col = new real_t[4];
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  6 ]
-	 *  [  1  0  7 ]
-	 *  [  2  0  8 ]
-	 *  [  0  4  9 ]
-	 *  [  0  5 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 5; jc[3] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; ir[3] = 3; ir[4] = 4;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; ir[8] = 3; ir[9] = 4;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix Ac(5, 3, ir, jc, val);
-	real_t *Acv = Ac.full(); // row major format
-	SparseMatrixRow A(5, 3, 3, Acv);
-	delete[] Acv;
-	Ac.free ();	// or delete[] val,jc,ir;
-
-	Indexlist rows(4);
-
-	rows.addNumber(2);
-	rows.addNumber(4);
-	rows.addNumber(3);
-	rows.addNumber(0);
-
-	/* Indexed matrix:
-	 *
-	 *  [  2  0  8 ]
-	 *  [  0  5 10 ]
-	 *  [  0  4  9 ]
-	 *  [  0  3  6 ]
-	 */
-
-	for (j = 0; j < 3; j++)
-	{
-		fprintf(stdFile, "Column %ld:\n", j);
-		A.getCol( (int_t)j, &rows, 1.0, col );
-		for (i = 0; i < 4; i++)
-			fprintf(stdFile, " %3.0f\n", col[i]);
-	}
-				
-	delete[] col;
-	A.free ();	// or delete[] val,jc,ir;
-
-	return TEST_PASSED;
-}
-
-
-/** Obtain row of sparse row matrix. */
-int sprGetRow()
-{
-	long j, i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[6];
-	real_t *val = new real_t[10];
-	real_t *row = new real_t[4];
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  4  6  0 ]
-	 *  [  1  0  0  7  9 ]
-	 *  [  2  0  5  8 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 3; jc[3] = 5; jc[4] = 8; jc[5] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; 
-	ir[3] = 0; ir[4] = 2;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; 
-	ir[8] = 1; ir[9] = 2;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix Ac(3, 5, ir, jc, val);
-	real_t *Acv = Ac.full(); // row major format
-	SparseMatrixRow A(3, 5, 5, Acv);
-	delete[] Acv;
-	Ac.free ();	// or delete[] val,jc,ir;
-
-	Indexlist cols(4);
-
-	cols.addNumber(2);
-	cols.addNumber(4);
-	cols.addNumber(3);
-	cols.addNumber(1);
-
-	/* Indexed matrix:
-	 *
-	 * [  4  0  6  3 ]
-	 * [  0  9  7  0 ]
-	 * [  5 10  8  0 ]
-	 */
-
-	for (j = 0; j < 3; j++)
-	{
-		A.getRow( (int_t)j, &cols, 1.0, row );
-		for (i = 0; i < 4; i++)
-			fprintf(stdFile, " %3.0f", row[i]);
-		fprintf(stdFile, "\n");
-	}
-				
-	delete[] row;
-	A.free ();
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying sparse row matrix. */
-int sprTimes()
-{
-	long i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[6];
-	real_t *val = new real_t[10];
-
-	real_t *x = new real_t[5*2];
-	real_t *y = new real_t[3*2];
-
-	real_t Ax[] = {-23, -11, -26, 42, 74, 99};
-	real_t ATy[] = {-63, -69, -222, -423, -359, 272, 126, 663, 1562, 1656};
-	real_t err=0.0, errT=0.0;
-
-	for (i = 0; i < 10; i++) x[i] = -4.0 + (double)i;
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  4  6  0 ]
-	 *  [  1  0  0  7  9 ]
-	 *  [  2  0  5  8 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 3; jc[3] = 5; jc[4] = 8; jc[5] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; 
-	ir[3] = 0; ir[4] = 2;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; 
-	ir[8] = 1; ir[9] = 2;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix Ac(3, 5, ir, jc, val);	// reference to ir, jc, val
-	real_t *Acv = Ac.full(); // row major format
-	SparseMatrixRow A(3, 5, 5, Acv);
-	delete[] Acv;
-	Ac.free ();	// or delete[] val,jc,ir;
-
-	A.times(2, 1.0, x, 5, 0.0, y, 3);
-	
-	for (i = 0; i < 6; i++)
-		if (getAbs(y[i] - Ax[i]) > err) err = getAbs(y[i] - Ax[i]);
-	fprintf(stdFile, "Error in sparse A*x: %9.2e\n", err);
-
-	A.transTimes(2, 1.0, y, 3, 0.0, x, 5);
-
-	errT = 0.0;
-	for (i = 0; i < 10; i++)
-		if (getAbs(x[i] - ATy[i]) > errT) errT = getAbs(x[i] - ATy[i]);
-	fprintf(stdFile, "Error in sparse A'*x: %9.2e\n", errT);
-
-	A.free ();	// or delete[] val,ir,jc
-	delete[] y;
-	delete[] x;
-
-	QPOASES_TEST_FOR_TOL( err ,1e-15 )
-	QPOASES_TEST_FOR_TOL( errT,1e-15 )
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying sparse row matrix via index lists. */
-int sprIndTimes()
-{
-	const long N = 4;
-	long i, j;
-	long nRows = 2 * N + 1;
-	long nCols = N;
-	long nnz = 3 * N;
-	sparse_int_t *ir = new sparse_int_t[nnz];
-	sparse_int_t *jc = new sparse_int_t[nCols+1];
-	real_t *val = new real_t[nnz];
-	real_t *xc = new real_t[3*2];
-	real_t *yc = new real_t[4*2];
-	real_t Ax[] = {0.31, 0.05, 0.06, 0.30, 0.76, 0.20, 0.24, 0.60};
-	real_t ATy[] = {0.278, 0.000, 0.548, 0.776, 0.000, 1.208};
-	real_t err=0.0, errT=0.0;
-
-	Indexlist rows(4), cols(3), allcols( (int_t)nCols );
-
-	rows.addNumber(2);
-	rows.addNumber(4);
-	rows.addNumber(3);
-	rows.addNumber(0);
-
-	cols.addNumber(1);
-	cols.addNumber(3);
-	cols.addNumber(0);
-
-	for (i = 0; i < nCols; i++) 
-		allcols.addNumber( (int_t)i );
-
-	// build test matrix
-	for (i = 0; i <= N; i++) jc[i] = (sparse_int_t)(3*i);
-	for (j = 0; j < N; j++) 
-		for (i = 0; i < 3; i++)
-		{
-			ir[j*3+i] = (sparse_int_t)(2*j + i);
-			val[j*3+i] = 1.0 - 0.1 * (double)(j*3+i);
-		}
-	SparseMatrix Ac( (int_t)nRows, (int_t)nCols, ir, jc, val);
-	real_t *Acv = Ac.full(); // row major format
-	SparseMatrixRow A( (int_t)nRows, (int_t)nCols, (int_t)nCols, Acv);
-	delete[] Acv;
-	Ac.free ();	// or delete[] val,jc,ir;
-
-	fprintf(stdFile, "Test matrix A =\n");
-	for (j = 0; j < nRows; j++)
-	{
-		A.getRow( (int_t)j, &allcols, 1.0, xc );
-		for (i = 0; i < nCols; i++)
-			fprintf(stdFile, "%6.2f", xc[i]);
-		fprintf(stdFile, "\n");
-	}
-
-	for (i = 0; i < 6; i++)
-		xc[i] = (1.0 + (double)i) * 0.1;
-
-	A.times(&rows, &cols, 2, 1.0, xc, 3, 0.0, yc, 4, BT_TRUE);
-
-	for (i = 0; i < 8; i++)
-		if (getAbs(yc[i] - Ax[i]) > err)
-			err = getAbs(yc[i] - Ax[i]);
-	fprintf(stdFile, "Error in sparse indexed A*x: %9.2e\n", err);
-
-	A.transTimes(&rows, &cols, 2, 1.0, yc, 4, 0.0, xc, 3);
-	for (i = 0; i < 3; i++)
-	{
-		for (j = 0; j < 2; j++)
-			fprintf(stdFile, "%6.2f", ATy[i + j*3]);
-		fprintf(stdFile, "\n");
-	}
-	for (i = 0; i < 3; i++)
-	{
-		for (j = 0; j < 2; j++)
-			fprintf(stdFile, "%6.2f", xc[i + j*3]);
-		fprintf(stdFile, "\n");
-	}
-	for (i = 0; i < 6; i++)
-		if (getAbs(xc[i] - ATy[i]) > errT)
-			errT = getAbs(xc[i] - ATy[i]);
-	fprintf(stdFile, "Error in sparse indexed A'*y: %9.2e\n", errT);
-
-	delete[] xc;
-	delete[] yc;
-	A.free ();
-
-	QPOASES_TEST_FOR_TOL( err ,1e-15 )
-	QPOASES_TEST_FOR_TOL( errT,1e-15 )
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when using bilinear multiplication with dense matrix. */
-int symmetry()
-{
-	int_t i,j;
-	real_t *Hv = new real_t[6*6];
-	real_t *Z = new real_t[6*3];
-	real_t *ZHZd = new real_t[3*3];
-	real_t *ZHZs = new real_t[3*3];
-	real_t ZHZv[] = {0.144, 0.426, 0.708, 0.426, 1.500, 2.574, 0.708, 2.574, 4.440};
-	real_t err=0.0, errS=0.0;
-	SymDenseMat *Hd;
-	SymSparseMat *Hs;
-	Indexlist *cols = new Indexlist(6);
-
-	for (i = 0; i < 36; i++) Hv[i] = 0.0;
-	for (i = 0; i < 6; i++) Hv[i*7] = 1.0 - 0.1 * i;
-	for (i = 0; i < 5; i++) Hv[i*7+1] = Hv[i*7+6] = -0.1 * (i+1);
-
-	Hd = new SymDenseMat(6, 6, 6, Hv);	// deep-copy from Hv
-	Hs = new SymSparseMat(6, 6, 6, Hv);	// deep-copy from Hv
-	Hs->createDiagInfo();
-
-	for (i = 0; i < 6; ++i)
-	{
-		for (j = 0; j < 6; ++j)
-			fprintf (stdFile, "%3.3f ", Hv[i*6+j]);
-		fprintf (stdFile, "\n");
-	}
-	fprintf (stdFile, "\n");
-	
-	cols->addNumber(3);
-	cols->addNumber(0);
-	cols->addNumber(4);
-	cols->addNumber(1);
-	for (i = 0; i < 18; i++) Z[i] = 0.1 * (i+1);
-
-	fprintf (stdFile, "\n");
-	for (i = 0; i < 6; ++i)
-	{
-		for (j = 0; j < 3; ++j)
-			fprintf (stdFile, "%3.3f ", Z[i+j*6]);
-		fprintf (stdFile, "\n");
-	}
-	fprintf (stdFile, "\n");
-	
-	Hd->bilinear(cols, 3, Z, 6, ZHZd, 3);
-
-	for (i = 0; i < 9; i++)
-		if (getAbs(ZHZd[i] - ZHZv[i]) > err)
-			err = getAbs(ZHZd[i] - ZHZv[i]);
-	fprintf(stdFile, "Error in indexed dense bilinear form: %9.2e\n", err);
-
-	Hs->bilinear(cols, 3, Z, 6, ZHZs, 3);
-	
-	for (i = 0; i < 3; ++i)
-	{
-		for (j = 0; j < 3; ++j)
-			fprintf (stdFile, "%3.3f ", ZHZd[i*3+j]);
-		fprintf (stdFile, "\n");
-	}
-	fprintf (stdFile, "\n");
-
-	for (i = 0; i < 3; ++i)
-	{
-		for (j = 0; j < 3; ++j)
-			fprintf (stdFile, "%3.3f ", ZHZv[i*3+j]);
-		fprintf (stdFile, "\n");
-	}
-	fprintf (stdFile, "\n");
-
-	for (i = 0; i < 9; i++)
-		if (getAbs(ZHZs[i] - ZHZv[i]) > errS)
-			errS = getAbs(ZHZs[i] - ZHZv[i]);
-	fprintf(stdFile, "Error in indexed sparse bilinear form: %9.2e\n", errS);
-
-	delete cols;
-	delete Hs;
-	delete Hd;
-	delete[] ZHZs;
-	delete[] ZHZd;
-	delete[] Z;
-	delete[] Hv;
-
-	QPOASES_TEST_FOR_TOL( err ,1e-15 )
-	QPOASES_TEST_FOR_TOL( errS,1e-15 )
-
-	return TEST_PASSED;
-}
-
-
-/** Run various tests on matrix classes. */
-int main()
-{
-	int errorCount = TEST_PASSED;
-	
-	errorCount += sumOfSquares();
-	errorCount += hilbert();
-	errorCount += submatrix();
-	errorCount += indexDenseSubmatrix();
-
-	errorCount += spGetCol();
-	errorCount += spGetRow();
-	errorCount += spTimes();
-	errorCount += spIndTimes();
-
-	errorCount += sprGetCol();
-	errorCount += sprGetRow();
-	errorCount += sprTimes();
-	errorCount += sprIndTimes();
-
-	errorCount += symmetry();
-	
-	return errorCount;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices2.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices2.cpp
deleted file mode 100644
index ee9614f..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices2.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_matrices2.cpp
- *	\author Hans Joachim Ferreau,Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Unit test for Matrix classes.
- */
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-#include "test_qrecipe_data.hpp"
-
-
-/** Compare deviations when performing matrix operations. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-	
-	int_t i;
-
-	real_t errH=0.0, errA=0.0;
-	real_t v[180];
-	real_t resHs[180];
-	real_t resHd[180];
-	real_t resAs[91];
-	real_t resAd[91];
-	
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	SparseMatrix *A = new SparseMatrix(91, 180, A_ir, A_jc, A_val);
-
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	real_t* A_full = A->full();
-
-	//print( A_full,91,180 );
-
-
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-	DenseMatrix *Ad = new DenseMatrix(91,180,180,A_full);
-
-	for( i=0; i<180; ++i )
-		v[i] = 2.0 * ((real_t)rand()) / ((real_t)RAND_MAX) - 1.0;
-	
-	H ->times(1, 1.0, v, 180, 0.0, resHs, 180);
-	Hd->times(1, 1.0, v, 180, 0.0, resHd, 180);
-	
-	A ->times(1, 1.0, v, 180, 0.0, resAs, 91);
-	Ad->times(1, 1.0, v, 180, 0.0, resAd, 91);
-
-	
-	for ( i=0; i<180; ++i )
-		if ( getAbs(resHs[i] - resHd[i]) > errH)
-			errH = getAbs(resHs[i] - resHd[i]);
-	
-	fprintf(stdFile, "maximum difference in H*v: %9.2e\n", errH);
-	
-	
-	for ( i=0; i<91; ++i )
-		if ( getAbs(resAs[i] - resAd[i]) > errA)
-			errA = getAbs(resAs[i] - resAd[i]);
-	
-	fprintf(stdFile, "maximum difference in A*v: %9.2e\n", errA);
-
-	delete H;
-	delete A;
-	delete[] H_full;
-	delete[] A_full;
-	delete Hd;
-	delete Ad;
-
-	
-	QPOASES_TEST_FOR_TOL( errH,1e-13 )
-	QPOASES_TEST_FOR_TOL( errA,1e-13 )
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices3.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices3.cpp
deleted file mode 100644
index 9b002b0..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices3.cpp
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_matrices3.cpp
- *	\author Hans Joachim Ferreau,Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Unit test for Matrix classes.
- */
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-#include "test_qrecipe_data.hpp"
-
-
-/** Compare deviations when performing matrix operations. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-	
-	int_t i;
-
-	real_t errH=0.0;
-	real_t v[180];
-	real_t resHn[180];
-	real_t resHt[180];
-	
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-
-	for( i=0; i<180; ++i )
-		v[i] = 2.0 * ((real_t)rand()) / ((real_t)RAND_MAX) - 1.0;
-	
-	Hd->times(     1, 1.0, v, 180, 0.0, resHn, 180);
-	Hd->transTimes(1, 1.0, v, 180, 0.0, resHt, 180);
-	
-	for ( i=0; i<180; ++i )
-		if ( getAbs(resHn[i] - resHt[i]) > errH)
-			errH = getAbs(resHn[i] - resHt[i]);
-	
-	fprintf(stdFile, "maximum difference in H*v vs. H'*v: %9.2e\n", errH);
-	
-	delete H;
-	delete[] H_full;
-	delete Hd;
-	
-	
-	QPOASES_TEST_FOR_TOL( errH,1e-15 )
-	
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe.cpp
deleted file mode 100644
index 966f220..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe.cpp
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_qrecipe.cpp
- *	\author Andreas Potschka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-#include "test_qrecipe_data.hpp"
-
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	long i;
-	int_t nWSR;
-	real_t tic, toc;
-	real_t errP=0.0, errD=0.0;
-	real_t *x1 = new real_t[180];
-	real_t *y1 = new real_t[271];
-	real_t *x2 = new real_t[180];
-	real_t *y2 = new real_t[271];
-
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	SparseMatrix *A = new SparseMatrix(91, 180, A_ir, A_jc, A_val);
-
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	real_t* A_full = A->full();
-
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-	DenseMatrix *Ad = new DenseMatrix(91,180,180,A_full);
-
-	/* solve with dense matrices */
-	nWSR = 1000;
-	QProblem qrecipeD(180, 91);
-	tic = getCPUtime();
-	qrecipeD.init(Hd, g, Ad, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeD.getPrimalSolution(x1);
-	qrecipeD.getDualSolution(y1);
-
-	fprintf(stdFile, "Solved dense problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* Compute KKT tolerances */
-	real_t statD, feasD, cmplD;
-	SolutionAnalysis analyzerD;
-
-	analyzerD.getKktViolation( &qrecipeD, &statD,&feasD,&cmplD );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n\n", statD,feasD,cmplD );
-
-
-	/* solve with sparse matrices */
-	nWSR = 1000;
-	QProblem qrecipeS(180, 91);
-	tic = getCPUtime();
-	qrecipeS.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeS.getPrimalSolution(x2);
-	qrecipeS.getDualSolution(y2);
-
-	fprintf(stdFile, "Solved sparse problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-	
-	/* Compute KKT tolerances */
-	real_t statS, feasS, cmplS;
-	SolutionAnalysis analyzerS;
-
-	analyzerS.getKktViolation( &qrecipeS, &statS,&feasS,&cmplS );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n\n", statS,feasS,cmplS );
-
-	/* check distance of solutions */
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x2[i]) > errP)
-			errP = getAbs(x1[i] - x2[i]);
-	fprintf(stdFile, "Primal error: %9.2e\n", errP);
-
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y2[i]) > errD)
-			errD = getAbs(y1[i] - y2[i]);
-	fprintf(stdFile, "Dual error: %9.2e (might not be unique)\n", errD);
-
-	delete H;
-	delete A;
-	delete[] H_full;
-	delete[] A_full;
-	delete Hd;
-	delete Ad;
-
-	delete[] y2;
-	delete[] x2;
-	delete[] y1;
-	delete[] x1;
-
-	QPOASES_TEST_FOR_TOL( statD,1e-14 );
-	QPOASES_TEST_FOR_TOL( feasD,1e-14 );
-	QPOASES_TEST_FOR_TOL( cmplD,1e-13 );
-	
-	QPOASES_TEST_FOR_TOL( statS,1e-14 );
-	QPOASES_TEST_FOR_TOL( feasS,1e-14 );
-	QPOASES_TEST_FOR_TOL( cmplS,1e-13 );
-
-	QPOASES_TEST_FOR_TOL( errP,1e-13 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipeSchur.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipeSchur.cpp
deleted file mode 100644
index e5f9ff2..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipeSchur.cpp
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_qrecipeSchur.cpp
- *	\author Dennis Janka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- *	Comparison between nullspace factorization (dense and sparse) and
- *	Schur complement approach.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-#include "test_qrecipe_data.hpp"
-
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	long i;
-	int_t nWSR;
-	real_t errP1, errP2, errP3, errD1, errD2, errD3, tic, toc;
-	real_t *x1 = new real_t[180];
-	real_t *y1 = new real_t[271];
-	real_t *x2 = new real_t[180];
-	real_t *y2 = new real_t[271];
-	real_t *x3 = new real_t[180];
-	real_t *y3 = new real_t[271];
-
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	SparseMatrix *A = new SparseMatrix(91, 180, A_ir, A_jc, A_val);
-
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	real_t* A_full = A->full();
-
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-	DenseMatrix *Ad = new DenseMatrix(91,180,180,A_full);
-
-	/* solve with dense matrices */
-	nWSR = 1000;
-	QProblem qrecipeD(180, 91);
-	tic = getCPUtime();
-	qrecipeD.init(Hd, g, Ad, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeD.getPrimalSolution(x1);
-	qrecipeD.getDualSolution(y1);
-
-	fprintf(stdFile, "Solved dense problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* solve with sparse matrices (nullspace factorization) */
-	nWSR = 1000;
-	QProblem qrecipeS(180, 91);
-	tic = getCPUtime();
-	qrecipeS.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeS.getPrimalSolution(x2);
-	qrecipeS.getDualSolution(y2);
-
-	fprintf(stdFile, "Solved sparse problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* solve with sparse matrices (Schur complement) */
-	#ifndef SOLVER_NONE
-	nWSR = 1000;
-	SQProblemSchur qrecipeSchur(180, 91);
-	tic = getCPUtime();
-	qrecipeSchur.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeSchur.getPrimalSolution(x3);
-	qrecipeSchur.getDualSolution(y3);
-
-	fprintf(stdFile, "Solved sparse problem (Schur complement approach) in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-	#endif /* SOLVER_NONE */
-
-	/* check distance of solutions */
-	errP1 = 0.0;
-	errP2 = 0.0;
-	errP3 = 0.0;
-	#ifndef SOLVER_NONE
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x2[i]) > errP1)
-			errP1 = getAbs(x1[i] - x2[i]);
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x3[i]) > errP2)
-			errP2 = getAbs(x1[i] - x3[i]);
-	for (i = 0; i < 180; i++)
-		if (getAbs(x2[i] - x3[i]) > errP3)
-			errP3 = getAbs(x2[i] - x3[i]);
-	#endif /* SOLVER_NONE */
-	fprintf(stdFile, "Primal error (dense and sparse): %9.2e\n", errP1);
-	fprintf(stdFile, "Primal error (dense and Schur):  %9.2e\n", errP2);
-	fprintf(stdFile, "Primal error (sparse and Schur): %9.2e\n", errP3);
-
-	errD1 = 0.0;
-	errD2 = 0.0;
-	errD3 = 0.0;
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y2[i]) > errD1)
-			errD1 = getAbs(y1[i] - y2[i]);
-	#ifndef SOLVER_NONE
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y3[i]) > errD2)
-			errD2 = getAbs(y1[i] - y3[i]);
-	for (i = 0; i < 271; i++)
-		if (getAbs(y2[i] - y3[i]) > errD3)
-			errD3 = getAbs(y2[i] - y3[i]);
-	#endif /* SOLVER_NONE */
-	fprintf(stdFile, "Dual error (dense and sparse): %9.2e  (might not be unique)\n", errD1);
-	fprintf(stdFile, "Dual error (dense and Schur):  %9.2e  (might not be unique)\n", errD2);
-	fprintf(stdFile, "Dual error (sparse and Schur): %9.2e  (might not be unique)\n", errD3);
-
-	delete H;
-	delete A;
-	delete[] H_full;
-	delete[] A_full;
-	delete Hd;
-	delete Ad;
-
-	delete[] y3;
-	delete[] x3;
-	delete[] y2;
-	delete[] x2;
-	delete[] y1;
-	delete[] x1;
-
-	QPOASES_TEST_FOR_TOL( errP1,1e-13 );
-	QPOASES_TEST_FOR_TOL( errP2,1e-13 );
-	QPOASES_TEST_FOR_TOL( errP3,1e-13 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe_data.hpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe_data.hpp
deleted file mode 100644
index 70334a9..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe_data.hpp
+++ /dev/null
@@ -1,401 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_qrecipe.cpp
- *	\author Andreas Potschka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- */
-
-
-USING_NAMESPACE_QPOASES
-
-
-
-const real_t Inf = INFTY;
-
-sparse_int_t H_jc[] = { 0,  4,  8, 12, 16, 20, 20, 20, 20, 20, 20,
-	                   24, 28, 32, 36, 40, 40, 40, 40, 40, 40,
-					   44, 48, 52, 56, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
-					   64, 68, 72, 76, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80 };
-
-sparse_int_t H_ir[] = {
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38, 
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38, 
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38, 
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38};
-
-real_t H_val[] = {10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1,
-	1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 1,
-	10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 1, 10, 1,
-	1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10};
-
-sparse_int_t A_jc[] = {
-	  0,  10,  20,  30,  40,  50,  60,  70,  80,  90, 100, 110, 120,
-	130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270,
-	280, 290, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312,
-	313, 314, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 331,
-	333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361,
-	363, 365, 367, 369, 371, 373, 383, 393, 403, 405, 408, 410, 413, 415, 418,
-	420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448,
-	450, 452, 454, 456, 458, 460, 462, 472, 482, 492, 494, 497, 499, 502, 504,
-	507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535,
-	537, 539, 541, 543, 545, 547, 549, 551, 561, 571, 581, 583, 586, 588, 591,
-	593, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609,
-	610, 611, 612, 613, 614, 615, 616, 617, 618, 628, 638, 648, 650, 653, 655,
-	658, 660, 663};
-
-sparse_int_t A_ir[] = {0, 14, 35, 36, 71, 72, 85, 86, 87, 88, 1, 14, 35, 36, 71, 72, 85,
-	86, 87, 88, 2, 14, 35, 36, 71, 72, 85, 86, 87, 88, 3, 14, 35, 36, 71, 72,
-	85, 86, 87, 88, 4, 14, 35, 36, 71, 72, 85, 86, 87, 88, 5, 14, 35, 36, 71,
-	72, 85, 86, 87, 88, 6, 14, 35, 36, 71, 72, 85, 86, 87, 88, 7, 14, 35, 36,
-	71, 72, 85, 86, 87, 88, 8, 14, 35, 36, 71, 72, 85, 86, 87, 88, 9, 14, 35,
-	36, 71, 72, 85, 86, 87, 88, 0, 15, 37, 38, 69, 70, 79, 80, 81, 82, 1, 15,
-	37, 38, 69, 70, 79, 80, 81, 82, 2, 15, 37, 38, 69, 70, 79, 80, 81, 82, 3,
-	15, 37, 38, 69, 70, 79, 80, 81, 82, 4, 15, 37, 38, 69, 70, 79, 80, 81, 82,
-	5, 15, 37, 38, 69, 70, 79, 80, 81, 82, 6, 15, 37, 38, 69, 70, 79, 80, 81,
-	82, 7, 15, 37, 38, 69, 70, 79, 80, 81, 82, 8, 15, 37, 38, 69, 70, 79, 80,
-	81, 82, 9, 15, 37, 38, 69, 70, 79, 80, 81, 82, 0, 16, 39, 40, 67, 68, 73,
-	74, 75, 76, 1, 16, 39, 40, 67, 68, 73, 74, 75, 76, 2, 16, 39, 40, 67, 68,
-	73, 74, 75, 76, 3, 16, 39, 40, 67, 68, 73, 74, 75, 76, 4, 16, 39, 40, 67,
-	68, 73, 74, 75, 76, 5, 16, 39, 40, 67, 68, 73, 74, 75, 76, 6, 16, 39, 40,
-	67, 68, 73, 74, 75, 76, 7, 16, 39, 40, 67, 68, 73, 74, 75, 76, 8, 16, 39,
-	40, 67, 68, 73, 74, 75, 76, 9, 16, 39, 40, 67, 68, 73, 74, 75, 76, 10, 11,
-	12, 13, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 47, 48, 49, 50, 51,
-	52, 53, 54, 55, 56, 57, 47, 58, 48, 59, 49, 60, 50, 61, 51, 62, 52, 63, 53,
-	64, 54, 65, 55, 66, 46, 56, 45, 57, 47, 58, 48, 59, 49, 60, 50, 61, 51, 62,
-	52, 63, 53, 64, 54, 65, 55, 66, 46, 56, 45, 57, 10, 14, 71, 72, 85, 86, 87,
-	88, 89, 90, 11, 15, 69, 70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74,
-	75, 76, 77, 78, 35, 90, 36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78,
-	44, 58, 43, 59, 42, 60, 41, 61, 34, 62, 33, 63, 32, 64, 31, 65, 30, 66, 29,
-	46, 28, 45, 44, 58, 43, 59, 42, 60, 41, 61, 34, 62, 33, 63, 32, 64, 31, 65,
-	30, 66, 29, 46, 28, 45, 10, 14, 71, 72, 85, 86, 87, 88, 89, 90, 11, 15, 69,
-	70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74, 75, 76, 77, 78, 35, 90,
-	36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78, 27, 44, 26, 43, 25, 42,
-	24, 41, 23, 34, 22, 33, 21, 32, 20, 31, 19, 30, 18, 29, 17, 28, 27, 44, 26,
-	43, 25, 42, 24, 41, 23, 34, 22, 33, 21, 32, 20, 31, 19, 30, 18, 29, 17, 28,
-	10, 14, 71, 72, 85, 86, 87, 88, 89, 90, 11, 15, 69, 70, 79, 80, 81, 82, 83,
-	84, 12, 16, 67, 68, 73, 74, 75, 76, 77, 78, 35, 90, 36, 89, 90, 37, 84, 38,
-	83, 84, 39, 78, 40, 77, 78, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 27,
-	26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 10, 14, 71, 72, 85, 86, 87, 88, 89,
-	90, 11, 15, 69, 70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74, 75, 76,
-	77, 78, 35, 90, 36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78};
-
-real_t A_val[] = {
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.8678200000000004e+01,
- 9.3617050000000006e+01,  1.6000000000000000e+01,  8.1999999999999993e+00,
- 9.9000000000000000e+01,  8.0000000000000000e+01,  1.2000000000000000e+01,
- 9.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.0062830000000005e+01,  9.9224010000000007e+01,  1.0000000000000000e+02,
- 2.1100000000000001e+01,  1.0000000000000000e+02,  1.0000000000000000e+02,
- 1.1400000000000000e+02,  1.1680000000000000e+02, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.4697360000000003e+01,  8.3801220000000001e+01,
--8.1999999999999993e+00,  2.0000000000000000e+00,  9.0000000000000000e+01,
- 2.3999999999999999e+00, -1.2000000000000000e+01, -1.4800000000000001e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.9194209999999998e+01,
- 9.0175110000000004e+01,  4.3000000000000000e+01,  8.0000000000000000e+00,
- 1.0000000000000000e+02,  9.5000000000000000e+01,  9.0000000000000000e+00,
- 2.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.8568219999999997e+01,  8.5996200000000002e+01, -1.2500000000000000e+01,
- 1.0000000000000000e+00,  9.6500000000000000e+01,  4.0000000000000000e+00,
--1.8000000000000000e+01, -2.1899999999999999e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.2922240000000002e+01,  8.6963380000000001e+01,
- 6.5000000000000000e+01,  1.2500000000000000e+01,  1.0000000000000000e+02,
- 9.8000000000000000e+01,  4.9000000000000000e+01,  3.7000000000000000e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.2592740000000006e+01,
- 9.3147599999999997e+01, -1.2000000000000000e+01,  1.0000000000000000e+00,
- 9.6500000000000000e+01,  4.0000000000000000e+00, -1.8000000000000000e+01,
--2.1899999999999999e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.6506460000000004e+01,  7.8210250000000002e+01,  7.9000000000000000e+01,
- 1.2000000000000000e+01,  1.0000000000000000e+02,  9.5000000000000000e+01,
- 6.8000000000000000e+01,  6.1000000000000000e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.8357460000000003e+01,  9.4257840000000002e+01,
- 1.2500000000000000e+02,  6.1299999999999997e+01,  1.0000000000000000e+02,
- 1.0000000000000000e+02,  1.4500000000000000e+02,  1.4500000000000000e+02,
--1.0000000000000000e+00,  1.0000000000000000e+00,  9.0590469999999996e+01,
- 1.0582863000000000e+02,  6.2000000000000002e+00,  6.0000000000000000e+00,
- 9.7000000000000000e+01,  2.8500000000000000e+01,  4.0000000000000000e+00,
- 3.6000000000000001e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.8678200000000004e+01,  9.3617050000000006e+01,  1.6000000000000000e+01,
- 8.1999999999999993e+00,  9.9000000000000000e+01,  8.0000000000000000e+01,
- 1.2000000000000000e+01,  9.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.0062830000000005e+01,  9.9224010000000007e+01,
- 1.0000000000000000e+02,  2.1100000000000001e+01,  1.0000000000000000e+02,
- 1.0000000000000000e+02,  1.1400000000000000e+02,  1.1680000000000000e+02,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.4697360000000003e+01,
- 8.3801220000000001e+01, -8.1999999999999993e+00,  2.0000000000000000e+00,
- 9.0000000000000000e+01,  2.3999999999999999e+00, -1.2000000000000000e+01,
--1.4800000000000001e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.9194209999999998e+01,  9.0175110000000004e+01,  4.3000000000000000e+01,
- 8.0000000000000000e+00,  1.0000000000000000e+02,  9.5000000000000000e+01,
- 9.0000000000000000e+00,  2.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.8568219999999997e+01,  8.5996200000000002e+01,
--1.2500000000000000e+01,  1.0000000000000000e+00,  9.6500000000000000e+01,
- 4.0000000000000000e+00, -1.8000000000000000e+01, -2.1899999999999999e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.2922240000000002e+01,
- 8.6963380000000001e+01,  6.5000000000000000e+01,  1.2500000000000000e+01,
- 1.0000000000000000e+02,  9.8000000000000000e+01,  4.9000000000000000e+01,
- 3.7000000000000000e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.2592740000000006e+01,  9.3147599999999997e+01, -1.2000000000000000e+01,
- 1.0000000000000000e+00,  9.6500000000000000e+01,  4.0000000000000000e+00,
--1.8000000000000000e+01, -2.1899999999999999e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.6506460000000004e+01,  7.8210250000000002e+01,
- 7.9000000000000000e+01,  1.2000000000000000e+01,  1.0000000000000000e+02,
- 9.5000000000000000e+01,  6.8000000000000000e+01,  6.1000000000000000e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.8357460000000003e+01,
- 9.4257840000000002e+01,  1.2500000000000000e+02,  6.1299999999999997e+01,
- 1.0000000000000000e+02,  1.0000000000000000e+02,  1.4500000000000000e+02,
- 1.4500000000000000e+02, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 9.0590469999999996e+01,  1.0582863000000000e+02,  6.2000000000000002e+00,
- 6.0000000000000000e+00,  9.7000000000000000e+01,  2.8500000000000000e+01,
- 4.0000000000000000e+00,  3.6000000000000001e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.8678200000000004e+01,  9.3617050000000006e+01,
- 1.6000000000000000e+01,  8.1999999999999993e+00,  9.9000000000000000e+01,
- 8.0000000000000000e+01,  1.2000000000000000e+01,  9.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.0062830000000005e+01,
- 9.9224010000000007e+01,  1.0000000000000000e+02,  2.1100000000000001e+01,
- 1.0000000000000000e+02,  1.0000000000000000e+02,  1.1400000000000000e+02,
- 1.1680000000000000e+02, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.4697360000000003e+01,  8.3801220000000001e+01, -8.1999999999999993e+00,
- 2.0000000000000000e+00,  9.0000000000000000e+01,  2.3999999999999999e+00,
--1.2000000000000000e+01, -1.4800000000000001e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.9194209999999998e+01,  9.0175110000000004e+01,
- 4.3000000000000000e+01,  8.0000000000000000e+00,  1.0000000000000000e+02,
- 9.5000000000000000e+01,  9.0000000000000000e+00,  2.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.8568219999999997e+01,
- 8.5996200000000002e+01, -1.2500000000000000e+01,  1.0000000000000000e+00,
- 9.6500000000000000e+01,  4.0000000000000000e+00, -1.8000000000000000e+01,
--2.1899999999999999e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.2922240000000002e+01,  8.6963380000000001e+01,  6.5000000000000000e+01,
- 1.2500000000000000e+01,  1.0000000000000000e+02,  9.8000000000000000e+01,
- 4.9000000000000000e+01,  3.7000000000000000e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.2592740000000006e+01,  9.3147599999999997e+01,
--1.2000000000000000e+01,  1.0000000000000000e+00,  9.6500000000000000e+01,
- 4.0000000000000000e+00, -1.8000000000000000e+01, -2.1899999999999999e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.6506460000000004e+01,
- 7.8210250000000002e+01,  7.9000000000000000e+01,  1.2000000000000000e+01,
- 1.0000000000000000e+02,  9.5000000000000000e+01,  6.8000000000000000e+01,
- 6.1000000000000000e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.8357460000000003e+01,  9.4257840000000002e+01,  1.2500000000000000e+02,
- 6.1299999999999997e+01,  1.0000000000000000e+02,  1.0000000000000000e+02,
- 1.4500000000000000e+02,  1.4500000000000000e+02, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  9.0590469999999996e+01,  1.0582863000000000e+02,
- 6.2000000000000002e+00,  6.0000000000000000e+00,  9.7000000000000000e+01,
- 2.8500000000000000e+01,  4.0000000000000000e+00,  3.6000000000000001e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00, -1.2000000000000000e-01,
--3.8000000000000000e-01, -5.0000000000000000e-01,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--9.3000000000000000e+01, -8.9000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -8.9000000000000000e+01, -8.5000000000000000e+01,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.1000000000000000e+01,
--8.8000000000000000e+01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.3000000000000000e+01,
--8.9000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--8.9000000000000000e+01, -8.5000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.1000000000000000e+01, -8.8000000000000000e+01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.3000000000000000e+01, -8.9000000000000000e+01,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -8.9000000000000000e+01,
--8.5000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--9.1000000000000000e+01, -8.8000000000000000e+01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.3000000000000000e+01,
--8.9000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--8.9000000000000000e+01, -8.5000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.1000000000000000e+01, -8.8000000000000000e+01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01};
-
-real_t g[] = {+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00,
-	-2e+00, +0e+00, -2e+00, +0e+00, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03,
-	+2e-03, +1e-03, +2e-03, +2e-03, +2e-03, +0e+00, -2e-03, -2e-03, -2e-03,
-	-2e-03, -2e-03, -2e-03, -1e-03, -2e-03, -2e-03, -2e-03, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +2e-03,
-	+2e-03, +2e-03, +2e-03, +2e-03, +2e-03, +1e-03, +2e-03, +2e-03, +2e-03,
-	+0e+00, -2e-03, -2e-03, -2e-03, -2e-03, -2e-03, -2e-03, -1e-03, -2e-03,
-	-2e-03, -2e-03, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03,
-	+1e-03, +2e-03, +2e-03, +2e-03, +0e+00, -2e-03, -2e-03, -2e-03, -2e-03,
-	-2e-03, -2e-03, -1e-03, -2e-03, -2e-03, -2e-03, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +1e-01, +1e-01,
-	+1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +0e+00,
-	-1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01,
-	-1e-01, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00};
-
-real_t lb[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, -Inf, 0, -Inf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 5,
-	10, 5, 0, 10, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 10, 5, 10, 5, 0, 10, 0, 5, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 5, 10, 5, 0, 10, 0, 5, 0, 10, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-real_t ub[] = {Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, 0, 92, 39, 87, 29, 0, 20, 0, 28, 20, 71, Inf, 130, 45, 53, 55, 75,
-	112, 0, 73, 480, 154, 121, 50, 30, 77, 20, 0, 18, 0, 5, 20, 71, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, 130, 55, 93, 60, 75, 115, 0, 67,
-	480, 154, 121, 50, 20, 37, 15, 0, 15, 0, 8, 20, 71, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, 130, 55, 93, 60, 75, 105, 0, 67, 4980, 154, 110,
-	50, 20, 37, 15, 0, 25, 0, 8, 20, 71, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, 20, 20, 20, 20, 0, 20, 0, 20, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf};
-
-real_t lbA[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -Inf, -Inf,
-	-Inf, -Inf, -Inf, -Inf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0};
-
-real_t ubA[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf};
-
-long H_nnz =  sizeof(H_val) / sizeof(real_t);
-long A_nnz =  sizeof(A_val) / sizeof(real_t);
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_runAllOqpExamples.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_runAllOqpExamples.cpp
deleted file mode 100644
index 93a3ae8..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_runAllOqpExamples.cpp
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_runAllOqpExamples.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2013-2015
- *
- *	Use qpOASES for solving all QP sequences of the Online QP Benchmark 
- *	Collection. In order to run it, you have to download all examples
- *	from http://www.qpOASES.org/onlineQP/.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the OQP interface. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* 1) Define benchmark arguments. */
-	BooleanType isSparse = BT_FALSE;
-	BooleanType useHotstarts;
-
-	Options options;
-	options.setToMPC();
-	options.printLevel = PL_LOW;
-
-	int_t maxAllowedNWSR;
-	real_t maxNWSR, avgNWSR, maxCPUtime, avgCPUtime;
-	real_t maxStationarity, maxFeasibility, maxComplementarity;
-
-	const int_t numBenchmarks = 4; //5
-	const char *benchmarkPath[numBenchmarks];
-	benchmarkPath[0] = "../testing/cpp/data/oqp/chain80/";
-	benchmarkPath[1] = "../testing/cpp/data/oqp/chain80w/";
-	benchmarkPath[2] = "../testing/cpp/data/oqp/diesel/";
-	benchmarkPath[3] = "../testing/cpp/data/oqp/crane/";
-	//benchmarkPath[4] = "../testing/cpp/data/oqp/CDU/";
-
-
-	/* 2) Run all benchmarks in a loop */
-	for ( int_t ii=0; ii<2*numBenchmarks; ++ii )
-	{
-		if ( ii%2 == 0 )
-			useHotstarts = BT_FALSE;
-		else
-			useHotstarts = BT_TRUE;
-		
-		maxAllowedNWSR = 1000;
-		maxNWSR = 0.0;
-		avgNWSR = 0.0;
-		maxCPUtime = 1000.0; /* seconds */
-		avgCPUtime =    0.0; /* seconds */
-		maxStationarity    = 0.0;
-		maxFeasibility     = 0.0;
-		maxComplementarity = 0.0;
-
-		if ( runOqpBenchmark(	benchmarkPath[ii/2],
-								isSparse,useHotstarts,
-								options,maxAllowedNWSR,
-								maxNWSR,avgNWSR,maxCPUtime,avgCPUtime,
-								maxStationarity,maxFeasibility,maxComplementarity
-								) != SUCCESSFUL_RETURN )
-		{
-			myPrintf( "Something went wrong when running benchmark!\n" );
-			return TEST_DATA_NOT_FOUND;
-		}
-
-		/* 3) Print results. */
-		printf( "\n\n" );
-		if ( useHotstarts == BT_FALSE )
-			printf( "OQP Benchmark Results for %s (cold-starts):\n", benchmarkPath[ii/2] );
-		else
-			printf( "OQP Benchmark Results for %s (hot-starts):\n", benchmarkPath[ii/2] );
-
-		printf( "===========================================================================\n\n" );
-		printf( "maximum CPU time:             %.2f milliseconds\n",1000.0*maxCPUtime );
-		printf( "average CPU time:             %.2f milliseconds\n",1000.0*avgCPUtime );
-		printf( "\n" );
-		printf( "maximum iterations:    %.1f\n",maxNWSR );
-		printf( "average iterations:    %.1f\n",avgNWSR );
-		printf( "\n" );
-		printf( "maximum violation stationarity:     %.3e\n",maxStationarity );
-		printf( "maximum violation feasibility:      %.3e\n",maxFeasibility );
-		printf( "maximum violation complementarity:  %.3e\n",maxComplementarity );
-		printf( "\n" );
-
-		QPOASES_TEST_FOR_TOL( maxStationarity,    1e-9  );
-		QPOASES_TEST_FOR_TOL( maxFeasibility,     1e-11 );
-		QPOASES_TEST_FOR_TOL( maxComplementarity, 1e-10 );
-		
-		switch( ii )
-		{
-			case 0:
-				/* chain80 (cold) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 62.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  7.5 );
-				break;
-
-			case 1:
-				/* chain80 (hot) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 19.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  2.4 );
-				break;
-
-			case 2:
-				/* chain80w (cold) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 84.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <= 10.1 );
-				break;
-
-			case 3:
-				/* chain80w (hot) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 16.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  2.7 );
-				break;
-
-			case 4:
-				/* diesel (cold) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 26.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  0.5 );
-				break;
-
-			case 5:
-				/* diesel (hot) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 22.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  0.3 );
-				break;
-
-			case 6:
-				/* crane (cold) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 64.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <= 44.0 );
-				break;
-
-			case 7:
-				/* crane (hot) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 42.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  0.4 );
-				break;
-		}
-	}
-	
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_sebastien1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_sebastien1.cpp
deleted file mode 100644
index 7ed5ba1..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_sebastien1.cpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_sebastien1.cpp
- *	\author Sebastien B.
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Example that caused troubles in an earlier release.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** qpOASES main function defining a unit test. */
-int main( )
-{
-	REFER_NAMESPACE_QPOASES real_t solution[2]       = {0.0f, 0.0f};
-	REFER_NAMESPACE_QPOASES real_t expectedFirst[2]  = {0.5f, -1.5f};
-  
-	REFER_NAMESPACE_QPOASES real_t H[2*2] = {1.0f, 0.0f, 0.0f, 0.5f};
-	REFER_NAMESPACE_QPOASES real_t g[2]   = {1.5f, 1.0f};
-
-	REFER_NAMESPACE_QPOASES real_t A[1*2] = {1.0f, 1.0f};
-	REFER_NAMESPACE_QPOASES real_t lbA[1] = {-1.0f};
-	REFER_NAMESPACE_QPOASES real_t ubA[1] = {2.0f};
-
-	REFER_NAMESPACE_QPOASES real_t lb[2]  = {0.5f, -2.0f};
-	REFER_NAMESPACE_QPOASES real_t ub[2]  = {5.0f, 2.0f};
-
-	REFER_NAMESPACE_QPOASES QProblem example(2, 1);
-	REFER_NAMESPACE_QPOASES Options options = example.getOptions();
-	//options.enableFarBounds = REFER_NAMESPACE_QPOASES BT_FALSE;
-	example.setOptions(options);
-	example.setPrintLevel(REFER_NAMESPACE_QPOASES PL_NONE);
-
-	// Solve first QP.
-	REFER_NAMESPACE_QPOASES int_t nWSR = 10;
-	QPOASES_TEST_FOR_TRUE( example.init(H, g, A, lb, ub, lbA, ubA, nWSR, NULL) == REFER_NAMESPACE_QPOASES SUCCESSFUL_RETURN );
-	QPOASES_TEST_FOR_TRUE( example.isSolved() == REFER_NAMESPACE_QPOASES BT_TRUE );
-	example.getPrimalSolution(solution);
-
-	printf( "\nxOpt = [ %e, %e ];\n\n", solution[0],solution[1] );
-
-	for( REFER_NAMESPACE_QPOASES uint_t i=0; i<2; i++ )
-		QPOASES_TEST_FOR_NEAR( solution[i],expectedFirst[i] );
-
-	return TEST_PASSED;
-}
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_vanBarelsUnboundedQP.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_vanBarelsUnboundedQP.cpp
deleted file mode 100644
index b0d3d8a..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_vanBarelsUnboundedQP.cpp
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_vanBarelsUnboundedQP.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Example that causes troubles when hotstarting.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-#include <stdio.h>
-
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.0 };
-	real_t g[2] = { 1.5, 1.0 };
-		
-	Options options;
-	//options.enableFarBounds = BT_FALSE;
-
-	QProblemB qp(2);
-	qp.setOptions( options );
-
-	int_t iter = 10;
-	qp.init( H,g,0,0,iter );
-
-	real_t xOpt[2];
-	qp.getPrimalSolution( xOpt );
-	print( xOpt,2 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateExample.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateExample.m
deleted file mode 100644
index 9476d7e..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateExample.m
+++ /dev/null
@@ -1,25 +0,0 @@
-function [ qpData ] = generateExample( nV,nC, isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC, seed, givenH,givenA )
-
-    if ( nargin < 11 )
-        givenA = [];
-        if ( nargin < 10 )
-            givenH = [];
-        end
-    end
-
-    qpFeatures = setupQpFeaturesStruct( );
-    
-    qpFeatures.nV = nV;
-    qpFeatures.nC = nC;
-    
-    qpFeatures.isSparseH = isSparseH;
-    qpFeatures.isSparseA = isSparseA;
-    
-    qpFeatures.hasLowerB = hasLowerB;
-    qpFeatures.hasUpperB = hasUpperB;
-    qpFeatures.hasLowerC = hasLowerC;
-    qpFeatures.hasUpperC = hasUpperC;
-    
-    qpData = generateRandomQp( qpFeatures,seed, givenH,givenA );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateRandomQp.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateRandomQp.m
deleted file mode 100644
index 3fd4fd3..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateRandomQp.m
+++ /dev/null
@@ -1,110 +0,0 @@
-function [ qpData ] = generateRandomQp( qpFeatures,randSeed, givenH,givenA )
-
-    if ( nargin < 4 )
-        givenA = [];
-        if ( nargin < 3 )
-            givenH = [];
-        end
-    end
-    
-    if ( isoctave == 0 )
-        if ( nargin < 2 )
-            s = RandStream( 'mt19937ar', 'Seed','shuffle' );
-            RandStream.setGlobalStream(s);
-        else
-            s = RandStream( 'mt19937ar', 'Seed',randSeed );
-            RandStream.setGlobalStream(s);
-        end
-    end
-    
-
-    qpData = setupQpDataStruct( );
-    qpData.nV = qpFeatures.nV;
-    qpData.nC = qpFeatures.nC;
-    
-    
-    % generate random optimal primal solution
-    xFeas = rand( qpFeatures.nV,1 );
-    
-    % generate random optimal dual solution
-    %yOpt = zeros( qpFeatures.nV+qpFeatures.nC,1 );
-    
-    if ( isempty(givenH) > 0 )
-        
-        switch ( qpFeatures.hessianType )
-
-            case 0
-                qpData.H = 100 * rand( qpData.nV,qpData.nV ) - 50;
-                qpData.H = qpData.H' * qpData.H / 2;
-
-            case 1
-                qpData.H = 100 * rand( qpData.nV,round(qpData.nV/2) ) - 50;
-                qpData.H = qpData.H' * qpData.H / 2;
-
-            case 2
-                qpData.H = eye( qpData.nV );
-
-            case 3
-                qpData.H = zeros( qpData.nV,qpData.nV );
-
-        end
-        
-    else
-        qpData.H = givenH;
-    end
-    
-    qpData.g = 1000 * rand( qpFeatures.nV,1 ) - 500;
-    
-    if ( isempty(givenA) > 0 )
-        
-        if ( qpFeatures.nC > 0 )
-            qpData.Ain = 100 * rand( qpData.nC,qpData.nV ) - 50;
-        else
-            qpData.Ain = [];
-        end
-        
-    else
-        qpData.Ain = givenA;
-    end
-    
-    if ( qpFeatures.makeInfeas > 0 )
-        alpha = -0.1;
-        beta  = -0.001;
-    else
-        alpha = 1;
-        beta  = 1;
-    end
-        
-    if ( qpFeatures.hasLowerB > 0 )
-        qpData.lb = xFeas - 3*rand( qpData.nV,1 );
-    else
-        qpData.lb = [];
-    end
-    
-    if ( qpFeatures.hasUpperB > 0 )
-        qpData.ub = xFeas + alpha*3*rand( qpData.nV,1 );
-    else
-        qpData.ub = [];
-    end
-    
-    if ( ( qpFeatures.hasLowerC > 0 ) && ( qpData.nC > 0 ) )
-        qpData.lbA = qpData.Ain*xFeas - 100*rand( qpData.nC,1 );
-    else
-        qpData.lbA = [];
-    end
-    
-    if ( ( qpFeatures.hasUpperC > 0 ) && ( qpData.nC > 0 ) )
-        qpData.ubA = qpData.Ain*xFeas + beta*100*rand( qpData.nC,1 );
-    else
-        qpData.ubA = [];
-    end
-    
-    if ( qpFeatures.isSparseH > 0 )
-        qpData.H = sparse( qpData.H );
-    end
-    
-    if ( qpFeatures.isSparseA > 0 )
-        qpData.Ain = sparse( qpData.Ain );
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/getKktResidual.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/getKktResidual.m
deleted file mode 100644
index 55b17a0..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/getKktResidual.m
+++ /dev/null
@@ -1,134 +0,0 @@
-function [kkt,stat,feas,cmpl] = getKktResidual( H,g,A,lb,ub,lbA,ubA, x,y )
-
-    % Tolerance for dual variables considered zero.
-	dualActiveTolerance = 1.0e3 * eps;
-
-	% Initialize residuals
-    stat = 0.0;
-    feas = 0.0;
-    cmpl = 0.0;
-    
-    if ( isempty(H) == 0 )
-        nV = size( H,1 );
-    else
-        nV = size( g,2 );
-    end
-
-    if ( isempty(A) == 0 )
-        nC = size( A,1 );
-    else
-        nC = 0;
-    end
-
-   
-	%% check stationarity
-	for i=1:nV
-        
-		% g term and variable bounds dual term
-        if ( isempty(g) == 0 )
-            sum = g(i) - y(i);
-        else
-            sum = 0 - y(i);
-        end
-
-		% H*x term
-        if ( isempty(H) == 0 )
-            sum = sum + H(i,:) * x;
-        end
-
-		% A'*y term
-        if ( isempty(A) == 0 )
-            sum = sum - A(:,i)' * y(nV+1:nV+nC);
-        end
-		
-		% update stat
-        if (abs(sum) > stat)
-            stat = abs(sum);
-        end
-        
-	end
-
-    %% check primal feasibility and complementarity
-	% variable bounds
-	for i=1:nV
-
-		% feasibility
-        if ( isempty(lb) == 0 )
-            if (lb(i) - x(i) > feas) 
-				feas = lb(i) - x(i);
-            end
-        end
-
-        if ( isempty(ub) == 0 )
-            if (x(i) - ub(i) > feas) 
-				feas = x(i) - ub(i);
-            end
-        end
-
-		% complementarity
-		prod = 0.0;
-
-        if ( isempty(lb) == 0 )
-             if (y(i) > dualActiveTolerance) % lower bound
-				prod = (x(i) - lb(i)) * y(i);
-            end
-        end
-
-        if ( isempty(ub) == 0 )
-            if (y(i) < -dualActiveTolerance) % upper bound
-				prod = (x(i) - ub(i)) * y(i);
-            end
-        end
-
-        if (abs(prod) > cmpl)
-            cmpl = abs(prod);
-        end
-        
-	end
-    
-	% A*x bounds
-    for i=1:nC
-
-        % compute sum = (A*x)_i
-		sum = 0.0;
-        if ( isempty(A) == 0 )
-            sum = sum + A(i,:) * x;
-        end
-
-		% feasibility
-        if ( isempty(lbA) == 0 )
-            if (lbA(i) - sum > feas) 
-				feas = lbA(i) - sum;
-            end
-        end
-
-        if ( isempty(ubA) == 0 )
-            if (sum - ubA(i) > feas) 
-				feas = sum - ubA(i);
-            end
-        end
-
-		% complementarity
-		prod = 0.0;
-
-        if ( isempty(lbA) == 0 )
-            if (y(nV+i) > dualActiveTolerance) % lower bound
-				prod = (sum - lbA(i)) * y(nV+i);
-            end
-        end
-		
-        if ( isempty(ubA) == 0 )
-            if (y(nV+i) < -dualActiveTolerance) % upper bound
-				prod = (sum - ubA(i)) * y(nV+i);
-            end
-        end
-
-        if (abs(prod) > cmpl)
-            cmpl = abs(prod);
-        end
-        
-    end
-    
-    kkt = max( [stat,feas,cmpl] );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/isoctave.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/isoctave.m
deleted file mode 100644
index e4726d4..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/isoctave.m
+++ /dev/null
@@ -1,21 +0,0 @@
-
-% ISOCTAVE  True if the operating environment is octave.
-%    Usage: t=isoctave();
-% 
-%    Returns 1 if the operating environment is octave, otherwise
-%    0 (Matlab)
-% 
-% ---------------------------------------------------------------
-function t=isoctave()
-%ISOCTAVE  True if the operating environment is octave.
-%   Usage: t=isoctave();
-%
-%   Returns 1 if the operating environment is octave, otherwise
-%   0 (Matlab)
-
-if exist('OCTAVE_VERSION')
-  % Only Octave has this variable.
-  t=1;
-else
-  t=0;
-end;
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpDataStruct.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpDataStruct.m
deleted file mode 100644
index 93d9e3c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpDataStruct.m
+++ /dev/null
@@ -1,18 +0,0 @@
-function [ qpData ] = setupQpDataStruct( )
-
-    qpData = struct(    'H', [], ...        % Hessian matrix
-                        'g', [], ...        % gradient vector
-                        'Aeq', [], ...      % equality constraints matrix
-                        'beq', [], ...      % equality constraints vector
-                        'lb', [], ...       % lower bound vector
-                        'ub', [], ...       % upper bound vector
-                        'Ain', [], ...      % inequality constraints matrix
-                        'lbA', [], ...      % lower constraints vector
-                        'ubA', [], ...      % upper constraints vector
-                        'x0', [], ...       % primal initial guess
-                        'options', [], ...  % QP solver options
-                        'nV', 0, ...        % number of QP variables
-                        'nC', 0 ...         % number of constraints
-                        );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpFeaturesStruct.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpFeaturesStruct.m
deleted file mode 100644
index 903a891..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpFeaturesStruct.m
+++ /dev/null
@@ -1,21 +0,0 @@
-function [ qpFeatures ] = setupQpFeaturesStruct( )
-
-    qpFeatures = struct(    'nV',  0, ...
-                            'nIB', 0, ...
-                            'nEB', 0, ...
-                            'nC',  0, ...
-                            'nIC', 0, ...
-                            'nEC', 0, ...
-                            'nActB', 0, ...
-                            'nActC', 0, ...
-                            'hasLowerB', 0, ...
-                            'hasUpperB', 0, ...
-                            'hasLowerC', 0, ...
-                            'hasUpperC', 0, ...
-                            'isSparseH', 0, ...
-                            'isSparseA', 0, ...
-                            'makeInfeas', 0, ...
-                            'hessianType', 0 ... % 0 = pos def; 1 = pos sem def; 2 = id; 3 = zero
-                            );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/data/fetch_matlab_data b/extlibs/qpOASES-3.2.0/testing/matlab/data/fetch_matlab_data
deleted file mode 100755
index 1cd223c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/data/fetch_matlab_data
+++ /dev/null
@@ -1,34 +0,0 @@
-#!/usr/bin/env bash
-
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/matlab/data/fetch_matlab_data
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014-2015
-
-
-svn export https://projects.coin-or.org/svn/qpOASES/misc/testingdata/matlab . --force
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/runAllTests.m b/extlibs/qpOASES-3.2.0/testing/matlab/runAllTests.m
deleted file mode 100644
index f17b0a0..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/runAllTests.m
+++ /dev/null
@@ -1,152 +0,0 @@
-function [ successFlag ] = runAllTests( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-    
-    successFlag = 1;
-    
-    curWarnLevel = warning;
-    warning('off');
-    
-    % add sub-folders to Matlab path
-	setupTestingPaths();
-    
-    clc;
-
-    %% run interface tests
-    fprintf( 'Running qpOASES interface tests... ' )
-    successFlag = updateSuccessFlag( successFlag, runInterfaceTest( 10,20, doPrint,42 ) );
-
-    fprintf( 'Running qpOASES_sequence interface tests... ' )
-    successFlag = updateSuccessFlag( successFlag, runInterfaceSeqTest( 8,5, doPrint,42 ) );
-    
-    
-    %% run functional tests
-    fprintf( 'Running tests with random QPs having identity Hessian... ' )
-    successFlag = updateSuccessFlag( successFlag, runRandomIdHessian( 12,12, doPrint,4242 ) );
-    
-    fprintf( 'Running tests with random QPs having zero Hessian... ' )
-    successFlag = updateSuccessFlag( successFlag, runRandomZeroHessian( 11,41, doPrint,4242 ) );
-    
-    fprintf( 'Running qpOASES passing an empty Hessian matrix argument... ' )
-    successFlag = updateSuccessFlag( successFlag, runEmptyHessianTests( doPrint ) );
-
-    fprintf( 'Running alternativeX0 test... ' )
-    successFlag = updateSuccessFlag( successFlag, runAlternativeX0Test( 50,300,doPrint,4242 ) );
-    
-    fprintf( 'Running testAPrioriKnownSeq1... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestAPrioriKnownSeq1( doPrint ) );
-        
-    fprintf( 'Running testSeq... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestSeq( doPrint ) );
-    
-    fprintf( 'Running testSparse... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestSparse( doPrint ) );
-    
-    fprintf( 'Running testSparse2... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestSparse2( doPrint ) );
-    
-    fprintf( 'Running testSparse3... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestSparse3( doPrint ) );
-    
-    fprintf( 'Running testSparse4... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestSparse4( doPrint ) );
-    
-    fprintf( 'Running simpleSpringExample... ' )
-    successFlag = updateSuccessFlag( successFlag, runSimpleSpringExample( doPrint ) );
-    
-    fprintf( 'Running vanBarelsUnboundedQP... ' )
-    successFlag = updateSuccessFlag( successFlag, runVanBarelsUnboundedQP( doPrint ) );
-    
-    fprintf( 'Running alexInfeas1... ' )
-    successFlag = updateSuccessFlag( successFlag, runAlexInfeas1( doPrint ) );
-    
-    %fprintf( 'Running alexInfeas2... ' )
-    %successFlag = updateSuccessFlag( successFlag, runAlexInfeas2( doPrint ) );
-
-    %fprintf( 'Running QAP8... ' )
-    %successFlag = updateSuccessFlag( successFlag, runQAP( doPrint ) );
-    
-    fprintf( 'Running testWorkingSetLI... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestWorkingSetLI( doPrint ) );
-    
-    fprintf( 'Running runExternalCholeskyTests... ' )
-    successFlag = updateSuccessFlag( successFlag, runExternalCholeskyTests( doPrint ) );
-
-    fprintf( 'Running EXAMPEL1... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkEXAMPLE1( 10,doPrint ) );
-	
-    fprintf( 'Running EXAMPLE1A... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkEXAMPLE1A( 10,doPrint ) );
-	
-    fprintf( 'Running EXAMPLE1B... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkEXAMPLE1B( 10,doPrint ) );
-
-	fprintf( 'Running CHAIN1... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkCHAIN1( 20,doPrint ) );
-	
-    fprintf( 'Running CHAIN1A... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkCHAIN1A( 20,doPrint ) );
-
-	fprintf( 'Running CRANE1... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkCRANE1( 100,doPrint ) );
-
-    fprintf( 'Running CRANE2... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkCRANE2( 100,doPrint ) );
-
-    fprintf( 'Running CRANE3... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkCRANE3( 100,doPrint ) );
-	
-	fprintf( 'Running EQUALITY1... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkEQUALITY1( 100,doPrint ) );
-
-    fprintf( 'Running EQUALITY2... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkEQUALITY2( 3200,doPrint ) );
-
-    %fprintf( 'Running IDHESSIAN1... ' );
-	%successFlag = updateSuccessFlag( successFlag, runBenchmarkIDHESSIAN1( 1200,doPrint ) );
-
-    fprintf( 'Running DIESEL... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkDIESEL( 230,doPrint ) );
-    
-    fprintf( 'Running QSHARE1B... ' )
-    successFlag = updateSuccessFlag( successFlag, runQSHARE1B( doPrint ) );
-
-    
-    
-    %% display results
-    disp( ' ' );
-    
-    if ( successFlag == 0 )
-        disp( 'At least one test failed!' );
-    else
-        disp( 'All available tests passed successfully!' );
-    end
-
-    warning( curWarnLevel );
-    
-end
-
-
-function [ newSuccessFlag ] = updateSuccessFlag( curSuccessFlag,curResult )
-
-    switch ( curResult )
-        
-        case 0
-            newSuccessFlag = 0;
-            fprintf( 'failed!\n' );
-        
-        case 1          
-            newSuccessFlag = curSuccessFlag;
-            fprintf( 'passed!\n' );
-            
-        case -1
-            newSuccessFlag = curSuccessFlag;
-            fprintf( 'problem data missing!\n' );
-            
-        otherwise
-            error( 'Unknown success flag!' );
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/setupTestingPaths.m b/extlibs/qpOASES-3.2.0/testing/matlab/setupTestingPaths.m
deleted file mode 100644
index 6373d11..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/setupTestingPaths.m
+++ /dev/null
@@ -1,14 +0,0 @@
-function [] = setupTestingPaths( )
-
-    addpath(genpath(pwd));
-    addpath(genpath([pwd 'auxFiles']));
-    addpath(genpath([pwd 'data']));
-    addpath(genpath([pwd 'tests']));
-    
-    if isoctave 
-		addpath('../../interfaces/octave/');
-	else
-		addpath('../../interfaces/matlab/');
-	end
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas1.m
deleted file mode 100644
index d1977ed..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas1.m
+++ /dev/null
@@ -1,30 +0,0 @@
-function [ successFlag ] = runAlexInfeas1( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-    try
-        data = load( 'alexInfeas1.mat' );
-    catch
-        successFlag = -1;
-        return;
-    end
-    
-    options1 = qpOASES_options( 'default', 'printLevel',-2*doPrint );
-    
-    [x1,dummy,exitflag1] = qpOASES( data.H,data.g,data.A, ...
-                data.lb,data.ub,data.lbA,data.ubA, options1 ); %#ok<*NASGU>
-
-    % should return "QP infeasible"
-    if ( exitflag1 == -2 )
-        successFlag = 1;
-    else
-        if ( doPrint > 0 )
-            disp( [data.lbA data.A*x1 data.ubA] );
-        end
-    end
-   
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas2.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas2.m
deleted file mode 100644
index 730a01c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas2.m
+++ /dev/null
@@ -1,35 +0,0 @@
-function [ successFlag ] = runAlexInfeas2( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-    try
-        data = load( 'alexInfeas2.mat' );
-    catch
-        successFlag = -1;
-        return;
-    end
-    
-    options1 = qpOASES_options( 'default', 'printLevel',-2*doPrint,... 
-                                           'maxIter',7000, 'enableFlippingBounds',0,...
-                                           'terminationTolerance',1e7*eps);
-                                       
-    options2 = qpOASES_options( 'MPC', 'printLevel',-2*doPrint,... 
-                                       'maxIter',3000, 'terminationTolerance',1e8*eps );
-    
-    [x1,dummy,exitflag1] = qpOASES( data.H,data.g,data.A, ...
-                data.lb,data.ub,data.lbA,data.ubA, options1 ); %#ok<*NASGU>
-
-    % should return "QP infeasible"
-    if ( exitflag1 == -2 )
-        successFlag = 1;
-    else
-        if ( doPrint > 0 )
-            %disp( [data.lbA data.A*x1 data.ubA] );
-        end
-    end
-   
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlternativeX0Test.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlternativeX0Test.m
deleted file mode 100644
index 3178ed2..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlternativeX0Test.m
+++ /dev/null
@@ -1,84 +0,0 @@
-function [ successFlag ] = runAlternativeX0Test( nV,nC, doPrint,seed )
-    
-    if ( nargin < 4 )
-        seed = 4242;
-        if ( nargin < 3 )
-            doPrint = 0;
-            if ( nargin < 2 )
-                nC = 300;
-                if ( nargin < 1 )
-                    nV = 50;
-                end
-            end
-        end
-    end
-
-    successFlag = 1;
-    TOL = eps;
-    
-    qpData = generateExample( nV,nC, 0,0, 0,1,1,1, seed );
-    
-    H = qpData.H;
-	g = qpData.g;
-    A = [qpData.Aeq;qpData.Ain];
-	lb = qpData.lb;
-    ub = qpData.ub;
-    lbA = [qpData.beq;qpData.lbA];
-    ubA = [qpData.beq;qpData.ubA];
-    
-    x0 = nV*rand( nV,1 );
-    
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-    auxInput = qpOASES_auxInput( 'x0',x0 );
-    
-    [ x1,f1,e1,i1,l1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],x0 );
-    [ x2,f2,e2,i2,l2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-    [ x3,f3,e3,i3,l3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,x0 );
-    [ x4,f4,e4,i4,l4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-    
-    if ( ( norm(x1-x2) > TOL ) || ...
-         ( norm(x1-x3) > TOL ) || ...
-         ( norm(x1-x4) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in x')
-        end
-        successFlag = 0;
-    end
-    
-    if ( ( norm(f1-f2) > TOL ) || ...
-         ( norm(f1-f3) > TOL ) || ...
-         ( norm(f1-f4) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in fval')
-        end
-        successFlag = 0;
-    end
-    
-    if ( ( norm(e1-e2) > TOL ) || ...
-         ( norm(e1-e3) > TOL ) || ...
-         ( norm(e1-e4) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in exitflag')
-        end
-        successFlag = 0;
-    end
-    
-    if ( ( norm(i1-i2) > TOL ) || ...
-         ( norm(i1-i3) > TOL ) || ...
-         ( norm(i1-i4) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in iter')
-        end
-        successFlag = 0;
-    end
-    
-    if ( ( norm(l1-l2) > TOL ) || ...
-         ( norm(l1-l3) > TOL ) || ...
-         ( norm(l1-l4) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in lambda')
-        end
-        successFlag = 0;
-    end
-		
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1.m
deleted file mode 100644
index 4aa70b1..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1.m
+++ /dev/null
@@ -1,60 +0,0 @@
-function [ successFlag ] = runBenchmarkCHAIN1( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-    
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-    
-    try
-        load 'benchmarkCHAIN1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    iter = zeros(1,nP);
-
-	options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-    %options = qpOASES_options( 'maxIter',nWSR );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda,ws] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-            %disp(ws')
-		else
-			[x,obj,status,nWSRout,lambda,ws] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-            %disp(ws')
-        end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-        
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-        iter(:,i) = nWSRout;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-    
-    if ( ( maxViolation < 9e-13 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-	
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1A.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1A.m
deleted file mode 100644
index 65311f6..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1A.m
+++ /dev/null
@@ -1,61 +0,0 @@
-function [ successFlag ] = runBenchmarkCHAIN1A( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-    
-    try
-        load 'benchmarkCHAIN1A.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-    %options = qpOASES_options( 'reliable', 'maxIter',500,'printLevel',1 );
-% ,'enableRamping',0,'enableFlippingBounds',0,'enableFullLITests',0,'enableDriftCorrection',0
-  
-  
-	for jj=1:1
-  
-	for i=1:nP
-		%disp(i);
-		if ( i == 1 )
-            [QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),lb(:,i),ub(:,i),options );
-		else
-            [x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),options );
-        end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),[],lb(:,i),ub(:,i),[],[], x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    end
-    
-    if ( ( maxViolation < 1e-14 ) && ( status == 0 ) )
-        successFlag = 1;
-    end   
-	
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE1.m
deleted file mode 100644
index 4243ccf..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE1.m
+++ /dev/null
@@ -1,55 +0,0 @@
-function [ successFlag ] = runBenchmarkCRANE1( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkCRANE1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-
-	options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-    for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 3e-9 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-	
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE2.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE2.m
deleted file mode 100644
index 7f7d47f..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE2.m
+++ /dev/null
@@ -1,56 +0,0 @@
-function [ successFlag ] = runBenchmarkCRANE2( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkCRANE2.mat';
-	catch
-        successFlag = -1;
-        return;
-    end
-    
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-    
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'm',QP,H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 1e-11 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE3.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE3.m
deleted file mode 100644
index 80caac9..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE3.m
+++ /dev/null
@@ -1,55 +0,0 @@
-function [ successFlag ] = runBenchmarkCRANE3( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-    try
-        load 'benchmarkCRANE3.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 5e-11 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkDIESEL.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkDIESEL.m
deleted file mode 100644
index ad6c585..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkDIESEL.m
+++ /dev/null
@@ -1,59 +0,0 @@
-function [ successFlag ] = runBenchmarkDIESEL( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-    try
-        load 'benchmarkDIESEL.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-		nEC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    iter = zeros(1,nP);
-
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-    %options = qpOASES_options( 'maxIter',nWSR );
-    %options = qpOASES_options( 'maxIter',nWSR, 'initialStatusBounds',0 );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-        end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-        
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-        iter(:,i) = nWSRout;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-    
-    if ( ( maxViolation < 6e-13 ) && ( status == 0 ) )
-        successFlag = 1;
-    end	
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY1.m
deleted file mode 100644
index b304b42..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY1.m
+++ /dev/null
@@ -1,56 +0,0 @@
-function [ successFlag ] = runBenchmarkEQUALITY1( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkEQUALITY1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-   	if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 4e-15 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY2.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY2.m
deleted file mode 100644
index bd7c48d..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY2.m
+++ /dev/null
@@ -1,60 +0,0 @@
-function [ successFlag ] = runBenchmarkEQUALITY2( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkEQUALITY2.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-   	if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-   
-    %H = H;
-    %lbA(65:320) = lbA(65:320) - 0.000000000;
-    %ubA(65:320) = ubA(65:320) + 0.000000000;
-
-	options = qpOASES_options( 'maxIter',nWSR, 'enableEqualities',1, 'printLevel',2*doPrint );
-    %options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',-2 );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 3e-7 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1.m
deleted file mode 100644
index 7706aff..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1.m
+++ /dev/null
@@ -1,56 +0,0 @@
-function [ successFlag ] = runBenchmarkEXAMPLE1( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkEXAMPLE1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-	
-    if ( ( maxViolation < 1e-12 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1A.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1A.m
deleted file mode 100644
index ba91b9e..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1A.m
+++ /dev/null
@@ -1,56 +0,0 @@
-function [ successFlag ] = runBenchmarkEXAMPLE1A( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-    maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkEXAMPLE1A.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:2
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H(:,:,i),g(:,i),A(:,:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'm',QP,H(:,:,i),g(:,i),A(:,:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H(:,:,i),g(:,i),A(:,:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 3e-13 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1B.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1B.m
deleted file mode 100644
index 36e933f..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1B.m
+++ /dev/null
@@ -1,56 +0,0 @@
-function [ successFlag ] = runBenchmarkEXAMPLE1B( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkEXAMPLE1B.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),lb(:,i),ub(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),[],lb(:,i),ub(:,i),[],[], x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 3e-12 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkIDHESSIAN1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkIDHESSIAN1.m
deleted file mode 100644
index d97797f..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkIDHESSIAN1.m
+++ /dev/null
@@ -1,59 +0,0 @@
-function [ successFlag ] = runBenchmarkIDHESSIAN1( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkIDHESSIAN1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-       
-	options = qpOASES_options( 'maxIter',nWSR, 'printLevel',-2*doPrint );
-    %options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2 );
-    
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i)-1e-11,ubA(:,i)+1e-11,options );
-			%disp(status);
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i)-1e-11,ubA(:,i)+1e-11,options );
-			%disp(status);
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 8e-6 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runEmptyHessianTests.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runEmptyHessianTests.m
deleted file mode 100644
index 46ade51..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runEmptyHessianTests.m
+++ /dev/null
@@ -1,261 +0,0 @@
-function [ successFlag ] = runEmptyHessianTests( doPrint )
-
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-    
-    successFlag = 1;
-    
-    TOL = 100*eps;
-	
-	options = qpOASES_options( 'maxIter',100, 'enableEqualities',1, 'printLevel',-2*doPrint );
-    auxInput0   = qpOASES_auxInput( 'hessianType',0 );
-    auxInput1   = qpOASES_auxInput( 'hessianType',1 );
-    auxInputErr = qpOASES_auxInput( 'hessianType',2 );
-
-    
-    load 'benchmarkEXAMPLE1.mat';
-    
-    %% test qpOASES with zero Hessian
-    [ x1,obj1,status1,nWSRout1,lambda1 ] = qpOASES( 0*H,g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options );
-    [ x2,obj2,status2,nWSRout2,lambda2 ] = qpOASES( [],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options );
-    [ x3,obj3,status3,nWSRout3,lambda3 ] = qpOASES( [],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInput0 );
-    [ x4,obj4,status4,nWSRout4,lambda4 ] = qpOASES( [],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInputErr );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 ) || ( status3 ~= 0 ) || ( status4 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL ) || ( norm(x1-x3) > TOL ) || ( norm(x1-x4) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL ) || ( norm(obj1-obj3) > TOL ) || ( norm(obj1-obj4) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL ) || ( norm(lambda1-lambda3) > TOL ) || ( norm(lambda1-lambda4) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    %% test qpOASES_sequence with zero Hessian
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',0*H,g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options ); %#ok<NASGU>
-	[x1,obj1,status1,nWSRout1,lambda1]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',[],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options ); %#ok<NASGU>
-	[x2,obj2,status2,nWSRout2,lambda2]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',[],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInput0 ); %#ok<NASGU>
-	[x3,obj3,status3,nWSRout3,lambda3]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',[],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInputErr ); %#ok<NASGU>
-	[x4,obj4,status4,nWSRout4,lambda4]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 ) || ( status3 ~= 0 ) || ( status4 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL ) || ( norm(x1-x3) > TOL ) || ( norm(x1-x4) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL ) || ( norm(obj1-obj3) > TOL ) || ( norm(obj1-obj4) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL ) || ( norm(lambda1-lambda3) > TOL ) || ( norm(lambda1-lambda4) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    %% test qpOASES with ID Hessian
-    [ x1,obj1,status1,nWSRout1,lambda1 ] = qpOASES( eye(2),g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options );
-    [ x2,obj2,status2,nWSRout2,lambda2 ] = qpOASES( [],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInput1 );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    %% test qpOASES_sequence with ID Hessian
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',eye(2),g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options ); %#ok<NASGU>
-	[x1,obj1,status1,nWSRout1,lambda1]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',[],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInput1 ); %#ok<NASGU>
-	[x2,obj2,status2,nWSRout2,lambda2]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    load 'benchmarkEXAMPLE1B.mat';
-    
-    %% test qpOASES (simply bounded) with zero Hessian
-    [ x1,obj1,status1,nWSRout1,lambda1 ] = qpOASES( 0*H,g(:,1),lb(:,1),ub(:,1),options );
-    [ x2,obj2,status2,nWSRout2,lambda2 ] = qpOASES( [],g(:,1),lb(:,1),ub(:,1),options );
-    [ x3,obj3,status3,nWSRout3,lambda3 ] = qpOASES( [],g(:,1),lb(:,1),ub(:,1),options,auxInput0 );
-    [ x4,obj4,status4,nWSRout4,lambda4 ] = qpOASES( [],g(:,1),lb(:,1),ub(:,1),options,auxInputErr );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 ) || ( status3 ~= 0 ) || ( status4 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL ) || ( norm(x1-x3) > TOL ) || ( norm(x1-x4) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL ) || ( norm(obj1-obj3) > TOL ) || ( norm(obj1-obj4) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL ) || ( norm(lambda1-lambda3) > TOL ) || ( norm(lambda1-lambda4) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    %% test qpOASES (simply bounded) with ID Hessian
-    [ x1,obj1,status1,nWSRout1,lambda1 ] = qpOASES( eye(2),g(:,1),lb(:,1),ub(:,1),options );
-    [ x2,obj2,status2,nWSRout2,lambda2 ] = qpOASES( [],g(:,1),lb(:,1),ub(:,1),options,auxInput1 );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runExternalCholeskyTests.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runExternalCholeskyTests.m
deleted file mode 100644
index 2434478..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runExternalCholeskyTests.m
+++ /dev/null
@@ -1,214 +0,0 @@
-function [ successFlag ] = runExternalCholeskyTests( doPrint )
-
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-    
-    successFlag = 1;
-    
-    TOL = 1e4*eps;
-	
-    load 'benchmarkCHAIN1.mat';
-    
-	options  = qpOASES_options( 'MPC', 'printLevel',2*doPrint );
-    auxInput = qpOASES_auxInput( 'R',chol(H) );
-    
-    %% test qpOASES
-    [ x1,obj1,status1,nWSRout1,lambda1,auxOut1 ] = qpOASES( H,g(:,10),A,lb(:,10),ub(:,10),lbA(:,10),ubA(:,10),options );
-    [ x2,obj2,status2,nWSRout2,lambda2,auxOut2 ] = qpOASES( H,g(:,10),A,lb(:,10),ub(:,10),lbA(:,10),ubA(:,10),options,auxInput );
-    
-    if doPrint
-        disp( ['Runtime without R: ', num2str(auxOut1.cpuTime),'s'] )
-        disp( ['Runtime with    R: ', num2str(auxOut2.cpuTime),'s'] )
-        disp( ' ' );
-    end
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error' );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    %% test qpOASES_sequence
-    [QP,x0,obj0,status0,nWSRout0,lambda0,auxOut1] = qpOASES_sequence( 'i',H,g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options );
-	[x1,obj1,status1,nWSRout1,lambda1]            = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0,auxOut2] = qpOASES_sequence( 'i',H,g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInput );
-	[x2,obj2,status2,nWSRout2,lambda2]            = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    if doPrint
-        disp( ['Runtime without R: ', num2str(auxOut1.cpuTime),'s'] )
-        disp( ['Runtime with    R: ', num2str(auxOut2.cpuTime),'s'] )
-        disp( ' ' )
-    end
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-
-        
-    %% test simply bounded QP
-    load 'benchmarkCHAIN1A.mat';
-    
-	options  = qpOASES_options( 'MPC', 'printLevel',0*doPrint );
-    auxInput = qpOASES_auxInput( 'R',chol(H) );
-    
-    %% test qpOASES
-    [ x1,obj1,status1,nWSRout1,lambda1,auxOut1 ] = qpOASES( H,g(:,10),lb(:,10),ub(:,10),options );
-    [ x2,obj2,status2,nWSRout2,lambda2,auxOut2 ] = qpOASES( H,g(:,10),lb(:,10),ub(:,10),options,auxInput );
-    
-    if doPrint
-        disp( ['Runtime without R: ', num2str(auxOut1.cpuTime),'s'] )
-        disp( ['Runtime with    R: ', num2str(auxOut2.cpuTime),'s'] )
-        disp( ' ' );
-    end
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error' );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    %% test qpOASES_sequence
-    [QP,x0,obj0,status0,nWSRout0,lambda0,auxOut1] = qpOASES_sequence( 'i',H,g(:,1),lb(:,1),ub(:,1),options );
-	[x1,obj1,status1,nWSRout1,lambda1]            = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0,auxOut2] = qpOASES_sequence( 'i',H,g(:,1),lb(:,1),ub(:,1),options,auxInput );
-	[x2,obj2,status2,nWSRout2,lambda2]            = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    if doPrint
-        disp( ['Runtime without R: ', num2str(auxOut1.cpuTime),'s'] )
-        disp( ['Runtime with    R: ', num2str(auxOut2.cpuTime),'s'] )
-        disp( ' ' )
-    end
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceSeqTest.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceSeqTest.m
deleted file mode 100644
index 88c06ec..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceSeqTest.m
+++ /dev/null
@@ -1,436 +0,0 @@
-function [ successFlag ] = runInterfaceSeqTest( nV,nC, doPrint,seed )
-
-    if ( nargin < 4 )
-        seed = 42;
-        if ( nargin < 3 )
-            doPrint = 1;
-            if ( nargin < 2 )
-                nC = 10;
-                if ( nargin < 1 )
-                    nV = 5;
-                end
-            end
-        end
-    end
-    
-    successFlag = 1;
-
-    for isSparseH=0:1
-        for isSparseA=0:1
-            successFlag = runSeveralInterfaceSeqTests( successFlag, nV,nC,isSparseH,isSparseA, doPrint,seed );
-        end
-    end
-    
-end
-
-
-
-function [ successFlag ] = runSeveralInterfaceSeqTests( successFlag, nV,nC, isSparseH,isSparseA, doPrint,seed )
-
-    %% test without or empty A matrix
-    for hasA=0:1
-        for changeMat=0:hasA % cannot change matrices if QProblemB object is instantiated
-            for hasLowerB=0:1
-                for hasUpperB=0:1
-                    for hasOptions=0:2
-                        for hasX0=0:2
-                            for hasWS=0:2
-                                curSuccessFLAG = runSingleInterfaceSeqTest( nV,0,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,0,0,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                                successFlag = min( successFlag,curSuccessFLAG );
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-    %% test with non-empty A matrix
-    for hasLowerB=0:1
-        for hasUpperB=0:1
-            for hasLowerC=0:1
-                for hasUpperC=0:1
-                    for hasOptions=0:2
-                        for hasX0=0:2
-                            for hasWS=0:2
-                                for changeMat=0:1
-                                    curSuccessFLAG = runSingleInterfaceSeqTest( nV,nC,1,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                                    successFlag = min( successFlag,curSuccessFLAG );
-                                end
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-end
-
-
-function [ successFlag ] = runSingleInterfaceSeqTest( nV,nC,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed )
-
-    successFlag = 0;
-
-    qpData1 = generateExample( nV,nC, isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC, seed );
-    if ( changeMat > 0 )
-        qpData2 = generateExample( nV,nC, isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC, seed+1 );
-    else
-        qpData2 = generateExample( nV,nC, isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC, seed+1,qpData1.H,qpData1.Ain );
-    end
-
-    if ( changeMat == 0 )
-        string = 'Testing qpOASES_sequence( ''i/h/c'',H';
-    else
-        string = 'Testing qpOASES_sequence( ''i/m/c'',H';
-    end
-    
-    if ( isSparseH > 0 )
-        string = [string,'s,g'];
-    else
-        string = [string,'d,g'];
-    end
-    
-    if ( nC > 0 )
-        if ( isSparseA > 0 )
-            string = [string,',As'];
-        else
-            string = [string,',Ad'];
-        end
-    else
-        if ( hasA > 0 )
-            string = [string,',[]'];
-        end
-    end
-    
-    if ( hasLowerB > 0 )
-        string = [string,',lb'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasUpperB > 0 )
-        string = [string,',ub'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasLowerC > 0 )
-        string = [string,',lbA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    if ( hasUpperC > 0 )
-        string = [string,',ubA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    switch ( hasOptions )
-        case 1
-            string = [string,',opt'];
-        
-        case 2
-            string = [string,',[] '];
-            
-        case 0
-            if ( ( hasX0 > 0 ) || ( hasWS > 0 ) )
-                string = [string,',[] '];
-            end
-    end
-
-    switch ( hasX0 )
-        case 1
-            string = [string,',{x0'];
-        
-        case 2
-            string = [string,',{[]'];
-            
-        case 0
-            if ( hasWS > 0 )
-                string = [string,',{[]'];
-            end
-    end
-    
-    switch ( hasWS )
-        case 1
-            string = [string,',WS}'];
-        
-        case 2
-            string = [string,',[]}'];
-    end
-
-    string = [string,' )... '];
-    if ( doPrint > 0 )
-        disp( string );
-    end
-    
-    curSuccessFlag = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat );
-    if ( curSuccessFlag > 0 )
-        string = [string,'pass!'];
-        successFlag = 1;
-    else
-        string = [string,'fail!'];
-    end
-    
-    if ( doPrint > 0 )
-        disp( string );
-        if ( curSuccessFlag == 0 )
-            pause(0.1);
-        end
-    end
-    
-end
-
-function [ successFlag ] = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat, doPrint )
-
-    if ( nargin < 8 )
-        doPrint = 1;
-    end
-
-    %TOL = 1e-15;
-    KKTTOL = 1e-6;
-
-    successFlag = 0;
-    
-    H1 = qpData1.H;
-	g1 = qpData1.g;
-    A1 = [qpData1.Aeq;qpData1.Ain];
-	lb1 = qpData1.lb;
-    ub1 = qpData1.ub;
-    lbA1 = [qpData1.beq;qpData1.lbA];
-    ubA1 = [qpData1.beq;qpData1.ubA];
-    
-    if ( changeMat > 0 )
-        H2 = qpData2.H;
-    else
-        H2 = H1;
-    end
-	g2 = qpData2.g;
-    if ( changeMat > 0 )
-        A2 = [qpData2.Aeq;qpData2.Ain];
-    else
-        A2 = A1;
-    end
-	lb2 = qpData2.lb;
-    ub2 = qpData2.ub;
-    lbA2 = [qpData2.beq;qpData2.lbA];
-    ubA2 = [qpData2.beq;qpData2.ubA];
-
-    [nV,dummy] = size(H1); %#ok<NASGU>
-    [nC,dummy] = size(A1); %#ok<NASGU>
-    
-    if ( hasWS > 0 )
-        if ( hasWS == 1 )
-            wsB = 0 * ones( nV,1 );
-            wsC = 0 * ones( nC,1 );
-        else
-            wsB = [];
-            wsC = [];
-        end
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0,'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-
-            %auxInput = qpOASES_auxInput( 'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-            auxInput = qpOASES_auxInput( 'guessedWorkingSetB',wsB );
-            
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,[] ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,[] ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-        
-    else % hasWS == 0
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0 );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-                    
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1 ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1 ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-
-    end % hasWS
-
-
-    kktTol1 = getKktResidual( H1,g1,A1,lb1,ub1,lbA1,ubA1, x1,l1 );
-    
-    if ( changeMat > 0 )
-		kktTol2 = getKktResidual( H2,g2,A2,lb2,ub2,lbA2,ubA2, x2,l2 );
-    else
-		kktTol2 = getKktResidual( H1,g2,A1,lb2,ub2,lbA2,ubA2, x2,l2 );
-    end
-    
-    if ( ( kktTol1 <= KKTTOL ) && ( e1 >= 0 ) && ( kktTol2 <= KKTTOL ) && ( e2 >= 0 ) )
-        successFlag = 1;
-    else
-        if ( doPrint > 0 )
-            if ( ( kktTol1 > KKTTOL ) || ( kktTol2 > KKTTOL ) )
-                disp( ['kkt error: ',num2str(kktTol1),'/',num2str(kktTol2)] )
-            else
-                disp('exitflag<0')
-            end
-        end
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceTest.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceTest.m
deleted file mode 100644
index 55a5c7b..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceTest.m
+++ /dev/null
@@ -1,462 +0,0 @@
-function [ successFlag ] = runInterfaceTest( nV,nC, doPrint,seed )
-
-    if ( nargin < 4 )
-        seed = 42;
-        if ( nargin < 3 )
-            doPrint = 1;
-            if ( nargin < 2 )
-                nC = 10;
-                if ( nargin < 1 )
-                    nV = 5;
-                end
-            end
-        end
-    end
-    
-    successFlag = 1;
-
-    for isSparseH=0:1
-        for isSparseA=0:1
-            successFlag = runSeveralInterfaceTests( successFlag, nV,nC,isSparseH,isSparseA, doPrint,seed );
-        end
-    end
-    
-end
-
-
-
-function [ successFLAG ] = runSeveralInterfaceTests( successFLAG, nV,nC, isSparseH,isSparseA, doPrint,seed )
-
-    %% test without or empty A matrix
-    for hasA=0:1
-        for hasLowerB=0:1
-            for hasUpperB=0:1
-                for hasOptions=0:2
-                    for hasX0=0:1
-                        for hasWS=0:2
-                            if ( ( hasWS ~= 2 ) || ( hasA ~= 0 ) || ( hasOptions == 1 ) || ( hasX0 ~= 0 ) )
-                                curSuccessFLAG = runSingleInterfaceTest( nV,0,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,0,0,hasOptions,hasX0,hasWS, doPrint,seed );
-                                successFLAG = min( successFLAG,curSuccessFLAG );
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-    %% test with non-empty A matrix
-    for hasLowerB=0:1
-        for hasUpperB=0:1
-            for hasLowerC=0:1
-                for hasUpperC=0:1
-                    for hasOptions=0:2
-                        for hasX0=0:1
-                            for hasWS=0:2
-                                curSuccessFLAG = runSingleInterfaceTest( nV,nC,1,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS, doPrint,seed );
-                                successFLAG = min( successFLAG,curSuccessFLAG );
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-end
-
-
-function [ successFLAG ] = runSingleInterfaceTest( nV,nC,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS, doPrint,seed )
-
-    successFLAG = 0;
-
-    qpData = generateExample( nV,nC, isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC, seed );
-
-    string = 'Testing qpOASES( H';
-    
-    if ( isSparseH > 0 )
-        string = [string,'s,g'];
-    else
-        string = [string,'d,g'];
-    end
-    
-    if ( nC > 0 )
-        if ( isSparseA > 0 )
-            string = [string,',As'];
-        else
-            string = [string,',Ad'];
-        end
-    else
-        if ( hasA > 0 )
-            string = [string,',[]'];
-        end
-    end
-    
-    if ( hasLowerB > 0 )
-        string = [string,',lb'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasUpperB > 0 )
-        string = [string,',ub'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasLowerC > 0 )
-        string = [string,',lbA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    if ( hasUpperC > 0 )
-        string = [string,',ubA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    switch ( hasOptions )
-        case 1
-            string = [string,',opt'];
-        
-        case 2
-            string = [string,',[] '];
-            
-        case 0
-            if ( ( hasX0 > 0 ) || ( hasWS > 0 ) )
-                string = [string,',[] '];
-            end
-    end
-
-    switch ( hasX0 )
-        case 1
-            string = [string,',{x0'];
-        
-        case 2
-            string = [string,',{[]'];
-            
-        case 0
-            if ( hasWS > 0 )
-                string = [string,',{[]'];
-            end
-    end
-    
-    switch ( hasWS )
-        case 1
-            string = [string,',WS}'];
-        
-        case 2
-            string = [string,',[]}'];
-    end
-
-    string = [string,' )... '];
-    if ( doPrint > 0 )
-        %disp( string );
-    end
-    
-    curSuccessFlag = callQpOases( qpData,hasA,hasOptions,hasX0,hasWS, 1 );
-    if ( curSuccessFlag > 0 )
-        string = [string,'pass!'];
-        successFLAG = 1;
-    else
-        string = [string,'fail!'];
-    end
-    
-    if ( doPrint > 0 )
-        disp( string );
-        if ( curSuccessFlag == 0 )
-            pause;
-        end
-    end
-    
-end
-
-function [ successFLAG ] = callQpOases( qpData,hasA,hasOptions,hasX0,hasWS, doPrint )
-
-    if ( nargin < 6 )
-        doPrint = 1;
-    end
-
-    TOL = 1e-15;
-    KKTTOL = 1e-6;
-
-    successFLAG = 0;
-    
-    H = qpData.H;
-	g = qpData.g;
-    A = [qpData.Aeq;qpData.Ain];
-	lb = qpData.lb;
-    ub = qpData.ub;
-    lbA = [qpData.beq;qpData.lbA];
-    ubA = [qpData.beq;qpData.ubA];
-
-    [nV,dummy] = size(H); %#ok<NASGU>
-    [nC,dummy] = size(A); %#ok<NASGU>
-    
-    if ( hasWS > 0 )
-        if ( hasWS == 1 )
-            wsB = 0 * ones( nV,1 );
-            wsC = 0 * ones( nC,1 );
-        else
-            wsB = [];
-            wsC = [];
-        end
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0,'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput ); %#ok<NASGU>
-                else                        
-                    [ x1 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,options,auxInput ); %#ok<NASGU>
-                end
-            else
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,[],auxInput ); %#ok<NASGU>
-                end
-            end
-
-        else % hasX0 == 0
-
-            %auxInput = qpOASES_auxInput( 'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-            auxInput = qpOASES_auxInput( 'guessedWorkingSetC',wsC );
-            
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-                
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,options,auxInput ); %#ok<NASGU>
-                end
-            else
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,[],auxInput ); %#ok<NASGU>
-                end
-            end
-
-        end % hasX0
-        
-    else % hasWS == 0
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0 );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,options,auxInput ); %#ok<NASGU>
-                end
-                    
-            else
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,[],auxInput ); %#ok<NASGU>
-                end
-            end
-
-        else % hasX0 == 0
-            
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,options );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,options );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,options );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,options );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,options );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,options ); %#ok<NASGU>
-                end
-            else
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub ); %#ok<NASGU>
-                end
-            end
-
-        end % hasX0
-
-    end % hasWS
-
-    % check whether all calls lead to same optimal solution
-    % independent from output arguments
-    if ( ( norm(x1-x2) > TOL ) || ...
-         ( norm(x1-x3) > TOL ) || ...
-         ( norm(x1-x4) > TOL ) || ...
-         ( norm(x1-x5) > TOL ) || ...
-         ( norm(x1-x6) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in x')
-        end
-        return;
-    end
-    
-    if ( ( norm(f2-f3) > TOL ) || ...
-         ( norm(f2-f4) > TOL ) || ...
-         ( norm(f2-f5) > TOL ) || ...
-         ( norm(f2-f6) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in fval')
-        end
-        return;
-    end
-
-    if ( ( norm(e3-e4) > TOL ) || ...
-         ( norm(e3-e5) > TOL ) || ...
-         ( norm(e3-e6) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in exitflag')
-        end
-        return;
-    end
-
-    if ( ( norm(i4-i5) > TOL ) || ...
-         ( norm(i4-i6) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in iter')
-        end
-        return;
-    end
-    
-    if ( norm(l5-l6) > TOL )
-        if ( doPrint > 0 )
-            disp('diff in lambda')
-        end
-        return;
-    end
-    
-    
-    kktTol = getKktResidual( H,g,A,lb,ub,lbA,ubA, x6,l6 );
-    
-    if ( ( kktTol <= KKTTOL ) && ( e6 >= 0 ) )
-        successFLAG = 1;
-    else
-        if ( doPrint > 0 )
-            disp( ['kkt error: ',num2str(kktTol)] )
-        end
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQAP8.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQAP8.m
deleted file mode 100644
index 58660d9..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQAP8.m
+++ /dev/null
@@ -1,37 +0,0 @@
-function [ successFlag ] = runQAP8( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-
-    try
-        load 'QAP8.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-    options = qpOASES_options('default', 'maxIter',30000, 'printLevel',-2*doPrint );
-    tic
-    [x, fval, status, nWSRout, y] = qpOASES(sparse(QP.H), QP.f, ...
-        sparse(QP.C), QP.lb, QP.ub, QP.cl, QP.cu, options);
-    t = toc;
-    
-    if ( doPrint > 0 )
-        disp( ['solution time: ',num2str(t),' seconds'] );
-    end
-    
-    if ( ( status == 0 ) && ( nWSRout < 23200 ) )
-        successFlag = 1;
-    end
-    
-    % check error and print
-    if doPrint
-        [stat, feas, cmpl] = qpresidual(S.B, S.b1, S.C, S.cl1, S.cu1, x, -y);
-        fprintf( '%d iters in %.3fs to tolerance %.2e\n', nWSRout, t, max([stat,feas,cmpl]) );
-        fprintf( 'Status: %d\n', status );
-    end
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQSHARE1B.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQSHARE1B.m
deleted file mode 100644
index c1ba1e2..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQSHARE1B.m
+++ /dev/null
@@ -1,44 +0,0 @@
-function [ successFlag ] = runQSHARE1B( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-
-    try
-        load 'QSHARE1B.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-    
-    options = qpOASES_options('default', 'maxIter',600, 'maxCpuTime',2.0, 'printLevel',-2*doPrint );
-    auxInput = qpOASES_auxInput( 'hessianType',[] );
-    tic
-    [xD,fvalD,exitflagD,iterD,lambdaD] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-    tD = toc;
-    kktD = getKktResidual( H,g,A,lb,ub,lbA,ubA, xD,lambdaD );
-    
-    if ( doPrint > 0 )
-        disp( ['dense kkt tol:        ',num2str(kktD, '%.3e')] );
-        disp( ['dense solution time:  ',num2str(tD),' seconds'] );
-		disp( ['dense #iterations:    ',num2str(iterD),] );
-    end
-    
-    tic
-    [xS,fvalS,exitflagS,iterS,lambdaS] = qpOASES( sparse(H),g,sparse(A),lb,ub,lbA,ubA,options );
-    tS = toc;
-    kktS = getKktResidual( H,g,A,lb,ub,lbA,ubA, xS,lambdaS );
-    
-    if ( doPrint > 0 )
-        disp( ['sparse kkt tol:       ',num2str(kktS, '%.3e')] );
-        disp( ['sparse solution time: ',num2str(tS),' seconds'] );
-		disp( ['sparse #iterations:   ',num2str(iterS),] );
-    end
-    
-    if ( ( exitflagD == 0 ) && ( kktD < 1e-6 ) && ( exitflagS == 0 ) && ( kktS < 1e-6 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomIdHessian.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomIdHessian.m
deleted file mode 100644
index 81199f7..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomIdHessian.m
+++ /dev/null
@@ -1,435 +0,0 @@
-function [ successFlag ] = runRandomIdHessian( nV,nC, doPrint,seed )
-
-    if ( nargin < 4 )
-        seed = 42;
-        if ( nargin < 3 )
-            doPrint = 1;
-            if ( nargin < 2 )
-                nC = 10;
-                if ( nargin < 1 )
-                    nV = 5;
-                end
-            end
-        end
-    end
-    
-    successFlag = 1;
-
-    for isSparseH=0:1
-        for isSparseA=0:1
-            successFlag = runSeveralIdSeqTests( successFlag, nV,nC,isSparseH,isSparseA, doPrint,seed );
-        end
-    end
-    
-end
-
-
-function [ successFlag ] = runSeveralIdSeqTests( successFlag, nV,nC, isSparseH,isSparseA, doPrint,seed )
-
-    %% test without or empty A matrix
-    for hasA=0:1
-        for changeMat=0:hasA % cannot change matrices if QProblemB object is instantiated
-            for hasLowerB=0:1
-                for hasUpperB=0:1
-                    for hasOptions=0:1
-                        for hasX0=0:2
-                            for hasWS=0:2
-                                curSuccessFLAG = runSingleIdSeqTest( nV,0,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,0,0,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                                successFlag = min( successFlag,curSuccessFLAG );
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-    %% test with non-empty A matrix
-    for hasLowerB=0:1
-        for hasUpperB=0:1
-            for hasLowerC=0:1
-                for hasUpperC=0:1
-                    for hasOptions=0:1
-                        for hasX0=0:2
-                            for hasWS=0:2
-                                for changeMat=0:1
-                                    curSuccessFLAG = runSingleIdSeqTest( nV,nC,1,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                                    successFlag = min( successFlag,curSuccessFLAG );
-                                end
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-end
-
-
-function [ successFlag ] = runSingleIdSeqTest( nV,nC,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed )
-
-    successFlag = 0;
-
-    qpFeatures = setupQpFeaturesStruct( );
-    
-    qpFeatures.nV = nV;
-    qpFeatures.nC = nC;
-    
-    qpFeatures.isSparseH = isSparseH;
-    qpFeatures.isSparseA = isSparseA;
-    
-    qpFeatures.hasLowerB = hasLowerB;
-    qpFeatures.hasUpperB = hasUpperB;
-    qpFeatures.hasLowerC = hasLowerC;
-    qpFeatures.hasUpperC = hasUpperC;
-    
-    qpFeatures.hessianType = 2;
-    
-    qpData1 = generateRandomQp( qpFeatures,seed );
-    qpData2 = generateRandomQp( qpFeatures,seed );
-
-    if ( changeMat == 0 )
-        string = 'Testing qpOASES_sequence( ''i/h/c'',ID';
-    else
-        string = 'Testing qpOASES_sequence( ''i/m/c'',ID';
-    end
-    
-    if ( isSparseH > 0 )
-        string = [string,'s,g'];
-    else
-        string = [string,'d,g'];
-    end
-    
-    if ( nC > 0 )
-        if ( isSparseA > 0 )
-            string = [string,',As'];
-        else
-            string = [string,',Ad'];
-        end
-    else
-        if ( hasA > 0 )
-            string = [string,',[]'];
-        end
-    end
-    
-    if ( hasLowerB > 0 )
-        string = [string,',lb'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasUpperB > 0 )
-        string = [string,',ub'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasLowerC > 0 )
-        string = [string,',lbA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    if ( hasUpperC > 0 )
-        string = [string,',ubA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    switch ( hasOptions )
-        case 1
-            string = [string,',opt'];
-        
-        case 2
-            string = [string,',[] '];
-            
-        case 0
-            if ( ( hasX0 > 0 ) || ( hasWS > 0 ) )
-                string = [string,',[] '];
-            end
-    end
-
-    switch ( hasX0 )
-        case 1
-            string = [string,',{x0'];
-        
-        case 2
-            string = [string,',{[]'];
-            
-        case 0
-            if ( hasWS > 0 )
-                string = [string,',{[]'];
-            end
-    end
-    
-    switch ( hasWS )
-        case 1
-            string = [string,',WS}'];
-        
-        case 2
-            string = [string,',[]}'];
-    end
-
-    string = [string,' )... '];
-    if ( doPrint > 0 )
-        %disp( string );
-    end
-    
-    curSuccessFlag = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat,doPrint );
-    if ( curSuccessFlag > 0 )
-        string = [string,'pass!'];
-        successFlag = 1;
-    else
-        string = [string,'fail!'];
-    end
-    
-    if ( doPrint > 0 )
-        disp( string );
-        if ( curSuccessFlag == 0 )
-            pause;
-        end
-    end
-    
-end
-
-
-
-function [ successFlag ] = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat, doPrint )
-
-    if ( nargin < 8 )
-        doPrint = 1;
-    end
-
-    TOL = 1e-15;
-    KKTTOL = 1e-6;
-
-    successFlag = 0;
-    
-    H1 = qpData1.H;
-	g1 = qpData1.g;
-    A1 = [qpData1.Aeq;qpData1.Ain];
-	lb1 = qpData1.lb;
-    ub1 = qpData1.ub;
-    lbA1 = [qpData1.beq;qpData1.lbA];
-    ubA1 = [qpData1.beq;qpData1.ubA];
-    
-    H2 = qpData2.H;
-	g2 = qpData2.g;
-    A2 = [qpData2.Aeq;qpData2.Ain];
-	lb2 = qpData2.lb;
-    ub2 = qpData2.ub;
-    lbA2 = [qpData2.beq;qpData2.lbA];
-    ubA2 = [qpData2.beq;qpData2.ubA];
-
-    [nV,dummy] = size(H1);
-    [nC,dummy] = size(A1);
-    
-    if ( hasWS > 0 )
-        if ( hasWS == 1 )
-            wsB = 0 * ones( nV,1 );
-            wsC = 0 * ones( nC,1 );
-        else
-            wsB = [];
-            wsC = [];
-        end
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0,'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else                        
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-            
-            auxInput = qpOASES_auxInput( 'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,[] );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,[] );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-        
-    else % hasWS == 0
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0 );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-                    
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1 );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1 );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-
-    end % hasWS
-
-
-    kktTol1 = getKktResidual( H1,g1,A1,lb1,ub1,lbA1,ubA1, x1,l1 );
-    
-    if ( changeMat > 0 )
-		kktTol2 = getKktResidual( H2,g2,A2,lb2,ub2,lbA2,ubA2, x2,l2 );
-	else
-		kktTol2 = getKktResidual( H1,g2,A1,lb2,ub2,lbA2,ubA2, x2,l2 );
-	end
-    
-    if ( ( kktTol1 <= KKTTOL ) && ( e1 >= 0 ) && ( kktTol2 <= KKTTOL ) && ( e2 >= 0 ) )
-        successFlag = 1;
-    else
-        if ( doPrint > 0 )
-            disp( ['kkt error: ',num2str(kktTol1),'/',num2str(kktTol2)] )
-        end
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomZeroHessian.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomZeroHessian.m
deleted file mode 100644
index 5fc4b91..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomZeroHessian.m
+++ /dev/null
@@ -1,433 +0,0 @@
-function [ successFlag ] = runRandomZeroHessian( nV,nC, doPrint,seed )
-
-    if ( nargin < 4 )
-        seed = 42;
-        if ( nargin < 3 )
-            doPrint = 1;
-            if ( nargin < 2 )
-                nC = 10;
-                if ( nargin < 1 )
-                    nV = 5;
-                end
-            end
-        end
-    end
-    
-    successFlag = 1;
-
-    for isSparseH=0:1
-        for isSparseA=0:1
-            successFlag = runSeveralIdSeqTests( successFlag, nV,nC,isSparseH,isSparseA, doPrint,seed );
-        end
-    end
-    
-end
-
-
-function [ successFlag ] = runSeveralIdSeqTests( successFlag, nV,nC, isSparseH,isSparseA, doPrint,seed )
-
-    %% test without or empty A matrix
-    % {
-    for hasA=0:1
-        for changeMat=0:hasA % cannot change matrices if QProblemB object is instantiated
-            for hasOptions=1:1
-                for hasX0=0:2
-                    for hasWS=0:2
-                        curSuccessFLAG = runSingleIdSeqTest( nV,0,hasA,isSparseH,isSparseA, 1,1,0,0,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                        successFlag = min( successFlag,curSuccessFLAG );
-                    end
-                end
-            end
-        end
-    end
-    %}
-    
-    %% test with non-empty A matrix
-    for hasLowerC=0:1
-        for hasUpperC=0:1
-            for hasOptions=1:1
-                for hasX0=0:2
-                    for hasWS=0:2
-                        for changeMat=0:1
-                            curSuccessFLAG = runSingleIdSeqTest( nV,nC,1,isSparseH,isSparseA, 1,1,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                            successFlag = min( successFlag,curSuccessFLAG );
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-end
-
-
-function [ successFlag ] = runSingleIdSeqTest( nV,nC,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed )
-
-    successFlag = 0;
-
-    qpFeatures = setupQpFeaturesStruct( );
-    
-    qpFeatures.nV = nV;
-    qpFeatures.nC = nC;
-    
-    qpFeatures.isSparseH = isSparseH;
-    qpFeatures.isSparseA = isSparseA;
-    
-    qpFeatures.hasLowerB = hasLowerB;
-    qpFeatures.hasUpperB = hasUpperB;
-    qpFeatures.hasLowerC = hasLowerC;
-    qpFeatures.hasUpperC = hasUpperC;
-    
-    qpFeatures.hessianType = 3;
-    
-    qpData1 = generateRandomQp( qpFeatures,seed );
-    qpData2 = generateRandomQp( qpFeatures,seed );
-
-    if ( changeMat == 0 )
-        string = 'Testing qpOASES_sequence( ''i/h/c'',0';
-    else
-        string = 'Testing qpOASES_sequence( ''i/m/c'',0';
-    end
-    
-    if ( isSparseH > 0 )
-        string = [string,'s,g'];
-    else
-        string = [string,'d,g'];
-    end
-    
-    if ( nC > 0 )
-        if ( isSparseA > 0 )
-            string = [string,',As'];
-        else
-            string = [string,',Ad'];
-        end
-    else
-        if ( hasA > 0 )
-            string = [string,',[]'];
-        end
-    end
-    
-    if ( hasLowerB > 0 )
-        string = [string,',lb'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasUpperB > 0 )
-        string = [string,',ub'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasLowerC > 0 )
-        string = [string,',lbA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    if ( hasUpperC > 0 )
-        string = [string,',ubA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    switch ( hasOptions )
-        case 1
-            string = [string,',opt'];
-        
-        case 2
-            string = [string,',[] '];
-            
-        case 0
-            if ( ( hasX0 > 0 ) || ( hasWS > 0 ) )
-                string = [string,',[] '];
-            end
-    end
-
-    switch ( hasX0 )
-        case 1
-            string = [string,',{x0'];
-        
-        case 2
-            string = [string,',{[]'];
-            
-        case 0
-            if ( hasWS > 0 )
-                string = [string,',{[]'];
-            end
-    end
-    
-    switch ( hasWS )
-        case 1
-            string = [string,',WS}'];
-        
-        case 2
-            string = [string,',[]}'];
-    end
-
-    string = [string,' )... '];
-    if ( doPrint > 0 )
-        %disp( string );
-    end
-    
-	%try
-    curSuccessFlag = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat,doPrint );
-	%catch
-	%curSuccessFlag = 0;
-	%end
-    if ( curSuccessFlag > 0 )
-        string = [string,'pass!'];
-        successFlag = 1;
-    else
-        string = [string,'fail!'];
-    end
-    
-    if ( doPrint > 0 )
-        disp( string );
-        if ( curSuccessFlag == 0 )
-            %pause;
-        end
-    end
-    
-end
-
-
-
-function [ successFlag ] = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat, doPrint )
-
-    if ( nargin < 8 )
-        doPrint = 1;
-    end
-
-    TOL = 1e-15;
-    KKTTOL = 1e-6;
-
-    successFlag = 0;
-    
-    H1 = qpData1.H;
-	g1 = qpData1.g;
-    A1 = [qpData1.Aeq;qpData1.Ain];
-	lb1 = qpData1.lb;
-    ub1 = qpData1.ub;
-    lbA1 = [qpData1.beq;qpData1.lbA];
-    ubA1 = [qpData1.beq;qpData1.ubA];
-    
-    H2 = qpData2.H;
-	g2 = qpData2.g;
-    A2 = [qpData2.Aeq;qpData2.Ain];
-	lb2 = qpData2.lb;
-    ub2 = qpData2.ub;
-    lbA2 = [qpData2.beq;qpData2.lbA];
-    ubA2 = [qpData2.beq;qpData2.ubA];
-
-    [nV,dummy] = size(H1);
-    [nC,dummy] = size(A1);
-    
-    if ( hasWS > 0 )
-        if ( hasWS == 1 )
-            wsB = 0 * ones( nV,1 );
-            wsC = 0 * ones( nC,1 );
-        else
-            wsB = [];
-            wsC = [];
-        end
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0,'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options( 'fast' );
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else                        
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-
-            auxInput = qpOASES_auxInput( 'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-            
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options( 'fast' );
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,[] );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,[] );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-        
-    else % hasWS == 0
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0 );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options( 'fast' );
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-                    
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options( 'fast' );
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1 );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1 );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-
-    end % hasWS
-
-
-    kktTol1 = getKktResidual( H1,g1,A1,lb1,ub1,lbA1,ubA1, x1,l1 );
-    
-    if ( changeMat > 0 )
-		kktTol2 = getKktResidual( H2,g2,A2,lb2,ub2,lbA2,ubA2, x2,l2 );
-	else
-		kktTol2 = getKktResidual( H1,g2,A1,lb2,ub2,lbA2,ubA2, x2,l2 );
-	end
-    
-    if ( ( kktTol1 <= KKTTOL ) && ( e1 >= 0 ) && ( kktTol2 <= KKTTOL ) && ( e2 >= 0 ) )
-        successFlag = 1;
-    else
-        if ( doPrint > 0 )
-            disp( ['kkt error: ',num2str(kktTol1),'/',num2str(kktTol2)] )
-        end
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runSimpleSpringExample.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runSimpleSpringExample.m
deleted file mode 100644
index 2f494a6..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runSimpleSpringExample.m
+++ /dev/null
@@ -1,34 +0,0 @@
-function [ successFlag ] = runSimpleSpringExample( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-    % parameter
-    k1 = 100;
-    k2 = 100;
-
-    m = 1;
-    g = 9.81;
-
-    % QP data
-    H = [ k1,0; 0,k2 ];
-    g = [ m*g; 0 ];
-
-    lb = [ 0; 0 ];
-    ub = [ 1; 1 ];
-
-    A = [ 1,1 ];
-    lbA = 1;
-    ubA = 1;
-
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-    [x,fval,exitflag,iter] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-
-    if ( ( exitflag == 0 ) && ( iter < 5 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestAPrioriKnownSeq1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestAPrioriKnownSeq1.m
deleted file mode 100644
index 7f963cd..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestAPrioriKnownSeq1.m
+++ /dev/null
@@ -1,87 +0,0 @@
-function [ successFlag ] = runTestAPrioriKnownSeq1( doPrint )
-
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 1;
-    TOL = eps;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkCRANE1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-    [nC,nV] = size(A);
-    [nV,nP] = size(g);
-
-    xOptSeq = zeros(nV,nP);
-    objOptSeq = zeros(1,nP);
-    statusSeq = zeros(1,nP);
-    iterSeq = zeros(1,nP);
-    yOptSeq = zeros(nV+nC,nP);
-
-	options = qpOASES_options( 'fast','maxIter',100, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-        xOptSeq(:,i) = x;
-        objOptSeq(:,i) = obj;
-        statusSeq(:,i) = status;
-        iterSeq(:,i) = nWSRout;
-        yOptSeq(:,i) = lambda;
-        
-    end
-	
-	qpOASES_sequence( 'c',QP );
-    
-    
-    [xOptAPKSeq,objOptAPKSeq,statusAPKSeq,iterAPKSeq,yOptAPKSeq] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-    
-    if ( norm( xOptSeq-xOptAPKSeq ) > TOL )
-        successFlag = 0;
-        if ( doPrint > 0 )
-            disp( 'xOpt error' )
-        end
-    end
-    
-    if ( norm( objOptSeq-objOptAPKSeq ) > TOL )
-        successFlag = 0;
-        if ( doPrint > 0 )
-            disp( 'objOpt error' )
-        end
-    end
-    
-    if ( sum( statusSeq~=statusAPKSeq ) > 0 )
-        successFlag = 0;
-        if ( doPrint > 0 )
-            disp( 'status error' )
-        end
-    end
-    
-    if ( sum( iterSeq~=iterAPKSeq ) > 0 )
-        successFlag = 0;
-        if ( doPrint > 0 )
-            disp( 'iter error' )
-        end
-    end
-    
-    if ( norm( yOptSeq-yOptAPKSeq ) > TOL )
-        successFlag = 0;
-        if ( doPrint > 0 )
-            disp( 'yOpt error' )
-        end
-    end
-	
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSeq.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSeq.m
deleted file mode 100644
index 00c4fe8..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSeq.m
+++ /dev/null
@@ -1,104 +0,0 @@
-function [ successFlag ] = runTestSeq( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 1;
-    
-
-    % test case constants
-    m = 50;
-    n = 100;
-    nMajSeq = 8;
-    nMinSeq = 4;
-    nSeq = nMajSeq * nMinSeq;
-    p = 2; % interpolation monomial power
-    fldim = 5; % feedback law dimension
-
-    % generate start and end problem
-    Ls = sprand(n, n, 0.03);
-    Hs = Ls' * Ls + 1e-8 * eye(n);
-    As = sprand(m, n, 0.05);
-
-    % negative (!) definite Hessian
-    Le = sprand(n, n, 0.03);
-    He = -Le' * Le;
-    Ae = sprand(m, n, 0.05);
-
-    lbAs = -rand(m,1);
-    ubAs = rand(m,1); 
-    ubs = ones(n,1);
-    lbs = -ones(n,1);
-    gs = 10*rand(n,1);
-
-    lbAe = -rand(m,1);
-    ubAe = rand(m,1); 
-    ube = ones(n,1);
-    lbe = -ones(n,1);
-    ge = 10*rand(n,1);
-
-    % monomial interpolation
-    tmaj = 1 - (1:1/(1-nMajSeq):0).^p;
-    for i = 1:nMajSeq
-        tau = tmaj(i);
-        H{i} = (1-tau) * Hs + tau * He;
-        A{i} = (1-tau) * As + tau * Ae;
-    end
-    t = 1 - (1:1/(1-nSeq):0).^p;
-    for i = 1:nSeq
-        tau = t(i);
-        lbA{i} = (1-tau) * lbAs + tau * lbAe;
-        ubA{i} = (1-tau) * ubAs + tau * ubAe;
-        lb{i} = (1-tau) * lbs + tau * lbe;
-        ub{i} = (1-tau) * ubs + tau * ube;
-        g{i} = (1-tau) * gs + tau * ge;
-    end
-
-    x = zeros(n,1);
-
-    if ~exist('cumIters', 'var')
-        cumIters = zeros(nSeq, 1);
-    end
-
-    % solve sequence of QPs
-    if ( doPrint > 0 )
-        fprintf('%3s %5s\n', 'seq', 'iters')
-    end
-    
-    for i = 1:nSeq
-        if i == 1
-            [QP, x, fval, exitflag, iter, lambda] = qpOASES_sequence('i', ...
-                H{i}, g{i}, A{i}, lb{i}, ub{i}, lbA{i}, ubA{i}, x);
-        else
-            if mod(i-1, nMinSeq) == 0
-                j = (i-1) / nMinSeq + 1;
-                [x, fval, exitflag, iter, lambda] = qpOASES_sequence('m', QP, ...
-                    H{j}, g{i}, A{j}, lb{i}, ub{i}, lbA{i}, ubA{i});
-            else
-                [x, fval, exitflag, iter, lambda] = qpOASES_sequence('h', QP, ...
-                    g{i}, lb{i}, ub{i}, lbA{i}, ubA{i});
-            end
-        end
-        
-        if ( doPrint > 0 )
-            fprintf('%3d %5d\n', i, iter)
-        end
-        
-        cumIters(i) = cumIters(i) + iter;
-        
-        if ( exitflag ~= 0 )
-            successFlag = 0;
-        end
-    end
-
-    % solve EQP
-    V0 = zeros(n, fldim);
-    Lambda = eye(m, fldim);
-    [X, Y] = qpOASES_sequence('e', QP, V0, V0, V0, Lambda, Lambda);
-    FL = X(1:fldim,:);
-
-    % clear
-    qpOASES_sequence('c', QP)
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse.m
deleted file mode 100644
index 272c689..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse.m
+++ /dev/null
@@ -1,33 +0,0 @@
-function [ successFlag ] = runTestSparse( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-
-
-    m = 50;
-    n = 100;
-
-    L = sprand(n, n, 0.03);
-    H = L' * L;
-    A = sprand(m, n, 0.05);
-
-    lbA = -rand(m,1);
-    ubA = rand(m,1); 
-    ub = ones(n,1);
-    lb = -ones(n,1);
-    g = 10*rand(n,1);
-    
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-
-    [x1,dummy1,exitflag1,iter1] = qpOASES(full(H), g, full(A), lb, ub, lbA, ubA, options);
-    [x2,dummy1,exitflag2,iter2] = qpOASES(H, g, A, lb, ub, lbA, ubA, options);
-    
-    if ( ( exitflag1 == 0 ) && ( exitflag2 == 0 ) && ( iter1 == iter2 ) ...
-            && ( norm(x1-x2) < 1e-10 ) )
-        successFlag = 1;
-    end
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse2.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse2.m
deleted file mode 100644
index fc1f816..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse2.m
+++ /dev/null
@@ -1,33 +0,0 @@
-function [ successFlag ] = runTestSparse2( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-
-    m = 50;
-    n = 100;
-
-    L = sprand(n, n, 0.03);
-    H = L' * L;
-    A = sprand(m, n, 0.05);
-
-    lbA = -rand(m,1);
-    ubA = rand(m,1); 
-    ub = ones(n,1);
-    lb = -ones(n,1);
-    g = 10*rand(n,1);
-
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-    
-    [QP,dummy1,dummy2,exitflag1] = qpOASES_sequence( 'i', H, g, A, lb, ub, lbA, ubA, options );
-    [dummy1,dummy2,exitflag2] = qpOASES_sequence( 'h',QP, g*2, lb, ub, lbA, ubA );
-    qpOASES_sequence( 'c',QP );
-    
-    if ( ( exitflag1 == 0 ) && ( exitflag2 == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse3.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse3.m
deleted file mode 100644
index c4f870c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse3.m
+++ /dev/null
@@ -1,39 +0,0 @@
-function [ successFlag ] = runTestSparse3( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-
-    
-    m = 50;
-    n = 100;
-
-    L = sprand(n, n, 0.03);
-    H = L' * L;
-    A = sprand(m, n, 0.05);
-
-    lbA = -rand(m,1);
-    ubA = rand(m,1); 
-    ub = ones(n,1);
-    lb = -ones(n,1);
-    g = 10*rand(n,1);
-
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-    
-    
-    [QP,dummy1,dummy2,exitflag1] = qpOASES_sequence( 'i', H, g, A, lb, ub, lbA, ubA, options );
-
-    L = sprand(n, n, 0.03);
-    H = L' * L;
-    A = sprand(m, n, 0.05);
-
-    [dummy1,dummy2,exitflag2] = qpOASES_sequence( 'm',QP, H, g*2, A, lb, ub, lbA, ubA );
-    qpOASES_sequence( 'c',QP );
-    
-    if ( ( exitflag1 == 0 ) && ( exitflag2 == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse4.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse4.m
deleted file mode 100644
index 7c468e4..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse4.m
+++ /dev/null
@@ -1,29 +0,0 @@
-function [ successFlag ] = runTestSparse4( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-    
-    n = 100;
-
-    L = sprand(n, n, 0.03);
-    H = L' * L;
-
-    ub = ones(n,1);
-    lb = -ones(n,1);
-    g = 10*rand(n,1);
-    
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-
-    [QP,dummy1,dummy2,exitflag1] = qpOASES_sequence( 'i', H, g, lb, ub, options );
-    [dummy1,dummy2,exitflag2] = qpOASES_sequence( 'h',QP, g*2, lb, ub );
-    qpOASES_sequence( 'c',QP );
-
-    if ( ( exitflag1 == 0 ) && ( exitflag2 == 0 ) )
-        successFlag = 1;
-    end
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestWorkingSetLI.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestWorkingSetLI.m
deleted file mode 100644
index 3cdfeb4..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestWorkingSetLI.m
+++ /dev/null
@@ -1,50 +0,0 @@
-function [ successFlag ] = runTestWorkingSetLI( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 1;
-    
-    qpFeatures = setupQpFeaturesStruct( );
-    
-    qpFeatures.nV = 20;
-    qpFeatures.nC = 100;
-    
-    qpFeatures.isSparseH = 0;
-    qpFeatures.isSparseA = 0;
-    
-    qpFeatures.hasLowerB = 1;
-    qpFeatures.hasUpperB = 1;
-    qpFeatures.hasLowerC = 1;
-    qpFeatures.hasUpperC = 1;
-    
-    qpFeatures.makeInfeas = 1;
-    
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint, 'initialStatusBounds',0 );
-    
-    exitflag = 0;
-    counter = 0;
-    
-    while ( ( exitflag ~= -42 ) && ( counter < 100 ) )
-        
-        counter = counter+1;
-        
-        qpData = generateRandomQp( qpFeatures );
-        B = [ eye( qpFeatures.nV ); qpData.Ain ];
-    
-        [x,dummy1,exitflag,dummy2,dummy3,auxOutput] = qpOASES( qpData.H,qpData.g,qpData.Ain, ...
-                qpData.lb,qpData.ub,qpData.lbA,qpData.ubA, options ); %#ok<*NASGU>
-            
-        WS = [auxOutput.workingSetB; auxOutput.workingSetC];
-        nAct = sum( WS~=0 );
-        Bact = B( WS~=0,: );
-
-        if ( nAct ~= rank(Bact) )
-            successFlag = 0;
-            return;
-        end
-        
-    end
-   
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runVanBarelsUnboundedQP.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runVanBarelsUnboundedQP.m
deleted file mode 100644
index 9198342..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runVanBarelsUnboundedQP.m
+++ /dev/null
@@ -1,25 +0,0 @@
-function [ successFlag ] = runVanBarelsUnboundedQP( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-    try
-        data = load( 'vanBarelsUnboundedQP.mat' );
-    catch
-        successFlag = -1;
-        return;
-    end
-    
-    options1 = qpOASES_options( 'default', 'printLevel',-1*doPrint );
-    
-    [dummy1,dummy2,exitflag1,iter1] = qpOASES( data.H,data.g,data.lb,data.ub,options1 ); %#ok<*NASGU>
-
-    % should return "QP unbounded"
-    if ( exitflag1 == -3 )
-        successFlag = 1;
-    end
-   
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/runUnitTests b/extlibs/qpOASES-3.2.0/testing/runUnitTests
deleted file mode 100755
index 3a1203e..0000000
--- a/extlibs/qpOASES-3.2.0/testing/runUnitTests
+++ /dev/null
@@ -1,110 +0,0 @@
-#!/usr/bin/env bash
-
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/runUnitTests
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014-2015
-
-# defining colors for output
-red='\e[0;31m'
-green='\e[0;32m'
-NC='\e[0m' # No Color
-
-# runs a number of examples to detect malfunctioning of the code
-
-function runTest {
-	echo -n "Running unit test $2 $3... "
-
-	$2 $3 > dummy.txt;
-	retVal=$?;
-	rm -rf dummy.txt;
-
-	if [ $retVal == 0 ]; then
-		echo -e "${green}passed!${NC}"
-	else
-		if [ $retVal == 99 ]; then
-			echo "problem data missing!"
-		else
-			echo -e "${red}failed!${NC}"
-			counter=$[counter+1];
-		fi
-	fi
-}
-
-
-cd ..;
-make testing;
-cd testing;
-
-counter=0;
-
-# run unit tests
-runTest $counter ../bin/test_matrices;
-runTest $counter ../bin/test_matrices2;
-runTest $counter ../bin/test_matrices3;
-runTest $counter ../bin/test_indexlist;
-
-runTest $counter ../bin/test_example1;
-runTest $counter ../bin/test_example1a;
-runTest $counter ../bin/test_example1b;
-runTest $counter ../bin/test_example2;
-runTest $counter ../bin/test_example4;
-runTest $counter ../bin/test_example5;
-runTest $counter ../bin/test_exampleLP;
-runTest $counter ../bin/test_qrecipe;
-runTest $counter ../bin/test_qrecipeSchur;
-runTest $counter ../bin/test_infeasible1;
-runTest $counter ../bin/test_hs268;
-
-runTest $counter ../bin/test_example6;
-runTest $counter ../bin/test_example7;
-runTest $counter ../bin/test_sebastien1;
-runTest $counter ../bin/test_vanBarelsUnboundedQP;
-runTest $counter ../bin/test_janick1;
-runTest $counter ../bin/test_janick2;
-runTest $counter ../bin/test_constraintProduct1;
-runTest $counter ../bin/test_constraintProduct2;
-runTest $counter ../bin/test_guessedWS1;
-runTest $counter ../bin/test_externalChol1;
-runTest $counter ../bin/test_gradientShift;
-runTest $counter ../bin/test_runAllOqpExamples;
-
-runTest $counter ../bin/test_bench Odd;
-runTest $counter ../bin/test_bench Ods;
-#runTest $counter ../bin/test_bench Ord;
-#runTest $counter ../bin/test_bench Ors;
-runTest $counter ../bin/test_bench Omd;
-#runTest $counter ../bin/test_bench Oms;
-
-
-if [ $counter == 0 ]; then
-	echo -e "${green}All available tests passed successfully!${NC}"
-else
-	echo -e "${red}$counter test(s) failed!${NC}"
-	exit 1
-fi
-- 
2.34.1

