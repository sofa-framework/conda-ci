From 14e4dede732cd7c9a381c1c7705079a95ae6701e Mon Sep 17 00:00:00 2001
From: Olivier Roussel <olivier.roussel@inria.fr>
Date: Mon, 25 Mar 2024 14:31:02 +0100
Subject: [PATCH 1/3] fix invalid case for cmake modules directory

---
 cmake/{modules => Modules}/FindHIDAPI.cmake   |  0
 cmake/{modules => Modules}/FindROBOTINO.cmake |  0
 cmake/{modules => Modules}/FindVRPN.cmake     |  0
 cmake/modules/FindOASES.cmake                 | 62 -------------------
 4 files changed, 62 deletions(-)
 rename cmake/{modules => Modules}/FindHIDAPI.cmake (100%)
 rename cmake/{modules => Modules}/FindROBOTINO.cmake (100%)
 rename cmake/{modules => Modules}/FindVRPN.cmake (100%)
 delete mode 100644 cmake/modules/FindOASES.cmake

diff --git a/cmake/modules/FindHIDAPI.cmake b/cmake/Modules/FindHIDAPI.cmake
similarity index 100%
rename from cmake/modules/FindHIDAPI.cmake
rename to cmake/Modules/FindHIDAPI.cmake
diff --git a/cmake/modules/FindROBOTINO.cmake b/cmake/Modules/FindROBOTINO.cmake
similarity index 100%
rename from cmake/modules/FindROBOTINO.cmake
rename to cmake/Modules/FindROBOTINO.cmake
diff --git a/cmake/modules/FindVRPN.cmake b/cmake/Modules/FindVRPN.cmake
similarity index 100%
rename from cmake/modules/FindVRPN.cmake
rename to cmake/Modules/FindVRPN.cmake
diff --git a/cmake/modules/FindOASES.cmake b/cmake/modules/FindOASES.cmake
deleted file mode 100644
index bcddfd3..0000000
--- a/cmake/modules/FindOASES.cmake
+++ /dev/null
@@ -1,62 +0,0 @@
-# Find the OASES includes and libraries.
-# The following variables are set if OASES is found.  If OASES is not
-# found, OASES_FOUND is set to false.
-#  OASES_FOUND        - True when the OASES include directory is found.
-#  OASES_INCLUDE_DIRS - the path to where the OASES include files are.
-#  OASES_LIBRARY_DIRS - The path to where the OASES library files are.
-#  OASES_LIBRARIES    - The libraries to link against OASES
-
-# One may want to use a specific OASES Library by setting
-# OASES_LIBRARY_DIRECTORY before FIND_PACKAGE(OASES)
-INCLUDE(FindPackageHandleStandardArgs)
-
-IF(APPLE)
-	set (extension ".dylib")
-ELSEIF(WIN32)
-	set (extension ".lib") #On Windows, load-time dynamic linking links to the .lib before using the dll at runtime
-ELSE(WIN32)
-	set (extension ".so")
-ENDIF(APPLE)
-
-IF(OASES_LIBRARY_DIRECTORY)
-  MESSAGE(STATUS "Looking for OASES library libqpOASES${extension} in ${OASES_LIBRARY_DIRECTORY}bin/")
-  FIND_LIBRARY(OASES_LIBRARY libqpOASES${extension} PATHS "${OASES_LIBRARY_DIRECTORY}bin/" NO_DEFAULT_PATH)
-  IF(OASES_LIBRARY)
-    MESSAGE(STATUS "Found : OASES_LIBRARY")
-  ENDIF(OASES_LIBRARY)
-ELSE(OASES_LIBRARY_DIRECTORY)
-  FIND_LIBRARY(OASES_LIBRARY libqpOASES${extension} PATHS ENV LD_LIBRARY_PATH ENV DYLD_LIBRARY_PATH)
-ENDIF(OASES_LIBRARY_DIRECTORY)
-
-FIND_PACKAGE_HANDLE_STANDARD_ARGS(qpOASES 
-  REQUIRED_VARS OASES_LIBRARY)
-
-
-IF(OASES_LIBRARY)
-  SET(OASES_LIBRARIES ${OASES_LIBRARY})
-  GET_FILENAME_COMPONENT(OASES_LIBRARY_NAME ${OASES_LIBRARY} NAME)
-  GET_FILENAME_COMPONENT(OASES_LIBRARY_DIRS ${OASES_LIBRARY} PATH)
-  GET_FILENAME_COMPONENT(OASES_LIBRARY_DIRS_DIR ${OASES_LIBRARY_DIRS} PATH)
-  GET_FILENAME_COMPONENT(OASES_LIBRARY_DIRS_DIR_DIR ${OASES_LIBRARY_DIRS_DIR} PATH)
-
-  FIND_PATH(OASES_INCLUDE_DIRS qpOASES.hpp 
-    HINTS ${OASES_LIBRARY_DIRS_DIR} ${OASES_LIBRARY_DIRS_DIR_DIR}
-    ENV PATH
-    PATH_SUFFIXES include)
-  
-  IF(NOT OASES_INCLUDE_DIRS)
-    IF(OASES_FIND_REQUIRED)
-      MESSAGE(FATAL_ERROR
-        "Required OASES headers not found. Please specify headers location in CMAKE_INCLUDE_PATH")
-    ENDIF(OASES_FIND_REQUIRED)
-  ELSE(NOT OASES_INCLUDE_DIRS)
-    SET(OASES_FOUND TRUE)
-  ENDIF(NOT OASES_INCLUDE_DIRS)
-
-ELSE(OASES_LIBRARY)
-  SET(OASES_FOUND FALSE)
-  IF(OASES_FIND_REQUIRED)
-    MESSAGE(FATAL_ERROR
-      "Required OASES library not found. Please specify library location in OASES_LIBRARY_DIRECTORY")
-  ENDIF(OASES_FIND_REQUIRED)
-ENDIF(OASES_LIBRARY)
-- 
2.34.1


From d713ba95f25c2145bb0b1af2242e709b226fdc5d Mon Sep 17 00:00:00 2001
From: Olivier Roussel <olivier.roussel@inria.fr>
Date: Mon, 25 Mar 2024 14:33:38 +0100
Subject: [PATCH 2/3] add cmake module for qpOASES

---
 cmake/Modules/FindqpOASES.cmake | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)
 create mode 100644 cmake/Modules/FindqpOASES.cmake

diff --git a/cmake/Modules/FindqpOASES.cmake b/cmake/Modules/FindqpOASES.cmake
new file mode 100644
index 0000000..a9706ea
--- /dev/null
+++ b/cmake/Modules/FindqpOASES.cmake
@@ -0,0 +1,23 @@
+# Find the qpOASES includes and libraries.
+# The following variables are set if qpOASES is found.  If qpOASES is not
+# found, qpOASES_FOUND is set to false.
+#  qpOASES_FOUND        - True when the qpOASES include directory is found.
+#  qpOASES_INCLUDE_DIRS - the path to where the qpOASES include files are.
+#  qpOASES_LIBRARIES    - The libraries to link against qpOASES
+
+include(FindPackageHandleStandardArgs)
+
+find_path(qpOASES_INCLUDE_DIR
+  NAMES qpOASES.hpp
+  PATH_SUFFIXES include
+)
+
+find_library(qpOASES_LIBRARY
+  NAMES qpOASES
+  PATH_SUFFIXES lib
+)
+
+set(qpOASES_INCLUDE_DIRS ${qpOASES_INCLUDE_DIR})
+set(qpOASES_LIBRARIES ${qpOASES_LIBRARY})
+
+find_package_handle_standard_args(qpOASES DEFAULT_MSG qpOASES_LIBRARIES qpOASES_INCLUDE_DIRS)
-- 
2.34.1


From a73aca2cb388773db16498e5819f0fe9dfd50b9b Mon Sep 17 00:00:00 2001
From: Olivier Roussel <olivier.roussel@inria.fr>
Date: Mon, 25 Mar 2024 14:34:50 +0100
Subject: [PATCH 3/3] force use of external qpOASES

---
 CMakeLists.txt                                |   13 +-
 extlibs/qpOASES-3.2.0/AUTHORS                 |   92 -
 extlibs/qpOASES-3.2.0/AUTHORS.txt             |   92 -
 .../CMakeFiles/example1.dir/depend.internal   |    3 -
 .../CMakeFiles/example1.dir/depend.make       |    3 -
 .../CMakeFiles/example1a.dir/depend.internal  |    3 -
 .../CMakeFiles/example1a.dir/depend.make      |    3 -
 .../CMakeFiles/example1b.dir/depend.internal  |    3 -
 .../CMakeFiles/example1b.dir/depend.make      |    3 -
 .../CMakeFiles/example2.dir/depend.internal   |    3 -
 .../CMakeFiles/example2.dir/depend.make       |    3 -
 .../CMakeFiles/example3.dir/depend.internal   |    3 -
 .../CMakeFiles/example3.dir/depend.make       |    3 -
 .../CMakeFiles/example3b.dir/depend.internal  |    3 -
 .../CMakeFiles/example3b.dir/depend.make      |    3 -
 .../CMakeFiles/example4.dir/depend.internal   |    3 -
 .../CMakeFiles/example4.dir/depend.make       |    3 -
 .../CMakeFiles/example5.dir/depend.internal   |    3 -
 .../CMakeFiles/example5.dir/depend.make       |    3 -
 .../CMakeFiles/exampleLP.dir/depend.internal  |    3 -
 .../CMakeFiles/exampleLP.dir/depend.make      |    3 -
 .../CMakeFiles/qpOASES.dir/depend.internal    |    3 -
 .../CMakeFiles/qpOASES.dir/depend.make        |    3 -
 .../CMakeFiles/qrecipe.dir/depend.internal    |    3 -
 .../CMakeFiles/qrecipe.dir/depend.make        |    3 -
 .../qrecipeSchur.dir/depend.internal          |    3 -
 .../CMakeFiles/qrecipeSchur.dir/depend.make   |    3 -
 extlibs/qpOASES-3.2.0/CMakeLists.txt          |  162 -
 extlibs/qpOASES-3.2.0/INSTALL                 |   79 -
 extlibs/qpOASES-3.2.0/INSTALL.txt             |   79 -
 extlibs/qpOASES-3.2.0/LICENSE                 |  503 --
 extlibs/qpOASES-3.2.0/LICENSE.txt             |  503 --
 extlibs/qpOASES-3.2.0/Makefile                |   94 -
 extlibs/qpOASES-3.2.0/README                  |   84 -
 extlibs/qpOASES-3.2.0/README.txt              |   84 -
 extlibs/qpOASES-3.2.0/VERSIONS                |  124 -
 extlibs/qpOASES-3.2.0/VERSIONS.txt            |  124 -
 extlibs/qpOASES-3.2.0/doc/DoxygenLayout.xml   |  189 -
 extlibs/qpOASES-3.2.0/doc/Makefile            |   66 -
 extlibs/qpOASES-3.2.0/doc/doxygen.config      |  310 -
 extlibs/qpOASES-3.2.0/doc/mainpage.dox        |  134 -
 extlibs/qpOASES-3.2.0/examples/Makefile       |  107 -
 extlibs/qpOASES-3.2.0/examples/example1.cpp   |   98 -
 extlibs/qpOASES-3.2.0/examples/example1a.cpp  |   85 -
 extlibs/qpOASES-3.2.0/examples/example1b.cpp  |   90 -
 extlibs/qpOASES-3.2.0/examples/example2.cpp   |  123 -
 extlibs/qpOASES-3.2.0/examples/example3.cpp   |   88 -
 extlibs/qpOASES-3.2.0/examples/example3b.cpp  |   88 -
 extlibs/qpOASES-3.2.0/examples/example4.cpp   |  172 -
 extlibs/qpOASES-3.2.0/examples/example4CP.cpp |  112 -
 extlibs/qpOASES-3.2.0/examples/example5.cpp   |  200 -
 extlibs/qpOASES-3.2.0/examples/exampleLP.cpp  |   87 -
 extlibs/qpOASES-3.2.0/examples/qrecipe.cpp    |  118 -
 .../qpOASES-3.2.0/examples/qrecipeSchur.cpp   |  160 -
 .../qpOASES-3.2.0/examples/qrecipe_data.hpp   |  401 -
 extlibs/qpOASES-3.2.0/include/qpOASES.hpp     |   66 -
 .../qpOASES-3.2.0/include/qpOASES/Bounds.hpp  |  256 -
 .../qpOASES-3.2.0/include/qpOASES/Bounds.ipp  |  120 -
 .../include/qpOASES/Constants.hpp             |   77 -
 .../include/qpOASES/ConstraintProduct.hpp     |   91 -
 .../include/qpOASES/Constraints.hpp           |  246 -
 .../include/qpOASES/Constraints.ipp           |  122 -
 .../qpOASES-3.2.0/include/qpOASES/Flipper.hpp |  155 -
 .../include/qpOASES/Indexlist.hpp             |  199 -
 .../include/qpOASES/Indexlist.ipp             |   92 -
 .../include/qpOASES/Matrices.hpp              | 1009 ---
 .../include/qpOASES/MessageHandling.hpp       |  480 --
 .../include/qpOASES/MessageHandling.ipp       |  144 -
 .../qpOASES-3.2.0/include/qpOASES/Options.hpp |  174 -
 .../include/qpOASES/QProblem.hpp              | 1079 ---
 .../include/qpOASES/QProblem.ipp              |  284 -
 .../include/qpOASES/QProblemB.hpp             | 1020 ---
 .../include/qpOASES/QProblemB.ipp             |  496 --
 .../include/qpOASES/SQProblem.hpp             |  358 -
 .../include/qpOASES/SQProblem.ipp             |   51 -
 .../include/qpOASES/SQProblemSchur.hpp        |  475 --
 .../include/qpOASES/SQProblemSchur.ipp        |   57 -
 .../include/qpOASES/SparseSolver.hpp          |  395 -
 .../include/qpOASES/SubjectTo.hpp             |  229 -
 .../include/qpOASES/SubjectTo.ipp             |  158 -
 .../qpOASES-3.2.0/include/qpOASES/Types.hpp   |  335 -
 .../include/qpOASES/UnitTesting.hpp           |   79 -
 .../qpOASES-3.2.0/include/qpOASES/Utils.hpp   |  366 -
 .../qpOASES-3.2.0/include/qpOASES/Utils.ipp   |  174 -
 .../include/qpOASES/extras/OQPinterface.hpp   |  250 -
 .../qpOASES/extras/SolutionAnalysis.hpp       |  166 -
 .../qpOASES/extras/SolutionAnalysis.ipp       |   51 -
 .../qpOASES-3.2.0/interfaces/CUTEst/Makefile  |   79 -
 .../qpOASES-3.2.0/interfaces/CUTEst/makeprob  |   28 -
 .../interfaces/CUTEst/qpoasesCutest.cpp       |  498 --
 .../interfaces/CUTEst/readme.txt              |   39 -
 extlibs/qpOASES-3.2.0/interfaces/c/Makefile   |  128 -
 .../qpOASES-3.2.0/interfaces/c/c_example1.c   |  104 -
 .../qpOASES-3.2.0/interfaces/c/c_example1a.c  |  105 -
 .../qpOASES-3.2.0/interfaces/c/c_example1b.c  |  102 -
 .../interfaces/c/qpOASES_wrapper.cpp          |  576 --
 .../interfaces/c/qpOASES_wrapper.h            |  293 -
 .../qpOASES-3.2.0/interfaces/matlab/Makefile  |   85 -
 .../qpOASES-3.2.0/interfaces/matlab/make.m    |  238 -
 .../interfaces/matlab/qpOASES.cpp             |  584 --
 .../qpOASES-3.2.0/interfaces/matlab/qpOASES.m |   75 -
 .../interfaces/matlab/qpOASES_auxInput.m      |  118 -
 .../matlab/qpOASES_matlab_utils.cpp           |  950 ---
 .../matlab/qpOASES_matlab_utils.hpp           |   93 -
 .../interfaces/matlab/qpOASES_options.m       |  251 -
 .../interfaces/matlab/qpOASES_sequence.cpp    | 1104 ---
 .../interfaces/matlab/qpOASES_sequence.m      |  111 -
 extlibs/qpOASES-3.2.0/interfaces/octave/clean |    3 -
 .../qpOASES-3.2.0/interfaces/octave/clean.sh  |    3 -
 .../qpOASES-3.2.0/interfaces/octave/make.m    |  238 -
 .../interfaces/octave/qpOASES.cpp             |  584 --
 .../qpOASES-3.2.0/interfaces/octave/qpOASES.m |   75 -
 .../interfaces/octave/qpOASES_auxInput.m      |  118 -
 .../octave/qpOASES_octave_utils.cpp           |  950 ---
 .../octave/qpOASES_octave_utils.hpp           |   93 -
 .../interfaces/octave/qpOASES_options.m       |  251 -
 .../interfaces/octave/qpOASES_sequence.cpp    | 1104 ---
 .../interfaces/octave/qpOASES_sequence.m      |  111 -
 .../interfaces/python/README.rst              |   68 -
 .../python/examples/cython/example1.pyx       |   73 -
 .../python/examples/cython/setup.py           |   16 -
 .../interfaces/python/examples/example1.py    |   76 -
 .../interfaces/python/examples/example1b.py   |   72 -
 .../interfaces/python/examples/example2.py    |   92 -
 .../interfaces/python/qpoases.pxd             |  487 --
 .../interfaces/python/qpoases.pyx             |  929 ---
 .../qpOASES-3.2.0/interfaces/python/setup.py  |   71 -
 .../interfaces/python/tests/__init__.py       |    1 -
 .../interfaces/python/tests/test_examples.py  |  360 -
 .../qpOASES-3.2.0/interfaces/scilab/Makefile  |   93 -
 .../interfaces/scilab/qpOASESinterface.c      |  893 ---
 .../interfaces/scilab/qpOASESinterface.sce    |   41 -
 .../interfaces/scilab/qpOASESroutines.cpp     |  369 -
 .../interfaces/simulink/example_QProblem.mdl  |  762 --
 .../interfaces/simulink/example_QProblemB.mdl |  728 --
 .../interfaces/simulink/example_SQProblem.mdl |  797 --
 .../simulink/load_example_QProblem.m          |   86 -
 .../simulink/load_example_QProblemB.m         |   72 -
 .../simulink/load_example_SQProblem.m         |   95 -
 .../qpOASES-3.2.0/interfaces/simulink/make.m  |  239 -
 .../interfaces/simulink/qpOASES_QProblem.cpp  |  506 --
 .../interfaces/simulink/qpOASES_QProblemB.cpp |  431 --
 .../interfaces/simulink/qpOASES_SQProblem.cpp |  475 --
 .../simulink/qpOASES_simulink_utils.cpp       |  121 -
 .../qpOASES-3.2.0/libqpOASESConfig.cmake.in   |   13 -
 extlibs/qpOASES-3.2.0/make.mk                 |   38 -
 extlibs/qpOASES-3.2.0/make_cygwin.mk          |  119 -
 extlibs/qpOASES-3.2.0/make_linux.mk           |  122 -
 extlibs/qpOASES-3.2.0/make_osx.mk             |  124 -
 extlibs/qpOASES-3.2.0/make_windows.mk         |  126 -
 extlibs/qpOASES-3.2.0/src/BLASReplacement.cpp |  146 -
 extlibs/qpOASES-3.2.0/src/Bounds.cpp          |  514 --
 extlibs/qpOASES-3.2.0/src/Constraints.cpp     |  499 --
 extlibs/qpOASES-3.2.0/src/Flipper.cpp         |  259 -
 extlibs/qpOASES-3.2.0/src/Indexlist.cpp       |  319 -
 .../qpOASES-3.2.0/src/LAPACKReplacement.cpp   |  151 -
 extlibs/qpOASES-3.2.0/src/Makefile            |  110 -
 extlibs/qpOASES-3.2.0/src/Matrices.cpp        | 2141 ------
 extlibs/qpOASES-3.2.0/src/MessageHandling.cpp |  632 --
 extlibs/qpOASES-3.2.0/src/OQPinterface.cpp    |  683 --
 extlibs/qpOASES-3.2.0/src/Options.cpp         |  563 --
 extlibs/qpOASES-3.2.0/src/QProblem.cpp        | 6433 -----------------
 extlibs/qpOASES-3.2.0/src/QProblemB.cpp       | 3850 ----------
 extlibs/qpOASES-3.2.0/src/SQProblem.cpp       |  553 --
 extlibs/qpOASES-3.2.0/src/SQProblemSchur.cpp  | 3626 ----------
 .../qpOASES-3.2.0/src/SolutionAnalysis.cpp    |  681 --
 extlibs/qpOASES-3.2.0/src/SparseSolver.cpp    | 1103 ---
 extlibs/qpOASES-3.2.0/src/SubjectTo.cpp       |  289 -
 extlibs/qpOASES-3.2.0/src/Utils.cpp           | 1061 ---
 extlibs/qpOASES-3.2.0/testing/c/Makefile      |   78 -
 .../qpOASES-3.2.0/testing/c/test_c_example1.c |  104 -
 .../testing/c/test_c_example1a.c              |  105 -
 .../testing/c/test_c_example1b.c              |  102 -
 .../qpOASES-3.2.0/testing/checkForMemoryLeaks |  109 -
 extlibs/qpOASES-3.2.0/testing/cpp/Makefile    |  136 -
 .../testing/cpp/data/fetch_cpp_data           |   34 -
 .../qpOASES-3.2.0/testing/cpp/test_bench.cpp  |  310 -
 .../testing/cpp/test_constraintProduct1.cpp   |  200 -
 .../testing/cpp/test_constraintProduct2.cpp   |  197 -
 .../testing/cpp/test_example1.cpp             |  116 -
 .../testing/cpp/test_example1a.cpp            |  111 -
 .../testing/cpp/test_example1b.cpp            |  112 -
 .../testing/cpp/test_example2.cpp             |  131 -
 .../testing/cpp/test_example4.cpp             |  206 -
 .../testing/cpp/test_example5.cpp             |  204 -
 .../testing/cpp/test_example6.cpp             |  109 -
 .../testing/cpp/test_example7.cpp             |   87 -
 .../testing/cpp/test_exampleLP.cpp            |  115 -
 .../testing/cpp/test_externalChol1.cpp        |  101 -
 .../testing/cpp/test_gradientShift.cpp        |  125 -
 .../testing/cpp/test_guessedWS1.cpp           |  153 -
 .../qpOASES-3.2.0/testing/cpp/test_hs268.cpp  |  104 -
 .../testing/cpp/test_indexlist.cpp            |   96 -
 .../testing/cpp/test_infeasible1.cpp          |  104 -
 .../testing/cpp/test_janick1.cpp              |  190 -
 .../testing/cpp/test_janick2.cpp              |  275 -
 .../testing/cpp/test_matrices.cpp             |  903 ---
 .../testing/cpp/test_matrices2.cpp            |  113 -
 .../testing/cpp/test_matrices3.cpp            |   90 -
 .../testing/cpp/test_qrecipe.cpp              |  144 -
 .../testing/cpp/test_qrecipeSchur.cpp         |  167 -
 .../testing/cpp/test_qrecipe_data.hpp         |  401 -
 .../testing/cpp/test_runAllOqpExamples.cpp    |  177 -
 .../testing/cpp/test_sebastien1.cpp           |   74 -
 .../testing/cpp/test_vanBarelsUnboundedQP.cpp |   69 -
 .../testing/matlab/auxFiles/generateExample.m |   25 -
 .../matlab/auxFiles/generateRandomQp.m        |  110 -
 .../testing/matlab/auxFiles/getKktResidual.m  |  134 -
 .../testing/matlab/auxFiles/isoctave.m        |   21 -
 .../matlab/auxFiles/setupQpDataStruct.m       |   18 -
 .../matlab/auxFiles/setupQpFeaturesStruct.m   |   21 -
 .../testing/matlab/data/fetch_matlab_data     |   34 -
 .../testing/matlab/runAllTests.m              |  152 -
 .../testing/matlab/setupTestingPaths.m        |   14 -
 .../testing/matlab/tests/runAlexInfeas1.m     |   30 -
 .../testing/matlab/tests/runAlexInfeas2.m     |   35 -
 .../matlab/tests/runAlternativeX0Test.m       |   84 -
 .../testing/matlab/tests/runBenchmarkCHAIN1.m |   60 -
 .../matlab/tests/runBenchmarkCHAIN1A.m        |   61 -
 .../testing/matlab/tests/runBenchmarkCRANE1.m |   55 -
 .../testing/matlab/tests/runBenchmarkCRANE2.m |   56 -
 .../testing/matlab/tests/runBenchmarkCRANE3.m |   55 -
 .../testing/matlab/tests/runBenchmarkDIESEL.m |   59 -
 .../matlab/tests/runBenchmarkEQUALITY1.m      |   56 -
 .../matlab/tests/runBenchmarkEQUALITY2.m      |   60 -
 .../matlab/tests/runBenchmarkEXAMPLE1.m       |   56 -
 .../matlab/tests/runBenchmarkEXAMPLE1A.m      |   56 -
 .../matlab/tests/runBenchmarkEXAMPLE1B.m      |   56 -
 .../matlab/tests/runBenchmarkIDHESSIAN1.m     |   59 -
 .../matlab/tests/runEmptyHessianTests.m       |  261 -
 .../matlab/tests/runExternalCholeskyTests.m   |  214 -
 .../matlab/tests/runInterfaceSeqTest.m        |  436 --
 .../testing/matlab/tests/runInterfaceTest.m   |  462 --
 .../testing/matlab/tests/runQAP8.m            |   37 -
 .../testing/matlab/tests/runQSHARE1B.m        |   44 -
 .../testing/matlab/tests/runRandomIdHessian.m |  435 --
 .../matlab/tests/runRandomZeroHessian.m       |  433 --
 .../matlab/tests/runSimpleSpringExample.m     |   34 -
 .../matlab/tests/runTestAPrioriKnownSeq1.m    |   87 -
 .../testing/matlab/tests/runTestSeq.m         |  104 -
 .../testing/matlab/tests/runTestSparse.m      |   33 -
 .../testing/matlab/tests/runTestSparse2.m     |   33 -
 .../testing/matlab/tests/runTestSparse3.m     |   39 -
 .../testing/matlab/tests/runTestSparse4.m     |   29 -
 .../matlab/tests/runTestWorkingSetLI.m        |   50 -
 .../matlab/tests/runVanBarelsUnboundedQP.m    |   25 -
 extlibs/qpOASES-3.2.0/testing/runUnitTests    |  110 -
 247 files changed, 5 insertions(+), 65266 deletions(-)
 delete mode 100644 extlibs/qpOASES-3.2.0/AUTHORS
 delete mode 100644 extlibs/qpOASES-3.2.0/AUTHORS.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.internal
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.make
 delete mode 100644 extlibs/qpOASES-3.2.0/CMakeLists.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/INSTALL
 delete mode 100644 extlibs/qpOASES-3.2.0/INSTALL.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/LICENSE
 delete mode 100644 extlibs/qpOASES-3.2.0/LICENSE.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/README
 delete mode 100644 extlibs/qpOASES-3.2.0/README.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/VERSIONS
 delete mode 100644 extlibs/qpOASES-3.2.0/VERSIONS.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/doc/DoxygenLayout.xml
 delete mode 100644 extlibs/qpOASES-3.2.0/doc/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/doc/doxygen.config
 delete mode 100644 extlibs/qpOASES-3.2.0/doc/mainpage.dox
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example1a.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example1b.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example2.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example3.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example3b.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example4.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example4CP.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/example5.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/exampleLP.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/qrecipe.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/qrecipeSchur.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/examples/qrecipe_data.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Constants.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/ConstraintProduct.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Flipper.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Matrices.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Options.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SparseSolver.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Types.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/UnitTesting.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Utils.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/Utils.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/extras/OQPinterface.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.ipp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/CUTEst/Makefile
 delete mode 100755 extlibs/qpOASES-3.2.0/interfaces/CUTEst/makeprob
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/CUTEst/qpoasesCutest.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/CUTEst/readme.txt
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/c_example1.c
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/c_example1a.c
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/c_example1b.c
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.h
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/make.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_auxInput.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_options.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/clean
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/clean.sh
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/make.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_auxInput.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_options.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/README.rst
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/example1.pyx
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/setup.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/examples/example1.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/examples/example1b.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/examples/example2.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pxd
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pyx
 delete mode 100755 extlibs/qpOASES-3.2.0/interfaces/python/setup.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/tests/__init__.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/python/tests/test_examples.py
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/scilab/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.c
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.sce
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESroutines.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblem.mdl
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblemB.mdl
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/example_SQProblem.mdl
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblem.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblemB.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_SQProblem.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/make.m
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblem.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblemB.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_SQProblem.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_simulink_utils.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/libqpOASESConfig.cmake.in
 delete mode 100644 extlibs/qpOASES-3.2.0/make.mk
 delete mode 100644 extlibs/qpOASES-3.2.0/make_cygwin.mk
 delete mode 100644 extlibs/qpOASES-3.2.0/make_linux.mk
 delete mode 100644 extlibs/qpOASES-3.2.0/make_osx.mk
 delete mode 100644 extlibs/qpOASES-3.2.0/make_windows.mk
 delete mode 100644 extlibs/qpOASES-3.2.0/src/BLASReplacement.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Bounds.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Constraints.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Flipper.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Indexlist.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/LAPACKReplacement.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Matrices.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/MessageHandling.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/OQPinterface.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Options.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/QProblem.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/QProblemB.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/SQProblem.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/SQProblemSchur.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/SolutionAnalysis.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/SparseSolver.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/SubjectTo.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/src/Utils.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/c/Makefile
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/c/test_c_example1.c
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/c/test_c_example1a.c
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/c/test_c_example1b.c
 delete mode 100755 extlibs/qpOASES-3.2.0/testing/checkForMemoryLeaks
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/Makefile
 delete mode 100755 extlibs/qpOASES-3.2.0/testing/cpp/data/fetch_cpp_data
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_bench.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct2.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example1a.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example1b.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example2.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example4.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example5.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example6.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_example7.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_exampleLP.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_externalChol1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_gradientShift.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_guessedWS1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_hs268.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_indexlist.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_infeasible1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_janick1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_janick2.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_matrices.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_matrices2.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_matrices3.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipeSchur.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe_data.hpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_runAllOqpExamples.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_sebastien1.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/cpp/test_vanBarelsUnboundedQP.cpp
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateExample.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateRandomQp.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/getKktResidual.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/isoctave.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpDataStruct.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpFeaturesStruct.m
 delete mode 100755 extlibs/qpOASES-3.2.0/testing/matlab/data/fetch_matlab_data
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/runAllTests.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/setupTestingPaths.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas2.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlternativeX0Test.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1A.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE2.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE3.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkDIESEL.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY2.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1A.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1B.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkIDHESSIAN1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runEmptyHessianTests.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runExternalCholeskyTests.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceSeqTest.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceTest.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runQAP8.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runQSHARE1B.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomIdHessian.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomZeroHessian.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runSimpleSpringExample.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestAPrioriKnownSeq1.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSeq.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse2.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse3.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse4.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestWorkingSetLI.m
 delete mode 100644 extlibs/qpOASES-3.2.0/testing/matlab/tests/runVanBarelsUnboundedQP.m
 delete mode 100755 extlibs/qpOASES-3.2.0/testing/runUnitTests

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1d15c4d..4650a68 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -139,13 +139,6 @@ endif()
 set(DOC_FILES README.md)
 file(GLOB_RECURSE EXAMPLE_FILES examples "*.pyscn" "*.py" "*.md" "*.psl" "*.pslx" "*.scn" "*.xml")
 
-set(OASES_LIBRARY_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/extlibs/qpOASES-3.2.0/")
-add_subdirectory(${OASES_LIBRARY_DIRECTORY} extlibs/libqpOASES)
-find_package(libqpOASES REQUIRED)
-message("libqpOASES_INCLUDE_DIRS = ${libqpOASES_INCLUDE_DIRS}")
-include_directories(${libqpOASES_INCLUDE_DIRS})
-sofa_install_libraries(PATHS ${libqpOASES_LIBRARY})
-
 option(SOFTROBOTSINVERSE_INSTALL_HEADERS "Install the headers" ON)
 if(SOFTROBOTSINVERSE_INSTALL_HEADERS)
     add_library(${PROJECT_NAME} SHARED ${SOURCE_FILES} ${DOC_FILES} ${EXAMPLE_FILES} ${HEADER_FILES})
@@ -153,11 +146,15 @@ else()
     add_library(${PROJECT_NAME} SHARED ${SOURCE_FILES} ${DOC_FILES} ${EXAMPLE_FILES} "${SRC_DIR}/component/config.h.in")
 endif()
 
+find_package(qpOASES REQUIRED)
+
+include_directories(${qpOASES_INCLUDE_DIRS})
+target_link_libraries(${PROJECT_NAME} ${qpOASES_LIBRARIES})
+
 target_link_libraries(${PROJECT_NAME}
     SoftRobots
     Sofa.Component.Constraint.Lagrangian.Solver
     Sofa.Component.Collision.Response.Contact)
-target_link_libraries(${PROJECT_NAME} ${libqpOASES_LIBRARY})
 
 # TODO: remove this when SoftRobotsConfig.cmake.in is fixed
 message("SOFTROBOTS_HAVE_SOFA_GL = ${SOFTROBOTS_HAVE_SOFA_GL}")
diff --git a/extlibs/qpOASES-3.2.0/AUTHORS b/extlibs/qpOASES-3.2.0/AUTHORS
deleted file mode 100644
index f8334b1..0000000
--- a/extlibs/qpOASES-3.2.0/AUTHORS
+++ /dev/null
@@ -1,92 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-MAIN AUTHORS
-============
-
-qpOASES's core functionality and software design have been developed by the
-following main developers (in alphabetical order):
-
-    Hans Joachim Ferreau
-    Christian Kirches
-    Andreas Potschka
-
-
-
-FURTHER AUTHORS
-===============
-
-Moreover, the following developers have contributed code to qpOASES's
-third-party interfaces or provided additional functionality 
-(in alphabetical order):
-
-    Alexander Buchner
-    Holger Diedam
-    Dennis Janka
-    Manuel Kudruss
-    Andreas Waechter
-    Sebastian F. Walter
-
-
-
-CONTRIBUTORS
-============
-
-Finally, the following people have not contributed to the source code,
-but have helped making qpOASES even more useful by testing, reporting
-bugs or proposing algorithmic improvements (in alphabetical order):
-
-    Eckhard Arnold
-    Boris Houska
-    D. Kwame Minde Kufoalor
-    Aude Perrin
-    Milan Vukov
-    Thomas Wiese
-    Leonard Wirsching
-
-
-
-SCIENTIFIC MENTORS
-==================
-
-We also would like to thank two persons who had a major share in making
-qpOASES a success. Not by writing even a single line of code, but by
-establishing the idea of using a homotopy-based approach for high-speed
-QP solutions and by excellent scientific guidance during the development
-process:
-
-    Hans Georg Bock
-    Moritz Diehl
-
-
-
-All users are invited to further improve qpOASES by providing comments,
-code enhancements, bug reports, additional documentation or whatever you
-feel is missing.
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/AUTHORS.txt b/extlibs/qpOASES-3.2.0/AUTHORS.txt
deleted file mode 100644
index 8b1180e..0000000
--- a/extlibs/qpOASES-3.2.0/AUTHORS.txt
+++ /dev/null
@@ -1,92 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-MAIN AUTHORS
-============
-
-qpOASES's core functionality and software design have been developed by the
-following main developers (in alphabetical order):
-
-    Hans Joachim Ferreau
-    Christian Kirches
-    Andreas Potschka
-
-
-
-FURTHER AUTHORS
-===============
-
-Moreover, the following developers have contributed code to qpOASES's
-third-party interfaces or provided additional functionality 
-(in alphabetical order):
-
-    Alexander Buchner
-    Holger Diedam
-    Dennis Janka
-    Manuel Kudruss
-    Andreas Waechter
-    Sebastian F. Walter
-
-
-
-CONTRIBUTORS
-============
-
-Finally, the following people have not contributed to the source code,
-but have helped making qpOASES even more useful by testing, reporting
-bugs or proposing algorithmic improvements (in alphabetical order):
-
-    Eckhard Arnold
-    Boris Houska
-    D. Kwame Minde Kufoalor
-    Aude Perrin
-    Milan Vukov
-    Thomas Wiese
-    Leonard Wirsching
-
-
-
-SCIENTIFIC MENTORS
-==================
-
-We also would like to thank two persons who had a major share in making
-qpOASES a success. Not by writing even a single line of code, but by
-establishing the idea of using a homotopy-based approach for high-speed
-QP solutions and by excellent scientific guidance during the development
-process:
-
-    Hans Georg Bock
-    Moritz Diehl
-
-
-
-All users are invited to further improve qpOASES by providing comments,
-code enhancements, bug reports, additional documentation or whatever you
-feel is missing.
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1a.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example1b.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example2.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example3.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example3b.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example4.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/example5.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/exampleLP.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qpOASES.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipe.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.internal b/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.internal
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.internal
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.make b/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.make
deleted file mode 100644
index eefd8bd..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeFiles/qrecipeSchur.dir/depend.make
+++ /dev/null
@@ -1,3 +0,0 @@
-# CMAKE generated file: DO NOT EDIT!
-# Generated by "Unix Makefiles" Generator, CMake Version 3.4
-
diff --git a/extlibs/qpOASES-3.2.0/CMakeLists.txt b/extlibs/qpOASES-3.2.0/CMakeLists.txt
deleted file mode 100644
index a17c482..0000000
--- a/extlibs/qpOASES-3.2.0/CMakeLists.txt
+++ /dev/null
@@ -1,162 +0,0 @@
-##
-##     This file is part of qpOASES.
-##
-##     qpOASES -- An Implementation of the Online Active Set Strategy.
-##     Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##     Christian Kirches et al. All rights reserved.
-##
-##     qpOASES is free software; you can redistribute it and/or
-##     modify it under the terms of the GNU Lesser General Public
-##     License as published by the Free Software Foundation; either
-##     version 2.1 of the License, or (at your option) any later version.
-##
-##     qpOASES is distributed in the hope that it will be useful,
-##     but WITHOUT ANY WARRANTY; without even the implied warranty of
-##     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##     See the GNU Lesser General Public License for more details.
-##
-##     You should have received a copy of the GNU Lesser General Public
-##     License along with qpOASES; if not, write to the Free Software
-##     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##     Filename:  CMakeLists.txt
-##     Author:    Hans Joachim Ferreau (thanks to Milan Vukov)
-##     Version:   3.2
-##     Date:      2007-2015
-##
-
-cmake_minimum_required(VERSION 3.1)
-
-project(libqpOASES VERSION 1.0)
-SET(PACKAGE_NAME "libqpOASES")
-SET(PACKAGE_VERSION "3.2.0")
-SET(PACKAGE_SO_VERSION "3.2")
-SET(PACKAGE_DESCRIPTION "An implementation of the online active set strategy")
-SET(PACKAGE_AUTHOR "Hans Joachim Ferreau, Andreas Potschka, Christian Kirches et al.")
-SET(PACKAGE_MAINTAINER "Hans Joachim Ferreau, Andreas Potschka, Christian Kirches et al.")
-SET(PACKAGE_URL "https://projects.coin-or.org/qpOASES")
-
-SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
-SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/libs)
-
-IF( NOT CMAKE_VERBOSE_MAKEFILE )
-    SET( CMAKE_VERBOSE_MAKEFILE OFF )
-ENDIF( NOT CMAKE_VERBOSE_MAKEFILE )
-
-IF( NOT CMAKE_BUILD_TYPE )
-    SET(CMAKE_BUILD_TYPE Release CACHE STRING
-        "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel."
-        FORCE
-        )
-ENDIF( NOT CMAKE_BUILD_TYPE )
-
-
-############################################################
-#################### compiler flags ########################
-############################################################
-SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D__NO_COPYRIGHT__")
-IF ( UNIX )
-    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -pedantic -Wfloat-equal -Wshadow -DLINUX")
-    SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_DEBUG} -O3 -finline-functions")
-ELSEIF( WINDOWS )
-    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -nologo -EHsc -DWIN32")
-ENDIF()
-
-SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -D__DEBUG__")
-
-############################################################
-######################## rpath #############################
-############################################################
-# use, i.e. don't skip the full RPATH for the build tree
-#set(CMAKE_SKIP_BUILD_RPATH  FALSE)
-
-# when building, don't use the install RPATH already
-# (but later on when installing)
-#set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
-
-#set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib:${CMAKE_INSTALL_PREFIX}/lib/casadi")
-
-# add the automatically determined parts of the RPATH
-# which point to directories outside the build tree to the install RPATH
-#set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
-
-# the RPATH to be used when installing, but only if it's not a system directory
-list(FIND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES "${CMAKE_INSTALL_PREFIX}/lib" isSystemDir)
-if("${isSystemDir}" STREQUAL "-1")
-   set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib:${CMAKE_INSTALL_PREFIX}/lib/casadi")
-endif("${isSystemDir}" STREQUAL "-1")
-
-
-
-############################################################
-#################### build and install #####################
-############################################################
-INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/include)
-
-# compile qpOASES libraries
-FILE(GLOB SRC src/*.cpp)
-FILE(GLOB_RECURSE HEADERS include/*.hpp)
-
-set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS TRUE)
-
-# library
-# ADD_LIBRARY(qpOASES STATIC ${SRC} ${HEADERS})
-ADD_LIBRARY(libqpOASES SHARED ${SRC} ${HEADERS})
-INSTALL(TARGETS libqpOASES
-  LIBRARY DESTINATION lib
-  ARCHIVE DESTINATION lib
-  RUNTIME DESTINATION lib
-)
-SET_TARGET_PROPERTIES(
-    libqpOASES
-    PROPERTIES
-    SOVERSION ${PACKAGE_SO_VERSION}
-    )
-
-# headers
-INSTALL(FILES include/qpOASES.hpp
-  DESTINATION include)
-INSTALL(DIRECTORY include/qpOASES
-  DESTINATION include
-  FILES_MATCHING PATTERN "*.hpp"
-  PATTERN "*.ipp"
-  PATTERN ".svn" EXCLUDE)
-
-sofa_create_package_with_targets(
-        PACKAGE_NAME ${PROJECT_NAME}
-        PACKAGE_VERSION ${PACKAGE_VERSION}
-        TARGETS ${PROJECT_NAME}
-        INCLUDE_INSTALL_DIR "${PROJECT_NAME}"
-        )
-
-############################################################
-######################### examples #########################
-############################################################
-# compile qpOASES examples
-# SET(EXAMPLE_NAMES
-    # example1
-    # example1a
-    # example1b
-    # example2
-    # example3
-    # example3b
-    # example4
-    # example5
-    # exampleLP
-    # qrecipe
-	# qrecipeSchur
-# )
-
-# FOREACH(ELEMENT ${EXAMPLE_NAMES})
-    # ADD_EXECUTABLE(${ELEMENT} examples/${ELEMENT}.cpp)
-    # TARGET_LINK_LIBRARIES(${ELEMENT} qpOASES)
-# ENDFOREACH(ELEMENT ${EXAMPLE_NAMES})
-
-
-##
-##   end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/INSTALL b/extlibs/qpOASES-3.2.0/INSTALL
deleted file mode 100644
index 465c7bb..0000000
--- a/extlibs/qpOASES-3.2.0/INSTALL
+++ /dev/null
@@ -1,79 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-INSTALLATION UNDER LINUX
-========================
-
-0. Obtain qpOASES from COIN-OR:
-
-Download a zipped archive containg the latest stable release and unpack it 
-into <install-dir>. Alternatively, you check out the latest stable branch, 
-e.g. by running
-
-svn co https://projects.coin-or.org/svn/qpOASES/stable/3.2 <install-dir>
-
-from your shell. 
-
-
-1. Compilation of the qpOASES library libqpOASES.a (or .so) and test examples:
-
-cd <install-dir>
-make
-
-The library  libqpOASES.a (or .so)  provides the complete functionality of the 
-qpOASES software package. It can be used by, e.g., linking it against a main 
-function from the examples folder. The make also compiles a couple of test 
-examples; executables are stored within the directory <install-dir>/bin.
-
-
-2. Running a simple test example:
-
-Among others, an executable called  example1  should have been created; run 
-it in order to test your installation:
-
-cd <install-dir>/bin
-./example1
-
-If it terminates after successfully solving two QP problems, qpOASES has been 
-successfully installed!
-
-
-3. Optional, create source code documentation (using doxygen):
-
-cd <install-dir>/doc
-doxygen doxygen.config
-
-Afterwards, you can open the file <install-dir>/doc/html/index.html with
-your favorite browser in order to view qpOASES's source code documentation.
-
-
-NOTE: More detailed installation instructions, including information on how
-      to run unit tests can be found in the qpOASES User's Manual located 
-      at <install-dir>/doc/manual.pdf!
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/INSTALL.txt b/extlibs/qpOASES-3.2.0/INSTALL.txt
deleted file mode 100644
index 9674ff5..0000000
--- a/extlibs/qpOASES-3.2.0/INSTALL.txt
+++ /dev/null
@@ -1,79 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-INSTALLATION UNDER LINUX
-========================
-
-0. Obtain qpOASES from COIN-OR:
-
-Download a zipped archive containg the latest stable release and unpack it 
-into <install-dir>. Alternatively, you check out the latest stable branch, 
-e.g. by running
-
-svn co https://projects.coin-or.org/svn/qpOASES/stable/3.2 <install-dir>
-
-from your shell. 
-
-
-1. Compilation of the qpOASES library libqpOASES.a (or .so) and test examples:
-
-cd <install-dir>
-make
-
-The library  libqpOASES.a (or .so)  provides the complete functionality of the 
-qpOASES software package. It can be used by, e.g., linking it against a main 
-function from the examples folder. The make also compiles a couple of test 
-examples; executables are stored within the directory <install-dir>/bin.
-
-
-2. Running a simple test example:
-
-Among others, an executable called  example1  should have been created; run 
-it in order to test your installation:
-
-cd <install-dir>/bin
-./example1
-
-If it terminates after successfully solving two QP problems, qpOASES has been 
-successfully installed!
-
-
-3. Optional, create source code documentation (using doxygen):
-
-cd <install-dir>/doc
-doxygen doxygen.config
-
-Afterwards, you can open the file <install-dir>/doc/html/index.html with
-your favorite browser in order to view qpOASES's source code documentation.
-
-
-NOTE: More detailed installation instructions, including information on how
-      to run unit tests can be found in the qpOASES User's Manual located 
-      at <install-dir>/doc/manual.pdf!
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/LICENSE b/extlibs/qpOASES-3.2.0/LICENSE
deleted file mode 100644
index 9ef3d70..0000000
--- a/extlibs/qpOASES-3.2.0/LICENSE
+++ /dev/null
@@ -1,503 +0,0 @@
-		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
- 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
-
diff --git a/extlibs/qpOASES-3.2.0/LICENSE.txt b/extlibs/qpOASES-3.2.0/LICENSE.txt
deleted file mode 100644
index 2d59e84..0000000
--- a/extlibs/qpOASES-3.2.0/LICENSE.txt
+++ /dev/null
@@ -1,503 +0,0 @@
-		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
- 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
-
diff --git a/extlibs/qpOASES-3.2.0/Makefile b/extlibs/qpOASES-3.2.0/Makefile
deleted file mode 100644
index 1ae785d..0000000
--- a/extlibs/qpOASES-3.2.0/Makefile
+++ /dev/null
@@ -1,94 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-include make.mk
-
-##
-##	targets
-##
-
-
-all: src examples
-#src_aw testing
-
-src:
-	@cd $@; ${MAKE} -s 
-
-#src_aw:
-#	@cd $@; ${MAKE} -s 
-
-examples: src
-	@cd $@; ${MAKE} -s
-
-doc:
-	@cd $@; ${MAKE} -s 
-
-testing: src
-	@cd testing/cpp; ${MAKE} -s
-
-test: testing
-	@cd testing/cpp; ${MAKE} -s runTests
-
-debugging:
-	@cd $@; ${MAKE} -s 
-
-clean:
-	@cd src               && ${MAKE} -s clean
-	@cd examples          && ${MAKE} -s clean
-	@cd bin               && ${RM} -f *.* *{EXE}
-	@cd testing/cpp       && ${MAKE} -s clean
-
-#	&& cd src_aw            && ${MAKE} -s clean && cd .. \
-#	&& cd debugging         && ${MAKE} -s clean && cd .. \
-
-
-clobber: clean
-
-scilab:
-	@echo Compiling Scilab interface...
-	@cd ./interfaces/scilab/; ${MAKE} -s
-
-python: all
-	cd ./interfaces/python/ && python setup.py build_ext --inplace
-
-pythoninstall: all
-	cd ./interfaces/python/ && python setup.py install
-
-c_wrapper:
-	@echo Compiling C interface...
-	@cd ./interfaces/c/; ${MAKE} -s
-
-.PHONY : all src examples doc testing debugging clean clobber scilab python phythoninstall c_wrapper
-
-
-##
-##   end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/README b/extlibs/qpOASES-3.2.0/README
deleted file mode 100644
index 6a0119e..0000000
--- a/extlibs/qpOASES-3.2.0/README
+++ /dev/null
@@ -1,84 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-INTRODUCTION
-============
-
-qpOASES is an open-source C++ implementation of the recently proposed 
-online active set strategy, which was inspired by important observations 
-from the field of parametric quadratic programming (QP). It has several 
-theoretical features that make it particularly suited for model predictive 
-control (MPC) applications. Further numerical modifications have made 
-qpOASES a reliable QP solver, even when tackling semi-definite, ill-posed or 
-degenerated QP problems. Moreover, several interfaces to third-party software 
-like Matlab or Simulink are provided that make qpOASES easy-to-use even for 
-users without knowledge of C/C++.
-
-
-
-GETTING STARTED
-===============
-
-1. For installation, usage and additional information on this software package 
-   see the qpOASES User's Manual located at doc/manual.pdf or check its
-   source code documentation!
-
-
-2. The file LICENSE.txt contains a copy of the GNU Lesser General Public 
-   License (v2.1). Please read it carefully before using qpOASES!
-
-
-3. The whole software package can be obtained from 
-
-       http://www.qpOASES.org/ or
-	   https://projects.coin-or.org/qpOASES/
-
-   On this webpage you will also find further support such as a list of 
-   questions posed by other users.
-
-
-
-CONTACT THE AUTHORS
-===================
-
-If you have got questions, remarks or comments on qpOASES, it is strongly 
-encouraged to report them by creating a new ticket at the qpOASES webpage.
-In case you do not want to disclose your feedback to the public, you may
-send an e-mail to
-
-        support@qpOASES.org
-
-Finally, you may contact one of the main authors directly:
-
-        Hans Joachim Ferreau, joachim.ferreau@ch.abb.com
-        Andreas Potschka,     potschka@iwr.uni-heidelberg.de
-        Christian Kirches,    christian.kirches@iwr.uni-heidelberg.de
-
-Also bug reports, source code enhancements or success stories are most welcome!
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/README.txt b/extlibs/qpOASES-3.2.0/README.txt
deleted file mode 100644
index 4c71c79..0000000
--- a/extlibs/qpOASES-3.2.0/README.txt
+++ /dev/null
@@ -1,84 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-INTRODUCTION
-============
-
-qpOASES is an open-source C++ implementation of the recently proposed 
-online active set strategy, which was inspired by important observations 
-from the field of parametric quadratic programming (QP). It has several 
-theoretical features that make it particularly suited for model predictive 
-control (MPC) applications. Further numerical modifications have made 
-qpOASES a reliable QP solver, even when tackling semi-definite, ill-posed or 
-degenerated QP problems. Moreover, several interfaces to third-party software 
-like Matlab or Simulink are provided that make qpOASES easy-to-use even for 
-users without knowledge of C/C++.
-
-
-
-GETTING STARTED
-===============
-
-1. For installation, usage and additional information on this software package 
-   see the qpOASES User's Manual located at doc/manual.pdf or check its
-   source code documentation!
-
-
-2. The file LICENSE.txt contains a copy of the GNU Lesser General Public 
-   License (v2.1). Please read it carefully before using qpOASES!
-
-
-3. The whole software package can be obtained from 
-
-       http://www.qpOASES.org/ or
-	   https://projects.coin-or.org/qpOASES/
-
-   On this webpage you will also find further support such as a list of 
-   questions posed by other users.
-
-
-
-CONTACT THE AUTHORS
-===================
-
-If you have got questions, remarks or comments on qpOASES, it is strongly 
-encouraged to report them by creating a new ticket at the qpOASES webpage.
-In case you do not want to disclose your feedback to the public, you may
-send an e-mail to
-
-        support@qpOASES.org
-
-Finally, you may contact one of the main authors directly:
-
-        Hans Joachim Ferreau, joachim.ferreau@ch.abb.com
-        Andreas Potschka,     potschka@iwr.uni-heidelberg.de
-        Christian Kirches,    christian.kirches@iwr.uni-heidelberg.de
-
-Also bug reports, source code enhancements or success stories are most welcome!
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/VERSIONS b/extlibs/qpOASES-3.2.0/VERSIONS
deleted file mode 100644
index c3c97e3..0000000
--- a/extlibs/qpOASES-3.2.0/VERSIONS
+++ /dev/null
@@ -1,124 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-VERSION HISTORY
-===============
-
-
-3.2 (released on 1st September 2015):
--------------------------------------
-
-+ Addition of SQProblemSchur class implementing Schur complement approach
-  for sparse QP problems
-+ Introduction of data types int_t and uint_t for integer-valued numbers
-+ Minor source code clean-up and bugfixes
-
-
-3.1 (released on 11th February 2015):
--------------------------------------
-
-+ Addition of C interface
-+ Further improved Matlab, Simulink, octave and Python interfaces
-+ Possibility to provide pre-computed Cholesky factor of Hessian matrix
-+ Source code clean-up and bugfixes
-
-
-3.0 (released on 29th July 2014, last updated on 17th December 2014):
----------------------------------------------------------------------
-
-+ Addition of unit testing
-+ Several bugfixes
-
-
-3.0beta (released on 16th August 2011, last updated on 4th April 2014):
------------------------------------------------------------------------
-
-+ Improved ratio tests and termination check for increased reliabilty
-+ Introduction of iterative refinement in step determination and 
-  drift correction to handle ill-conditioned QPs
-+ Introduction of ramping strategy to handle degenerated QPs
-+ Addition of far bounds and flipping bounds strategy to handle 
-  semi-definite and unbounded QPs more reliably
-+ Limited support of sparse QP matrices (also in Matlab interface)
-+ Optional linking of LAPACK/BLAS for linear algebra operations
-+ Addition of a number of algorithmic options, summarised in an option struct
-+ Improved Matlab interface
-+ Python interface added
-+ Several bugfixes
-
-
-2.0 (released on 10th February 2009, last updated on 7th December 2009):
-------------------------------------------------------------------------
-
-+ Implementation of regularisation scheme for treating QPs with 
-  semi-definite Hessians
-+ Addition of convenience functionality for Bounds and Constraints 
-  objects for specifying guessed active sets
-+ Allows to specify a CPU time in addition to an iteration limit
-+ Improved efficiency for QPs comprising many constraints
-+ Source code cleanup and bugfixing
-
-
-1.3 (released on 2nd June 2008, last updated on 13th August 2008):
-------------------------------------------------------------------
-
-+ Implementation of "initialised homotopy" concept
-+ Addition of the SolutionAnalysis class
-+ Utility functions for solving test problems in OQP format added
-+ Flexibility of Matlab(R) interface enhanced
-+ Major source code cleanup
-  (Attention: a few class names and calling interfaces have changed!)
-
-  
-1.2 (released on 9th October 2007):
------------------------------------
-
-+ Special treatment of diagonal Hessians
-+ Improved infeasibility detection
-+ Further improved Matlab(R) interface
-+ Extended Simulink(R) interface
-+ scilab interface added
-+ Code cleanup and several bugfixes
-
-
-1.1 (released on 8th July 2007):
---------------------------------
-
-+ Implementation of the QProblemB class
-+ Basic implementation of the SQProblem class
-+ Improved Matlab(R) interface
-+ Enabling/Disabling of constraints introduced
-+ Several bugfixes
-
-
-1.0 (released on 17th April 2007):
-----------------------------------
-
-Initial release.
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/VERSIONS.txt b/extlibs/qpOASES-3.2.0/VERSIONS.txt
deleted file mode 100644
index 23fbdcb..0000000
--- a/extlibs/qpOASES-3.2.0/VERSIONS.txt
+++ /dev/null
@@ -1,124 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-VERSION HISTORY
-===============
-
-
-3.2 (released on 1st September 2015):
--------------------------------------
-
-+ Addition of SQProblemSchur class implementing Schur complement approach
-  for sparse QP problems
-+ Introduction of data types int_t and uint_t for integer-valued numbers
-+ Minor source code clean-up and bugfixes
-
-
-3.1 (released on 11th February 2015):
--------------------------------------
-
-+ Addition of C interface
-+ Further improved Matlab, Simulink, octave and Python interfaces
-+ Possibility to provide pre-computed Cholesky factor of Hessian matrix
-+ Source code clean-up and bugfixes
-
-
-3.0 (released on 29th July 2014, last updated on 17th December 2014):
----------------------------------------------------------------------
-
-+ Addition of unit testing
-+ Several bugfixes
-
-
-3.0beta (released on 16th August 2011, last updated on 4th April 2014):
------------------------------------------------------------------------
-
-+ Improved ratio tests and termination check for increased reliabilty
-+ Introduction of iterative refinement in step determination and 
-  drift correction to handle ill-conditioned QPs
-+ Introduction of ramping strategy to handle degenerated QPs
-+ Addition of far bounds and flipping bounds strategy to handle 
-  semi-definite and unbounded QPs more reliably
-+ Limited support of sparse QP matrices (also in Matlab interface)
-+ Optional linking of LAPACK/BLAS for linear algebra operations
-+ Addition of a number of algorithmic options, summarised in an option struct
-+ Improved Matlab interface
-+ Python interface added
-+ Several bugfixes
-
-
-2.0 (released on 10th February 2009, last updated on 7th December 2009):
-------------------------------------------------------------------------
-
-+ Implementation of regularisation scheme for treating QPs with 
-  semi-definite Hessians
-+ Addition of convenience functionality for Bounds and Constraints 
-  objects for specifying guessed active sets
-+ Allows to specify a CPU time in addition to an iteration limit
-+ Improved efficiency for QPs comprising many constraints
-+ Source code cleanup and bugfixes
-
-
-1.3 (released on 2nd June 2008, last updated on 13th August 2008):
-------------------------------------------------------------------
-
-+ Implementation of "initialised homotopy" concept
-+ Addition of the SolutionAnalysis class
-+ Utility functions for solving test problems in OQP format added
-+ Flexibility of Matlab(R) interface enhanced
-+ Major source code cleanup
-  (Attention: a few class names and calling interfaces have changed!)
-
-  
-1.2 (released on 9th October 2007):
------------------------------------
-
-+ Special treatment of diagonal Hessians
-+ Improved infeasibility detection
-+ Further improved Matlab(R) interface
-+ Extended Simulink(R) interface
-+ scilab interface added
-+ Code cleanup and several bugfixes
-
-
-1.1 (released on 8th July 2007):
---------------------------------
-
-+ Implementation of the QProblemB class
-+ Basic implementation of the SQProblem class
-+ Improved Matlab(R) interface
-+ Enabling/Disabling of constraints introduced
-+ Several bugfixes
-
-
-1.0 (released on 17th April 2007):
-----------------------------------
-
-Initial release.
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/doc/DoxygenLayout.xml b/extlibs/qpOASES-3.2.0/doc/DoxygenLayout.xml
deleted file mode 100644
index 927d94d..0000000
--- a/extlibs/qpOASES-3.2.0/doc/DoxygenLayout.xml
+++ /dev/null
@@ -1,189 +0,0 @@
-<doxygenlayout version="1.0">
-  <!-- Navigation index tabs for HTML output -->
-  <navindex>
-    <tab type="mainpage" visible="yes" title=""/>
-    <tab type="pages" visible="yes" title="" intro=""/>
-    <tab type="modules" visible="yes" title="" intro=""/>
-    <tab type="namespaces" visible="yes" title="">
-      <tab type="namespacelist" visible="yes" title="" intro=""/>
-      <tab type="namespacemembers" visible="yes" title="" intro=""/>
-    </tab>
-    <tab type="classes" visible="yes" title="">
-      <tab type="classlist" visible="yes" title="" intro=""/>
-      <tab type="classindex" visible="$ALPHABETICAL_INDEX" title=""/> 
-      <tab type="hierarchy" visible="yes" title="" intro=""/>
-      <tab type="classmembers" visible="yes" title="" intro=""/>
-    </tab>
-    <tab type="files" visible="yes" title="">
-      <tab type="filelist" visible="yes" title="" intro=""/>
-      <tab type="globals" visible="yes" title="" intro=""/>
-    </tab>
-    <tab type="dirs" visible="yes" title="" intro=""/>
-    <tab type="examples" visible="yes" title="" intro=""/>
-	<tab type="user" visible="yes" url="../manual.pdf" title="Manual" intro=""/>
-  </navindex>
-
-  <!-- Layout definition for a class page -->
-  <class>
-    <briefdescription visible="yes"/>
-    <includes visible="$SHOW_INCLUDE_FILES"/>
-    <inheritancegraph visible="$CLASS_GRAPH"/>
-    <collaborationgraph visible="$COLLABORATION_GRAPH"/>
-    <allmemberslink visible="yes"/>
-    <memberdecl>
-      <nestedclasses visible="yes" title=""/>
-      <publictypes title=""/>
-      <publicslots title=""/>
-      <signals title=""/>
-      <publicmethods title=""/>
-      <publicstaticmethods title=""/>
-      <publicattributes title=""/>
-      <publicstaticattributes title=""/>
-      <protectedtypes title=""/>
-      <protectedslots title=""/>
-      <protectedmethods title=""/>
-      <protectedstaticmethods title=""/>
-      <protectedattributes title=""/>
-      <protectedstaticattributes title=""/>
-      <packagetypes title=""/>
-      <packagemethods title=""/>
-      <packagestaticmethods title=""/>
-      <packageattributes title=""/>
-      <packagestaticattributes title=""/>
-      <properties title=""/>
-      <events title=""/>
-      <privatetypes title=""/>
-      <privateslots title=""/>
-      <privatemethods title=""/>
-      <privatestaticmethods title=""/>
-      <privateattributes title=""/>
-      <privatestaticattributes title=""/>
-      <friends title=""/>
-      <related title="" subtitle=""/>
-      <membergroups visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-    <memberdef>
-      <inlineclasses title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <constructors title=""/>
-      <functions title=""/>
-      <related title=""/>
-      <variables title=""/>
-      <properties title=""/>
-      <events title=""/>
-    </memberdef>
-    <usedfiles visible="$SHOW_USED_FILES"/>
-    <authorsection visible="yes"/>
-  </class>
-
-  <!-- Layout definition for a namespace page -->
-  <namespace>
-    <briefdescription visible="yes"/>
-    <memberdecl>
-      <nestednamespaces visible="yes" title=""/>
-      <classes visible="yes" title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <membergroups visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-    <memberdef>
-      <inlineclasses title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-    </memberdef>
-    <authorsection visible="yes"/>
-  </namespace>
-
-  <!-- Layout definition for a file page -->
-  <file>
-    <briefdescription visible="yes"/>
-    <includes visible="$SHOW_INCLUDE_FILES"/>
-    <includegraph visible="$INCLUDE_GRAPH"/>
-    <includedbygraph visible="$INCLUDED_BY_GRAPH"/>
-    <sourcelink visible="yes"/>
-    <memberdecl>
-      <classes visible="yes" title=""/>
-      <namespaces visible="yes" title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <membergroups visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-    <memberdef>
-      <inlineclasses title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <functions title=""/>
-      <variables title=""/>
-    </memberdef>
-    <authorsection/>
-  </file>
-
-  <!-- Layout definition for a group page -->
-  <group>
-    <briefdescription visible="yes"/>
-    <groupgraph visible="$GROUP_GRAPHS"/>
-    <memberdecl>
-      <classes visible="yes" title=""/>
-      <namespaces visible="yes" title=""/>
-      <dirs visible="yes" title=""/>
-      <nestedgroups visible="yes" title=""/>
-      <files visible="yes" title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <enumvalues title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <signals title=""/>
-      <publicslots title=""/>
-      <protectedslots title=""/>
-      <privateslots title=""/>
-      <events title=""/>
-      <properties title=""/>
-      <friends title=""/>
-      <membergroups visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-    <memberdef>
-      <pagedocs/>
-      <inlineclasses title=""/>
-      <defines title=""/>
-      <typedefs title=""/>
-      <enums title=""/>
-      <enumvalues title=""/>
-      <functions title=""/>
-      <variables title=""/>
-      <signals title=""/>
-      <publicslots title=""/>
-      <protectedslots title=""/>
-      <privateslots title=""/>
-      <events title=""/>
-      <properties title=""/>
-      <friends title=""/>
-    </memberdef>
-    <authorsection visible="yes"/>
-  </group>
-
-  <!-- Layout definition for a directory page -->
-  <directory>
-    <briefdescription visible="yes"/>
-    <directorygraph visible="yes"/>
-    <memberdecl>
-      <dirs visible="yes"/>
-      <files visible="yes"/>
-    </memberdecl>
-    <detaileddescription title=""/>
-  </directory>
-</doxygenlayout>
diff --git a/extlibs/qpOASES-3.2.0/doc/Makefile b/extlibs/qpOASES-3.2.0/doc/Makefile
deleted file mode 100644
index 6267159..0000000
--- a/extlibs/qpOASES-3.2.0/doc/Makefile
+++ /dev/null
@@ -1,66 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-
-
-##
-##	settings
-##
-
-MAKEPDF = pdflatex
-LATEX = latex
-
-
-##
-##	targets
-##
-
-all: doc
-
-
-.PHONY: doc
-doc:
-	@ echo "Creating doxygen documentation "
-	@ doxygen doxygen.config
-	
-
-.PHONY: clean
-clean:
-	@ ${RM} -rf ./html
-
-
-.PHONY: clobber
-clobber: clean
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/doc/doxygen.config b/extlibs/qpOASES-3.2.0/doc/doxygen.config
deleted file mode 100644
index 4a50e22..0000000
--- a/extlibs/qpOASES-3.2.0/doc/doxygen.config
+++ /dev/null
@@ -1,310 +0,0 @@
-#---------------------------------------------------------------------------
-# Project related configuration options
-#---------------------------------------------------------------------------
-DOXYFILE_ENCODING      = UTF-8
-PROJECT_NAME           = qpOASES
-PROJECT_NUMBER         = 3.2.0
-PROJECT_BRIEF          = "An Implementation of the Online Active Set Strategy"
-PROJECT_LOGO           =
-OUTPUT_DIRECTORY       =
-CREATE_SUBDIRS         = NO
-OUTPUT_LANGUAGE        = English
-BRIEF_MEMBER_DESC      = YES
-REPEAT_BRIEF           = NO
-ABBREVIATE_BRIEF       =
-ALWAYS_DETAILED_SEC    = NO
-INLINE_INHERITED_MEMB  = YES
-FULL_PATH_NAMES        = YES
-STRIP_FROM_PATH        = ..
-STRIP_FROM_INC_PATH    =
-SHORT_NAMES            = NO
-JAVADOC_AUTOBRIEF      = NO
-QT_AUTOBRIEF           = NO
-MULTILINE_CPP_IS_BRIEF = NO
-INHERIT_DOCS           = YES
-SEPARATE_MEMBER_PAGES  = NO
-TAB_SIZE               = 4
-ALIASES                =
-TCL_SUBST              =
-OPTIMIZE_OUTPUT_FOR_C  = NO
-OPTIMIZE_OUTPUT_JAVA   = NO
-OPTIMIZE_FOR_FORTRAN   = NO
-OPTIMIZE_OUTPUT_VHDL   = NO
-EXTENSION_MAPPING      =
-MARKDOWN_SUPPORT       = YES
-AUTOLINK_SUPPORT       = YES
-BUILTIN_STL_SUPPORT    = NO
-CPP_CLI_SUPPORT        = NO
-SIP_SUPPORT            = NO
-IDL_PROPERTY_SUPPORT   = YES
-DISTRIBUTE_GROUP_DOC   = NO
-SUBGROUPING            = YES
-INLINE_GROUPED_CLASSES = NO
-INLINE_SIMPLE_STRUCTS  = NO
-TYPEDEF_HIDES_STRUCT   = NO
-SYMBOL_CACHE_SIZE      = 0
-LOOKUP_CACHE_SIZE      = 0
-
-#---------------------------------------------------------------------------
-# Build related configuration options
-#---------------------------------------------------------------------------
-EXTRACT_ALL            = NO
-EXTRACT_PRIVATE        = YES
-EXTRACT_PACKAGE        = NO
-EXTRACT_STATIC         = NO
-EXTRACT_LOCAL_CLASSES  = YES
-EXTRACT_LOCAL_METHODS  = NO
-EXTRACT_ANON_NSPACES   = NO
-HIDE_UNDOC_MEMBERS     = NO
-HIDE_UNDOC_CLASSES     = NO
-HIDE_FRIEND_COMPOUNDS  = NO
-HIDE_IN_BODY_DOCS      = NO
-INTERNAL_DOCS          = NO
-CASE_SENSE_NAMES       = YES
-HIDE_SCOPE_NAMES       = NO
-SHOW_INCLUDE_FILES     = YES
-FORCE_LOCAL_INCLUDES   = NO
-INLINE_INFO            = YES
-SORT_MEMBER_DOCS       = YES
-SORT_BRIEF_DOCS        = NO
-SORT_MEMBERS_CTORS_1ST = NO
-SORT_GROUP_NAMES       = NO
-SORT_BY_SCOPE_NAME     = NO
-STRICT_PROTO_MATCHING  = NO
-GENERATE_TODOLIST      = NO
-GENERATE_TESTLIST      = NO
-GENERATE_BUGLIST       = NO
-GENERATE_DEPRECATEDLIST= YES
-ENABLED_SECTIONS       =
-MAX_INITIALIZER_LINES  = 30
-SHOW_USED_FILES        = YES
-SHOW_FILES             = YES
-SHOW_NAMESPACES        = YES
-FILE_VERSION_FILTER    =
-LAYOUT_FILE            = DoxygenLayout.xml
-CITE_BIB_FILES         =
-
-#---------------------------------------------------------------------------
-# configuration options related to warning and progress messages
-#---------------------------------------------------------------------------
-QUIET                  = NO
-WARNINGS               = YES
-WARN_IF_UNDOCUMENTED   = YES
-WARN_IF_DOC_ERROR      = YES
-WARN_NO_PARAMDOC       = NO
-WARN_FORMAT            = "$file:$line: $text"
-WARN_LOGFILE           =
-
-#---------------------------------------------------------------------------
-# configuration options related to the input files
-#---------------------------------------------------------------------------
-INPUT                  = ./mainpage.dox \
-../src \
-../include/qpOASES \
-../include/qpOASES/extras \
-../examples
-INPUT_ENCODING         = UTF-8
-FILE_PATTERNS          = *.cpp \
-*.ipp \
-*.hpp \
-*.c
-RECURSIVE              = YES
-EXCLUDE                =
-EXCLUDE_SYMLINKS       = NO
-EXCLUDE_PATTERNS       =
-EXCLUDE_SYMBOLS        =
-EXAMPLE_PATH           = ../examples
-EXAMPLE_PATTERNS       =
-EXAMPLE_RECURSIVE      = NO
-IMAGE_PATH             =
-INPUT_FILTER           =
-FILTER_PATTERNS        =
-FILTER_SOURCE_FILES    = NO
-FILTER_SOURCE_PATTERNS =
-
-#---------------------------------------------------------------------------
-# configuration options related to source browsing
-#---------------------------------------------------------------------------
-SOURCE_BROWSER         = NO
-INLINE_SOURCES         = NO
-STRIP_CODE_COMMENTS    = YES
-REFERENCED_BY_RELATION = YES
-REFERENCES_RELATION    = YES
-REFERENCES_LINK_SOURCE = YES
-USE_HTAGS              = NO
-VERBATIM_HEADERS       = YES
-
-#---------------------------------------------------------------------------
-# configuration options related to the alphabetical class index
-#---------------------------------------------------------------------------
-ALPHABETICAL_INDEX     = NO
-COLS_IN_ALPHA_INDEX    = 5
-IGNORE_PREFIX          =
-
-#---------------------------------------------------------------------------
-# configuration options related to the HTML output
-#---------------------------------------------------------------------------
-GENERATE_HTML          = YES
-HTML_OUTPUT            = html
-HTML_FILE_EXTENSION    = .html
-HTML_HEADER            =
-HTML_FOOTER            =
-HTML_STYLESHEET        =
-HTML_EXTRA_STYLESHEET  =
-HTML_EXTRA_FILES       =
-HTML_COLORSTYLE_HUE    = 220
-HTML_COLORSTYLE_SAT    = 100
-HTML_COLORSTYLE_GAMMA  = 80
-HTML_TIMESTAMP         = YES
-HTML_DYNAMIC_SECTIONS  = NO
-HTML_INDEX_NUM_ENTRIES = 100
-GENERATE_DOCSET        = NO
-DOCSET_FEEDNAME        = "Doxygen generated docs"
-DOCSET_BUNDLE_ID       = org.doxygen.Project
-DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
-DOCSET_PUBLISHER_NAME  = Publisher
-GENERATE_HTMLHELP      = NO
-CHM_FILE               =
-HHC_LOCATION           =
-GENERATE_CHI           = NO
-CHM_INDEX_ENCODING     =
-BINARY_TOC             = NO
-TOC_EXPAND             = NO
-GENERATE_QHP           = NO
-QCH_FILE               =
-QHP_NAMESPACE          = org.doxygen.Project
-QHP_VIRTUAL_FOLDER     = doc
-QHP_CUST_FILTER_NAME   =
-QHP_CUST_FILTER_ATTRS  =
-QHP_SECT_FILTER_ATTRS  =
-QHG_LOCATION           =
-GENERATE_ECLIPSEHELP   = NO
-ECLIPSE_DOC_ID         = org.doxygen.Project
-DISABLE_INDEX          = NO
-GENERATE_TREEVIEW      = NO
-ENUM_VALUES_PER_LINE   = 4
-TREEVIEW_WIDTH         = 250
-EXT_LINKS_IN_WINDOW    = NO
-FORMULA_FONTSIZE       = 10
-FORMULA_TRANSPARENT    = YES
-USE_MATHJAX            = NO
-MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
-MATHJAX_EXTENSIONS     =
-SEARCHENGINE           = NO
-SERVER_BASED_SEARCH    = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the LaTeX output
-#---------------------------------------------------------------------------
-GENERATE_LATEX         = NO
-LATEX_OUTPUT           = latex
-LATEX_CMD_NAME         = latex
-MAKEINDEX_CMD_NAME     = makeindex
-COMPACT_LATEX          = NO
-PAPER_TYPE             = a4wide
-EXTRA_PACKAGES         =
-LATEX_HEADER           =
-LATEX_FOOTER           =
-PDF_HYPERLINKS         = YES
-USE_PDFLATEX           = NO
-LATEX_BATCHMODE        = NO
-LATEX_HIDE_INDICES     = NO
-LATEX_SOURCE_CODE      = NO
-LATEX_BIB_STYLE        = plain
-
-#---------------------------------------------------------------------------
-# configuration options related to the RTF output
-#---------------------------------------------------------------------------
-GENERATE_RTF           = NO
-RTF_OUTPUT             = RTF
-COMPACT_RTF            = NO
-RTF_HYPERLINKS         = NO
-RTF_STYLESHEET_FILE    =
-RTF_EXTENSIONS_FILE    =
-
-#---------------------------------------------------------------------------
-# configuration options related to the man page output
-#---------------------------------------------------------------------------
-GENERATE_MAN           = NO
-MAN_OUTPUT             = MAN
-MAN_EXTENSION          = .3
-MAN_LINKS              = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the XML output
-#---------------------------------------------------------------------------
-GENERATE_XML           = NO
-XML_OUTPUT             = XML
-XML_SCHEMA             =
-XML_DTD                =
-XML_PROGRAMLISTING     = YES
-
-#---------------------------------------------------------------------------
-# configuration options for the AutoGen Definitions output
-#---------------------------------------------------------------------------
-GENERATE_AUTOGEN_DEF   = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the Perl module output
-#---------------------------------------------------------------------------
-GENERATE_PERLMOD       = NO
-PERLMOD_LATEX          = NO
-PERLMOD_PRETTY         = YES
-PERLMOD_MAKEVAR_PREFIX =
-
-#---------------------------------------------------------------------------
-# Configuration options related to the preprocessor
-#---------------------------------------------------------------------------
-ENABLE_PREPROCESSING   = YES
-MACRO_EXPANSION        = NO
-EXPAND_ONLY_PREDEF     = NO
-SEARCH_INCLUDES        = YES
-INCLUDE_PATH           =
-INCLUDE_FILE_PATTERNS  =
-PREDEFINED             =
-EXPAND_AS_DEFINED      =
-SKIP_FUNCTION_MACROS   = YES
-
-#---------------------------------------------------------------------------
-# Configuration::additions related to external references
-#---------------------------------------------------------------------------
-TAGFILES               =
-GENERATE_TAGFILE       =
-ALLEXTERNALS           = NO
-EXTERNAL_GROUPS        = YES
-PERL_PATH              = /usr/bin/perl
-
-#---------------------------------------------------------------------------
-# Configuration options related to the dot tool
-#---------------------------------------------------------------------------
-CLASS_DIAGRAMS         = YES
-MSCGEN_PATH            =
-HIDE_UNDOC_RELATIONS   = YES
-HAVE_DOT               = NO
-DOT_NUM_THREADS        = 0
-DOT_FONTNAME           = Helvetica
-DOT_FONTSIZE           = 10
-DOT_FONTPATH           =
-CLASS_GRAPH            = YES
-COLLABORATION_GRAPH    = NO
-GROUP_GRAPHS           = YES
-UML_LOOK               = NO
-UML_LIMIT_NUM_FIELDS   = 10
-TEMPLATE_RELATIONS     = NO
-INCLUDE_GRAPH          = YES
-INCLUDED_BY_GRAPH      = YES
-CALL_GRAPH             = NO
-CALLER_GRAPH           = NO
-GRAPHICAL_HIERARCHY    = YES
-DIRECTORY_GRAPH        = YES
-DOT_IMAGE_FORMAT       = png
-INTERACTIVE_SVG        = NO
-DOT_PATH               =
-DOTFILE_DIRS           =
-MSCFILE_DIRS           =
-DOT_GRAPH_MAX_NODES    = 50
-MAX_DOT_GRAPH_DEPTH    = 0
-DOT_TRANSPARENT        = NO
-DOT_MULTI_TARGETS      = NO
-GENERATE_LEGEND        = YES
-DOT_CLEANUP            = YES
diff --git a/extlibs/qpOASES-3.2.0/doc/mainpage.dox b/extlibs/qpOASES-3.2.0/doc/mainpage.dox
deleted file mode 100644
index 8a93b00..0000000
--- a/extlibs/qpOASES-3.2.0/doc/mainpage.dox
+++ /dev/null
@@ -1,134 +0,0 @@
-/**
- *	\mainpage Main Page
- *
- *	<p>&nbsp;</p>
- *
- *	\section sec_copyright Copyright
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy. \n
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *	<p>&nbsp;</p>
- *
- *
- *	\section sec_developers Authors and Contributors
- *
- *	qpOASES's core functionality and software design have been developed by 
- *	the following main developers (in alphabetical order):
- *	<ul>
- *	<li>Hans Joachim Ferreau
- *	<li>Christian Kirches
- *	<li>Andreas Potschka
- *	</ul>
- *
- *	Moreover, the following developers have contributed code to qpOASES's 
- *	third-party interfaces or provided additional functionality 
- *	(in alphabetical order):
- *	<ul>
- *	<li>Alexander Buchner
- *	<li>Holger Diedam
- *	<li>Dennis Janka
- *	<li>Manuel Kudruss
- *	<li>Andreas Waechter
- *	<li>Sebastian F. Walter
- *	</ul>
- *
- *	Finally, the following people have not contributed to the source code, 
- *	but have helped making qpOASES even more useful by testing, reporting 
- *	bugs or proposing algorithmic improvements (in alphabetical order): 
- *	<ul>
- *	<li>Eckhard Arnold
- *	<li>Boris Houska
- *	<li>D. Kwame Minde Kufoalor
- *	<li>Aude Perrin
- *	<li>Milan Vukov
- *	<li>Thomas Wiese
- *	<li>Leonard Wirsching
- *	</ul>
- *
- *	We also would like to thank two persons who had a major share in making 
- *	qpOASES a success. Not by writing even a single line of code, but by 
- *	establishing the idea of using a homotopy-based approach for high-speed 
- *	QP solutions and by excellent scientific guidance during the development 
- *	process:
- *	<ul>
- *	<li>Hans Georg Bock
- *	<li>Moritz Diehl 
- *	</ul>
- *
- *	All users are invited to further improve qpOASES by providing comments, code enhancements, 
- *	bug reports, additional documentation or whatever you feel is missing. The preferred way
- *	of doing so is to <b>create a <a href="https://projects.coin-or.org/qpOASES/newticket">new ticket</a>
- *	at the qpOASES webpage</b>. In case you do not want to disclose your feedback to the public, 
- *	you may send an e-mail to <a href="mailto:support@qpOASES.org">support@qpOASES.org</a> 
- *	or contact one of the main developers directly.
- *	<p>&nbsp;</p>
- *
- *
- *	\section sec_citing Citing qpOASES
- *
- *	If you use qpOASES within your scientific work, we strongly encourage you to cite at least 
- *	one of the following publications:
- *
- *	<ul>
- *	<li>Reference to the <b>software</b>:
- *	\code
- *	 @ARTICLE{Ferreau2014,
- *	  author = {H.J. Ferreau and C. Kirches and A. Potschka and H.G. Bock and M. Diehl},
- *	  title = {{qpOASES}: A parametric active-set algorithm for quadratic programming},
- *	  journal = {Mathematical Programming Computation},
- *	  year = {2014},
- *	  volume = {6},
- *	  number = {4},
- *	  pages = {327--363},
- *	  keywords = {qpOASES, parametric quadratic programming, active set method, model predictive control}
- *	}
- *	\endcode
- *
- *	<li>Reference to the <b>online active set strategy</b>:
- *	\code
- *	 @ARTICLE{Ferreau2008,
- *	  author = {H.J. Ferreau and H.G. Bock and M. Diehl},
- *	  title = {An online active set strategy to overcome the limitations of explicit MPC},
- *	  journal = {International Journal of Robust and Nonlinear Control},
- *	  year = {2008},
- *	  volume = {18},
- *	  number = {8},
- *	  pages = {816--830},
- *	  keywords = {model predictive control, parametric quadratic programming, online active set strategy}
- *	}
- *	\endcode
- *
- *	<li>Reference to the <b>webpage</b>:
- *	\code
- *	 @MISC{qpOASES2014,
- *	  author = {H.J. Ferreau and A. Potschka and C. Kirches},
- *	  title = {{qpOASES} webpage},
- *	  howpublished = {http://www.qpOASES.org/},
- *	  year = {2007--2015},
- *	  keywords = {qpOASES, model predictive control, parametric quadratic programming, online active set strategy}
- *	}
- *	\endcode
- *	</ul>
- *	<p>&nbsp;</p>
- *
- *	\section sec_moreinfo More Information
- *
- *	More information can be found on <a href="http://www.qpOASES.org/">http://www.qpOASES.org/</a> 
- *	and in the <a href="../manual.pdf">qpOASES User's Manual</a>.
- *	<p>&nbsp;</p>
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/Makefile b/extlibs/qpOASES-3.2.0/examples/Makefile
deleted file mode 100644
index 03cfe00..0000000
--- a/extlibs/qpOASES-3.2.0/examples/Makefile
+++ /dev/null
@@ -1,107 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  examples/Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-include ../make.mk
-
-##
-##	flags
-##
-
-IFLAGS      =  -I. \
-               -I${IDIR}
-
-QPOASES_EXES = \
-	${BINDIR}/example1${EXE} \
-	${BINDIR}/example1a${EXE} \
-	${BINDIR}/example1b${EXE} \
-	${BINDIR}/example2${EXE} \
-	${BINDIR}/example3${EXE} \
-	${BINDIR}/example3b${EXE} \
-	${BINDIR}/example4${EXE} \
-	${BINDIR}/example5${EXE} \
-	${BINDIR}/exampleLP${EXE} \
-	${BINDIR}/qrecipe${EXE} \
-	${BINDIR}/qrecipeSchur${EXE}
-
-
-##
-##	targets
-##
-
-all: ${QPOASES_EXES}
-
-${BINDIR}/%${EXE}: %.${OBJEXT} ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/example4${EXE}: example4.${OBJEXT} example4CP.cpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/qrecipe${EXE}: qrecipe.${OBJEXT} qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/qrecipeSchur${EXE}: qrecipeSchur.${OBJEXT} qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-
-clean:
-	@${ECHO} "Cleaning up (examples)"
-	@${RM} -f *.${OBJEXT} ${QPOASES_EXES}
-
-clobber: clean
-
-
-${LINK_DEPENDS}:
-	@cd ..; ${MAKE} -s src
-
-example4.${OBJEXT}: example4.cpp example4CP.cpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-qrecipe.${OBJEXT}: qrecipe.cpp qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-qrecipeSchur.${OBJEXT}: qrecipeSchur.cpp qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-%.${OBJEXT}: %.cpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/examples/example1.cpp b/extlibs/qpOASES-3.2.0/examples/example1.cpp
deleted file mode 100644
index 1489537..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example1.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES using the QProblem class.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up QProblem object. */
-	QProblem example( 2,1 );
-
-	Options options;
-	example.setOptions( options );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR );
-
-	/* Get and print solution of first QP. */
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-	
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-
-	example.printOptions();
-	/*example.printProperties();*/
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example1a.cpp b/extlibs/qpOASES-3.2.0/examples/example1a.cpp
deleted file mode 100644
index 848c4d6..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example1a.cpp
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example1a.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES using the SQProblem class.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the SQProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up SQProblem object. */
-	SQProblem example( 2,1 );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[2];
-	example.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example1b.cpp b/extlibs/qpOASES-3.2.0/examples/example1b.cpp
deleted file mode 100644
index 6960d0f..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example1b.cpp
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example1b.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES using the QProblemB class.
- */
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the QProblemB class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-
-
-	/* Setting up QProblemB object. */
-	QProblemB example( 2 );
-
-	Options options;
-	//options.enableFlippingBounds = BT_FALSE;
-	options.initialStatusBounds = ST_INACTIVE;
-	options.numRefinementSteps = 1;
-	options.enableCholeskyRefactorisation = 1;
-	example.setOptions( options );
-
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,lb,ub, nWSR,0 );
-
-	/* Get and print solution of first QP. */
-	real_t xOpt[2];
-	example.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-	
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new, nWSR,0 );
-// 	printf( "\nnWSR = %d\n\n", nWSR );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example2.cpp b/extlibs/qpOASES-3.2.0/examples/example2.cpp
deleted file mode 100644
index 5017a54..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example2.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example2.cpp
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Very simple example for testing qpOASES in combination
- *  with the SolutionAnalysis class.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the SolutionAnalysis class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up SQProblem object and solution analyser. */
-	SQProblem example( 2,1 );
-	SolutionAnalysis analyser;
-
-	/* Solve first QP ... */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	/* ... and analyse it. */
-	real_t maxKktViolation = analyser.getKktViolation( &example );
-    printf( "maxKktViolation: %e\n", maxKktViolation );
-
-	/* Solve second QP ... */
-	nWSR = 10;
-	example.hotstart( H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-	/* ... and analyse it. */
-	maxKktViolation = analyser.getKktViolation( &example );
-    printf( "maxKktViolation: %e\n", maxKktViolation );
-
-
-//  ------------ VARIANCE-COVARIANCE EVALUATION --------------------
-
-        real_t *Var              = new real_t[5*5];
-        real_t *Primal_Dual_Var  = new real_t[5*5];
-
-        int_t run1, run2;
-        for( run1 = 0; run1 < 5*5; run1++ )
-            Var[run1] = 0.0;
-
-        Var[0] = 1.0;
-        Var[6] = 1.0;
-
-//                  (  1   0   0   0   0   )
-//                  (  0   1   0   0   0   )
-//     Var     =    (  0   0   0   0   0   )
-//                  (  0   0   0   0   0   )
-//                  (  0   0   0   0   0   )
-
-
-        analyser.getVarianceCovariance( &example, Var,Primal_Dual_Var );
-
-        printf("\nPrimal_Dual_VAR = \n");
-        for( run1 = 0; run1 < 5; run1++ ){
-          for( run2 = 0; run2 < 5; run2++ ){
-            printf(" %10f", Primal_Dual_Var[run1*5+run2]);
-          }
-          printf("\n");
-        }
-
-        delete[] Primal_Dual_Var;
-        delete[] Var;
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example3.cpp b/extlibs/qpOASES-3.2.0/examples/example3.cpp
deleted file mode 100644
index 5257579..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example3.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example3.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Example demonstrating usage of qpOASES for solving a QP sequence of the
- *	Online QP Benchmark Collection. In order to run it, you have to download
- *	"Example 02" from from http://www.qpOASES.org/onlineQP/ and store it into 
- *	the directory bin/chain80w/.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the OQP interface. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* 1) Define benchmark arguments. */
-	BooleanType isSparse = BT_FALSE;
-	Options options;
-	options.setToMPC();
-	options.printLevel = PL_NONE;
-
-	int_t nWSR = 600;
-	real_t maxCPUtime = 10.0; /* seconds */
-	real_t maxStationarity, maxFeasibility, maxComplementarity;
-
-	/* 2) Run benchmark. */
-	if ( runOqpBenchmark(	"./chain80w/",
-							isSparse,
-							options,
-							nWSR,
-							maxCPUtime,
-							maxStationarity,
-							maxFeasibility,
-							maxComplementarity
-							) != SUCCESSFUL_RETURN )
-	{
-		myPrintf( "In order to run this example, you need to download example no. 02\nfrom the Online QP Benchmark Collection website first!\n" );
-		return -1;
-	}
-
-	/* 3) Print results. */
-	printf( "\n\n" );
-	printf( "OQP Benchmark Results:\n" );
-	printf( "======================\n\n" );
-	printf( "maximum violation stationarity:     %.3e\n",maxStationarity );
-	printf( "maximum violation feasibility:      %.3e\n",maxFeasibility );
-	printf( "maximum violation complementarity:  %.3e\n",maxComplementarity );
-	printf( "\n" );
-	printf( "maximum CPU time:             %.3f milliseconds\n\n",1000.0*maxCPUtime );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example3b.cpp b/extlibs/qpOASES-3.2.0/examples/example3b.cpp
deleted file mode 100644
index 7e023a7..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example3b.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example3b.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Example demonstrating usage of qpOASES for solving a QP sequence of the
- *	Online QP Benchmark Collection. In order to run it, you have to download
- *	"Example 02" from http://www.qpOASES.org/onlineQP/ and store it into 
- *	the directory bin/chain80/.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the OQP interface. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* 1) Define benchmark arguments. */
-	BooleanType isSparse = BT_FALSE;
-	Options options;
-	options.setToMPC();
-	options.printLevel = PL_NONE;
-	
-	int_t nWSR = 300;
-	real_t maxCPUtime = 10.0; /* seconds */
-	real_t maxStationarity, maxFeasibility, maxComplementarity;
-
-	/* 2) Run benchmark. */
-	if ( runOqpBenchmark(	"./chain80/",
-							isSparse,
-							options,
-							nWSR,
-							maxCPUtime,
-							maxStationarity,
-							maxFeasibility,
-							maxComplementarity
-							) != SUCCESSFUL_RETURN )
-	{
-		myPrintf( "In order to run this example, you need to download example no. 02\nfrom the Online QP Benchmark Collection website first!\n" );
-		return -1;
-	}
-
-	/* 3) Print results. */
-	printf( "\n\n" );
-	printf( "OQP Benchmark Results:\n" );
-	printf( "======================\n\n" );
-	printf( "maximum violation stationarity:     %.3e\n",maxStationarity );
-	printf( "maximum violation feasibility:      %.3e\n",maxFeasibility );
-	printf( "maximum violation complementarity:  %.3e\n",maxComplementarity );
-	printf( "\n" );
-	printf( "maximum CPU time:             %.3f milliseconds\n\n",1000.0*maxCPUtime );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example4.cpp b/extlibs/qpOASES-3.2.0/examples/example4.cpp
deleted file mode 100644
index 59205ab..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example4.cpp
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example4.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2009-2015
- *
- *	Very simple example for testing qpOASES (using the possibility to specify 
- *	user-defined constraint product function).
- */
-
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "example4CP.cpp"
-
-
-/**	Example for qpOASES main function using the possibility to specify 
- *	user-defined constraint product function. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t i,j;
-
-	/* Setup data of first QP... */
-	real_t H[7*7];
-	real_t A[50*7];
-	real_t g[7];
-	real_t lbA[50];
-
-	/*	    ( 1.0 0.5 |                    )
-	 *	    ( 0.5 2.0 |                    )
-	 *	    ( --------+------------------- )
-	 *	H = (         | 1e-6               )
-	 *	    (         |      1e-6          )
-	 *	    (         |           ...      )
-	 *	    (         |               1e-6 ) */
-	for( i=0; i<7*7; ++i )
-		H[i] = 0.0;
-	for( i=2; i<7; ++i )
-		H[i*7+i] = 1.0e-6;
-	H[0] = 1.0;
-	H[1] = 0.5;
-	H[7] = 0.5;
-	H[8] = 2.0;
-
-	/*	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x | ...             )
-	 *	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x |     1.0         )
-	 *	A = ( x.x x.x |     ...         )
-	 *	    ( x.x x.x |     1.0         )
-	 *	    ( x.x x.x |         ...     )
-	 *	    ( x.x x.x |             1.0 )
-	 *	    ( x.x x.x |             ... )
-	 *	    ( x.x x.x |             1.0 ) */
-	for( i=0; i<50*7; ++i )
-		A[i] = 0.0;
-	for( i=0; i<50; ++i )
-	{
-		for( j=0; j<2; ++j )
-			A[i*7+j] = (real_t)rand() / (real_t)RAND_MAX;
-
-		A[i*7 + (i/10)+2] = 1.0;
-	}
-
-	/*	    ( -1.0 )
-	 *	    ( -0.5 )
-	 *	    ( ---- )
-	 *	g = (      )
-	 *	    (      )
-	 *	    (      )
-	 *	    (      ) */
-	for( i=0; i<7; ++i )
-		g[i] = 0.0;
-	g[0] = -1.0;
-	g[1] = -0.5;
-
-	for( i=0; i<50; ++i )
-		lbA[i] = 1.0;
-
-	/* ... and setting up user-defined constraint product function. */
-	MyConstraintProduct myCP( 7,50,A );
-
-
-	/* Setting up QProblem object and set construct product function. */
-	QProblem exampleCP( 7,50 );
-	exampleCP.setPrintLevel( PL_NONE );
-	
-	exampleCP.setConstraintProduct( &myCP );
-
-
-	/* Solve first QP. */
-	real_t cputime = 1.0;
-	int_t nWSR = 100;
-	exampleCP.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-
-
-	/* Solve second QP using a modified gradient. */
-	g[0] = -2.0;
-	g[1] =  0.5;
-
-	cputime = 1.0;
-	nWSR = 100;
-	exampleCP.hotstart( g,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[7];
-	exampleCP.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e, %e ... ];  objVal = %e\n", xOpt[0],xOpt[1],xOpt[2],exampleCP.getObjVal() );
-	printf( "CPU time:  %.3f microseconds\n\n", cputime*1.0e6 ); 
-
-	
-	
-	/* Do the same without specifying constraint product. */
-	QProblem example( 7,50 );
-	example.setPrintLevel( PL_NONE );
-	
-	/* Solve first QP. */
-	g[0] = -1.0;
-	g[1] = -0.5;
-	
-	cputime = 1.0;
-	nWSR = 100;
-	example.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-	
-	/* Solve second QP using a modified gradient. */
-	g[0] = -2.0;
-	g[1] =  0.5;
-
-	cputime = 1.0;
-	nWSR = 100;
-	example.hotstart( g,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e, %e ... ];  objVal = %e\n", xOpt[0],xOpt[1],xOpt[2],example.getObjVal() );
-	printf( "CPU time:  %.3f microseconds\n\n", cputime*1.0e6 ); 
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/example4CP.cpp b/extlibs/qpOASES-3.2.0/examples/example4CP.cpp
deleted file mode 100644
index 3eeada7..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example4CP.cpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example4CP.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2009-2015
- *
- *	Sample implementation of the ConstraintProduct class tailored for Example4.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Example illustrating the use of the \a ConstraintProduct class.
- *
- *	Example illustrating the use of the \a ConstraintProduct class.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- */
-class MyConstraintProduct : public ConstraintProduct
-{
-	public:
-		/** Default constructor. */
-		MyConstraintProduct( ) {};
-
-		/** Constructor. */
-		MyConstraintProduct(	int_t _nV,
-								int_t _nC,
-								real_t* _A
-								)
-		{
-			nV = _nV;
-			nC = _nC;
-			A  = _A;
-		};
-
-		/** Copy constructor (flat copy). */
-		MyConstraintProduct(	const MyConstraintProduct& rhs
-								)
-		{
-			nV = rhs.nV;
-			nC = rhs.nC;
-			A  = rhs.A;
-		};
-
-		/** Destructor. */
-		virtual ~MyConstraintProduct( ) {};
-		
-		/** Assignment operator (flat copy). */
-		MyConstraintProduct& operator=(	const MyConstraintProduct& rhs
-										)
-		{
-			if ( this != &rhs )
-			{
-				nV = rhs.nV;
-				nC = rhs.nC;
-				A  = rhs.A;
-			}
-			return *this;
-		};
-
-		virtual int_t operator() (	int_t constrIndex,
-									const real_t* const x,
-									real_t* const constrValue
-									) const
-		{
-			int_t i;
-
-			constrValue[0] = 1.0 * x[(constrIndex/10)+2];
-
-			for( i=0; i<2; ++i )
-				constrValue[0] += A[constrIndex*nV + i] * x[i];
-
-			return 0;
-		};
-
-	protected:
-		int_t nV;		/**< Number of variables. */
-		int_t nC;		/**< Number of constraints. */
-		real_t* A;		/**< Pointer to full constraint matrix (typically not needed!). */
-};
-
-
-END_NAMESPACE_QPOASES
-
diff --git a/extlibs/qpOASES-3.2.0/examples/example5.cpp b/extlibs/qpOASES-3.2.0/examples/example5.cpp
deleted file mode 100644
index 1798f9c..0000000
--- a/extlibs/qpOASES-3.2.0/examples/example5.cpp
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/example5.cpp
- *	\author Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2011-2015
- *
- *	Very simple example for testing qpOASES (using the possibility to
- *  compute the local linear feedback law)
- */
-
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "example4CP.cpp"
-
-
-/**	Example for qpOASES main function using the possibility to specify
- *	user-defined constraint product function. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t i,j,jj;
-	real_t d = 0.0;
-
-	/* Setup data of first QP... */
-	real_t H[7*7];
-	real_t A[50*7];
-	real_t g[7];
-	real_t lbA[50];
-
-	/*	    ( 1.0 0.5 |                    )
-	 *	    ( 0.5 2.0 |                    )
-	 *	    ( --------+------------------- )
-	 *	H = (         | 1e-6               )
-	 *	    (         |      1e-6          )
-	 *	    (         |           ...      )
-	 *	    (         |               1e-6 ) */
-	for( i=0; i<7*7; ++i )
-		H[i] = 0.0;
-	for( i=2; i<7; ++i )
-		H[i*7+i] = 1.0e-6;
-	H[0] = 1.0;
-	H[1] = 0.5;
-	H[7] = 0.5;
-	H[8] = 2.0;
-
-	/*	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x | ...             )
-	 *	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x |     1.0         )
-	 *	A = ( x.x x.x |     ...         )
-	 *	    ( x.x x.x |     1.0         )
-	 *	    ( x.x x.x |         ...     )
-	 *	    ( x.x x.x |             1.0 )
-	 *	    ( x.x x.x |             ... )
-	 *	    ( x.x x.x |             1.0 ) */
-	for( i=0; i<50*7; ++i )
-		A[i] = 0.0;
-	for( i=0; i<50; ++i )
-	{
-		for( j=0; j<2; ++j )
-			A[i*7+j] = (real_t)rand() / (real_t)RAND_MAX;
-
-		A[i*7 + (i/10)+2] = 1.0;
-	}
-
-	/*	    ( -1.0 )
-	 *	    ( -0.5 )
-	 *	    ( ---- )
-	 *	g = (      )
-	 *	    (      )
-	 *	    (      )
-	 *	    (      ) */
-	for( i=0; i<7; ++i )
-		g[i] = 0.0;
-	g[0] = -1.0;
-	g[1] = -0.5;
-
-	for( i=0; i<50; ++i )
-		lbA[i] = 1.0;
-
-	/* ... and setting up user-defined constraint product function. */
-	MyConstraintProduct myCP( 7,50,A );
-
-
-	/* Setting up QProblem object and set construct product function. */
-	QProblem example( 7,50 );
-	example.setConstraintProduct( &myCP );
-
-
-	/* Solve first QP. */
-	real_t cputime = 1.0;
-	int_t nWSR = 100;
-	example.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of QP. */
-	real_t xOpt[7], yOpt[7+50];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-
-
-	/* Compute local linear feedback law */
-	const int_t n_rhs = 7+7+50;
-	real_t g_in[7*n_rhs];
-	real_t b_in[7*n_rhs];
-	real_t bA_in[50*n_rhs];
-	real_t x_out[7*n_rhs];
-	real_t y_out[(7+50)*n_rhs];
-
-	int_t ii;
-	memset (g_in, 0, sizeof (g_in));
-	memset (b_in, 0, sizeof (b_in));
-	memset (bA_in, 0, sizeof (bA_in));
-
-	for ( ii = 0; ii < 7; ++ii )
-		g_in[ii*7 + ii] = 1.0;
-	for ( ii = 0; ii < 7; ++ii )
-		b_in[(ii+7)*7 + ii] = 1.0;
-	for ( ii = 0; ii < 50; ++ii )
-		bA_in[(ii+14)*50 + ii] = 1.0;
-
-	example.solveCurrentEQP ( n_rhs, g_in, b_in, b_in, bA_in, bA_in, x_out, y_out );
-
-	/* Verify validity of local feedback law by perturbation and hot starts */
-	real_t perturb = 1.0e-6;
-	real_t nrm = 0.0;
-	for ( ii = 0; ii < n_rhs; ++ii )
-	{
-		for ( jj = 0; jj < 7; ++jj )
-			g_in[ii*7 + jj] = g[jj] + g_in[ii*7+jj]*perturb;
-		for ( jj = 0; jj < 50; ++jj )
-			bA_in[ii*50 + jj] = lbA[jj] + bA_in[ii*50+jj]*perturb;
-
-		nWSR = 100;
-		example.hotstart( &g_in[ii*7],0,0,&bA_in[ii*50],0, nWSR, 0 );
-
-		real_t xPer[7], yPer[7+50];
-		example.getPrimalSolution( xPer );
-		example.getDualSolution( yPer );
-
-		for ( jj = 0; jj < 7; ++jj )
-		{
-			d = getAbs (x_out[ii*7+jj]*perturb - (xPer[jj]-xOpt[jj]) );
-			if (nrm < d) nrm=d;
-		}
-		for ( jj = 0; jj < 7+50; ++jj )
-		{
-			d = getAbs (y_out[ii*(7+50)+jj]*perturb - (yPer[jj]-yOpt[jj]) );
-			if (nrm < d) nrm=d;
-		}
-	}
-	printf ("Maximum perturbation over all directions: %e\n", nrm);
-
-	/* // print feedback matrix
-	for (ii = 0; ii < n_rhs; ++ii)
-	{
-		printf ("x: ");
-		for (jj = 0; jj < 7; ++jj )
-			printf ("%8.2e ", x_out[ii*7+jj]);
-		printf (" y: ");
-		for (jj = 0; jj < 7+50; ++jj )
-			printf ("%8.2e ", y_out[ii*(7+50)+jj]);
-		printf("\n");
-	}
-*/
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/exampleLP.cpp b/extlibs/qpOASES-3.2.0/examples/exampleLP.cpp
deleted file mode 100644
index 5492e34..0000000
--- a/extlibs/qpOASES-3.2.0/examples/exampleLP.cpp
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/exampleLP.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Very simple example for solving a LP sequence using qpOASES.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function solving LPs. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first LP. */
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second LP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up QProblem object with zero Hessian matrix. */
-	QProblem example( 2,1,HST_ZERO );
-
-	Options options;
- 	//options.setToMPC();
-	example.setOptions( options );
-
-	/* Solve first LP. */
-	int_t nWSR = 10;
-	example.init( 0,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	/* Solve second LP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-
-	/* Get and print solution of second LP. */
-	real_t xOpt[2];
-	example.getPrimalSolution( xOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/qrecipe.cpp b/extlibs/qpOASES-3.2.0/examples/qrecipe.cpp
deleted file mode 100644
index 25aa2c7..0000000
--- a/extlibs/qpOASES-3.2.0/examples/qrecipe.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/qrecipe.cpp
- *	\author Andreas Potschka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- */
-
-
-
-#include <qpOASES.hpp>
-
-#include "qrecipe_data.hpp"
-
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	long i;
-	int_t nWSR;
-	real_t err, tic, toc;
-	real_t *x1 = new real_t[180];
-	real_t *y1 = new real_t[271];
-	real_t *x2 = new real_t[180];
-	real_t *y2 = new real_t[271];
-
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	SparseMatrix *A = new SparseMatrix(91, 180, A_ir, A_jc, A_val);
-
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	real_t* A_full = A->full();
-
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-	DenseMatrix *Ad = new DenseMatrix(91,180,180,A_full);
-
-	/* solve with dense matrices */
-	nWSR = 1000;
-	QProblem qrecipeD(180, 91);
-	tic = getCPUtime();
-	qrecipeD.init(Hd, g, Ad, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeD.getPrimalSolution(x1);
-	qrecipeD.getDualSolution(y1);
-
-	fprintf(stdFile, "Solved dense problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* solve with sparse matrices */
-	nWSR = 1000;
-	QProblem qrecipeS(180, 91);
-	tic = getCPUtime();
-	qrecipeS.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeS.getPrimalSolution(x2);
-	qrecipeS.getDualSolution(y2);
-
-	fprintf(stdFile, "Solved sparse problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* check distance of solutions */
-	err = 0.0;
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x2[i]) > err)
-			err = getAbs(x1[i] - x2[i]);
-	fprintf(stdFile, "Primal error: %9.2e\n", err);
-	err = 0.0;
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y2[i]) > err)
-			err = getAbs(y1[i] - y2[i]);
-	fprintf(stdFile, "Dual error: %9.2e  (might not be unique)\n", err);
-
-	delete H;
-	delete A;
-	delete[] H_full;
-	delete[] A_full;
-	delete Hd;
-	delete Ad;
-
-	delete[] y2;
-	delete[] x2;
-	delete[] y1;
-	delete[] x1;
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/qrecipeSchur.cpp b/extlibs/qpOASES-3.2.0/examples/qrecipeSchur.cpp
deleted file mode 100644
index 9e6c885..0000000
--- a/extlibs/qpOASES-3.2.0/examples/qrecipeSchur.cpp
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file examples/qrecipeSchur.cpp
- *	\author Dennis Janka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- *	Comparison between nullspace factorization (dense and sparse) and
- *	Schur complement approach.
- */
-
-
-
-#include <qpOASES.hpp>
-
-#include "qrecipe_data.hpp"
-
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	long i;
-	int_t nWSR;
-	real_t errP1, errP2, errP3, errD1, errD2, errD3, tic, toc;
-	real_t *x1 = new real_t[180];
-	real_t *y1 = new real_t[271];
-	real_t *x2 = new real_t[180];
-	real_t *y2 = new real_t[271];
-	real_t *x3 = new real_t[180];
-	real_t *y3 = new real_t[271];
-
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	SparseMatrix *A = new SparseMatrix(91, 180, A_ir, A_jc, A_val);
-
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	real_t* A_full = A->full();
-
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-	DenseMatrix *Ad = new DenseMatrix(91,180,180,A_full);
-
-	/* solve with dense matrices */
-	nWSR = 1000;
-	QProblem qrecipeD(180, 91);
-	tic = getCPUtime();
-	qrecipeD.init(Hd, g, Ad, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeD.getPrimalSolution(x1);
-	qrecipeD.getDualSolution(y1);
-
-	fprintf(stdFile, "Solved dense problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* solve with sparse matrices (nullspace factorization) */
-	nWSR = 1000;
-	QProblem qrecipeS(180, 91);
-	tic = getCPUtime();
-	qrecipeS.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeS.getPrimalSolution(x2);
-	qrecipeS.getDualSolution(y2);
-
-	fprintf(stdFile, "Solved sparse problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* solve with sparse matrices (Schur complement) */
-	nWSR = 1000;
-	SQProblemSchur qrecipeSchur(180, 91);
-	tic = getCPUtime();
-	qrecipeSchur.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeSchur.getPrimalSolution(x3);
-	qrecipeSchur.getDualSolution(y3);
-
-	fprintf(stdFile, "Solved sparse problem (Schur complement approach) in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* check distance of solutions */
-	errP1 = 0.0;
-	errP2 = 0.0;
-	errP3 = 0.0;
-	#ifndef SOLVER_NONE
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x2[i]) > errP1)
-			errP1 = getAbs(x1[i] - x2[i]);
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x3[i]) > errP2)
-			errP2 = getAbs(x1[i] - x3[i]);
-	for (i = 0; i < 180; i++)
-		if (getAbs(x2[i] - x3[i]) > errP3)
-			errP3 = getAbs(x2[i] - x3[i]);
-	#endif /* SOLVER_NONE */
-	fprintf(stdFile, "Primal error (dense and sparse): %9.2e\n", errP1);
-	fprintf(stdFile, "Primal error (dense and Schur):  %9.2e\n", errP2);
-	fprintf(stdFile, "Primal error (sparse and Schur): %9.2e\n", errP3);
-
-	errD1 = 0.0;
-	errD2 = 0.0;
-	errD3 = 0.0;
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y2[i]) > errD1)
-			errD1 = getAbs(y1[i] - y2[i]);
-	#ifndef SOLVER_NONE
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y3[i]) > errD2)
-			errD2 = getAbs(y1[i] - y3[i]);
-	for (i = 0; i < 271; i++)
-		if (getAbs(y2[i] - y3[i]) > errD3)
-			errD3 = getAbs(y2[i] - y3[i]);
-	#endif /* SOLVER_NONE */
-	fprintf(stdFile, "Dual error (dense and sparse): %9.2e  (might not be unique)\n", errD1);
-	fprintf(stdFile, "Dual error (dense and Schur):  %9.2e  (might not be unique)\n", errD2);
-	fprintf(stdFile, "Dual error (sparse and Schur): %9.2e  (might not be unique)\n", errD3);
-
-	delete H;
-	delete A;
-	delete[] H_full;
-	delete[] A_full;
-	delete Hd;
-	delete Ad;
-
-	delete[] y3;
-	delete[] x3;
-	delete[] y2;
-	delete[] x2;
-	delete[] y1;
-	delete[] x1;
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/examples/qrecipe_data.hpp b/extlibs/qpOASES-3.2.0/examples/qrecipe_data.hpp
deleted file mode 100644
index 3357b96..0000000
--- a/extlibs/qpOASES-3.2.0/examples/qrecipe_data.hpp
+++ /dev/null
@@ -1,401 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_qrecipe.cpp
- *	\author Andreas Potschka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- */
-
-
-USING_NAMESPACE_QPOASES
-
-
-
-const real_t Inf = INFTY;
-
-sparse_int_t H_jc[] = { 0,  4,  8, 12, 16, 20, 20, 20, 20, 20, 20,
-	                   24, 28, 32, 36, 40, 40, 40, 40, 40, 40,
-					   44, 48, 52, 56, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
-					   64, 68, 72, 76, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80 };
-
-sparse_int_t H_ir[] = {
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38,
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38,
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38,
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38};
-
-real_t H_val[] = {10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1,
-	1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 1,
-	10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 1, 10, 1,
-	1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10};
-
-sparse_int_t A_jc[] = {
-	  0,  10,  20,  30,  40,  50,  60,  70,  80,  90, 100, 110, 120,
-	130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270,
-	280, 290, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312,
-	313, 314, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 331,
-	333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361,
-	363, 365, 367, 369, 371, 373, 383, 393, 403, 405, 408, 410, 413, 415, 418,
-	420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448,
-	450, 452, 454, 456, 458, 460, 462, 472, 482, 492, 494, 497, 499, 502, 504,
-	507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535,
-	537, 539, 541, 543, 545, 547, 549, 551, 561, 571, 581, 583, 586, 588, 591,
-	593, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609,
-	610, 611, 612, 613, 614, 615, 616, 617, 618, 628, 638, 648, 650, 653, 655,
-	658, 660, 663};
-
-sparse_int_t A_ir[] = {0, 14, 35, 36, 71, 72, 85, 86, 87, 88, 1, 14, 35, 36, 71, 72, 85,
-	86, 87, 88, 2, 14, 35, 36, 71, 72, 85, 86, 87, 88, 3, 14, 35, 36, 71, 72,
-	85, 86, 87, 88, 4, 14, 35, 36, 71, 72, 85, 86, 87, 88, 5, 14, 35, 36, 71,
-	72, 85, 86, 87, 88, 6, 14, 35, 36, 71, 72, 85, 86, 87, 88, 7, 14, 35, 36,
-	71, 72, 85, 86, 87, 88, 8, 14, 35, 36, 71, 72, 85, 86, 87, 88, 9, 14, 35,
-	36, 71, 72, 85, 86, 87, 88, 0, 15, 37, 38, 69, 70, 79, 80, 81, 82, 1, 15,
-	37, 38, 69, 70, 79, 80, 81, 82, 2, 15, 37, 38, 69, 70, 79, 80, 81, 82, 3,
-	15, 37, 38, 69, 70, 79, 80, 81, 82, 4, 15, 37, 38, 69, 70, 79, 80, 81, 82,
-	5, 15, 37, 38, 69, 70, 79, 80, 81, 82, 6, 15, 37, 38, 69, 70, 79, 80, 81,
-	82, 7, 15, 37, 38, 69, 70, 79, 80, 81, 82, 8, 15, 37, 38, 69, 70, 79, 80,
-	81, 82, 9, 15, 37, 38, 69, 70, 79, 80, 81, 82, 0, 16, 39, 40, 67, 68, 73,
-	74, 75, 76, 1, 16, 39, 40, 67, 68, 73, 74, 75, 76, 2, 16, 39, 40, 67, 68,
-	73, 74, 75, 76, 3, 16, 39, 40, 67, 68, 73, 74, 75, 76, 4, 16, 39, 40, 67,
-	68, 73, 74, 75, 76, 5, 16, 39, 40, 67, 68, 73, 74, 75, 76, 6, 16, 39, 40,
-	67, 68, 73, 74, 75, 76, 7, 16, 39, 40, 67, 68, 73, 74, 75, 76, 8, 16, 39,
-	40, 67, 68, 73, 74, 75, 76, 9, 16, 39, 40, 67, 68, 73, 74, 75, 76, 10, 11,
-	12, 13, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 47, 48, 49, 50, 51,
-	52, 53, 54, 55, 56, 57, 47, 58, 48, 59, 49, 60, 50, 61, 51, 62, 52, 63, 53,
-	64, 54, 65, 55, 66, 46, 56, 45, 57, 47, 58, 48, 59, 49, 60, 50, 61, 51, 62,
-	52, 63, 53, 64, 54, 65, 55, 66, 46, 56, 45, 57, 10, 14, 71, 72, 85, 86, 87,
-	88, 89, 90, 11, 15, 69, 70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74,
-	75, 76, 77, 78, 35, 90, 36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78,
-	44, 58, 43, 59, 42, 60, 41, 61, 34, 62, 33, 63, 32, 64, 31, 65, 30, 66, 29,
-	46, 28, 45, 44, 58, 43, 59, 42, 60, 41, 61, 34, 62, 33, 63, 32, 64, 31, 65,
-	30, 66, 29, 46, 28, 45, 10, 14, 71, 72, 85, 86, 87, 88, 89, 90, 11, 15, 69,
-	70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74, 75, 76, 77, 78, 35, 90,
-	36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78, 27, 44, 26, 43, 25, 42,
-	24, 41, 23, 34, 22, 33, 21, 32, 20, 31, 19, 30, 18, 29, 17, 28, 27, 44, 26,
-	43, 25, 42, 24, 41, 23, 34, 22, 33, 21, 32, 20, 31, 19, 30, 18, 29, 17, 28,
-	10, 14, 71, 72, 85, 86, 87, 88, 89, 90, 11, 15, 69, 70, 79, 80, 81, 82, 83,
-	84, 12, 16, 67, 68, 73, 74, 75, 76, 77, 78, 35, 90, 36, 89, 90, 37, 84, 38,
-	83, 84, 39, 78, 40, 77, 78, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 27,
-	26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 10, 14, 71, 72, 85, 86, 87, 88, 89,
-	90, 11, 15, 69, 70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74, 75, 76,
-	77, 78, 35, 90, 36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78};
-
-real_t A_val[] = {
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.8678200000000004e+01,
- 9.3617050000000006e+01,  1.6000000000000000e+01,  8.1999999999999993e+00,
- 9.9000000000000000e+01,  8.0000000000000000e+01,  1.2000000000000000e+01,
- 9.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.0062830000000005e+01,  9.9224010000000007e+01,  1.0000000000000000e+02,
- 2.1100000000000001e+01,  1.0000000000000000e+02,  1.0000000000000000e+02,
- 1.1400000000000000e+02,  1.1680000000000000e+02, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.4697360000000003e+01,  8.3801220000000001e+01,
--8.1999999999999993e+00,  2.0000000000000000e+00,  9.0000000000000000e+01,
- 2.3999999999999999e+00, -1.2000000000000000e+01, -1.4800000000000001e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.9194209999999998e+01,
- 9.0175110000000004e+01,  4.3000000000000000e+01,  8.0000000000000000e+00,
- 1.0000000000000000e+02,  9.5000000000000000e+01,  9.0000000000000000e+00,
- 2.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.8568219999999997e+01,  8.5996200000000002e+01, -1.2500000000000000e+01,
- 1.0000000000000000e+00,  9.6500000000000000e+01,  4.0000000000000000e+00,
--1.8000000000000000e+01, -2.1899999999999999e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.2922240000000002e+01,  8.6963380000000001e+01,
- 6.5000000000000000e+01,  1.2500000000000000e+01,  1.0000000000000000e+02,
- 9.8000000000000000e+01,  4.9000000000000000e+01,  3.7000000000000000e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.2592740000000006e+01,
- 9.3147599999999997e+01, -1.2000000000000000e+01,  1.0000000000000000e+00,
- 9.6500000000000000e+01,  4.0000000000000000e+00, -1.8000000000000000e+01,
--2.1899999999999999e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.6506460000000004e+01,  7.8210250000000002e+01,  7.9000000000000000e+01,
- 1.2000000000000000e+01,  1.0000000000000000e+02,  9.5000000000000000e+01,
- 6.8000000000000000e+01,  6.1000000000000000e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.8357460000000003e+01,  9.4257840000000002e+01,
- 1.2500000000000000e+02,  6.1299999999999997e+01,  1.0000000000000000e+02,
- 1.0000000000000000e+02,  1.4500000000000000e+02,  1.4500000000000000e+02,
--1.0000000000000000e+00,  1.0000000000000000e+00,  9.0590469999999996e+01,
- 1.0582863000000000e+02,  6.2000000000000002e+00,  6.0000000000000000e+00,
- 9.7000000000000000e+01,  2.8500000000000000e+01,  4.0000000000000000e+00,
- 3.6000000000000001e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.8678200000000004e+01,  9.3617050000000006e+01,  1.6000000000000000e+01,
- 8.1999999999999993e+00,  9.9000000000000000e+01,  8.0000000000000000e+01,
- 1.2000000000000000e+01,  9.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.0062830000000005e+01,  9.9224010000000007e+01,
- 1.0000000000000000e+02,  2.1100000000000001e+01,  1.0000000000000000e+02,
- 1.0000000000000000e+02,  1.1400000000000000e+02,  1.1680000000000000e+02,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.4697360000000003e+01,
- 8.3801220000000001e+01, -8.1999999999999993e+00,  2.0000000000000000e+00,
- 9.0000000000000000e+01,  2.3999999999999999e+00, -1.2000000000000000e+01,
--1.4800000000000001e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.9194209999999998e+01,  9.0175110000000004e+01,  4.3000000000000000e+01,
- 8.0000000000000000e+00,  1.0000000000000000e+02,  9.5000000000000000e+01,
- 9.0000000000000000e+00,  2.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.8568219999999997e+01,  8.5996200000000002e+01,
--1.2500000000000000e+01,  1.0000000000000000e+00,  9.6500000000000000e+01,
- 4.0000000000000000e+00, -1.8000000000000000e+01, -2.1899999999999999e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.2922240000000002e+01,
- 8.6963380000000001e+01,  6.5000000000000000e+01,  1.2500000000000000e+01,
- 1.0000000000000000e+02,  9.8000000000000000e+01,  4.9000000000000000e+01,
- 3.7000000000000000e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.2592740000000006e+01,  9.3147599999999997e+01, -1.2000000000000000e+01,
- 1.0000000000000000e+00,  9.6500000000000000e+01,  4.0000000000000000e+00,
--1.8000000000000000e+01, -2.1899999999999999e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.6506460000000004e+01,  7.8210250000000002e+01,
- 7.9000000000000000e+01,  1.2000000000000000e+01,  1.0000000000000000e+02,
- 9.5000000000000000e+01,  6.8000000000000000e+01,  6.1000000000000000e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.8357460000000003e+01,
- 9.4257840000000002e+01,  1.2500000000000000e+02,  6.1299999999999997e+01,
- 1.0000000000000000e+02,  1.0000000000000000e+02,  1.4500000000000000e+02,
- 1.4500000000000000e+02, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 9.0590469999999996e+01,  1.0582863000000000e+02,  6.2000000000000002e+00,
- 6.0000000000000000e+00,  9.7000000000000000e+01,  2.8500000000000000e+01,
- 4.0000000000000000e+00,  3.6000000000000001e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.8678200000000004e+01,  9.3617050000000006e+01,
- 1.6000000000000000e+01,  8.1999999999999993e+00,  9.9000000000000000e+01,
- 8.0000000000000000e+01,  1.2000000000000000e+01,  9.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.0062830000000005e+01,
- 9.9224010000000007e+01,  1.0000000000000000e+02,  2.1100000000000001e+01,
- 1.0000000000000000e+02,  1.0000000000000000e+02,  1.1400000000000000e+02,
- 1.1680000000000000e+02, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.4697360000000003e+01,  8.3801220000000001e+01, -8.1999999999999993e+00,
- 2.0000000000000000e+00,  9.0000000000000000e+01,  2.3999999999999999e+00,
--1.2000000000000000e+01, -1.4800000000000001e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.9194209999999998e+01,  9.0175110000000004e+01,
- 4.3000000000000000e+01,  8.0000000000000000e+00,  1.0000000000000000e+02,
- 9.5000000000000000e+01,  9.0000000000000000e+00,  2.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.8568219999999997e+01,
- 8.5996200000000002e+01, -1.2500000000000000e+01,  1.0000000000000000e+00,
- 9.6500000000000000e+01,  4.0000000000000000e+00, -1.8000000000000000e+01,
--2.1899999999999999e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.2922240000000002e+01,  8.6963380000000001e+01,  6.5000000000000000e+01,
- 1.2500000000000000e+01,  1.0000000000000000e+02,  9.8000000000000000e+01,
- 4.9000000000000000e+01,  3.7000000000000000e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.2592740000000006e+01,  9.3147599999999997e+01,
--1.2000000000000000e+01,  1.0000000000000000e+00,  9.6500000000000000e+01,
- 4.0000000000000000e+00, -1.8000000000000000e+01, -2.1899999999999999e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.6506460000000004e+01,
- 7.8210250000000002e+01,  7.9000000000000000e+01,  1.2000000000000000e+01,
- 1.0000000000000000e+02,  9.5000000000000000e+01,  6.8000000000000000e+01,
- 6.1000000000000000e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.8357460000000003e+01,  9.4257840000000002e+01,  1.2500000000000000e+02,
- 6.1299999999999997e+01,  1.0000000000000000e+02,  1.0000000000000000e+02,
- 1.4500000000000000e+02,  1.4500000000000000e+02, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  9.0590469999999996e+01,  1.0582863000000000e+02,
- 6.2000000000000002e+00,  6.0000000000000000e+00,  9.7000000000000000e+01,
- 2.8500000000000000e+01,  4.0000000000000000e+00,  3.6000000000000001e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00, -1.2000000000000000e-01,
--3.8000000000000000e-01, -5.0000000000000000e-01,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--9.3000000000000000e+01, -8.9000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -8.9000000000000000e+01, -8.5000000000000000e+01,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.1000000000000000e+01,
--8.8000000000000000e+01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.3000000000000000e+01,
--8.9000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--8.9000000000000000e+01, -8.5000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.1000000000000000e+01, -8.8000000000000000e+01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.3000000000000000e+01, -8.9000000000000000e+01,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -8.9000000000000000e+01,
--8.5000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--9.1000000000000000e+01, -8.8000000000000000e+01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.3000000000000000e+01,
--8.9000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--8.9000000000000000e+01, -8.5000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.1000000000000000e+01, -8.8000000000000000e+01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01};
-
-real_t g[] = {+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00,
-	-2e+00, +0e+00, -2e+00, +0e+00, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03,
-	+2e-03, +1e-03, +2e-03, +2e-03, +2e-03, +0e+00, -2e-03, -2e-03, -2e-03,
-	-2e-03, -2e-03, -2e-03, -1e-03, -2e-03, -2e-03, -2e-03, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +2e-03,
-	+2e-03, +2e-03, +2e-03, +2e-03, +2e-03, +1e-03, +2e-03, +2e-03, +2e-03,
-	+0e+00, -2e-03, -2e-03, -2e-03, -2e-03, -2e-03, -2e-03, -1e-03, -2e-03,
-	-2e-03, -2e-03, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03,
-	+1e-03, +2e-03, +2e-03, +2e-03, +0e+00, -2e-03, -2e-03, -2e-03, -2e-03,
-	-2e-03, -2e-03, -1e-03, -2e-03, -2e-03, -2e-03, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +1e-01, +1e-01,
-	+1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +0e+00,
-	-1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01,
-	-1e-01, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00};
-
-real_t lb[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, -Inf, 0, -Inf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 5,
-	10, 5, 0, 10, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 10, 5, 10, 5, 0, 10, 0, 5, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 5, 10, 5, 0, 10, 0, 5, 0, 10, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-real_t ub[] = {Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, 0, 92, 39, 87, 29, 0, 20, 0, 28, 20, 71, Inf, 130, 45, 53, 55, 75,
-	112, 0, 73, 480, 154, 121, 50, 30, 77, 20, 0, 18, 0, 5, 20, 71, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, 130, 55, 93, 60, 75, 115, 0, 67,
-	480, 154, 121, 50, 20, 37, 15, 0, 15, 0, 8, 20, 71, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, 130, 55, 93, 60, 75, 105, 0, 67, 4980, 154, 110,
-	50, 20, 37, 15, 0, 25, 0, 8, 20, 71, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, 20, 20, 20, 20, 0, 20, 0, 20, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf};
-
-real_t lbA[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -Inf, -Inf,
-	-Inf, -Inf, -Inf, -Inf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0};
-
-real_t ubA[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf};
-
-long H_nnz = (long) sizeof(H_val) / (long) sizeof(real_t);
-long A_nnz = (long) sizeof(A_val) / (long) sizeof(real_t);
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES.hpp
deleted file mode 100644
index 9d51cf9..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-
-
-#if defined(__SINGLE_OBJECT__) || defined(__C_WRAPPER__)
-
-#include <MessageHandling.cpp>
-#include <Utils.cpp>
-#include <Indexlist.cpp>
-#include <SubjectTo.cpp>
-#include <Bounds.cpp>
-#include <Constraints.cpp>
-#include <BLASReplacement.cpp>
-#include <LAPACKReplacement.cpp>
-#include <Matrices.cpp>
-#include <Options.cpp>
-#include <QProblemB.cpp>
-#include <Flipper.cpp>
-#include <QProblem.cpp>
-#include <SQProblem.cpp>
-#include <SparseSolver.cpp>
-#include <SQProblemSchur.cpp>
-
-#ifndef __C_WRAPPER__
-#include <OQPinterface.cpp>
-#include <SolutionAnalysis.cpp>
-#endif
-
-#else /* default compilation mode */
-
-#include <qpOASES/QProblemB.hpp>
-#include <qpOASES/QProblem.hpp>
-#include <qpOASES/SQProblem.hpp>
-#include <qpOASES/SQProblemSchur.hpp>
-#include <qpOASES/extras/OQPinterface.hpp>
-#include <qpOASES/extras/SolutionAnalysis.hpp>
-
-#endif
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.hpp
deleted file mode 100644
index 312bc1a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.hpp
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Bounds.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the Bounds class designed to manage working sets of
- *	bounds within a QProblem.
- */
-
-
-#ifndef QPOASES_BOUNDS_HPP
-#define QPOASES_BOUNDS_HPP
-
-
-#include <qpOASES/SubjectTo.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Manages working sets of bounds (i.e. box constraints).
- *
- *	This class manages working sets of bounds (= box constraints) 
- *	by storing index sets and other status information.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- */
-class Bounds : public SubjectTo
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Bounds( );
-
-		/** Constructor which takes the number of bounds. */
-		Bounds(	int_t _n								/**< Number of bounds. */
-				);
-
-		/** Copy constructor (deep copy). */
-		Bounds(	const Bounds& rhs						/**< Rhs object. */
-				);
-
-		/** Destructor. */
-		virtual ~Bounds( );
-
-		/** Assignment operator (deep copy). */
-		Bounds& operator=(	const Bounds& rhs			/**< Rhs object. */
-							);
-
-
-		/** Initialises object with given number of bounds.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INVALID_ARGUMENTS */
-		returnValue init(	int_t _n = 0				/**< Number of bounds. */
-							);
-
-
-		/** Initially adds number of a new (i.e. not yet in the list) bound to
-		 *  given index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_BOUND_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS \n
-					RET_INVALID_ARGUMENTS */
-		returnValue setupBound(	int_t number,			/**< Number of new bound. */
-								SubjectToStatus _status	/**< Status of new bound. */
-								);
-
-		/** Initially adds all numbers of new (i.e. not yet in the list) bounds to
-		 *  to the index set of free bounds; the order depends on the SujectToType
-		 *  of each index.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_BOUND_FAILED */
-		returnValue setupAllFree( );
-
-		/** Initially adds all numbers of new (i.e. not yet in the list) bounds to
-		 *  to the index set of fixed bounds (on their lower bounds);
-		 *  the order depends on the SujectToType of each index.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_BOUND_FAILED */
-		returnValue setupAllLower( );
-
-		/** Initially adds all numbers of new (i.e. not yet in the list) bounds to
-		 *  to the index set of fixed bounds (on their upper bounds);
-		 *  the order depends on the SujectToType of each index.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_BOUND_FAILED */
-		returnValue setupAllUpper( );
-
-
-		/** Moves index of a bound from index list of fixed to that of free bounds.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_BOUND_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS */
-		returnValue moveFixedToFree(	int_t number			/**< Number of bound to be freed. */
-										);
-
-		/** Moves index of a bound from index list of free to that of fixed bounds.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_BOUND_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS */
-		returnValue moveFreeToFixed(	int_t number,			/**< Number of bound to be fixed. */
-										SubjectToStatus _status	/**< Status of bound to be fixed. */
-										);
-
-		/** Flip fixed bound.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_BOUND_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS */
-		returnValue flipFixed( int_t number );
-
-		/** Swaps the indices of two free bounds within the index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SWAPINDEX_FAILED */
-		returnValue swapFree(	int_t number1,					/**< Number of first constraint or bound. */
-								int_t number2					/**< Number of second constraint or bound. */
-								);
-
-
-		/** Returns number of variables.
-		 *	\return Number of variables. */
-		inline int_t getNV( ) const;
-
-		/** Returns number of implicitly fixed variables.
-		 *	\return Number of implicitly fixed variables. */
-		inline int_t getNFV( ) const;
-
-		/** Returns number of bounded (but possibly free) variables.
-		 *	\return Number of bounded (but possibly free) variables. */
-		inline int_t getNBV( ) const;
-
-		/** Returns number of unbounded variables.
-		 *	\return Number of unbounded variables. */
-		inline int_t getNUV( ) const;
-
-		/** Returns number of free variables.
-		 *	\return Number of free variables. */
-		inline int_t getNFR( ) const;
-
-		/** Returns number of fixed variables.
-		 *	\return Number of fixed variables. */
-		inline int_t getNFX( ) const;
-
-
-		/** Returns a pointer to free variables index list.
-		 *	\return Pointer to free variables index list. */
-		inline Indexlist* getFree( );
-
-		/** Returns a pointer to fixed variables index list.
-		 *	\return Pointer to fixed variables index list. */
-		inline Indexlist* getFixed( );
-
-
-		/** Shifts forward type and status of all bounds by a given
-		 *  offset. This offset has to lie within the range [0,n/2] and has to
-		 *  be an integer divisor of the total number of bounds n.
-		 *  Type and status of the first \<offset\> bounds is thrown away,
-		 *  type and status of the last \<offset\> bounds is doubled,
-		 *  e.g. for offset = 2: \n
-		 *  shift( {b1,b2,b3,b4,b5,b6} ) = {b3,b4,b5,b6,b5,b6}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_INVALID_ARGUMENTS \n
-		 			RET_SHIFTING_FAILED */
-		virtual returnValue shift(	int_t offset	/**< Shift offset within the range [0,n/2] and integer divisor of n. */
-									);
-
-		/** Rotates forward type and status of all bounds by a given
-		 *  offset. This offset has to lie within the range [0,n].
-		 *  Example for offset = 2: \n
-		 *  rotate( {b1,b2,b3,b4,b5,b6} ) = {b3,b4,b5,b6,b1,b2}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_ROTATING_FAILED */
-		virtual returnValue rotate(	int_t offset	/**< Rotation offset within the range [0,n]. */
-									);
-
-
-		/** Prints information on bounds object
-		 *  (in particular, lists of free and fixed bounds.
-		 * \return SUCCESSFUL_RETURN \n
-				   RET_INDEXLIST_CORRUPTED */
-		returnValue print( );
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-		
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Bounds& rhs	/**< Rhs object. */
-							);
-
-
-		/** Initially adds all numbers of new (i.e. not yet in the list) bounds to
-		 *  to the index set corresponding to the desired status;
-		 *  the order depends on the SujectToType of each index.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_BOUND_FAILED */
-		returnValue setupAll(	SubjectToStatus _status	/**< Desired initial status for all bounds. */
-								);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		Indexlist freee;		/**< Index list of free variables. */
-		Indexlist fixed;		/**< Index list of fixed variables. */
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/Bounds.ipp>
-
-#endif	/* QPOASES_BOUNDS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.ipp
deleted file mode 100644
index ebd0eeb..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Bounds.ipp
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Bounds.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the Bounds class designed
- *	to manage working sets of bounds within a QProblem.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-/*
- *	g e t N V
- */
-inline int_t Bounds::getNV( ) const
-{
- 	return n;
-}
-
-
-/*
- *	g e t N F V
- */
-inline int_t Bounds::getNFV( ) const
-{
- 	return getNumberOfType( ST_EQUALITY );
-}
-
-
-/*
- *	g e t N B V
- */
-inline int_t Bounds::getNBV( ) const
-{
- 	return getNumberOfType( ST_BOUNDED );
-}
-
-
-/*
- *	g e t N U V
- */
-inline int_t Bounds::getNUV( ) const
-{
-	return getNumberOfType( ST_UNBOUNDED );
-}
-
-
-/*
- *	g e t N F R
- */
-inline int_t Bounds::getNFR( ) const
-{
- 	return freee.getLength( );
-}
-
-
-/*
- *	g e t N F X
- */
-inline int_t Bounds::getNFX( ) const
-{
-	return fixed.getLength( );
-}
-
-
-/*
- *	g e t F r e e
- */
-inline Indexlist* Bounds::getFree( )
-{
-	return &freee;
-}
-
-
-/*
- *	g e t F i x e d
- */
-inline Indexlist* Bounds::getFixed( )
-{
-	return &fixed;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Constants.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Constants.hpp
deleted file mode 100644
index 214167c..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Constants.hpp
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Constants.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Definition of all global constants.
- */
-
-
-#ifndef QPOASES_CONSTANTS_HPP
-#define QPOASES_CONSTANTS_HPP
-
-
-#include <qpOASES/Types.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** Numerical value of machine precision (min eps, s.t. 1+eps > 1).
- *	Note: this value has to be positive! */
-#ifdef __USE_SINGLE_PRECISION__
-const real_t EPS = 1.193e-07f;
-#else
-const real_t EPS = 2.221e-16;
-#endif /* __USE_SINGLE_PRECISION__ */
-
-
-/** Numerical value of zero (for situations in which it would be
- *	unreasonable to compare with 0.0).
- *	Note: this value has to be positive! */
-const real_t ZERO = 1.0e-25;
-
-/** Numerical value of infinity (e.g. for non-existing bounds).
-	Note: this value has to be positive! */
-const real_t INFTY = 1.0e20;
-
-
-/** Maximum number of characters within a string.
- *	Note: this value should be at least 41! */
-const uint_t MAX_STRING_LENGTH = 160;
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_CONSTANTS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/ConstraintProduct.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/ConstraintProduct.hpp
deleted file mode 100644
index 4d70831..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/ConstraintProduct.hpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/ConstraintProduct.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2009-2015
- *
- *	Declaration of the ConstraintProduct class which allows to specify a
- *	user-defined function for evaluating the constraint product at the 
- *	current iterate to speed-up QP solution in case of a specially structured
- *	constraint matrix.
- */
-
-
-
-#ifndef QPOASES_CONSTRAINT_PRODUCT_HPP
-#define QPOASES_CONSTRAINT_PRODUCT_HPP
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Interface for specifying user-defined evaluations of constraint products.
- *
- *	A class which allows to specify a user-defined function for evaluating the 
- *	constraint product at the current iterate to speed-up QP solution in case 
- *	of a specially structured constraint matrix.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2009-2015
- */
-class ConstraintProduct
-{
-	public:
-		/** Default constructor. */
-		ConstraintProduct( ) {};
-
-		/** Copy constructor. */
-        ConstraintProduct(	const ConstraintProduct &/*toCopy*/	/**< Rhs object. */
-							) {};
-
-		/** Destructor. */
-		virtual ~ConstraintProduct( ) {};
-		
-		/** Assignment operator. */
-        ConstraintProduct &operator=(	const ConstraintProduct &/*toCopy*/	/**< Rhs object. */
-										)
-		{
-			return *this;
-		}
-
-		/** Evaluates the product of a given constraint with the current iterate.
-		 *	This function needs to be implemented in a derived class for the 
-		 *	user-defined constraint product function.
-		 *	\return 0:         successful \n
-					otherwise: not successful */
-		virtual int_t operator() (	int_t constrIndex,			/**< Number of constraint to be evaluated. */
-									const real_t* const x,		/**< Array containing current primal iterate. */
-									real_t* const constrValue	/**< Output: Scalar value of the evaluated constraint. */
-									) const = 0;
-};
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_CONSTRAINT_PRODUCT_HPP */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.hpp
deleted file mode 100644
index 3b43635..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.hpp
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Constraints.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the Constraints class designed to manage working sets of
- *	constraints within a QProblem.
- */
-
-
-#ifndef QPOASES_CONSTRAINTS_HPP
-#define QPOASES_CONSTRAINTS_HPP
-
-
-#include <qpOASES/SubjectTo.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Manages working sets of constraints.
- *
- *	This class manages working sets of constraints by storing
- *	index sets and other status information.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- */
-class Constraints : public SubjectTo
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Constraints( );
-
-		/** Constructor which takes the number of constraints. */
-		Constraints(	int_t _n						/**< Number of constraints. */
-						);
-
-		/** Copy constructor (deep copy). */
-		Constraints(	const Constraints& rhs			/**< Rhs object. */
-						);
-
-		/** Destructor. */
-		virtual ~Constraints( );
-
-		/** Assignment operator (deep copy). */
-		Constraints& operator=(	const Constraints& rhs	/**< Rhs object. */
-								);
-
-
-		/** Initialises object with given number of constraints.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INVALID_ARGUMENTS */
-		returnValue init(	int_t _n = 0				/**< Number of constraints. */
-							);
-
-
-		/** Initially adds number of a new (i.e. not yet in the list) constraint to
-		 *  a given index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_CONSTRAINT_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS \n
-					RET_INVALID_ARGUMENTS */
-		returnValue setupConstraint(	int_t number,			/**< Number of new constraint. */
-										SubjectToStatus _status	/**< Status of new constraint. */
-										);
-
-		/** Initially adds all enabled numbers of new (i.e. not yet in the list) constraints to
-		 *  to the index set of inactive constraints; the order depends on the SujectToType
-		 *  of each index. Only disabled constraints are added to index set of disabled constraints!
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_CONSTRAINT_FAILED */
-		returnValue setupAllInactive( );
-
-		/** Initially adds all enabled numbers of new (i.e. not yet in the list) constraints to
-		 *  to the index set of active constraints (on their lower bounds); the order depends on the SujectToType
-		 *  of each index. Only disabled constraints are added to index set of disabled constraints!
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_CONSTRAINT_FAILED */
-		returnValue setupAllLower( );
-
-		/** Initially adds all enabled numbers of new (i.e. not yet in the list) constraints to
-		 *  to the index set of active constraints (on their upper bounds); the order depends on the SujectToType
-		 *  of each index. Only disabled constraints are added to index set of disabled constraints!
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_CONSTRAINT_FAILED */
-		returnValue setupAllUpper( );
-
-
-		/** Moves index of a constraint from index list of active to that of inactive constraints.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_CONSTRAINT_FAILED */
-		returnValue moveActiveToInactive(	int_t number			/**< Number of constraint to become inactive. */
-											);
-
-		/** Moves index of a constraint from index list of inactive to that of active constraints.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_CONSTRAINT_FAILED */
-		returnValue moveInactiveToActive(	int_t number,			/**< Number of constraint to become active. */
-											SubjectToStatus _status	/**< Status of constraint to become active. */
-											);
-
-		/** Flip fixed constraint.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MOVING_CONSTRAINT_FAILED \n
-					RET_INDEX_OUT_OF_BOUNDS */
-		returnValue flipFixed( int_t number );
-
-
-		/** Returns the number of constraints.
-		 *	\return Number of constraints. */
-		inline int_t getNC( ) const;
-
-		/** Returns the number of implicit equality constraints.
-		 *	\return Number of implicit equality constraints. */
-		inline int_t getNEC( ) const;
-
-		/** Returns the number of "real" inequality constraints.
-		 *	\return Number of "real" inequality constraints. */
-		inline int_t getNIC( ) const;
-
-		/** Returns the number of unbounded constraints (i.e. without any bounds).
-		 *	\return Number of unbounded constraints (i.e. without any bounds). */
-		inline int_t getNUC( ) const;
-
-		/** Returns the number of active constraints.
-		 *	\return Number of active constraints. */
-		inline int_t getNAC( ) const;
-
-		/** Returns the number of inactive constraints.
-		 *	\return Number of inactive constraints. */
-		inline int_t getNIAC( ) const;
-
-
-		/** Returns a pointer to active constraints index list.
-		 *	\return Pointer to active constraints index list. */
-		inline Indexlist* getActive( );
-
-		/** Returns a pointer to inactive constraints index list.
-		 *	\return Pointer to inactive constraints index list. */
-		inline Indexlist* getInactive( );
-
-
-		/** Shifts forward type and status of all constraints by a given
-		 *  offset. This offset has to lie within the range [0,n/2] and has to
-		 *  be an integer divisor of the total number of constraints n.
-		 *  Type and status of the first \<offset\> constraints  is thrown away,
-		 *  type and status of the last \<offset\> constraints is doubled,
-		 *  e.g. for offset = 2: \n
-		 *  shift( {c1,c2,c3,c4,c5,c6} ) = {c3,c4,c5,c6,c5,c6}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_INVALID_ARGUMENTS \n
-		 			RET_SHIFTING_FAILED */
-		virtual returnValue shift(	int_t offset	/**< Shift offset within the range [0,n/2] and integer divisor of n. */
-									);
-
-		/** Rotates forward type and status of all constraints by a given
-		 *  offset. This offset has to lie within the range [0,n].
-		 *  Example for offset = 2: \n
-		 *  rotate( {c1,c2,c3,c4,c5,c6} ) = {c3,c4,c5,c6,c1,c2}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_ROTATING_FAILED */
-		virtual returnValue rotate(	int_t offset	/**< Rotation offset within the range [0,n]. */
-									);
-
-
-		/** Prints information on constraints object
-		 *  (in particular, lists of inactive and active constraints.
-		 * \return SUCCESSFUL_RETURN \n
-				   RET_INDEXLIST_CORRUPTED */
-		returnValue print( );
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-		
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Constraints& rhs	/**< Rhs object. */
-							);
-
-
-		/** Initially adds all numbers of new (i.e. not yet in the list) bounds to
-		 *  to the index set corresponding to the desired status;
-		 *  the order depends on the SujectToType of each index.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SETUP_CONSTRAINT_FAILED */
-		returnValue setupAll(	SubjectToStatus _status	/**< Desired initial status for all bounds. */
-								);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		Indexlist active;		/**< Index list of active constraints. */
-		Indexlist inactive;		/**< Index list of inactive constraints. */
-};
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/Constraints.ipp>
-
-#endif	/* QPOASES_CONSTRAINTS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.ipp
deleted file mode 100644
index ca7035a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Constraints.ipp
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Constraints.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of inlined member functions of the Constraints class designed
- *	to manage working sets of constraints within a QProblem.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	g e t N C
- */
-inline int_t Constraints::getNC( ) const
-{
- 	return n;
-}
-
-
-/*
- *	g e t N E C
- */
-inline int_t Constraints::getNEC( ) const
-{
-	return getNumberOfType( ST_EQUALITY );
-}
-
-
-/*
- *	g e t N I C
- */
-inline int_t Constraints::getNIC( ) const
-{
- 	return getNumberOfType( ST_BOUNDED );
-}
-
-
-/*
- *	g e t N U C
- */
-inline int_t Constraints::getNUC( ) const
-{
- 	return getNumberOfType( ST_UNBOUNDED );
-}
-
-
-/*
- *	g e t N A C
- */
-inline int_t Constraints::getNAC( ) const
-{
- 	return active.getLength( );
-}
-
-
-/*
- *	g e t N I A C
- */
-inline int_t Constraints::getNIAC( ) const
-{
-	return inactive.getLength( );
-}
-
-
-
-/*
- *	g e t A c t i v e
- */
-inline Indexlist* Constraints::getActive( )
-{
-	return &active;
-}
-
-
-/*
- *	g e t I n a c t i v e
- */
-inline Indexlist* Constraints::getInactive( )
-{
-	return &inactive;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Flipper.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Flipper.hpp
deleted file mode 100644
index a97c4d1..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Flipper.hpp
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Flipper.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the Options class designed to manage user-specified
- *	options for solving a QProblem.
- */
-
-
-#ifndef QPOASES_FLIPPER_HPP
-#define QPOASES_FLIPPER_HPP
-
-
-#include <qpOASES/Bounds.hpp>
-#include <qpOASES/Constraints.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Auxiliary class for storing a copy of the current matrix factorisations.
- *
- *	This auxiliary class stores a copy of the current matrix factorisations. It
- *	is used by the classe QProblemB and QProblem in case flipping bounds are enabled.
- *
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-class Flipper
-{
-	friend class QProblemB;
-	friend class QProblem;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Flipper( );
-
-		/** Constructor which takes the number of bounds and constraints. */
-		Flipper(	uint_t _nV,			/**< Number of bounds. */
-					uint_t _nC = 0		/**< Number of constraints. */
-					);
-
-		/** Copy constructor (deep copy). */
-		Flipper(	const Flipper& rhs			/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		~Flipper( );
-
-		/** Assignment operator (deep copy). */
-		Flipper& operator=(	const Flipper& rhs	/**< Rhs object. */
-							);
-
-
-		/** Initialises object with given number of bounds and constraints.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INVALID_ARGUMENTS */
-		returnValue init(	uint_t _nV = 0,		/**< Number of bounds. */
-							uint_t _nC = 0		/**< Number of constraints. */
-							);
-
-
-		/** Copies current values to non-null arguments (assumed to be allocated with consistent size).
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue get(	Bounds* const _bounds,					/**< Pointer to new bounds. */
-							real_t* const R,						/**< New matrix R. */
-							Constraints* const _constraints = 0,	/**< Pointer to new constraints. */
-							real_t* const _Q = 0,					/**< New matrix Q. */
-							real_t* const _T = 0					/**< New matrix T. */
-							) const;
-
-		/** Assigns new values to non-null arguments.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue set(	const Bounds* const _bounds,				/**< Pointer to new bounds. */
-							const real_t* const _R,						/**< New matrix R. */
-							const Constraints* const _constraints = 0,	/**< Pointer to new constraints. */
-							const real_t* const _Q = 0,					/**< New matrix Q. */
-							const real_t* const _T = 0					/**< New matrix T. */
-							);
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-		
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Flipper& rhs	/**< Rhs object. */
-							);
-
-		/** Returns dimension of matrix T.
-		 *  \return Dimension of matrix T. */
-		uint_t getDimT( ) const;
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		uint_t nV;						/**< Number of variables. */
-		uint_t nC;						/**< Number of constraints. */
-
-		Bounds      bounds;				/**< Data structure for problem's bounds. */
-		Constraints constraints;		/**< Data structure for problem's constraints. */
-
-		real_t* R;						/**< Cholesky factor of H (i.e. H = R^T*R). */
-		real_t* Q;						/**< Orthonormal quadratic matrix, A = [0 T]*Q'. */
-		real_t* T;						/**< Reverse triangular matrix, A = [0 T]*Q'. */
-};
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_FLIPPER_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.hpp
deleted file mode 100644
index 62ff915..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.hpp
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Indexlist.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the Indexlist class designed to manage index lists of
- *	constraints and bounds within a SubjectTo object.
- */
-
-
-#ifndef QPOASES_INDEXLIST_HPP
-#define QPOASES_INDEXLIST_HPP
-
-
-#include <qpOASES/Utils.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Stores and manages index lists.
- *
- *	This class manages index lists of active/inactive bounds/constraints.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- */
-class Indexlist
-{
-	/*
-	 *  FRIENDS
-	 */
-	friend class DenseMatrix;
-	friend class SymDenseMat;
-	friend class SparseMatrix;
-	friend class SparseMatrixRow;
-	friend class SymSparseMat;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Indexlist( );
-
-		/** Constructor which takes the desired physical length of the index list. */
-		Indexlist(	int_t n	/**< Physical length of index list. */
-					);
-
-		/** Copy constructor (deep copy). */
-		Indexlist(	const Indexlist& rhs	/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		~Indexlist( );
-
-		/** Assingment operator (deep copy). */
-		Indexlist& operator=(	const Indexlist& rhs	/**< Rhs object. */
-								);
-
-
-		/** Initialises index list of desired physical length.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INVALID_ARGUMENTS */
-		returnValue init(	int_t n = 0	/**< Physical length of index list. */
-							);
-
-
-		/** Creates an array of all numbers within the index set in correct order.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEXLIST_CORRUPTED */
-		returnValue	getNumberArray(	int_t** const numberarray	/**< Output: Array of numbers (NULL on error). */
-									) const;
-
-		/** Creates an array of all numbers within the index set in correct order.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INDEXLIST_CORRUPTED */
-		returnValue	getISortArray(	int_t** const iSortArray	/**< Output: iSort Array. */
-									) const;
-
-
-		/** Determines the index within the index list at which a given number is stored.
-		 *	\return >= 0: Index of given number. \n
-		 			-1: Number not found. */
-		int_t getIndex(	int_t givennumber	/**< Number whose index shall be determined. */
-						) const;
-
-		/** Returns the number stored at a given physical index.
-		 *	\return >= 0: Number stored at given physical index. \n
-		 			-RET_INDEXLIST_OUTOFBOUNDS */
-		int_t getNumber(	int_t physicalindex	/**< Physical index of the number to be returned. */
-							) const;
-
-
-		/** Returns the current length of the index list.
-		 *	\return Current length of the index list. */
-		inline int_t getLength( ) const;
-
-		/** Returns last number within the index list.
-		 *	\return Last number within the index list. */
-		inline int_t getLastNumber( ) const;
-
-
-		/** Adds number to index list.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEXLIST_MUST_BE_REORDERD \n
-		 			RET_INDEXLIST_EXCEEDS_MAX_LENGTH */
-		returnValue addNumber(	int_t addnumber			/**< Number to be added. */
-								);
-
-		/** Removes number from index list.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue removeNumber(	int_t removenumber	/**< Number to be removed. */
-									);
-
-		/** Swaps two numbers within index list.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue swapNumbers(	int_t number1,		/**< First number for swapping. */
-									int_t number2			/**< Second number for swapping. */
-									);
-
-		/** Determines if a given number is contained in the index set.
-		 *	\return BT_TRUE iff number is contain in the index set */
-		inline BooleanType isMember(	int_t _number		/**< Number to be tested for membership. */
-										) const;
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Indexlist& rhs	/**< Rhs object. */
-							);
-
-		/** Find first index j between -1 and length in sorted list of indices
-		 *  iSort such that numbers[iSort[j]] <= i < numbers[iSort[j+1]]. Uses
-		 *  bisection.
-		 *  \return j. */
-		int_t findInsert(	int_t i
-							) const;
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		int_t* number;			/**< Array to store numbers of constraints or bounds. */
-		int_t* iSort;			/**< Index list to sort vector \a number */
-
-		int_t	length;			/**< Length of index list. */
-		int_t	first;			/**< Physical index of first element. */
-		int_t	last;			/**< Physical index of last element. */
-		int_t	lastusedindex;	/**< Physical index of last entry in index list. */
-		int_t	physicallength;	/**< Physical length of index list. */
-};
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/Indexlist.ipp>
-
-#endif	/* QPOASES_INDEXLIST_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.ipp
deleted file mode 100644
index f1bd9cf..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Indexlist.ipp
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Indexlist.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the Indexlist class designed
- *	to manage index lists of constraints and bounds within a QProblem_SubjectTo.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	g e t N u m b e r
- */
-inline int_t Indexlist::getNumber( int_t physicalindex ) const
-{
-	/* consistency check */
-	if ( ( physicalindex < 0 ) || ( physicalindex > length ) )
-		return -RET_INDEXLIST_OUTOFBOUNDS;
-
-	return number[physicalindex];
-}
-
-
-/*
- *	g e t L e n g t h
- */
-inline int_t Indexlist::getLength( ) const
-{
-	return length;
-}
-
-
-/*
- *	g e t L a s t N u m b e r
- */
-inline int_t Indexlist::getLastNumber( ) const
-{
-	return number[length-1];
-}
-
-
-/*
- *	g e t L a s t N u m b e r
- */
-inline BooleanType Indexlist::isMember( int_t _number ) const
-{
-	if ( getIndex( _number ) >= 0 )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Matrices.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Matrices.hpp
deleted file mode 100644
index ae06407..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Matrices.hpp
+++ /dev/null
@@ -1,1009 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Matrices.hpp
- *	\author Andreas Potschka, Hans Joachim Ferreau, Christian Kirches
- *	\version 3.2
- *	\date 2009-2015
- *
- *  Various matrix classes: Abstract base matrix class, dense and sparse matrices,
- *  including symmetry exploiting specializations.
- */
-
-
-
-#ifndef QPOASES_MATRICES_HPP
-#define QPOASES_MATRICES_HPP
-
-
-#include <qpOASES/Utils.hpp>
-#include <qpOASES/Indexlist.hpp>
-
-
-#ifdef __USE_SINGLE_PRECISION__
-
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define GEMM sgemm_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define SYR ssyr_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define SYR2 ssyr2_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define POTRF spotrf_
-
-#else
-
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define GEMM dgemm_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define SYR  dsyr_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define SYR2 dsyr2_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define POTRF dpotrf_
-
-#endif /* __USE_SINGLE_PRECISION__ */
-
-
-extern "C"
-{
-	/** Performs one of the matrix-matrix operation in double precision. */
-	void dgemm_ ( const char*, const char*, const unsigned long*, const unsigned long*, const unsigned long*,
-			const double*, const double*, const unsigned long*, const double*, const unsigned long*,
-			const double*, double*, const unsigned long* );
-	/** Performs one of the matrix-matrix operation in single precision. */
-	void sgemm_ ( const char*, const char*, const unsigned long*, const unsigned long*, const unsigned long*,
-			const float*, const float*, const unsigned long*, const float*, const unsigned long*,
-			const float*, float*, const unsigned long* );
-
-	/** Performs a symmetric rank 1 operation in double precision. */
-	void dsyr_ ( const char *, const unsigned long *, const double *, const double *,
-				 const unsigned long *, double *, const unsigned long *);
-	/** Performs a symmetric rank 1 operation in single precision. */
-	void ssyr_ ( const char *, const unsigned long *, const float *, const float *,
-				 const unsigned long *, float *, const unsigned long *);
-
-	/** Performs a symmetric rank 2 operation in double precision. */
-	void dsyr2_ ( const char *, const unsigned long *, const double *, const double *,
-				  const unsigned long *, const double *, const unsigned long *, double *, const unsigned long *);
-	/** Performs a symmetric rank 2 operation in single precision. */
-	void ssyr2_ ( const char *, const unsigned long *, const float *, const float *,
-				  const unsigned long *, const float *, const unsigned long *, float *, const unsigned long *);
-
-	/** Calculates the Cholesky factorization of a real symmetric positive definite matrix in double precision. */
-	void dpotrf_ ( const char *, const unsigned long *, double *, const unsigned long *, long * );
-	/** Calculates the Cholesky factorization of a real symmetric positive definite matrix in single precision. */
-	void spotrf_ ( const char *, const unsigned long *, float *, const unsigned long *, long * );
-}
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-	/**
- *	\brief Abstract base class for interfacing tailored matrix-vector operations.
- *
- *	Abstract base matrix class. Supplies interface to matrix vector
- *  products, including products with submatrices given by (ordered) working set
- *  index lists (see \a SubjectTo).
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class Matrix
-{
-	public:
-		/** Default constructor. */
-		Matrix( ) { doNotFreeMemory(); };
-
-		/** Destructor. */
-		virtual ~Matrix( ) { };
-
-		/** Frees all internal memory. */
-		virtual void free( ) = 0;
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix* duplicate( ) const = 0;
-
-		/** Returns i-th diagonal entry.
-		 *	\return i-th diagonal entry */
-		virtual real_t diag(	int_t i			/**< Index. */
-								) const = 0;
-
-		/** Checks whether matrix is square and diagonal.
-		 *	\return BT_TRUE  iff matrix is square and diagonal; \n
-		 *	        BT_FALSE otherwise. */
-		virtual BooleanType isDiag( ) const = 0;
-
-        /** Get the N-norm of the matrix
-         *  \return N-norm of the matrix
-         */
-        virtual real_t getNorm(	int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-								) const = 0;
-
-        /** Get the N-norm of a row
-         *  \return N-norm of row \a rNum
-         */
-        virtual real_t getRowNorm(	int_t rNum,		/**< Row number. */
-									int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-									) const = 0;
-
-		/** Retrieve indexed entries of matrix row multiplied by alpha.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue getRow(	int_t rNum,						/**< Row number. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									real_t alpha,					/**< Scalar factor. */
-									real_t *row						/**< Output row vector. */
-									) const = 0;
-
-		/** Retrieve indexed entries of matrix column multiplied by alpha.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue getCol(	int_t cNum,						/**< Column number. */
-									const Indexlist* const irows,	/**< Index list specifying rows. */
-									real_t alpha,					/**< Scalar factor. */
-									real_t *col						/**< Output column vector. */
-									) const = 0;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				const Indexlist* const irows,	/**< Index list specifying rows. */
-				const Indexlist* const icols,	/**< Index list specifying columns. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.  This version retrieves one
-		 *  column.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				const Indexlist* const irows,	/**< Index list specifying rows. */
-				int_t idx_icol,					/**< Index list specifying columns. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.  This version retrieves one row.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				int_t idx_row,					/**< Row number. */
-				const Indexlist* const icols,	/**< Index list specifying columns. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				int_t irowsLength,				/**< Number of rows. */
-				const int_t* const irowsNumber, /**< Array with row numbers. */
-				int_t icolsLength,				/**< Number of columns. */
-				const int_t* const icolsNumber, /**< Array with column numbers. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const = 0;
-
-		/** Evaluate Y=alpha*A*X + beta*Y.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue times (	int_t xN,				/**< Number of vectors to multiply. */
-									real_t alpha,			/**< Scalar factor for matrix vector product. */
-									const real_t *x,		/**< Input vector to be multiplied. */
-									int_t xLD,				/**< Leading dimension of input x. */
-									real_t beta,			/**< Scalar factor for y. */
-									real_t *y,				/**< Output vector of results. */
-									int_t yLD				/**< Leading dimension of output y. */
-									) const = 0;
-
-		/** Evaluate Y=alpha*A'*X + beta*Y.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue transTimes (	int_t xN,			/**< Number of vectors to multiply. */
-											real_t alpha,		/**< Scalar factor for matrix vector product. */
-											const real_t *x,	/**< Input vector to be multiplied. */
-											int_t xLD,			/**< Leading dimension of input x. */
-											real_t beta,		/**< Scalar factor for y. */
-											real_t *y,			/**< Output vector of results. */
-											int_t yLD			/**< Leading dimension of output y. */
-											) const = 0;
-
-		/** Evaluate matrix vector product with submatrix given by Indexlist.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue times (	const Indexlist* const irows,	/**< Index list specifying rows. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									int_t xN,						/**< Number of vectors to multiply. */
-									real_t alpha,					/**< Scalar factor for matrix vector product. */
-									const real_t *x,				/**< Input vector to be multiplied. */
-									int_t xLD,						/**< Leading dimension of input x. */
-									real_t beta,					/**< Scalar factor for y. */
-									real_t *y,						/**< Output vector of results. */
-									int_t yLD,						/**< Leading dimension of output y. */
-									BooleanType yCompr = BT_TRUE	/**< Compressed storage for y. */
-									) const = 0;
-
-		/** Evaluate matrix transpose vector product.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue transTimes (	const Indexlist* const irows,	/**< Index list specifying rows. */
-											const Indexlist* const icols,	/**< Index list specifying columns. */
-											int_t xN,						/**< Number of vectors to multiply. */
-											real_t alpha,					/**< Scalar factor for matrix vector product. */
-											const real_t *x,				/**< Input vector to be multiplied. */
-											int_t xLD,						/**< Leading dimension of input x. */
-											real_t beta,					/**< Scalar factor for y. */
-											real_t *y,						/**< Output vector of results. */
-											int_t yLD						/**< Leading dimension of output y. */
-											) const = 0;
-
-		/** Adds given offset to diagonal of matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_NO_DIAGONAL_AVAILABLE */
-		virtual returnValue addToDiag(	real_t alpha		/**< Diagonal offset. */
-										) = 0;
-
-		/** Allocates and creates dense matrix array in row major format.
-		 *
-		 *  Note: Calling function has to free allocated memory!
-		 *
-		 *  \return Pointer to matrix array. 
-		 */
-		virtual real_t* full() const = 0;
-
-
-		/** Prints matrix to screen.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue print(	const char* name = 0	/** Name of matrix. */
-									) const = 0;
-
-		/** Write matrix to file.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue writeToFile( FILE* output_file, const char* prefix ) const = 0;
-
-		/** Returns whether internal memory needs to be de-allocated.
-		 *	\return BT_TRUE  iff internal memory needs to be de-allocated, \n
-		 			BT_FALSE otherwise */
-		BooleanType needToFreeMemory( ) const { return freeMemory; };
-
-		/** Enables de-allocation of internal memory. */
-		void doFreeMemory( ) { freeMemory = BT_TRUE; };
-
-		/** Disables de-allocation of internal memory. */
-		void doNotFreeMemory( ) { freeMemory = BT_FALSE; };
-
-
-	protected:
-			BooleanType freeMemory;				/**< Indicating whether internal memory needs to be de-allocated. */
-
-};
-
-
-/**
- *	\brief Abstract base class for interfacing matrix-vector operations tailored to symmetric matrices.
- *
- *	Abstract base class for symmetric matrices. Extends Matrix interface with
- *  bilinear form evaluation.
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class SymmetricMatrix : public virtual Matrix
-{
-	public:
-		/** Default constructor. */
-		SymmetricMatrix( ) { };
-
-		/** Destructor. */
-		virtual ~SymmetricMatrix( ) { };
-
-		/** Returns a deep-copy of the SymmetricMatrix object.
-		 *	\return Deep-copy of SymmetricMatrix object */
-		virtual SymmetricMatrix* duplicateSym( ) const = 0;
-
-
-		/** Compute bilinear form y = x'*H*x using submatrix given by index list.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue bilinear(	const Indexlist* const icols,	/**< Index list specifying columns of x. */
-										int_t xN,						/**< Number of vectors to multiply. */
-										const real_t *x,				/**< Input vector to be multiplied (uncompressed). */
-										int_t xLD,						/**< Leading dimension of input x. */
-										real_t *y,						/**< Output vector of results (compressed). */
-										int_t yLD						/**< Leading dimension of output y. */
-										) const = 0;
-
-};
-
-
-/**
- *	\brief Interfaces matrix-vector operations tailored to general dense matrices.
- *
- *	Dense matrix class (row major format).
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class DenseMatrix : public virtual Matrix
-{
-	public:
-		/** Default constructor. */
-		DenseMatrix( ) : nRows(0), nCols(0), leaDim(0), val(0) { };
-
-		/** Constructor from vector of values.
-		 *  Caution: Data pointer must be valid throughout lifetime
-		 */
-		DenseMatrix(	int_t m,		/**< Number of rows. */
-						int_t n,		/**< Number of columns. */
-						int_t lD,		/**< Leading dimension. */
-						real_t *v		/**< Values. */
-						) : nRows(m), nCols(n), leaDim(lD), val(v) {}
-
-
-		/** Destructor. */
-		virtual ~DenseMatrix( );
-
-		/** Frees all internal memory. */
-		virtual void free( );
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix *duplicate( ) const;
-
-		/** Returns i-th diagonal entry.
-		 *	\return i-th diagonal entry */
-		virtual real_t diag(	int_t i			/**< Index. */
-								) const;
-
-		/** Checks whether matrix is square and diagonal.
-		 *	\return BT_TRUE  iff matrix is square and diagonal; \n
-		 *	        BT_FALSE otherwise. */
-		virtual BooleanType isDiag( ) const;
-
-        /** Get the N-norm of the matrix
-         *  \return N-norm of the matrix
-         */
-        virtual real_t getNorm(	int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-								) const;
-		
-        /** Get the N-norm of a row
-         *  \return N-norm of row \a rNum
-         */
-        virtual real_t getRowNorm(	int_t rNum,		/**< Row number. */
-									int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-									) const;
-
-        /** Retrieve indexed entries of matrix row multiplied by alpha.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getRow(	int_t rNum,						/**< Row number. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									real_t alpha,					/**< Scalar factor. */
-									real_t *row						/**< Output row vector. */
-									) const;
-
-		/** Retrieve indexed entries of matrix column multiplied by alpha.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getCol(
-				int_t cNum,						/**< Column number. */
-				const Indexlist* const irows,	/**< Index list specifying rows. */
-				real_t alpha,					/**< Scalar factor. */
-				real_t *col						/**< Output column vector. */
-				) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				int_t irowsLength,				/**< Number of rows. */
-				const int_t* const irowsNumber, /**< Array with row numbers. */
-				int_t icolsLength,				/**< Number of columns. */
-				const int_t* const icolsNumber, /**< Array with column numbers. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-
-		/** Evaluate Y=alpha*A*X + beta*Y.
-		 *  \return SUCCESSFUL_RETURN. */
-		virtual returnValue times(	int_t xN,				/**< Number of vectors to multiply. */
-									real_t alpha,			/**< Scalar factor for matrix vector product. */
-									const real_t *x,		/**< Input vector to be multiplied. */
-									int_t xLD,				/**< Leading dimension of input x. */
-									real_t beta,			/**< Scalar factor for y. */
-									real_t *y,				/**< Output vector of results. */
-									int_t yLD				/**< Leading dimension of output y. */
-									) const;
-
-		/** Evaluate Y=alpha*A'*X + beta*Y.
-		 *  \return SUCCESSFUL_RETURN. */
-		virtual returnValue transTimes(	int_t xN,			/**< Number of vectors to multiply. */
-										real_t alpha,		/**< Scalar factor for matrix vector product. */
-										const real_t *x,	/**< Input vector to be multiplied. */
-										int_t xLD,			/**< Leading dimension of input x. */
-										real_t beta,		/**< Scalar factor for y. */
-										real_t *y,			/**< Output vector of results. */
-										int_t yLD			/**< Leading dimension of output y. */
-										) const;
-
-		/** Evaluate matrix vector product with submatrix given by Indexlist.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue times(	const Indexlist* const irows,	/**< Index list specifying rows. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									int_t xN,						/**< Number of vectors to multiply. */
-									real_t alpha,					/**< Scalar factor for matrix vector product. */
-									const real_t *x,				/**< Input vector to be multiplied. */
-									int_t xLD,						/**< Leading dimension of input x. */
-									real_t beta,					/**< Scalar factor for y. */
-									real_t *y,						/**< Output vector of results. */
-									int_t yLD,						/**< Leading dimension of output y. */
-									BooleanType yCompr = BT_TRUE	/**< Compressed storage for y. */
-									) const;
-
-		/** Evaluate matrix transpose vector product.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue transTimes(	const Indexlist* const irows,	/**< Index list specifying rows. */
-										const Indexlist* const icols,	/**< Index list specifying columns. */
-										int_t xN,						/**< Number of vectors to multiply. */
-										real_t alpha,					/**< Scalar factor for matrix vector product. */
-										const real_t *x,				/**< Input vector to be multiplied. */
-										int_t xLD,						/**< Leading dimension of input x. */
-										real_t beta,					/**< Scalar factor for y. */
-										real_t *y,						/**< Output vector of results. */
-										int_t yLD						/**< Leading dimension of output y. */
-										) const;
-
-		/** Adds given offset to diagonal of matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_NO_DIAGONAL_AVAILABLE */
-		virtual returnValue addToDiag(	real_t alpha		/**< Diagonal offset. */
-										);
-
-
-		/** Allocates and creates dense matrix array in row major format.
-		 *
-		 *  Note: Calling function has to free allocated memory!
-		 *
-		 *  \return Pointer to matrix array. 
-		 */
-		virtual real_t* full() const;
-
-
-		/** Prints matrix to screen.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue print( 	const char* name = 0	/** Name of matrix. */
-									) const;
-
-		/** Write matrix to file.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue writeToFile( FILE* output_file, const char* prefix ) const;
-
-	protected:
-		int_t nRows;		/**< Number of rows. */
-		int_t nCols;		/**< Number of columns. */
-		int_t leaDim;		/**< Leading dimension. */
-		real_t *val;		/**< Vector of entries. */
-};
-
-
-/**
- *	\brief Interfaces matrix-vector operations tailored to symmetric dense matrices.
- *
- *	Symmetric dense matrix class.
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class SymDenseMat : public DenseMatrix, public SymmetricMatrix
-{
-	public:
-		/** Default constructor. */
-		SymDenseMat() : DenseMatrix() { };
-
-		/** Constructor from vector of values. */
-		SymDenseMat(	int_t m,		/**< Number of rows. */
-						int_t n,		/**< Number of columns. */
-						int_t lD,		/**< Leading dimension. */
-						real_t *v		/**< Values. */
-						) : DenseMatrix(m, n, lD, v) { };
-
-		/** Destructor. */
-		virtual ~SymDenseMat() { };
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix *duplicate( ) const;
-
-		/** Returns a deep-copy of the SymmetricMatrix object.
-		 *	\return Deep-copy of SymmetricMatrix object */
-		virtual SymmetricMatrix* duplicateSym( ) const;
-
-
-		/** Compute bilinear form y = x'*H*x using submatrix given by index list.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue bilinear(	const Indexlist* const icols,	/**< Index list specifying columns of x. */
-										int_t xN,						/**< Number of vectors to multiply. */
-										const real_t *x,				/**< Input vector to be multiplied (uncompressed). */
-										int_t xLD,						/**< Leading dimension of input x. */
-										real_t *y,						/**< Output vector of results (compressed). */
-										int_t yLD						/**< Leading dimension of output y. */
-										) const;
-};
-
-
-/**
- *	\brief Interfaces matrix-vector operations tailored to general sparse matrices.
- *
- *	Sparse matrix class (col compressed format).
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class SparseMatrix : public virtual Matrix
-{
-	public:
-		/** Default constructor. */
-		SparseMatrix( );
-
-		/** Constructor with arguments. */
-		SparseMatrix(	int_t nr, 			/**< Number of rows. */
-						int_t nc, 			/**< Number of columns. */
-						sparse_int_t *r, 	/**< Row indices (length). */
-						sparse_int_t *c, 	/**< Indices to first entry of columns (nCols+1). */
-						real_t *v			/**< Vector of entries (length). */
-						);
-
-		/** Constructor from dense matrix. */
-		SparseMatrix(	int_t nr, 				/**< Number of rows. */
-						int_t nc,		 		/**< Number of columns. */
-						int_t ld,				/**< Leading dimension. */
-						const real_t * const v	/**< Row major stored matrix elements. */
-						);
-
-		/** Destructor. */
-		virtual ~SparseMatrix( );
-
-		/** Frees all internal memory. */
-		virtual void free( );
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix *duplicate( ) const;
-
-		/** Returns i-th diagonal entry.
-		 *	\return i-th diagonal entry (or INFTY if diagonal does not exist)*/
-		virtual real_t diag(	int_t i			/**< Index. */
-								) const;
-
-		/** Checks whether matrix is square and diagonal.
-		 *	\return BT_TRUE  iff matrix is square and diagonal; \n
-		 *	        BT_FALSE otherwise. */
-		virtual BooleanType isDiag( ) const;
-
-
-        /** Get the N-norm of the matrix
-         *  \return N-norm of the matrix
-         */
-        virtual real_t getNorm(	int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-								) const;
-
-        /** Get the N-norm of a row
-         *  \return N-norm of row \a rNum
-         */
-        virtual real_t getRowNorm(	int_t rNum,		/**< Row number. */
-									int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-									) const;
-
-		/** Retrieve indexed entries of matrix row multiplied by alpha. */
-		virtual returnValue getRow(	int_t rNum,						/**< Row number. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									real_t alpha,					/**< Scalar factor. */
-									real_t *row						/**< Output row vector. */
-									) const;
-
-		/** Retrieve indexed entries of matrix column multiplied by alpha. */
-		virtual returnValue getCol(	int_t cNum,						/**< Column number. */
-									const Indexlist* const irows,	/**< Index list specifying rows. */
-									real_t alpha,					/**< Scalar factor. */
-									real_t *col						/**< Output column vector. */
-									) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				int_t irowsLength,				/**< Number of rows. */
-				const int_t* const irowsNumber, /**< Array with row numbers. */
-				int_t icolsLength,				/**< Number of columns. */
-				const int_t* const icolsNumber, /**< Array with column numbers. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-		/** Evaluate Y=alpha*A*X + beta*Y. */
-		virtual returnValue times (	int_t xN,				/**< Number of vectors to multiply. */
-									real_t alpha,			/**< Scalar factor for matrix vector product. */
-									const real_t *x,		/**< Input vector to be multiplied. */
-									int_t xLD,				/**< Leading dimension of input x. */
-									real_t beta,			/**< Scalar factor for y. */
-									real_t *y,				/**< Output vector of results. */
-									int_t yLD				/**< Leading dimension of output y. */
-									) const;
-
-		/** Evaluate Y=alpha*A'*X + beta*Y. */
-		virtual returnValue transTimes (	int_t xN,			/**< Number of vectors to multiply. */
-											real_t alpha,		/**< Scalar factor for matrix vector product. */
-											const real_t *x,	/**< Input vector to be multiplied. */
-											int_t xLD,			/**< Leading dimension of input x. */
-											real_t beta,		/**< Scalar factor for y. */
-											real_t *y,			/**< Output vector of results. */
-											int_t yLD			/**< Leading dimension of output y. */
-											) const;
-
-		/** Evaluate matrix vector product with submatrix given by Indexlist. */
-		virtual returnValue times (	const Indexlist* const irows,	/**< Index list specifying rows. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									int_t xN,						/**< Number of vectors to multiply. */
-									real_t alpha,					/**< Scalar factor for matrix vector product. */
-									const real_t *x,				/**< Input vector to be multiplied. */
-									int_t xLD,						/**< Leading dimension of input x. */
-									real_t beta,					/**< Scalar factor for y. */
-									real_t *y,						/**< Output vector of results. */
-									int_t yLD,						/**< Leading dimension of output y. */
-									BooleanType yCompr = BT_TRUE	/**< Compressed storage for y. */
-									) const;
-
-		/** Evaluate matrix transpose vector product. */
-		virtual returnValue transTimes (	const Indexlist* const irows,	/**< Index list specifying rows. */
-											const Indexlist* const icols,	/**< Index list specifying columns. */
-											int_t xN,						/**< Number of vectors to multiply. */
-											real_t alpha,					/**< Scalar factor for matrix vector product. */
-											const real_t *x,				/**< Input vector to be multiplied. */
-											int_t xLD,						/**< Leading dimension of input x. */
-											real_t beta,					/**< Scalar factor for y. */
-											real_t *y,						/**< Output vector of results. */
-											int_t yLD						/**< Leading dimension of output y. */
-											) const;
-
-		/** Adds given offset to diagonal of matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_NO_DIAGONAL_AVAILABLE */
-		virtual returnValue addToDiag(	real_t alpha		/**< Diagonal offset. */
-										);
-
-		/** Create jd field from ir and jc.
-		 *  \return Pointer to jd. */
-		sparse_int_t *createDiagInfo();
-
-		/** Allocates and creates dense matrix array in row major format.
-		 *
-		 *  Note: Calling function has to free allocated memory!
-		 *
-		 *  \return Pointer to matrix array. 
-		 */
-		virtual real_t* full() const;
-
-		/** Prints matrix to screen.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue print( 	const char* name = 0	/** Name of matrix. */
-									) const;
-
-		/** Write matrix to file.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue writeToFile( FILE* output_file, const char* prefix ) const;
-
-
-	protected:
-		int_t nRows;		/**< Number of rows. */
-		int_t nCols;		/**< Number of columns. */
-		sparse_int_t *ir;	/**< Row indices (length). */
-		sparse_int_t *jc;	/**< Indices to first entry of columns (nCols+1). */
-		sparse_int_t *jd;	/**< Indices to first entry of lower triangle (including diagonal) (nCols). */
-		real_t *val;		/**< Vector of entries (length). */
-};
-
-
-/**
- *	\brief Interfaces matrix-vector operations tailored to general sparse matrices.
- *
- *	Sparse matrix class (row compressed format).
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class SparseMatrixRow : public virtual Matrix
-{
-	public:
-		/** Default constructor. */
-		SparseMatrixRow( );
-
-		/** Constructor with arguments. */
-		SparseMatrixRow(	int_t nr, 			/**< Number of rows. */
-							int_t nc, 			/**< Number of columns. */
-							sparse_int_t *r, 	/**< Indices to first entry of rows (nRows+1). */
-							sparse_int_t *c, 	/**< Column indices (length). */
-							real_t *v			/**< Vector of entries (length). */
-							);
-
-		/** Constructor from dense matrix. */
-		SparseMatrixRow(	int_t nr, 				/**< Number of rows. */
-							int_t nc,			 	/**< Number of columns. */
-							int_t ld,				/**< Leading dimension. */
-							const real_t * const v	/**< Row major stored matrix elements. */
-							);
-
-		/** Destructor. */
-		virtual ~SparseMatrixRow( );
-
-		/** Frees all internal memory. */
-		virtual void free( );
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix *duplicate( ) const;
-
-		/** Returns i-th diagonal entry.
-		 *	\return i-th diagonal entry (or INFTY if diagonal does not exist)*/
-		virtual real_t diag(	int_t i			/**< Index. */
-								) const;
-
-		/** Checks whether matrix is square and diagonal.
-		 *	\return BT_TRUE  iff matrix is square and diagonal; \n
-		 *	        BT_FALSE otherwise. */
-		virtual BooleanType isDiag( ) const;
-
-		
-        /** Get the N-norm of the matrix
-         *  \return N-norm of the matrix
-         */
-        virtual real_t getNorm(	int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-								) const;
-
-        /** Get the N-norm of a row
-         *  \return N-norm of row \a rNum
-         */
-        virtual real_t getRowNorm(	int_t rNum,		/**< Row number. */
-									int_t type = 2	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-									) const;
-
-		/** Retrieve indexed entries of matrix row multiplied by alpha. */
-		virtual returnValue getRow (	int_t rNum,						/**< Row number. */
-										const Indexlist* const icols,	/**< Index list specifying columns. */
-										real_t alpha,					/**< Scalar factor. */
-										real_t *row						/**< Output row vector. */
-										) const;
-
-		/** Retrieve indexed entries of matrix column multiplied by alpha. */
-		virtual returnValue getCol (	int_t cNum,						/**< Column number. */
-										const Indexlist* const irows,	/**< Index list specifying rows. */
-										real_t alpha,					/**< Scalar factor. */
-										real_t *col						/**< Output column vector. */
-										) const;
-
-		/** Retrieve entries of submatrix in Harwell-Boeing sparse format.
-		 *  If irn, jcn, and avals are null, this only counts the number of nonzeros.
-		 *  Otherwise, numNonzeros containts the size of irn, jcn, and avals on entry,
-		 *  and the written number of entries on return.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue getSparseSubmatrix(
-				int_t irowsLength,				/**< Number of rows. */
-				const int_t* const irowsNumber, /**< Array with row numbers. */
-				int_t icolsLength,				/**< Number of columns. */
-				const int_t* const icolsNumber, /**< Array with column numbers. */
-				int_t rowoffset,				/**< Offset for row entries. */
-				int_t coloffset,				/**< Offset for row entries. */
-				int_t& numNonzeros,				/**< Number of nonzeros in submatrix. */
-				int_t* irn,						/**< Row position of entries (as position in irows) plus rowoffset. */
-				int_t* jcn,						/**< Column position of entries (as position in irows) plus coloffset. */
-				real_t* avals,					/**< Numerical values of the entries. */
-				BooleanType only_lower_triangular = BT_FALSE /**< if true, only the lower triangular portion is returned.  This can only be true for symmetric matrices and if irows==jcols. */
-				) const;
-
-		/** Evaluate Y=alpha*A*X + beta*Y. */
-		virtual returnValue times(	int_t xN,				/**< Number of vectors to multiply. */
-									real_t alpha,			/**< Scalar factor for matrix vector product. */
-									const real_t *x,		/**< Input vector to be multiplied. */
-									int_t xLD,				/**< Leading dimension of input x. */
-									real_t beta,			/**< Scalar factor for y. */
-									real_t *y,				/**< Output vector of results. */
-									int_t yLD				/**< Leading dimension of output y. */
-									) const;
-
-		/** Evaluate Y=alpha*A'*X + beta*Y. */
-		virtual returnValue transTimes(	int_t xN,			/**< Number of vectors to multiply. */
-										real_t alpha,		/**< Scalar factor for matrix vector product. */
-										const real_t *x,	/**< Input vector to be multiplied. */
-										int_t xLD,			/**< Leading dimension of input x. */
-										real_t beta,		/**< Scalar factor for y. */
-										real_t *y,			/**< Output vector of results. */
-										int_t yLD			/**< Leading dimension of output y. */
-										) const;
-
-		/** Evaluate matrix vector product with submatrix given by Indexlist. */
-		virtual returnValue times(	const Indexlist* const irows,	/**< Index list specifying rows. */
-									const Indexlist* const icols,	/**< Index list specifying columns. */
-									int_t xN,						/**< Number of vectors to multiply. */
-									real_t alpha,					/**< Scalar factor for matrix vector product. */
-									const real_t *x,				/**< Input vector to be multiplied. */
-									int_t xLD,						/**< Leading dimension of input x. */
-									real_t beta,					/**< Scalar factor for y. */
-									real_t *y,						/**< Output vector of results. */
-									int_t yLD,						/**< Leading dimension of output y. */
-									BooleanType yCompr = BT_TRUE	/**< Compressed storage for y. */
-									) const;
-
-		/** Evaluate matrix transpose vector product. */
-		virtual returnValue transTimes(	const Indexlist* const irows,	/**< Index list specifying rows. */
-										const Indexlist* const icols,	/**< Index list specifying columns. */
-										int_t xN,						/**< Number of vectors to multiply. */
-										real_t alpha,					/**< Scalar factor for matrix vector product. */
-										const real_t *x,				/**< Input vector to be multiplied. */
-										int_t xLD,						/**< Leading dimension of input x. */
-										real_t beta,					/**< Scalar factor for y. */
-										real_t *y,						/**< Output vector of results. */
-										int_t yLD						/**< Leading dimension of output y. */
-										) const;
-
-		/** Adds given offset to diagonal of matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_NO_DIAGONAL_AVAILABLE */
-		virtual returnValue addToDiag(	real_t alpha		/**< Diagonal offset. */
-										);
-
-		/** Create jd field from ir and jc.
-		 *  \return Pointer to jd. */
-		sparse_int_t *createDiagInfo();
-
-		/** Allocates and creates dense matrix array in row major format.
-		 *
-		 *  Note: Calling function has to free allocated memory!
-		 *
-		 *  \return Pointer to matrix array. 
-		 */
-		virtual real_t* full() const;
-
-		/** Prints matrix to screen.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue print( 	const char* name = 0	/** Name of matrix. */
-									) const;
-
-		/** Write matrix to file.
-		 *	\return SUCCESSFUL_RETURN */
-		virtual returnValue writeToFile( FILE* output_file, const char* prefix ) const;
-
-	protected:
-		int_t nRows;		/**< Number of rows. */
-		int_t nCols;		/**< Number of columns. */
-		sparse_int_t *jr;	/**< Indices to first entry of row (nRows+1). */
-		sparse_int_t *ic;	/**< Column indices (length). */
-		sparse_int_t *jd;	/**< Indices to first entry of upper triangle (including diagonal) (nRows). */
-		real_t *val;		/**< Vector of entries (length). */
-};
-
-
-/**
- *	\brief Interfaces matrix-vector operations tailored to symmetric sparse matrices.
- *
- *	Symmetric sparse matrix class (column compressed format).
- *
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- */
-class SymSparseMat : public SymmetricMatrix, public SparseMatrix
-{
-	public:
-		/** Default constructor. */
-		SymSparseMat( ) : SparseMatrix( ) { };
-
-		/** Constructor with arguments. */
-		SymSparseMat(	int_t nr, 			/**< Number of rows. */
-						int_t nc, 			/**< Number of columns. */
-						sparse_int_t *r, 	/**< Row indices (length). */
-						sparse_int_t *c, 	/**< Indices to first entry of columns (nCols+1). */
-						real_t *v			/**< Vector of entries (length). */
-						) : SparseMatrix(nr, nc, r, c, v) { };
-
-		/** Constructor from dense matrix. */
-		SymSparseMat(	int_t nr, 				/**< Number of rows. */
-						int_t nc,		 		/**< Number of columns. */
-						int_t ld,				/**< Leading dimension. */
-						const real_t * const v	/**< Row major stored matrix elements. */
-						) : SparseMatrix(nr, nc, ld, v) { };
-
-		/** Destructor. */
-		virtual ~SymSparseMat( ) { };
-
-		/** Returns a deep-copy of the Matrix object.
-		 *	\return Deep-copy of Matrix object */
-		virtual Matrix *duplicate( ) const;
-
-		/** Returns a deep-copy of the SymmetricMatrix object.
-		 *	\return Deep-copy of SymmetricMatrix object */
-		virtual SymmetricMatrix* duplicateSym( ) const;
-
-
-		/** Compute bilinear form y = x'*H*x using submatrix given by index list.
-		*	\return SUCCESSFUL_RETURN */
-		virtual returnValue bilinear(	const Indexlist* const icols,	/**< Index list specifying columns of x. */
-										int_t xN,						/**< Number of vectors to multiply. */
-										const real_t *x,				/**< Input vector to be multiplied (uncompressed). */
-										int_t xLD,						/**< Leading dimension of input x. */
-										real_t *y,						/**< Output vector of results (compressed). */
-										int_t yLD						/**< Leading dimension of output y. */
-										) const;
-};
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_MATRICES_HPP */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.hpp
deleted file mode 100644
index 8520686..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.hpp
+++ /dev/null
@@ -1,480 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/MessageHandling.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches (thanks to Leonard Wirsching)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the MessageHandling class including global return values.
- */
-
-
-#ifndef QPOASES_MESSAGEHANDLING_HPP
-#define QPOASES_MESSAGEHANDLING_HPP
-
-
-#include <stdio.h>
-#include <string.h>
-
-#ifdef __DEBUG__
-#include <assert.h>
-#endif
-
-#include <qpOASES/Constants.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** Default file to display messages. */
-extern FILE* stdFile;
-
-
-/**
- *	\brief Defines all symbols for global return values.
- *
- *  The enumeration returnValueType defines all symbols for global return values.
- *	Important: All return values are assumed to be nonnegative!
- *
- *	\author Hans Joachim Ferreau
- */
-enum returnValue
-{
-TERMINAL_LIST_ELEMENT = -1,						/**< Terminal list element, internal usage only! */
-/* miscellaneous */
-SUCCESSFUL_RETURN = 0,							/**< Successful return. */
-RET_DIV_BY_ZERO,		   						/**< Division by zero. */
-RET_INDEX_OUT_OF_BOUNDS,						/**< Index out of bounds. */
-RET_INVALID_ARGUMENTS,							/**< At least one of the arguments is invalid. */
-RET_ERROR_UNDEFINED,							/**< Error number undefined. */
-RET_WARNING_UNDEFINED,							/**< Warning number undefined. */
-RET_INFO_UNDEFINED,								/**< Info number undefined. */
-RET_EWI_UNDEFINED,								/**< Error/warning/info number undefined. */
-RET_AVAILABLE_WITH_LINUX_ONLY,					/**< This function is available under Linux only. */
-RET_UNKNOWN_BUG,								/**< The error occurred is not yet known. */
-RET_PRINTLEVEL_CHANGED,							/**< Print level changed. (10) */
-RET_NOT_YET_IMPLEMENTED,						/**< Requested function is not yet implemented in this version of qpOASES. */
-/* Indexlist */
-RET_INDEXLIST_MUST_BE_REORDERD,					/**< Index list has to be reordered. */
-RET_INDEXLIST_EXCEEDS_MAX_LENGTH,				/**< Index list exceeds its maximal physical length. */
-RET_INDEXLIST_CORRUPTED,						/**< Index list corrupted. */
-RET_INDEXLIST_OUTOFBOUNDS,						/**< Physical index is out of bounds. */
-RET_INDEXLIST_ADD_FAILED,						/**< Adding indices from another index set failed. */
-RET_INDEXLIST_INTERSECT_FAILED,					/**< Intersection with another index set failed. */
-/* SubjectTo / Bounds / Constraints */
-RET_INDEX_ALREADY_OF_DESIRED_STATUS,			/**< Index is already of desired status. (18) */
-RET_ADDINDEX_FAILED,							/**< Adding index to index set failed. */
-RET_REMOVEINDEX_FAILED,							/**< Removing index from index set failed. (20) */
-RET_SWAPINDEX_FAILED,							/**< Cannot swap between different indexsets. */
-RET_NOTHING_TO_DO,								/**< Nothing to do. */
-RET_SETUP_BOUND_FAILED,							/**< Setting up bound index failed. */
-RET_SETUP_CONSTRAINT_FAILED,					/**< Setting up constraint index failed. */
-RET_MOVING_BOUND_FAILED,						/**< Moving bound between index sets failed. */
-RET_MOVING_CONSTRAINT_FAILED,					/**< Moving constraint between index sets failed. */
-RET_SHIFTING_FAILED,							/**< Shifting of bounds/constraints failed. */
-RET_ROTATING_FAILED,							/**< Rotating of bounds/constraints failed. */
-/* QProblem */
-RET_QPOBJECT_NOT_SETUP,							/**< The QP object has not been setup correctly, use another constructor. */
-RET_QP_ALREADY_INITIALISED,						/**< QProblem has already been initialised. (30) */
-RET_NO_INIT_WITH_STANDARD_SOLVER,				/**< Initialisation via extern QP solver is not yet implemented. */
-RET_RESET_FAILED,								/**< Reset failed. */
-RET_INIT_FAILED,								/**< Initialisation failed. */
-RET_INIT_FAILED_TQ,								/**< Initialisation failed due to TQ factorisation. */
-RET_INIT_FAILED_CHOLESKY,						/**< Initialisation failed due to Cholesky decomposition. */
-RET_INIT_FAILED_HOTSTART,						/**< Initialisation failed! QP could not be solved! */
-RET_INIT_FAILED_INFEASIBILITY,					/**< Initial QP could not be solved due to infeasibility! */
-RET_INIT_FAILED_UNBOUNDEDNESS,					/**< Initial QP could not be solved due to unboundedness! */
-RET_INIT_FAILED_REGULARISATION,					/**< Initialisation failed as Hessian matrix could not be regularised. */
-RET_INIT_SUCCESSFUL,							/**< Initialisation done. (40) */
-RET_OBTAINING_WORKINGSET_FAILED,				/**< Failed to obtain working set for auxiliary QP. */
-RET_SETUP_WORKINGSET_FAILED,					/**< Failed to setup working set for auxiliary QP. */
-RET_SETUP_AUXILIARYQP_FAILED,					/**< Failed to setup auxiliary QP for initialised homotopy. */
-RET_NO_CHOLESKY_WITH_INITIAL_GUESS,				/**< Externally computed Cholesky factor cannot be combined with an initial guess. */
-RET_NO_EXTERN_SOLVER,							/**< No extern QP solver available. */
-RET_QP_UNBOUNDED,								/**< QP is unbounded. */
-RET_QP_INFEASIBLE,								/**< QP is infeasible. */
-RET_QP_NOT_SOLVED,								/**< Problems occurred while solving QP with standard solver. */
-RET_QP_SOLVED,									/**< QP successfully solved. */
-RET_UNABLE_TO_SOLVE_QP,							/**< Problems occurred while solving QP. (50) */
-RET_INITIALISATION_STARTED,						/**< Starting problem initialisation... */
-RET_HOTSTART_FAILED,							/**< Unable to perform homotopy due to internal error. */
-RET_HOTSTART_FAILED_TO_INIT,					/**< Unable to initialise problem. */
-RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED,		/**< Unable to perform homotopy as previous QP is not solved. */
-RET_ITERATION_STARTED,							/**< Iteration... */
-RET_SHIFT_DETERMINATION_FAILED,					/**< Determination of shift of the QP data failed. */
-RET_STEPDIRECTION_DETERMINATION_FAILED,			/**< Determination of step direction failed. */
-RET_STEPLENGTH_DETERMINATION_FAILED,			/**< Determination of step direction failed. */
-RET_OPTIMAL_SOLUTION_FOUND,						/**< Optimal solution of neighbouring QP found. */
-RET_HOMOTOPY_STEP_FAILED,						/**< Unable to perform homotopy step. (60) */
-RET_HOTSTART_STOPPED_INFEASIBILITY,				/**< Premature homotopy termination because QP is infeasible. */
-RET_HOTSTART_STOPPED_UNBOUNDEDNESS,				/**< Premature homotopy termination because QP is unbounded. */
-RET_WORKINGSET_UPDATE_FAILED,					/**< Unable to update working sets according to initial guesses. */
-RET_MAX_NWSR_REACHED,							/**< Maximum number of working set recalculations performed. */
-RET_CONSTRAINTS_NOT_SPECIFIED,					/**< Problem does comprise constraints! You also have to specify new constraints' bounds. */
-RET_INVALID_FACTORISATION_FLAG,					/**< Invalid factorisation flag. */
-RET_UNABLE_TO_SAVE_QPDATA,						/**< Unable to save QP data. */
-RET_STEPDIRECTION_FAILED_TQ,					/**< Abnormal termination due to TQ factorisation. */
-RET_STEPDIRECTION_FAILED_CHOLESKY,				/**< Abnormal termination due to Cholesky factorisation. */
-RET_CYCLING_DETECTED,							/**< Cycling detected. (70) */
-RET_CYCLING_NOT_RESOLVED,						/**< Cycling cannot be resolved, QP probably infeasible. */
-RET_CYCLING_RESOLVED,							/**< Cycling probably resolved. */
-RET_STEPSIZE,									/**< For displaying performed stepsize. */
-RET_STEPSIZE_NONPOSITIVE,						/**< For displaying non-positive stepsize. */
-RET_SETUPSUBJECTTOTYPE_FAILED,					/**< Setup of SubjectToTypes failed. */
-RET_ADDCONSTRAINT_FAILED,						/**< Addition of constraint to working set failed. */
-RET_ADDCONSTRAINT_FAILED_INFEASIBILITY,			/**< Addition of constraint to working set failed (due to QP infeasibility). */
-RET_ADDBOUND_FAILED,							/**< Addition of bound to working set failed. */
-RET_ADDBOUND_FAILED_INFEASIBILITY,				/**< Addition of bound to working set failed (due to QP infeasibility). */
-RET_REMOVECONSTRAINT_FAILED,					/**< Removal of constraint from working set failed. (80) */
-RET_REMOVEBOUND_FAILED,							/**< Removal of bound from working set failed. */
-RET_REMOVE_FROM_ACTIVESET,						/**< Removing from active set... */
-RET_ADD_TO_ACTIVESET,							/**< Adding to active set... */
-RET_REMOVE_FROM_ACTIVESET_FAILED,				/**< Removing from active set failed. */
-RET_ADD_TO_ACTIVESET_FAILED,					/**< Adding to active set failed. */
-RET_CONSTRAINT_ALREADY_ACTIVE,					/**< Constraint is already active. */
-RET_ALL_CONSTRAINTS_ACTIVE,						/**< All constraints are active, no further constraint can be added. */
-RET_LINEARLY_DEPENDENT,							/**< New bound/constraint is linearly dependent. */
-RET_LINEARLY_INDEPENDENT,						/**< New bound/constraint is linearly independent. */
-RET_LI_RESOLVED,								/**< Linear independence of active constraint matrix successfully resolved. (90) */
-RET_ENSURELI_FAILED,							/**< Failed to ensure linear independence of active constraint matrix. */
-RET_ENSURELI_FAILED_TQ,							/**< Abnormal termination due to TQ factorisation. */
-RET_ENSURELI_FAILED_NOINDEX,					/**< QP is infeasible. */
-RET_ENSURELI_FAILED_CYCLING,					/**< QP is infeasible. */
-RET_BOUND_ALREADY_ACTIVE,						/**< Bound is already active. */
-RET_ALL_BOUNDS_ACTIVE,							/**< All bounds are active, no further bound can be added. */
-RET_CONSTRAINT_NOT_ACTIVE,						/**< Constraint is not active. */
-RET_BOUND_NOT_ACTIVE,							/**< Bound is not active. */
-RET_HESSIAN_NOT_SPD,							/**< Projected Hessian matrix not positive definite. */
-RET_HESSIAN_INDEFINITE,							/**< Hessian matrix is indefinite. (100) */
-RET_MATRIX_SHIFT_FAILED,						/**< Unable to update matrices or to transform vectors. */
-RET_MATRIX_FACTORISATION_FAILED,				/**< Unable to calculate new matrix factorisations. */
-RET_PRINT_ITERATION_FAILED,						/**< Unable to print information on current iteration. */
-RET_NO_GLOBAL_MESSAGE_OUTPUTFILE,				/**< No global message output file initialised. */
-RET_DISABLECONSTRAINTS_FAILED,					/**< Unable to disbable constraints. */
-RET_ENABLECONSTRAINTS_FAILED,					/**< Unable to enbable constraints. */
-RET_ALREADY_ENABLED,							/**< Bound or constraint is already enabled. */
-RET_ALREADY_DISABLED,							/**< Bound or constraint is already disabled. */
-RET_NO_HESSIAN_SPECIFIED, 						/**< No Hessian matrix has been specified. */
-RET_USING_REGULARISATION,						/**< Using regularisation as Hessian matrix is not positive definite. (110) */
-RET_EPS_MUST_BE_POSITVE,						/**< Eps for regularisation must be sufficiently positive. */
-RET_REGSTEPS_MUST_BE_POSITVE, 					/**< Maximum number of regularisation steps must be non-negative. */
-RET_HESSIAN_ALREADY_REGULARISED,				/**< Hessian has been already regularised. */
-RET_CANNOT_REGULARISE_IDENTITY,					/**< Identity Hessian matrix cannot be regularised. */
-RET_CANNOT_REGULARISE_SPARSE,					/**< Sparse matrix cannot be regularised as diagonal entry is missing. */
-RET_NO_REGSTEP_NWSR,							/**< No additional regularisation step could be performed due to limits. */
-RET_FEWER_REGSTEPS_NWSR,						/**< Fewer additional regularisation steps have been performed due to limits. */
-RET_CHOLESKY_OF_ZERO_HESSIAN, 					/**< Cholesky decomposition of (unregularised) zero Hessian matrix. */
-RET_ZERO_HESSIAN_ASSUMED,						/**< Zero Hessian matrix assumed as null pointer passed without specifying hessianType. */
-RET_CONSTRAINTS_ARE_NOT_SCALED, 				/**< (no longer in use) (120) */
-RET_INITIAL_BOUNDS_STATUS_NYI, 					/**< (no longer in use) */
-RET_ERROR_IN_CONSTRAINTPRODUCT,					/**< Error in user-defined constraint product function. */
-RET_FIX_BOUNDS_FOR_LP,							/**< All initial bounds must be fixed when solving an (unregularised) LP. */
-RET_USE_REGULARISATION_FOR_LP,					/**< Set options.enableRegularisation=BT_TRUE for solving LPs. */
-/* SQProblem */
-RET_UPDATEMATRICES_FAILED,						/**< Unable to update QP matrices. */
-RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED,		/**< Unable to update matrices as previous QP is not solved. */
-/* Utils */
-RET_UNABLE_TO_OPEN_FILE,						/**< Unable to open file. */
-RET_UNABLE_TO_WRITE_FILE,						/**< Unable to write into file. */
-RET_UNABLE_TO_READ_FILE,						/**< Unable to read from file. */
-RET_FILEDATA_INCONSISTENT,						/**< File contains inconsistent data. (130) */
-/* Options */
-RET_OPTIONS_ADJUSTED,							/**< Options needed to be adjusted for consistency reasons. */
-/* SolutionAnalysis */
-RET_UNABLE_TO_ANALYSE_QPROBLEM, 				/**< Unable to analyse (S)QProblem(B) object. */
-/* Benchmark */
-RET_NWSR_SET_TO_ONE,							/**< Maximum number of working set changes was set to 1. */
-RET_UNABLE_TO_READ_BENCHMARK,					/**< Unable to read benchmark data. */
-RET_BENCHMARK_ABORTED,							/**< Benchmark aborted. */
-RET_INITIAL_QP_SOLVED,							/**< Initial QP solved. */
-RET_QP_SOLUTION_STARTED,						/**< Solving QP... */
-RET_BENCHMARK_SUCCESSFUL,						/**< Benchmark terminated successfully. */
-/* Sparse matrices */
-RET_NO_DIAGONAL_AVAILABLE,						/**< Sparse matrix does not have entries on full diagonal. */
-RET_DIAGONAL_NOT_INITIALISED,					/**< Diagonal data of sparse matrix has not been initialised. (140) */
-/* Dropping of infeasible constraints */
-RET_ENSURELI_DROPPED,							/**< Linear independence resolved by dropping blocking constraint. */
-/* Schur complement computations */
-RET_KKT_MATRIX_SINGULAR,						/**< KKT matrix is singular. */
-RET_QR_FACTORISATION_FAILED,					/**< QR factorization of Schur complement failed. */
-RET_INERTIA_CORRECTION_FAILED,					/**< Inertia correction failed after KKT matrix had too many negative eigenvalues. */
-RET_NO_SPARSE_SOLVER,							/**< No factorization routine for the KKT matrix installed. */
-/* Simple exitflags */
-RET_SIMPLE_STATUS_P1,							/**< QP problem could not be solved within given number of iterations. */
-RET_SIMPLE_STATUS_P0,							/**< QP problem solved. */
-RET_SIMPLE_STATUS_M1,							/**< QP problem could not be solved due to an internal error. */
-RET_SIMPLE_STATUS_M2,							/**< QP problem is infeasible (and thus could not be solved). */
-RET_SIMPLE_STATUS_M3							/**< QP problem is unbounded (and thus could not be solved). (150) */
-};
-
-
-/**
- *	\brief Handles all kind of error messages, warnings and other information.
- *
- *	This class handles all kinds of messages (errors, warnings, infos) initiated
- *  by qpOASES modules and stores the corresponding global preferences.
- *
- *	\author Hans Joachim Ferreau (thanks to Leonard Wirsching)
- *	\version 3.2
- *	\date 2007-2015
- */
-class MessageHandling
-{
-	/*
-	 *	INTERNAL DATA STRUCTURES
-	 */
-	public:
-		/**
-		*	\brief Data structure for entries in global message list.
-		*
-		*	Data structure for entries in global message list.
-		*
-		*	\author Hans Joachim Ferreau
-		*/
-		typedef struct {
-			returnValue key;							/**< Global return value. */
-			const char* data;							/**< Corresponding message. */
-			VisibilityStatus globalVisibilityStatus; 	/**< Determines if message can be printed.
-														* 	 If this value is set to VS_HIDDEN, no message is printed! */
-		} ReturnValueList;
-
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		MessageHandling( );
-
-		/** Constructor which takes the desired output file. */
-		MessageHandling(  FILE* _outputFile						/**< Output file. */
-						  );
-
-		/** Constructor which takes the desired visibility states. */
-		MessageHandling(	VisibilityStatus _errorVisibility,	/**< Visibility status for error messages. */
-							VisibilityStatus _warningVisibility,/**< Visibility status for warning messages. */
-							VisibilityStatus _infoVisibility	/**< Visibility status for info messages. */
-							);
-
-		/** Constructor which takes the desired output file and desired visibility states. */
-		MessageHandling(	FILE* _outputFile,					/**< Output file. */
-							VisibilityStatus _errorVisibility,	/**< Visibility status for error messages. */
-							VisibilityStatus _warningVisibility,/**< Visibility status for warning messages. */
-							VisibilityStatus _infoVisibility	/**< Visibility status for info messages. */
-							);
-
-		/** Copy constructor (deep copy). */
-		MessageHandling(	const MessageHandling& rhs	/**< Rhs object. */
-							);
-
-		/** Destructor. */
-		~MessageHandling( );
-
-		/** Assignment operator (deep copy). */
-		MessageHandling& operator=(	const MessageHandling& rhs	/**< Rhs object. */
-									);
-
-
-		/** Prints an error message(a simplified macro THROWERROR is also provided). \n
-		 *  Errors are defined as abnormal events which cause an immediate termination of the current (sub) function.
-		 *  Errors of a sub function should be commented by the calling function by means of a warning message
-		 *  (if this error does not cause an error of the calling function, either)!
-		 *  \return Error number returned by sub function call
-		 */
-		returnValue throwError(	returnValue Enumber,					/**< Error number returned by sub function call. */
-								const char* additionaltext,				/**< Additional error text (0, if none). */
-								const char* functionname,				/**< Name of function which caused the error. */
-								const char* filename,					/**< Name of file which caused the error. */
-								const unsigned long linenumber,			/**< Number of line which caused the error.incompatible binary file */
-								VisibilityStatus localVisibilityStatus	/**< Determines (locally) if error message can be printed to stdFile.
-																	*   If GLOBAL visibility status of the message is set to VS_HIDDEN,
-																	*   no message is printed, anyway! */
-								);
-
-		/** Prints a warning message (a simplified macro THROWWARNING is also provided).
-		 *  Warnings are definied as abnormal events which does NOT cause an immediate termination of the current (sub) function.
-		 *  \return Warning number returned by sub function call
-		 */
-		returnValue throwWarning(	returnValue Wnumber,	 				/**< Warning number returned by sub function call. */
-									const char* additionaltext,				/**< Additional warning text (0, if none). */
-									const char* functionname,				/**< Name of function which caused the warning. */
-									const char* filename,   				/**< Name of file which caused the warning. */
-									const unsigned long linenumber,	 		/**< Number of line which caused the warning. */
-									VisibilityStatus localVisibilityStatus	/**< Determines (locally) if warning message can be printed to stdFile.
-																			*   If GLOBAL visibility status of the message is set to VS_HIDDEN,
-																			*   no message is printed, anyway! */
-									);
-
-	   /** Prints a info message (a simplified macro THROWINFO is also provided).
-		 *  \return Info number returned by sub function call
-		 */
-		returnValue throwInfo(	returnValue Inumber,	 				/**< Info number returned by sub function call. */
-								const char* additionaltext,	 			/**< Additional warning text (0, if none). */
-								const char* functionname,				/**< Name of function which submitted the info. */
-								const char* filename,   				/**< Name of file which submitted the info. */
-								const unsigned long linenumber,			/**< Number of line which submitted the info. */
-								VisibilityStatus localVisibilityStatus	/**< Determines (locally) if info message can be printed to stdFile.
-																		*   If GLOBAL visibility status of the message is set to VS_HIDDEN,
-																		*   no message is printed, anyway! */
-								);
-
-
-		/** Resets all preferences to default values.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue reset( );
-
-
-		/** Prints a complete list of all messages to output file.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue listAllMessages( );
-
-
-		/** Returns visibility status for error messages.
-		 *	\return Visibility status for error messages. */
-		inline VisibilityStatus getErrorVisibilityStatus( ) const;
-
-		/** Returns visibility status for warning messages.
-		 *	\return Visibility status for warning messages. */
-		inline VisibilityStatus getWarningVisibilityStatus( ) const;
-
-		/** Returns visibility status for info messages.
-		 *	\return Visibility status for info messages. */
-		inline VisibilityStatus getInfoVisibilityStatus( ) const;
-
-		/** Returns pointer to output file.
-		 *	\return Pointer to output file. */
-		inline FILE* getOutputFile( ) const;
-
-		/** Returns error count value.
-		 *	\return Error count value. */
-		inline int_t getErrorCount( ) const;
-
-
-		/** Changes visibility status for error messages. */
-		inline void setErrorVisibilityStatus(	VisibilityStatus _errorVisibility	/**< New visibility status for error messages. */
-												);
-
-		/** Changes visibility status for warning messages. */
-		inline void setWarningVisibilityStatus(	VisibilityStatus _warningVisibility	/**< New visibility status for warning messages. */
-												);
-
-		/** Changes visibility status for info messages. */
-		inline void setInfoVisibilityStatus(	VisibilityStatus _infoVisibility	/**< New visibility status for info messages. */
-												);
-
-		/** Changes output file for messages. */
-		inline void setOutputFile(	FILE* _outputFile	/**< New output file for messages. */
-									);
-
-		/** Changes error count.
-		 * \return SUCCESSFUL_RETURN \n
-		 *		   RET_INVALID_ARGUMENT */
-		inline returnValue setErrorCount(	int_t _errorCount	/**< New error count value. */
-											);
-
-		/** Provides message text corresponding to given \a returnValue.
-		 * \return String containing message text. */
-		static const char* getErrorCodeMessage(	const returnValue _returnValue
-												);
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Prints a info message to stdFile (auxiliary function).
-		 *  \return Error/warning/info number returned by sub function call
-		 */
-		returnValue throwMessage(
-			returnValue RETnumber,	 				/**< Error/warning/info number returned by sub function call. */
-			const char* additionaltext,				/**< Additional warning text (0, if none). */
-			const char* functionname,				/**< Name of function which caused the error/warning/info. */
-			const char* filename,   				/**< Name of file which caused the error/warning/info. */
-			const unsigned long linenumber,			/**< Number of line which caused the error/warning/info. */
-			VisibilityStatus localVisibilityStatus,	/**< Determines (locally) if info message can be printed to stdFile.
-					  								 *   If GLOBAL visibility status of the message is set to VS_HIDDEN,
-				   									 *   no message is printed, anyway! */
-			const char* RETstring					/**< Leading string of error/warning/info message. */
-			);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		VisibilityStatus errorVisibility;		/**< Error messages visible? */
-		VisibilityStatus warningVisibility;		/**< Warning messages visible? */
-		VisibilityStatus infoVisibility;		/**< Info messages visible? */
-
-		FILE* outputFile;						/**< Output file for messages. */
-
-		int_t errorCount; 						/**< Counts number of errors (for nicer output only). */
-};
-
-
-#ifndef __FILE__
-  /** Ensures that __FILE__ macro is defined. */
-  #define __FILE__ 0
-#endif
-
-#ifndef __LINE__
-  /** Ensures that __LINE__ macro is defined. */
-  #define __LINE__ 0
-#endif
-
-/** Define __FUNC__ macro providing current function for debugging. */
-/*#define __FUNC__ 0*/
-#define __FUNC__ ("(no function name provided)")
-/*#define __FUNC__ __func__*/
-/*#define __FUNC__ __FUNCTION__*/
-
-
-/** Short version of throwError with default values, only returnValue is needed */
-#define THROWERROR(retval) ( getGlobalMessageHandler( )->throwError((retval),0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE) )
-
-/** Short version of throwWarning with default values, only returnValue is needed */
-#define THROWWARNING(retval) ( getGlobalMessageHandler( )->throwWarning((retval),0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE) )
-
-/** Short version of throwInfo with default values, only returnValue is needed */
-#define THROWINFO(retval) ( getGlobalMessageHandler( )->throwInfo((retval),0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE) )
-
-
-/** Returns a pointer to global message handler.
- *  \return Pointer to global message handler.
- */
-MessageHandling* getGlobalMessageHandler( );
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/MessageHandling.ipp>
-
-#endif /* QPOASES_MESSAGEHANDLING_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.ipp
deleted file mode 100644
index 4ae9629..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/MessageHandling.ipp
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/MessageHandling.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the MessageHandling class.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	g e t E r r o r V i s i b i l i t y S t a t u s
- */
-inline VisibilityStatus MessageHandling::getErrorVisibilityStatus( ) const
-{
- 	return errorVisibility;
-}
-
-
-/*
- *	g e t W a r n i n g V i s i b i l i t y S t a t u s
- */
-inline VisibilityStatus MessageHandling::getWarningVisibilityStatus( ) const
-{
- 	return warningVisibility;
-}
-
-
-/*
- *	g e t I n f o V i s i b i l i t y S t a t u s
- */
-inline VisibilityStatus MessageHandling::getInfoVisibilityStatus( ) const
-{
- 	return infoVisibility;
-}
-
-
-/*
- *	g e t O u t p u t F i l e
- */
-inline FILE* MessageHandling::getOutputFile( ) const
-{
- 	return outputFile;
-}
-
-
-/*
- *	g e t E r r o r C o u n t
- */
-inline int_t MessageHandling::getErrorCount( ) const
-{
- 	return errorCount;
-}
-
-
-/*
- *	s e t E r r o r V i s i b i l i t y S t a t u s
- */
-inline void MessageHandling::setErrorVisibilityStatus( VisibilityStatus _errorVisibility )
-{
- 	errorVisibility = _errorVisibility;
-}
-
-
-/*
- *	s e t W a r n i n g V i s i b i l i t y S t a t u s
- */
-inline void MessageHandling::setWarningVisibilityStatus( VisibilityStatus _warningVisibility )
-{
- 	warningVisibility = _warningVisibility;
-}
-
-
-/*
- *	s e t I n f o V i s i b i l i t y S t a t u s
- */
-inline void MessageHandling::setInfoVisibilityStatus( VisibilityStatus _infoVisibility )
-{
- 	infoVisibility = _infoVisibility;
-}
-
-
-/*
- *	s e t O u t p u t F i l e
- */
-inline void MessageHandling::setOutputFile( FILE* _outputFile )
-{
- 	outputFile = _outputFile;
-}
-
-
-/*
- *	s e t E r r o r C o u n t
- */
-inline returnValue MessageHandling::setErrorCount( int_t _errorCount )
-{
-	if ( _errorCount >= -1 )
-	{
-		errorCount = _errorCount;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-		return RET_INVALID_ARGUMENTS;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Options.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Options.hpp
deleted file mode 100644
index 6a1ec01..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Options.hpp
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Options.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the Options class designed to manage user-specified
- *	options for solving a QProblem.
- */
-
-
-#ifndef QPOASES_OPTIONS_HPP
-#define QPOASES_OPTIONS_HPP
-
-
-#include <qpOASES/Utils.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Manages all user-specified options for solving QPs.
- *
- *	This class manages all user-specified options used for solving
- *	quadratic programs.
- *
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-class Options
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Options( );
-
-		/** Copy constructor (deep copy). */
-		Options(	const Options& rhs			/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		~Options( );
-
-		/** Assignment operator (deep copy). */
-		Options& operator=(	const Options& rhs	/**< Rhs object. */
-							);
-
-
-		/** Sets all options to default values.
- 		 *	\return SUCCESSFUL_RETURN */
-		returnValue setToDefault( );
-
-		/** Sets all options to values resulting in maximum reliabilty.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue setToReliable( );
-
-		/** Sets all options to values resulting in minimum solution time.
- 		 *	\return SUCCESSFUL_RETURN */
-		returnValue setToMPC( );
-
-		/** Same as setToMPC( ), for ensuring backwards compatibility.
- 		 *	\return SUCCESSFUL_RETURN */
-		returnValue setToFast( );
-
-
-		/** Ensures that all options have consistent values by automatically
-		 *	adjusting inconsistent ones.
-		 *	Note: This routine cannot (and does not try to) ensure that values
-		 *	      are set to reasonable values that make the QP solution work!
-		 *	\return SUCCESSFUL_RETURN \n
-		 *          RET_OPTIONS_ADJUSTED */
-		returnValue ensureConsistency( );
-
-
-		/** Prints values of all options.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue print( ) const;
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Options& rhs	/**< Rhs object. */
-							);
-
-	/*
-	 *	PUBLIC MEMBER VARIABLES
-	 */
-	public:
-		PrintLevel printLevel;					/**< Print level. */
-
-		BooleanType enableRamping;				/**< Specifies whether ramping shall be enabled or not. */
-		BooleanType enableFarBounds;			/**< Specifies whether far bounds shall be used or not. */
-		BooleanType enableFlippingBounds;		/**< Specifies whether flipping bounds shall be used or not. */
-		BooleanType enableRegularisation;		/**< Specifies whether Hessian matrix shall be regularised in case semi-definiteness is detected. */
-		BooleanType enableFullLITests;			/**< Specifies whether condition-hardened LI test shall be used or not. */
-		BooleanType enableNZCTests;				/**< Specifies whether nonzero curvature tests shall be used. */
-		int_t enableDriftCorrection;			/**< Specifies the frequency of drift corrections (0 = off). */
-		int_t enableCholeskyRefactorisation;	/**< Specifies the frequency of full refactorisation of proj. Hessian (otherwise updates). */
-		BooleanType enableEqualities;			/**< Specifies whether equalities shall be always treated as active constraints. */
-
-		real_t terminationTolerance;			/**< Termination tolerance. */
-		real_t boundTolerance;					/**< Lower/upper (constraints') bound tolerance (an inequality constraint whose lower and
-													 upper bounds differ by less is regarded to be an equality constraint). */
-		real_t boundRelaxation;					/**< Offset for relaxing (constraints') bounds at beginning of an initial homotopy. It is also as initial value for far bounds. */
-		real_t epsNum;							/**< Numerator tolerance for ratio tests. */
-		real_t epsDen;							/**< Denominator tolerance for ratio tests. */
-		real_t maxPrimalJump;					/**< Maximum allowed jump in primal variables in nonzero curvature tests. */
-		real_t maxDualJump;						/**< Maximum allowed jump in dual variables in linear independence tests. */
-
-		real_t initialRamping;					/**< Start value for Ramping Strategy. */
-		real_t finalRamping;					/**< Final value for Ramping Strategy. */
-		real_t initialFarBounds;				/**< Initial size of Far Bounds. */
-		real_t growFarBounds;					/**< Factor to grow Far Bounds. */
-		SubjectToStatus initialStatusBounds;	/**< Initial status of bounds at first iteration. */
-		real_t epsFlipping;						/**< Tolerance of squared Cholesky diagonal factor which triggers flipping bound. */
-		int_t numRegularisationSteps;			/**< Maximum number of successive regularisation steps. */
-		real_t epsRegularisation;				/**< Scaling factor of identity matrix used for Hessian regularisation. */
-		int_t numRefinementSteps;				/**< Maximum number of iterative refinement steps. */
-		real_t epsIterRef;						/**< Early termination tolerance for iterative refinement. */
-		real_t epsLITests;						/**< Tolerance for linear independence tests. */
-		real_t epsNZCTests;						/**< Tolerance for nonzero curvature tests. */
-
-		real_t rcondSMin;						/**< Minimum reciprocal condition number of S before refactorization is triggered */
-		BooleanType enableInertiaCorrection;	/**< Specifies whether the working set should be repaired when negative curvature is discovered during hotstart. */
-
-		BooleanType enableDropInfeasibles;		/**< ... */
-		int_t dropBoundPriority;				/**< ... */
-        int_t dropEqConPriority;				/**< ... */
-        int_t dropIneqConPriority;				/**< ... */
-};
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_OPTIONS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.hpp
deleted file mode 100644
index a142151..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.hpp
+++ /dev/null
@@ -1,1079 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/QProblem.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the QProblem class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming.
- */
-
-
-
-#ifndef QPOASES_QPROBLEM_HPP
-#define QPOASES_QPROBLEM_HPP
-
-
-#include <qpOASES/QProblemB.hpp>
-#include <qpOASES/Constraints.hpp>
-#include <qpOASES/ConstraintProduct.hpp>
-#include <qpOASES/Matrices.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Implements the online active set strategy for QPs with general constraints.
- *
- *	A class for setting up and solving quadratic programs. The main feature is
- *	the possibily to use the newly developed online active set strategy for
- * 	parametric quadratic programming.
- *
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-class QProblem : public QProblemB
-{
-	/* allow SolutionAnalysis class to access private members */
-	friend class SolutionAnalysis;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		QProblem( );
-
-		/** Constructor which takes the QP dimension and Hessian type
-		 *  information. If the Hessian is the zero (i.e. HST_ZERO) or the
-		 *  identity matrix (i.e. HST_IDENTITY), respectively, no memory
-		 *  is allocated for it and a NULL pointer can be passed for it
-		 *  to the init() functions. */
-		QProblem(	int_t _nV,	  							/**< Number of variables. */
-					int_t _nC,		  						/**< Number of constraints. */
-					HessianType _hessianType = HST_UNKNOWN	/**< Type of Hessian matrix. */
-					);
-
-		/** Copy constructor (deep copy). */
-		QProblem(	const QProblem& rhs		/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~QProblem( );
-
-		/** Assignment operator (deep copy). */
-		virtual QProblem& operator=(	const QProblem& rhs	/**< Rhs object. */
-								);
-
-
-		/** Clears all data structures of QProblemB except for QP data.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_RESET_FAILED */
-		virtual returnValue reset( );
-
-
-		/** Initialises a QP problem with given QP data and tries to solve it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0    : starts with xOpt = 0, yOpt = 0 and gB/gC empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0    : starts with xOpt, yOpt = 0 and obtain gB/gC by "clipping", \n
-		 *	3. 0,    yOpt, 0    : starts with xOpt = 0, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	4. 0,    0,    gB/gC: starts with xOpt = 0, yOpt = 0 and gB/gC, \n
-		 *	5. xOpt, yOpt, 0    : starts with xOpt, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB/gC: starts with xOpt, yOpt = 0 and gB/gC, \n
-		 *	7. xOpt, yOpt, gB/gC: starts with xOpt, yOpt and gB/gC (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		  *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_TQ \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue init(	SymmetricMatrix *_H,							/**< Hessian matrix (a shallow copy is made). */
-							const real_t* const _g, 						/**< Gradient vector. */
-							Matrix *_A,  									/**< Constraint matrix (a shallow copy is made). */
-							const real_t* const _lb,						/**< Lower bound vector (on variables). \n
-																				 If no lower bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ub,						/**< Upper bound vector (on variables). \n
-																				 If no upper bounds exist, a NULL pointer can be passed. */
-							const real_t* const _lbA,						/**< Lower constraints' bound vector. \n
-																				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ubA,						/**< Upper constraints' bound vector. \n
-																				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR,									/**< Input: Maximum number of working set recalculations when using initial homotopy.
-																				 Output: Number of performed working set recalculations. */
-							real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																				 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,					/**< Optimal primal solution vector. \n
-																				 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,					/**< Optimal dual solution vector. \n
-																				 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const Constraints* const guessedConstraints = 0,/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all constraints are assumed inactive!) */
-							const real_t* const _R = 0						/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix.
-																			 	 The Cholesky factor must be stored in a real_t array of size nV*nV
-																				 in row-major format. Note: Only used if xOpt/yOpt and gB are NULL! \n
-																				 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-
-		/** Initialises a QP problem with given QP data and tries to solve it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0    : starts with xOpt = 0, yOpt = 0 and gB/gC empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0    : starts with xOpt, yOpt = 0 and obtain gB/gC by "clipping", \n
-		 *	3. 0,    yOpt, 0    : starts with xOpt = 0, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	4. 0,    0,    gB/gC: starts with xOpt = 0, yOpt = 0 and gB/gC, \n
-		 *	5. xOpt, yOpt, 0    : starts with xOpt, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB/gC: starts with xOpt, yOpt = 0 and gB/gC, \n
-		 *	7. xOpt, yOpt, gB/gC: starts with xOpt, yOpt and gB/gC (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_TQ \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue init(	const real_t* const _H,							/**< Hessian matrix (a shallow copy is made). \n
-																				 If Hessian matrix is trivial, a NULL pointer can be passed. */
-							const real_t* const _g,							/**< Gradient vector. */
-							const real_t* const _A,							/**< Constraint matrix (a shallow copy is made). */
-							const real_t* const _lb,						/**< Lower bound vector (on variables). \n
-																				 If no lower bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ub,						/**< Upper bound vector (on variables). \n
-																				 If no upper bounds exist, a NULL pointer can be passed. */
-							const real_t* const _lbA,						/**< Lower constraints' bound vector. \n
-																				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ubA,						/**< Upper constraints' bound vector. \n
-																				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR,									/**< Input: Maximum number of working set recalculations when using initial homotopy.
-																				 Output: Number of performed working set recalculations. */
-							real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																				 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,					/**< Optimal primal solution vector. \n
-																				 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,					/**< Optimal dual solution vector. \n
-																				 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const Constraints* const guessedConstraints = 0,/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all constraints are assumed inactive!) */
-							const real_t* const _R = 0						/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix.
-																			 	 The Cholesky factor must be stored in a real_t array of size nV*nV
-																				 in row-major format. Note: Only used if xOpt/yOpt and gB are NULL! \n
-																				 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-		/** Initialises a QP problem with given data to be read from files and solves it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0    : starts with xOpt = 0, yOpt = 0 and gB/gC empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0    : starts with xOpt, yOpt = 0 and obtain gB/gC by "clipping", \n
-		 *	3. 0,    yOpt, 0    : starts with xOpt = 0, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	4. 0,    0,    gB/gC: starts with xOpt = 0, yOpt = 0 and gB/gC, \n
-		 *	5. xOpt, yOpt, 0    : starts with xOpt, yOpt and obtain gB/gC from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB/gC: starts with xOpt, yOpt = 0 and gB/gC, \n
-		 *	7. xOpt, yOpt, gB/gC: starts with xOpt, yOpt and gB/gC (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_TQ \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue init(	const char* const H_file,						/**< Name of file where Hessian matrix is stored. \n
-																				 If Hessian matrix is trivial, a NULL pointer can be passed. */
-							const char* const g_file,						/**< Name of file where gradient vector is stored. */
-							const char* const A_file,						/**< Name of file where constraint matrix is stored. */
-							const char* const lb_file,						/**< Name of file where lower bound vector. \n
-																				 If no lower bounds exist, a NULL pointer can be passed. */
-							const char* const ub_file,						/**< Name of file where upper bound vector. \n
-																				 If no upper bounds exist, a NULL pointer can be passed. */
-							const char* const lbA_file,						/**< Name of file where lower constraints' bound vector. \n
-																				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-							const char* const ubA_file,						/**< Name of file where upper constraints' bound vector. \n
-																				 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR,									/**< Input: Maximum number of working set recalculations when using initial homotopy.
-																				 Output: Number of performed working set recalculations. */
-							real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																				 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,					/**< Optimal primal solution vector. \n
-																				 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,					/**< Optimal dual solution vector. \n
-																				 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const Constraints* const guessedConstraints = 0,/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																				 (If a null pointer is passed, all constraints are assumed inactive!) */
-							const char* const R_file = 0					/**< Name of the file where a pre-computed (upper triangular) Cholesky factor
-																			 	 of the Hessian matrix is stored. \n
-																				 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-
-		/** Solves an initialised QP sequence using the online active set strategy.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This function internally calls solveQP/solveRegularisedQP
-		 *        for solving an initialised QP!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue hotstart(	const real_t* const g_new,						/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const lb_new,						/**< Lower bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,						/**< Upper bounds of neighbouring QP to be solved. \n
-													 							 	 If no upper bounds exist, a NULL pointer can be passed. */
-								const real_t* const lbA_new,					/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const real_t* const ubA_new,					/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-													 							 	 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,									/**< Input: Maximum number of working set recalculations; \n
-																			 		 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																				 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-		/** Solves an initialised QP sequence using the online active set strategy,
-		 *  where QP data is read from files.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This function internally calls solveQP/solveRegularisedQP
-		 *        for solving an initialised QP!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue hotstart(	const char* const g_file,						/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-								const char* const lb_file,					 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower bounds exist, a NULL pointer can be passed. */
-								const char* const ub_file,						/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper bounds exist, a NULL pointer can be passed. */
-								const char* const lbA_file,						/**< Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const char* const ubA_file,						/**< Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR, 									/**< Input: Maximum number of working set recalculations; \n
-																					 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																				 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-
-        /** Solves an equality-constrained QP problem resulting from the current working set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_STEPDIRECTION_FAILED_TQ \n
-		 *			RET_STEPDIRECTION_FAILED_CHOLESKY \n
-		 *			RET_INVALID_ARGUMENTS */
-        returnValue solveCurrentEQP (	const int_t n_rhs,			/**< Number of consecutive right hand sides */
-										const real_t* g_in,			/**< Gradient of neighbouring QP to be solved. */
-										const real_t* lb_in,		/**< Lower bounds of neighbouring QP to be solved. \n
-																		 If no lower bounds exist, a NULL pointer can be passed. */
-										const real_t* ub_in,		/**< Upper bounds of neighbouring QP to be solved. \n
-																		 If no upper bounds exist, a NULL pointer can be passed. */
-										const real_t* lbA_in,		/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-																		 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-										const real_t* ubA_in,		/**< Upper constraints' bounds of neighbouring QP to be solved. \n */
-										real_t* x_out,				/**< Output: Primal solution */
-										real_t* y_out				/**< Output: Dual solution */
-										);
-
-		/** Writes a vector with the state of the working set
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSet(	real_t* workingSet		/** Output: array containing state of the working set. */
-											);
-
-		/** Writes a vector with the state of the working set of bounds
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSetBounds(	real_t* workingSetB		/** Output: array containing state of the working set of bounds. */
-													);
-
-		/** Writes a vector with the state of the working set of constraints
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSetConstraints(	real_t* workingSetC	/** Output: array containing state of the working set of constraints. */
-														);
-
-
-		/** Returns current constraints object of the QP (deep copy).
-		  *	\return SUCCESSFUL_RETURN \n
-		  			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue getConstraints(	Constraints& _constraints	/** Output: Constraints object. */
-											) const;
-
-
-		/** Returns the number of constraints.
-		 *	\return Number of constraints. */
-		inline int_t getNC( ) const;
-
-		/** Returns the number of (implicitly defined) equality constraints.
-		 *	\return Number of (implicitly defined) equality constraints. */
-		inline int_t getNEC( ) const;
-
-		/** Returns the number of active constraints.
-		 *	\return Number of active constraints. */
-		inline int_t getNAC( ) const;
-
-		/** Returns the number of inactive constraints.
-		 *	\return Number of inactive constraints. */
-		inline int_t getNIAC( ) const;
-
-		/** Returns the dimension of null space.
-		 *	\return Dimension of null space. */
-		virtual int_t getNZ( ) const;
-
-
-		/** Returns the dual solution vector (deep copy).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_QP_NOT_SOLVED */
-		virtual returnValue getDualSolution(	real_t* const yOpt	/**< Output: Dual solution vector (if QP has been solved). */
-												) const;
-
-
-		/** Defines user-defined routine for calculating the constraint product A*x
-		 *	\return  SUCCESSFUL_RETURN \n */
-		returnValue setConstraintProduct(	ConstraintProduct* const _constraintProduct
-											);
-
-
-		/** Prints concise list of properties of the current QP.
-		 *	\return  SUCCESSFUL_RETURN \n */
-		virtual returnValue printProperties( );
-
-		/** Set the incoming array to true for each variable entry that is
-			in the set of free variables */
-		returnValue getFreeVariablesFlags( BooleanType* varIsFree );
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const QProblem& rhs	/**< Rhs object. */
-							);
-
-		/** Solves a QProblem whose QP data is assumed to be stored in the member variables.
-		 *  A guess for its primal/dual optimal solution vectors and the corresponding
-		 *  working sets of bounds and constraints can be provided.
-		 *  Note: This function is internally called by all init functions!
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_TQ \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED */
-		returnValue solveInitialQP(	const real_t* const xOpt,						/**< Optimal primal solution vector.*/
-									const real_t* const yOpt,						/**< Optimal dual solution vector. */
-									const Bounds* const guessedBounds,				/**< Optimal working set of bounds for solution (xOpt,yOpt). */
-									const Constraints* const guessedConstraints,	/**< Optimal working set of constraints for solution (xOpt,yOpt). */
-									const real_t* const _R,							/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix. */
-									int_t& nWSR, 									/**< Input: Maximum number of working set recalculations; \n
-																 						 Output: Number of performed working set recalculations. */
-									real_t* const cputime							/**< Input: Maximum CPU time allowed for QP solution. \n
-																			 			 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-									);
-
-		/** Solves QProblem using online active set strategy.
-		 *  Note: This function is internally called by all hotstart functions!
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue solveQP(	const real_t* const g_new,			/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const lb_new,			/**< Lower bounds of neighbouring QP to be solved. \n
-													 			 		 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,			/**< Upper bounds of neighbouring QP to be solved. \n
-													 				 	 If no upper bounds exist, a NULL pointer can be passed. */
-								const real_t* const lbA_new,		/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-													 			 		 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const real_t* const ubA_new,		/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-													 					 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,						/**< Input: Maximum number of working set recalculations; \n
-																 		 Output: Number of performed working set recalculations. */
-								real_t* const cputime,				/**< Input: Maximum CPU time allowed for QP solution. \n
-																	 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								int_t nWSRperformed = 0,			/**< Number of working set recalculations already performed to solve
-																		 this QP within previous solveQP() calls. This number is
-																		 always zero, except for successive calls from solveRegularisedQP()
-																		 or when using the far bound strategy. */
-								BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-								);
-
-
-		/** Solves QProblem using online active set strategy.
-		 *  Note: This function is internally called by all hotstart functions!
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue solveRegularisedQP(	const real_t* const g_new,			/**< Gradient of neighbouring QP to be solved. */
-										const real_t* const lb_new,			/**< Lower bounds of neighbouring QP to be solved. \n
-															 				 	 If no lower bounds exist, a NULL pointer can be passed. */
-										const real_t* const ub_new,			/**< Upper bounds of neighbouring QP to be solved. \n
-															 				 	 If no upper bounds exist, a NULL pointer can be passed. */
-										const real_t* const lbA_new,		/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-															 				 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-										const real_t* const ubA_new,		/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-															 				 	 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-										int_t& nWSR,						/**< Input: Maximum number of working set recalculations; \n
-																		 		 Output: Number of performed working set recalculations. */
-										real_t* const cputime,				/**< Input: Maximum CPU time allowed for QP solution. \n
-																			 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-										int_t nWSRperformed = 0,			/**< Number of working set recalculations already performed to solve
-																				 this QP within previous solveRegularisedQP() calls. This number is
-																				 always zero, except for successive calls when using the far bound strategy. */
-										BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-										);
-
-
-		/** Update activities in a hot start if some of the bounds have
-			become infinity or if variables have become fixed.  */
-		/*	\return SUCCESSFUL_RETURN \n
-					RET_HOTSTART_FAILED */
-		virtual returnValue updateActivitiesForHotstart( const real_t* const lb_new,	/**< New lower bounds. */
-														 const real_t* const ub_new,	/**< New upper bounds. */
-														 const real_t* const lbA_new,	/**< New lower constraints' bounds. */
-														 const real_t* const ubA_new	/**< New upper constraints' bounds. */
-														 );
-
-
-		/** Determines type of existing constraints and bounds (i.e. implicitly fixed, unbounded etc.).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUPSUBJECTTOTYPE_FAILED */
-		virtual returnValue setupSubjectToType( );
-
-		/** Determines type of new constraints and bounds (i.e. implicitly fixed, unbounded etc.).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUPSUBJECTTOTYPE_FAILED */
-		using QProblemB::setupSubjectToType;
-		virtual returnValue setupSubjectToType(	const real_t* const lb_new,		/**< New lower bounds. */
-												const real_t* const ub_new,		/**< New upper bounds. */
-												const real_t* const lbA_new,	/**< New lower constraints' bounds. */
-												const real_t* const ubA_new		/**< New upper constraints' bounds. */
-												);
-
-		/** Computes the Cholesky decomposition of the projected Hessian (i.e. R^T*R = Z^T*H*Z).
-		 *  Note: If Hessian turns out not to be positive definite, the Hessian type
-		 *		  is set to HST_SEMIDEF accordingly.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_HESSIAN_NOT_SPD \n
-		 *			RET_INDEXLIST_CORRUPTED */
-		virtual returnValue computeProjectedCholesky( );
-
-		/** Computes initial Cholesky decomposition of the projected Hessian making
-		 *  use of the function computeCholesky() or computeProjectedCholesky().
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_HESSIAN_NOT_SPD \n
-		 *			RET_INDEXLIST_CORRUPTED */
-		virtual returnValue setupInitialCholesky( );
-
-		/** Initialises TQ factorisation of A (i.e. A*Q = [0 T]) if NO constraint is active.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEXLIST_CORRUPTED */
-		virtual returnValue setupTQfactorisation( );
-
-
-		/** Obtains the desired working set for the auxiliary initial QP in
-		 *  accordance with the user specifications
-		 *  (assumes that member AX has already been initialised!)
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_OBTAINING_WORKINGSET_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue obtainAuxiliaryWorkingSet(	const real_t* const xOpt,						/**< Optimal primal solution vector.
-																								 *	 If a NULL pointer is passed, all entries are assumed to be zero. */
-												const real_t* const yOpt,						/**< Optimal dual solution vector.
-																								 *	 If a NULL pointer is passed, all entries are assumed to be zero. */
-												const Bounds* const guessedBounds,				/**< Guessed working set of bounds for solution (xOpt,yOpt). */
-												const Constraints* const guessedConstraints,	/**< Guessed working set for solution (xOpt,yOpt). */
-												Bounds* auxiliaryBounds,						/**< Input: Allocated bound object. \n
-																								 *	 Ouput: Working set of constraints for auxiliary QP. */
-												Constraints* auxiliaryConstraints				/**< Input: Allocated bound object. \n
-																								 *	 Ouput: Working set for auxiliary QP. */
-												) const;
-
-		/** Sets up bound and constraints data structures according to auxiliaryBounds/Constraints.
-		 *  (If the working set shall be setup afresh, make sure that
-		 *  bounds and constraints data structure have been resetted
-		 *  and the TQ factorisation has been initialised!)
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUP_WORKINGSET_FAILED \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNOWN_BUG */
-		virtual returnValue setupAuxiliaryWorkingSet(	const Bounds* const auxiliaryBounds,			/**< Working set of bounds for auxiliary QP. */
-												const Constraints* const auxiliaryConstraints,	/**< Working set of constraints for auxiliary QP. */
-												BooleanType setupAfresh							/**< Flag indicating if given working set shall be
-																								 *    setup afresh or by updating the current one. */
-												);
-
-		/** Sets up the optimal primal/dual solution of the auxiliary initial QP.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue setupAuxiliaryQPsolution(	const real_t* const xOpt,			/**< Optimal primal solution vector.
-																				 	*	 If a NULL pointer is passed, all entries are set to zero. */
-												const real_t* const yOpt			/**< Optimal dual solution vector.
-																					 *	 If a NULL pointer is passed, all entries are set to zero. */
-												);
-
-		/** Sets up gradient of the auxiliary initial QP for given
-		 *  optimal primal/dual solution and given initial working set
-		 *  (assumes that members X, Y and BOUNDS, CONSTRAINTS have already been initialised!).
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue setupAuxiliaryQPgradient( );
-
-		/** Sets up (constraints') bounds of the auxiliary initial QP for given
-		 *  optimal primal/dual solution and given initial working set
-		 *  (assumes that members X, Y and BOUNDS, CONSTRAINTS have already been initialised!).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNKNOWN_BUG */
-		returnValue setupAuxiliaryQPbounds(	const Bounds* const auxiliaryBounds,			/**< Working set of bounds for auxiliary QP. */
-											const Constraints* const auxiliaryConstraints,	/**< Working set of constraints for auxiliary QP. */
-											BooleanType useRelaxation						/**< Flag indicating if inactive (constraints') bounds shall be relaxed. */
-											);
-
-
-		/** Adds a constraint to active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDCONSTRAINT_FAILED \n
-					RET_ADDCONSTRAINT_FAILED_INFEASIBILITY \n
-					RET_ENSURELI_FAILED */
-		virtual returnValue addConstraint(	int_t number,					/**< Number of constraint to be added to active set. */
-											SubjectToStatus C_status,		/**< Status of new active constraint. */
-											BooleanType updateCholesky,		/**< Flag indicating if Cholesky decomposition shall be updated. */
-											BooleanType ensureLI = BT_TRUE	/**< Ensure linear independence by exchange rules by default. */
-											);
-
-		/** Checks if new active constraint to be added is linearly dependent from
-		 *	from row of the active constraints matrix.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT \n
-					 RET_INDEXLIST_CORRUPTED */
-		virtual returnValue addConstraint_checkLI(	int_t number	/**< Number of constraint to be added to active set. */
-													);
-
-		/** Ensures linear independence of constraint matrix when a new constraint is added.
-		 * 	To this end a bound or constraint is removed simultaneously if necessary.
-		 *	\return	 SUCCESSFUL_RETURN \n
-		 			 RET_LI_RESOLVED \n
-					 RET_ENSURELI_FAILED \n
-					 RET_ENSURELI_FAILED_TQ \n
-					 RET_ENSURELI_FAILED_NOINDEX \n
-					 RET_REMOVE_FROM_ACTIVESET */
-		virtual returnValue addConstraint_ensureLI(	int_t number,				/**< Number of constraint to be added to active set. */
-													SubjectToStatus C_status	/**< Status of new active bound. */
-													);
-
-		/** Adds a bound to active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDBOUND_FAILED \n
-					RET_ADDBOUND_FAILED_INFEASIBILITY \n
-					RET_ENSURELI_FAILED */
-		virtual returnValue addBound(	int_t number,					/**< Number of bound to be added to active set. */
-										SubjectToStatus B_status,		/**< Status of new active bound. */
-										BooleanType updateCholesky,		/**< Flag indicating if Cholesky decomposition shall be updated. */
-										BooleanType ensureLI = BT_TRUE	/**< Ensure linear independence by exchange rules by default. */
-										);
-
-		/** Checks if new active bound to be added is linearly dependent from
-		 *	from row of the active constraints matrix.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT */
-		virtual returnValue addBound_checkLI(	int_t number	/**< Number of bound to be added to active set. */
-												);
-
-		/** Ensures linear independence of constraint matrix when a new bound is added.
-		 *	To this end a bound or constraint is removed simultaneously if necessary.
-		 *	\return	 SUCCESSFUL_RETURN \n
-		 			 RET_LI_RESOLVED \n
-					 RET_ENSURELI_FAILED \n
-					 RET_ENSURELI_FAILED_TQ \n
-					 RET_ENSURELI_FAILED_NOINDEX \n
-					 RET_REMOVE_FROM_ACTIVESET */
-		virtual returnValue addBound_ensureLI(	int_t number,				/**< Number of bound to be added to active set. */
-												SubjectToStatus B_status	/**< Status of new active bound. */
-												);
-
-		/** Removes a constraint from active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_CONSTRAINT_NOT_ACTIVE \n
-					RET_REMOVECONSTRAINT_FAILED \n
-					RET_HESSIAN_NOT_SPD */
-		virtual returnValue removeConstraint(	int_t number,							/**< Number of constraint to be removed from active set. */
-												BooleanType updateCholesky,				/**< Flag indicating if Cholesky decomposition shall be updated. */
-												BooleanType allowFlipping = BT_FALSE,	/**< Flag indicating if flipping bounds are allowed. */
-												BooleanType ensureNZC = BT_FALSE		/**< Flag indicating if non-zero curvature is ensured by exchange rules. */
-												);
-
-		/** Removes a bounds from active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_BOUND_NOT_ACTIVE \n
-					RET_HESSIAN_NOT_SPD \n
-					RET_REMOVEBOUND_FAILED */
-		virtual returnValue removeBound(	int_t number,							/**< Number of bound to be removed from active set. */
-											BooleanType updateCholesky,				/**< Flag indicating if Cholesky decomposition shall be updated. */
-											BooleanType allowFlipping = BT_FALSE,	/**< Flag indicating if flipping bounds are allowed. */
-											BooleanType ensureNZC = BT_FALSE		/**< Flag indicating if non-zero curvature is ensured by exchange rules. */
-											);
-
-
-		/** Performs robustified ratio test yield the maximum possible step length
-		 *  along the homotopy path.
-		 *	\return  SUCCESSFUL_RETURN */
-		returnValue performPlainRatioTest(	int_t nIdx, 						/**< Number of ratios to be checked. */
-											const int_t* const idxList, 		/**< Array containing the indices of all ratios to be checked. */
-											const real_t* const num,	 		/**< Array containing all numerators for performing the ratio test. */
-											const real_t* const den,		 	/**< Array containing all denominators for performing the ratio test. */
-											real_t epsNum,						/**< Numerator tolerance. */
-											real_t epsDen,						/**< Denominator tolerance. */
-											real_t& t,							/**< Output: Maximum possible step length along the homotopy path. */
-											int_t& BC_idx 						/**< Output: Index of blocking constraint. */
-											) const;
-
-
-		/** Ensure non-zero curvature by primal jump.
-		 *  \return SUCCESSFUL_RETURN \n
-		 *          RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue ensureNonzeroCurvature(
-				BooleanType removeBoundNotConstraint,	/**< SubjectTo to be removed is a bound. */
-				int_t remIdx,							/**< Index of bound/constraint to be removed. */
-				BooleanType &exchangeHappened,			/**< Output: Exchange was necessary to ensure. */
-				BooleanType &addBoundNotConstraint,		/**< SubjectTo to be added is a bound. */
-				int_t &addIdx,							/**< Index of bound/constraint to be added. */
-				SubjectToStatus &addStatus				/**< Status of bound/constraint to be added. */
-				);
-
-
-		/** Solves the system Ta = b or T^Ta = b where T is a reverse upper triangular matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_DIV_BY_ZERO */
-		virtual returnValue backsolveT(	const real_t* const b,	/**< Right hand side vector. */
-								BooleanType transposed,	/**< Indicates if the transposed system shall be solved. */
-								real_t* const a 		/**< Output: Solution vector */
-								) const;
-
-
-		/** Determines step direction of the shift of the QP data.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue determineDataShift(	const real_t* const g_new,	/**< New gradient vector. */
-										const real_t* const lbA_new,/**< New lower constraints' bounds. */
-										const real_t* const ubA_new,/**< New upper constraints' bounds. */
-										const real_t* const lb_new,	/**< New lower bounds. */
-										const real_t* const ub_new,	/**< New upper bounds. */
-										real_t* const delta_g,	 	/**< Output: Step direction of gradient vector. */
-										real_t* const delta_lbA,	/**< Output: Step direction of lower constraints' bounds. */
-										real_t* const delta_ubA,	/**< Output: Step direction of upper constraints' bounds. */
-										real_t* const delta_lb,	 	/**< Output: Step direction of lower bounds. */
-										real_t* const delta_ub,	 	/**< Output: Step direction of upper bounds. */
-										BooleanType& Delta_bC_isZero,/**< Output: Indicates if active constraints' bounds are to be shifted. */
-										BooleanType& Delta_bB_isZero/**< Output: Indicates if active bounds are to be shifted. */
-										);
-
-		/** Determines step direction of the homotopy path.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_STEPDIRECTION_FAILED_TQ \n
-					RET_STEPDIRECTION_FAILED_CHOLESKY */
-		virtual returnValue determineStepDirection(	const real_t* const delta_g,	/**< Step direction of gradient vector. */
-											const real_t* const delta_lbA,	/**< Step direction of lower constraints' bounds. */
-											const real_t* const delta_ubA,	/**< Step direction of upper constraints' bounds. */
-											const real_t* const delta_lb,	/**< Step direction of lower bounds. */
-											const real_t* const delta_ub,	/**< Step direction of upper bounds. */
-											BooleanType Delta_bC_isZero, 	/**< Indicates if active constraints' bounds are to be shifted. */
-											BooleanType Delta_bB_isZero,	/**< Indicates if active bounds are to be shifted. */
-											real_t* const delta_xFX, 		/**< Output: Primal homotopy step direction of fixed variables. */
-											real_t* const delta_xFR,	 	/**< Output: Primal homotopy step direction of free variables. */
-											real_t* const delta_yAC, 		/**< Output: Dual homotopy step direction of active constraints' multiplier. */
-											real_t* const delta_yFX 		/**< Output: Dual homotopy step direction of fixed variables' multiplier. */
-											);
-
-		/** Determines the maximum possible step length along the homotopy path
-		 *  and performs this step (without changing working set).
-		 *	\return SUCCESSFUL_RETURN \n
-		 * 			RET_ERROR_IN_CONSTRAINTPRODUCT \n
-		 * 			RET_QP_INFEASIBLE */
-		returnValue performStep(	const real_t* const delta_g,		/**< Step direction of gradient. */
-									const real_t* const delta_lbA,		/**< Step direction of lower constraints' bounds. */
-									const real_t* const delta_ubA,		/**< Step direction of upper constraints' bounds. */
-									const real_t* const delta_lb,	 	/**< Step direction of lower bounds. */
-									const real_t* const delta_ub,	 	/**< Step direction of upper bounds. */
-									const real_t* const delta_xFX, 		/**< Primal homotopy step direction of fixed variables. */
-									const real_t* const delta_xFR,		/**< Primal homotopy step direction of free variables. */
-									const real_t* const delta_yAC,		/**< Dual homotopy step direction of active constraints' multiplier. */
-									const real_t* const delta_yFX,		/**< Dual homotopy step direction of fixed variables' multiplier. */
-									int_t& BC_idx, 						/**< Output: Index of blocking constraint. */
-									SubjectToStatus& BC_status,			/**< Output: Status of blocking constraint. */
-									BooleanType& BC_isBound 			/**< Output: Indicates if blocking constraint is a bound. */
-									);
-
-		/** Updates the active set.
-		 *	\return  SUCCESSFUL_RETURN \n
-		 			 RET_REMOVE_FROM_ACTIVESET_FAILED \n
-					 RET_ADD_TO_ACTIVESET_FAILED */
-		returnValue changeActiveSet(	int_t BC_idx, 						/**< Index of blocking constraint. */
-										SubjectToStatus BC_status,			/**< Status of blocking constraint. */
-										BooleanType BC_isBound 				/**< Indicates if blocking constraint is a bound. */
-										);
-
-
-		/** Compute relative length of homotopy in data space for termination
-		 *  criterion.
-		 *  \return Relative length in data space. */
-		real_t getRelativeHomotopyLength(	const real_t* const g_new,		/**< Final gradient. */
-											const real_t* const lb_new,		/**< Final lower variable bounds. */
-											const real_t* const ub_new,		/**< Final upper variable bounds. */
-											const real_t* const lbA_new,	/**< Final lower constraint bounds. */
-											const real_t* const ubA_new		/**< Final upper constraint bounds. */
-											);
-
-
-		/** Ramping Strategy to avoid ties. Modifies homotopy start without
-		 *  changing current active set.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue performRamping( );
-
-
-		/** ... */
-		returnValue updateFarBounds(	real_t curFarBound,					/**< ... */
-                                        int_t nRamp,						/**< ... */
-                                        const real_t* const lb_new,			/**< ... */
-                                        real_t* const lb_new_far,			/**< ... */
-                                        const real_t* const ub_new,			/**< ... */
-                                        real_t* const ub_new_far,			/**< ... */
-                                        const real_t* const lbA_new,		/**< ... */
-                                        real_t* const lbA_new_far,			/**< ... */
-                                        const real_t* const ubA_new,		/**< ... */
-                                        real_t* const ubA_new_far			/**< ... */
-                                        ) const;
-
-
-		/** Drift correction at end of each active set iteration
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue performDriftCorrection( );
-
-
-		/** Updates QP vectors, working sets and internal data structures in order to
-			start from an optimal solution corresponding to initial guesses of the working
-			set for bounds and constraints.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_SETUP_AUXILIARYQP_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		using QProblemB::setupAuxiliaryQP;
-		virtual returnValue setupAuxiliaryQP(	const Bounds* const guessedBounds,			/**< Initial guess for working set of bounds. */
-												const Constraints* const guessedConstraints	/**< Initial guess for working set of constraints. */
-												);
-
-		/** Determines if it is more efficient to refactorise the matrices when
-		 *  hotstarting or not (i.e. better to update the existing factorisations).
-		 *	\return BT_TRUE iff matrices shall be refactorised afresh
-		 */
-		BooleanType shallRefactorise(	const Bounds* const guessedBounds,			/**< Guessed new working set of bounds. */
-										const Constraints* const guessedConstraints	/**< Guessed new working set of constraints. */
-										) const;
-
-		/** Sets up internal QP data.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNONW_BUG */
-		returnValue setupQPdata(	SymmetricMatrix *_H, 		/**< Hessian matrix. \n
-																     If Hessian matrix is trivial,a NULL pointer can be passed. */
-									const real_t* const _g, 	/**< Gradient vector. */
-									Matrix *_A, 			 	/**< Constraint matrix. */
-									const real_t* const _lb,	/**< Lower bound vector (on variables). \n
-																	 If no lower bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ub,	/**< Upper bound vector (on variables). \n
-																	 If no upper bounds exist, a NULL pointer can be passed. */
-									const real_t* const _lbA,	/**< Lower constraints' bound vector. \n
-																	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ubA	/**< Upper constraints' bound vector. \n
-																	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-									);
-
-
-		/** Sets up dense internal QP data. If the current Hessian is trivial
-		 *  (i.e. HST_ZERO or HST_IDENTITY) but a non-trivial one is given,
-		 *  memory for Hessian is allocated and it is set to the given one.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNONW_BUG */
-		returnValue setupQPdata(	const real_t* const _H, 	/**< Hessian matrix. \n
-																     If Hessian matrix is trivial,a NULL pointer can be passed. */
-									const real_t* const _g, 	/**< Gradient vector. */
-									const real_t* const _A,  	/**< Constraint matrix. */
-									const real_t* const _lb,	/**< Lower bound vector (on variables). \n
-																	 If no lower bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ub,	/**< Upper bound vector (on variables). \n
-																	 If no upper bounds exist, a NULL pointer can be passed. */
-									const real_t* const _lbA,	/**< Lower constraints' bound vector. \n
-																	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ubA	/**< Upper constraints' bound vector. \n
-																	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-									);
-
-		/** Sets up internal QP data by loading it from files. If the current Hessian
-		 *  is trivial (i.e. HST_ZERO or HST_IDENTITY) but a non-trivial one is given,
-		 *  memory for Hessian is allocated and it is set to the given one.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNABLE_TO_OPEN_FILE \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNONW_BUG */
-		returnValue setupQPdataFromFile(	const char* const H_file, 	/**< Name of file where Hessian matrix, of neighbouring QP to be solved, is stored. \n
-																     		 If Hessian matrix is trivial,a NULL pointer can be passed. */
-											const char* const g_file, 	/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-											const char* const A_file,	/**< Name of file where constraint matrix, of neighbouring QP to be solved, is stored. */
-											const char* const lb_file, 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower bounds exist, a NULL pointer can be passed. */
-											const char* const ub_file, 	/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper bounds exist, a NULL pointer can be passed. */
-											const char* const lbA_file, /**< Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-											const char* const ubA_file	/**< Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-											);
-
-		/** Loads new QP vectors from files (internal members are not affected!).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNABLE_TO_OPEN_FILE \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue loadQPvectorsFromFile(	const char* const g_file, 	/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-											const char* const lb_file, 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower bounds exist, a NULL pointer can be passed. */
-											const char* const ub_file, 	/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper bounds exist, a NULL pointer can be passed. */
-											const char* const lbA_file, /**< Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-											const char* const ubA_file, /**< Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-											real_t* const g_new,		/**< Output: Gradient of neighbouring QP to be solved. */
-											real_t* const lb_new,		/**< Output: Lower bounds of neighbouring QP to be solved */
-											real_t* const ub_new,		/**< Output: Upper bounds of neighbouring QP to be solved */
-											real_t* const lbA_new,		/**< Output: Lower constraints' bounds of neighbouring QP to be solved */
-											real_t* const ubA_new		/**< Output: Upper constraints' bounds of neighbouring QP to be solved */
-											) const;
-
-
-		/** Prints concise information on the current iteration.
-		 *	\return  SUCCESSFUL_RETURN \n */
-		returnValue printIteration(	int_t iter,							/**< Number of current iteration. */
-									int_t BC_idx, 						/**< Index of blocking constraint. */
-									SubjectToStatus BC_status,			/**< Status of blocking constraint. */
-									BooleanType BC_isBound,				/**< Indicates if blocking constraint is a bound. */
-									real_t homotopyLength,				/**< Current homotopy distance. */
-									BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-		 							);
-
-
-		/** Sets constraint matrix of the QP. \n
-			Note: Also internal vector Ax is recomputed!
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_INVALID_ARGUMENTS */
-		inline returnValue setA(	Matrix *A_new	/**< New constraint matrix (a shallow copy is made). */
-									);
-
-		/** Sets dense constraint matrix of the QP. \n
-			Note: Also internal vector Ax is recomputed!
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_INVALID_ARGUMENTS */
-		inline returnValue setA(	const real_t* const A_new	/**< New dense constraint matrix (with correct dimension!), a shallow copy is made. */
-									);
-
-
-		/** Sets constraints' lower bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue setLBA(	const real_t* const lbA_new	/**< New constraints' lower bound vector (with correct dimension!). */
-									);
-
-		/** Changes single entry of lower constraints' bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP \n
-		 *			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setLBA(	int_t number,	/**< Number of entry to be changed. */
-									real_t value	/**< New value for entry of lower constraints' bound vector (with correct dimension!). */
-									);
-
-		/** Sets constraints' upper bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue setUBA(	const real_t* const ubA_new	/**< New constraints' upper bound vector (with correct dimension!). */
-									);
-
-		/** Changes single entry of upper constraints' bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP \n
-		 *			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setUBA(	int_t number,	/**< Number of entry to be changed. */
-									real_t value	/**< New value for entry of upper constraints' bound vector (with correct dimension!). */
-									);
-
-
-		/** Drops the blocking bound/constraint that led to infeasibility, or finds another
-		 *  bound/constraint to drop according to drop priorities.
-		 *  \return SUCCESSFUL_RETURN \n
-		 */
-		returnValue dropInfeasibles ( 	int_t BC_number,			/**< Number of the bound or constraint to be added. */
-										SubjectToStatus BC_status, 	/**< New status of the bound or constraint to be added. */
-										BooleanType BC_isBound,		/**< Whether a bound or a constraint is to be added. */
-										real_t *xiB,				/**< (not yet documented) */
-										real_t *xiC					/**< (not yet documented) */
-										);
-
-		/** Decides if lower bounds are smaller than upper bounds
-		 *
-		 * \return SUCCESSFUL_RETURN \n
-		 * 		   RET_QP_INFEASIBLE */
-
-				returnValue areBoundsConsistent(const real_t* const lb,  /**< Vector of lower bounds*/
-												const real_t* const ub,  /**< Vector of upper bounds*/
-												const real_t* const lbA, /**< Vector of lower constraints*/
-												const real_t* const ubA  /**< Vector of upper constraints*/
-												) const;
-
-
-	public:
-		/** ...
-		 *	\return SUCCESSFUL_RETURN  \n
-					RET_UNABLE_TO_OPEN_FILE */
-		returnValue writeQpDataIntoMatFile(	const char* const filename	/**< Mat file name. */
-											) const;
-
-		/** ...
-		 *	\return SUCCESSFUL_RETURN  \n
-					RET_UNABLE_TO_OPEN_FILE */
-		returnValue writeQpWorkspaceIntoMatFile(	const char* const filename	/**< Mat file name. */
-													);
-
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		BooleanType freeConstraintMatrix; 		/**< Flag indicating whether the constraint matrix needs to be de-allocated. */
-		Matrix* A;								/**< Constraint matrix. */
-
-		real_t* lbA;							/**< Lower constraints' bound vector. */
-		real_t* ubA;							/**< Upper constraints' bound vector. */
-
-		Constraints constraints;				/**< Data structure for problem's constraints. */
-
-		real_t* T;								/**< Reverse triangular matrix, A = [0 T]*Q'. */
-		real_t* Q;								/**< Orthonormal quadratic matrix, A = [0 T]*Q'. */
-		int_t sizeT;							/**< Matrix T is stored in a (sizeT x sizeT) array. */
-
-		real_t* Ax;								/**< Stores the current A*x \n
-												 *	 (for increased efficiency only). */
-		real_t* Ax_l;							/**< Stores the current distance to lower constraints' bounds A*x-lbA \n
-												 *	 (for increased efficiency only). */
-		real_t* Ax_u;							/**< Stores the current distance to lower constraints' bounds ubA-A*x \n
-												 *	 (for increased efficiency only). */
-
-		ConstraintProduct* constraintProduct;	/**< Pointer to user-defined constraint product function. */
-
-		real_t* tempA;							/**< Temporary for determineStepDirection. */
-		real_t* tempB;							/**< Temporary for determineStepDirection. */
-		real_t* ZFR_delta_xFRz;					/**< Temporary for determineStepDirection. */
-		real_t* delta_xFRy;						/**< Temporary for determineStepDirection. */
-		real_t* delta_xFRz;						/**< Temporary for determineStepDirection. */
-		real_t* delta_yAC_TMP;					/**< Temporary for determineStepDirection. */
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/QProblem.ipp>
-
-#endif	/* QPOASES_QPROBLEM_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.ipp
deleted file mode 100644
index c7d2a14..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblem.ipp
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/QProblem.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the QProblem class which
- *	is able to use the newly developed online active set strategy for
- *	parametric quadratic programming.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	g e t C o n s t r a i n t s
- */
-inline returnValue QProblem::getConstraints( Constraints& _constraints ) const
-{
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	_constraints = constraints;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	g e t N C
- */
-inline int_t QProblem::getNC( ) const
-{
-	return constraints.getNC( );
-}
-
-
-/*
- *	g e t N E C
- */
-inline int_t QProblem::getNEC( ) const
-{
-	return constraints.getNEC( );
-}
-
-
-/*
- *	g e t N A C
- */
-inline int_t QProblem::getNAC( ) const
-{
-	return constraints.getNAC( );
-}
-
-
-/*
- *	g e t N I A C
- */
-inline int_t QProblem::getNIAC( ) const
-{
-	return constraints.getNIAC( );
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-
-/*
- *	s e t A
- */
-inline returnValue QProblem::setA( Matrix *A_new )
-{
-	int_t j;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( A_new == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* Set constraint matrix AND update member AX. */
-	if ( ( freeConstraintMatrix == BT_TRUE ) && ( A != 0 ) )
-	{
-		delete A;
-		A = 0;
-	}
-	A = A_new;
-	freeConstraintMatrix = BT_FALSE;
-
-	A->times(1, 1.0, x, nV, 0.0, Ax, nC);
-
-	for( j=0; j<nC; ++j )
-	{
-		Ax_u[j] = ubA[j] - Ax[j];
-		Ax_l[j] = Ax[j] - lbA[j];
-		/* AW: TODO: Takes too much time - could be implemented differently
-		// (ckirches) disable constraints with empty rows	
-		*/
-		if ( isZero( A->getRowNorm (j) ) == BT_TRUE )
-			constraints.setType ( j, ST_DISABLED );
-	}
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t A
- */
-inline returnValue QProblem::setA( const real_t* const A_new )
-{
-	int_t j;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-	DenseMatrix* dA;
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( A_new == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* Set constraint matrix AND update member AX. */
-	if ( ( freeConstraintMatrix == BT_TRUE ) && ( A != 0 ) )
-	{
-		delete A;
-		A = 0;
-	}
-	A = dA = new DenseMatrix(nC, nV, nV, (real_t*) A_new);
-	freeConstraintMatrix = BT_TRUE;
-
-	A->times(1, 1.0, x, nV, 0.0, Ax, nC);
-
-	for( j=0; j<nC; ++j )
-	{
-		Ax_u[j] = ubA[j] - Ax[j];
-		Ax_l[j] = Ax[j] - lbA[j];
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t L B A
- */
-inline returnValue QProblem::setLBA( const real_t* const lbA_new )
-{
-	uint_t i;
-	uint_t nV = (uint_t)getNV( );
-	uint_t nC = (uint_t)getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( lbA_new != 0 )
-	{	
-		memcpy( lbA,lbA_new,nC*sizeof(real_t) );
-	}
-	else
-	{
-		/* if no lower constraints' bounds are specified, set them to -infinity */
-		for( i=0; i<nC; ++i )
-			lbA[i] = -INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t L B A
- */
-inline returnValue QProblem::setLBA( int_t number, real_t value )
-{
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ( number >= 0 ) && ( number < nC ) )
-	{
-		lbA[number] = value;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-}
-
-
-/*
- *	s e t U B A
- */
-inline returnValue QProblem::setUBA( const real_t* const ubA_new )
-{
-	uint_t i;
-	uint_t nV = (uint_t)getNV( );
-	uint_t nC = (uint_t)getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ubA_new != 0 )
-	{
-		memcpy( ubA,ubA_new,nC*sizeof(real_t) );
-	}
-	else
-	{
-		/* if no upper constraints' bounds are specified, set them to infinity */
-		for( i=0; i<nC; ++i )
-			ubA[i] = INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t U B A
- */
-inline returnValue QProblem::setUBA( int_t number, real_t value )
-{
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ( number >= 0 ) && ( number < nC ) )
-	{
-		ubA[number] = value;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.hpp
deleted file mode 100644
index 4801d06..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.hpp
+++ /dev/null
@@ -1,1020 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/QProblemB.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the QProblemB class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming
- *	for problems with (simple) bounds only.
- */
-
-
-
-#ifndef QPOASES_QPROBLEMB_HPP
-#define QPOASES_QPROBLEMB_HPP
-
-
-#include <qpOASES/Flipper.hpp>
-#include <qpOASES/Options.hpp>
-#include <qpOASES/Matrices.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-class SolutionAnalysis;
-
-/**
- *	\brief Implements the online active set strategy for box-constrained QPs.
- *
- *	Class for setting up and solving quadratic programs with bounds (= box constraints) only.
- *	The main feature is the possibily to use the newly developed online active set strategy
- *	for parametric quadratic programming.
- *
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-class QProblemB
-{
-	/* allow SolutionAnalysis class to access private members */
-	friend class SolutionAnalysis;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		QProblemB( );
-
-		/** Constructor which takes the QP dimension and Hessian type
-		 *  information. If the Hessian is the zero (i.e. HST_ZERO) or the
-		 *  identity matrix (i.e. HST_IDENTITY), respectively, no memory
-		 *  is allocated for it and a NULL pointer can be passed for it
-		 *  to the init() functions. */
-		QProblemB(	int_t _nV,								/**< Number of variables. */
-					HessianType _hessianType = HST_UNKNOWN	/**< Type of Hessian matrix. */
-					);
-
-		/** Copy constructor (deep copy). */
-		QProblemB(	const QProblemB& rhs	/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~QProblemB( );
-
-		/** Assignment operator (deep copy). */
-		virtual QProblemB& operator=(	const QProblemB& rhs	/**< Rhs object. */
-								);
-
-
-		/** Clears all data structures of QProblemB except for QP data.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_RESET_FAILED */
-		virtual returnValue reset( );
-
-
-		/** Initialises a simply bounded QP problem with given QP data and tries to solve it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0 : starts with xOpt = 0, yOpt = 0 and gB empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0 : starts with xOpt, yOpt = 0 and obtain gB by "clipping", \n
-		 *	3. 0,    yOpt, 0 : starts with xOpt = 0, yOpt and obtain gB from yOpt != 0, \n
-		 *	4. 0,    0,    gB: starts with xOpt = 0, yOpt = 0 and gB, \n
-		 *	5. xOpt, yOpt, 0 : starts with xOpt, yOpt and obtain gB from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB: starts with xOpt, yOpt = 0 and gB, \n
-		 *	7. xOpt, yOpt, gB: starts with xOpt, yOpt and gB (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue init(	SymmetricMatrix *_H,					/**< Hessian matrix (a shallow copy is made). */
-							const real_t* const _g,					/**< Gradient vector. */
-							const real_t* const _lb,				/**< Lower bounds (on variables). \n
-																		 If no lower bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ub,				/**< Upper bounds (on variables). \n
-																		 If no upper bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR, 							/**< Input: Maximum number of working set recalculations when using initial homotopy. \n
-																		 Output: Number of performed working set recalculations. */
-				 			real_t* const cputime = 0,				/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																		 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,			/**< Optimal primal solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,			/**< Optimal dual solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,	/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																		 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const real_t* const _R = 0				/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix.
-																	 	 The Cholesky factor must be stored in a real_t array of size nV*nV
-																		 in row-major format. Note: Only used if xOpt/yOpt and gB are NULL! \n
-																		 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-		/** Initialises a simply bounded QP problem with given QP data and tries to solve it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0 : starts with xOpt = 0, yOpt = 0 and gB empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0 : starts with xOpt, yOpt = 0 and obtain gB by "clipping", \n
-		 *	3. 0,    yOpt, 0 : starts with xOpt = 0, yOpt and obtain gB from yOpt != 0, \n
-		 *	4. 0,    0,    gB: starts with xOpt = 0, yOpt = 0 and gB, \n
-		 *	5. xOpt, yOpt, 0 : starts with xOpt, yOpt and obtain gB from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB: starts with xOpt, yOpt = 0 and gB, \n
-		 *	7. xOpt, yOpt, gB: starts with xOpt, yOpt and gB (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue init(	const real_t* const _H, 				/**< Hessian matrix (a shallow copy is made). \n
-																		 If Hessian matrix is trivial, a NULL pointer can be passed. */
-							const real_t* const _g,					/**< Gradient vector. */
-							const real_t* const _lb,				/**< Lower bounds (on variables). \n
-																		 If no lower bounds exist, a NULL pointer can be passed. */
-							const real_t* const _ub,				/**< Upper bounds (on variables). \n
-																		 If no upper bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR, 							/**< Input: Maximum number of working set recalculations when using initial homotopy. \n
-																		 Output: Number of performed working set recalculations. */
-				 			real_t* const cputime = 0,				/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																		 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,			/**< Optimal primal solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,			/**< Optimal dual solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,	/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																		 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const real_t* const _R = 0				/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix.
-																	 	 The Cholesky factor must be stored in a real_t array of size nV*nV
-																		 in row-major format. Note: Only used if xOpt/yOpt and gB are NULL! \n
-																		 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-		/** Initialises a simply bounded QP problem with given QP data to be read from files and solves it
-		 *	using at most nWSR iterations. Depending on the parameter constellation it: \n
-		 *	1. 0,    0,    0 : starts with xOpt = 0, yOpt = 0 and gB empty (or all implicit equality bounds), \n
-		 *	2. xOpt, 0,    0 : starts with xOpt, yOpt = 0 and obtain gB by "clipping", \n
-		 *	3. 0,    yOpt, 0 : starts with xOpt = 0, yOpt and obtain gB from yOpt != 0, \n
-		 *	4. 0,    0,    gB: starts with xOpt = 0, yOpt = 0 and gB, \n
-		 *	5. xOpt, yOpt, 0 : starts with xOpt, yOpt and obtain gB from yOpt != 0, \n
-		 *	6. xOpt, 0,    gB: starts with xOpt, yOpt = 0 and gB, \n
-		 *	7. xOpt, yOpt, gB: starts with xOpt, yOpt and gB (assume them to be consistent!)
-		 *
-		 *  Note: This function internally calls solveInitialQP for initialisation!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED \n
-					RET_UNABLE_TO_READ_FILE */
-		returnValue init(	const char* const H_file,				/**< Name of file where Hessian matrix is stored. \n
-																		 If Hessian matrix is trivial, a NULL pointer can be passed. */
-							const char* const g_file,				/**< Name of file where gradient vector is stored. */
-							const char* const lb_file,				/**< Name of file where lower bound vector. \n
-																		 If no lower bounds exist, a NULL pointer can be passed. */
-							const char* const ub_file,				/**< Name of file where upper bound vector. \n
-																		 If no upper bounds exist, a NULL pointer can be passed. */
-							int_t& nWSR, 							/**< Input: Maximum number of working set recalculations when using initial homotopy. \n
-																		 Output: Number of performed working set recalculations. */
-				 			real_t* const cputime = 0,				/**< Input: Maximum CPU time allowed for QP initialisation. \n
-																		 Output: CPU time spent for QP initialisation (if pointer passed). */
-							const real_t* const xOpt = 0,			/**< Optimal primal solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old primal solution is kept!) */
-							const real_t* const yOpt = 0,			/**< Optimal dual solution vector. A NULL pointer can be passed. \n
-																		 (If a null pointer is passed, the old dual solution is kept!) */
-							const Bounds* const guessedBounds = 0,	/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																		 (If a null pointer is passed, all bounds are assumed inactive!) */
-							const char* const R_file = 0			/**< Name of the file where a pre-computed (upper triangular) Cholesky factor
-																		 of the Hessian matrix is stored. \n
-																		 (If a null pointer is passed, Cholesky decomposition is computed internally!) */
-							);
-
-
-		/** Solves an initialised QP sequence using the online active set strategy.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This function internally calls solveQP/solveRegularisedQP
-		 *        for solving an initialised QP!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_MAX_NWSR_REACHED \n
-					RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_SETUP_AUXILIARYQP_FAILED */
-		returnValue hotstart(	const real_t* const g_new,				/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const lb_new,				/**< Lower bounds of neighbouring QP to be solved. \n
-													 						 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,				/**< Upper bounds of neighbouring QP to be solved. \n
-													 						 If no upper bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,							/**< Input: Maximum number of working set recalculations; \n
-																			 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,				/**< Input: Maximum CPU time allowed for QP solution. \n
-																			 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0	/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																			 (If a null pointer is passed, the previous working set is kept!) */
-								);
-
-		/** Solves an initialised QP sequence using the online active set strategy,
-		 *  where QP data is read from files.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This function internally calls solveQP/solveRegularisedQP
-		 *        for solving an initialised QP!
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_SETUP_AUXILIARYQP_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue hotstart(	const char* const g_file, 				/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-								const char* const lb_file,				/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-													 						 If no lower bounds exist, a NULL pointer can be passed. */
-								const char* const ub_file,				/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-													 						 If no upper bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR, 							/**< Input: Maximum number of working set recalculations; \n
-																			 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,			 	/**< Input: Maximum CPU time allowed for QP solution. \n
-																			 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0	/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																			 (If a null pointer is passed, the previous working set is kept!) */
-								);
-
-
-		/** Writes a vector with the state of the working set
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSet(	real_t* workingSet				/** Output: array containing state of the working set. */
-											);
-
-		/** Writes a vector with the state of the working set of bounds
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSetBounds(	real_t* workingSetB		/** Output: array containing state of the working set of bounds. */
-													);
-
-		/** Writes a vector with the state of the working set of constraints
-		 *	\return SUCCESSFUL_RETURN \n
-		 *	        RET_INVALID_ARGUMENTS */
-		virtual returnValue getWorkingSetConstraints(	real_t* workingSetC	/** Output: array containing state of the working set of constraints. */
-														);
-
-
-		/** Returns current bounds object of the QP (deep copy).
-		  *	\return SUCCESSFUL_RETURN \n
-		  			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue getBounds(	Bounds& _bounds	/** Output: Bounds object. */
-										) const;
-
-
-		/** Returns the number of variables.
-		 *	\return Number of variables. */
-		inline int_t getNV( ) const;
-
-		/** Returns the number of free variables.
-		 *	\return Number of free variables. */
-		inline int_t getNFR( ) const;
-
-		/** Returns the number of fixed variables.
-		 *	\return Number of fixed variables. */
-		inline int_t getNFX( ) const;
-
-		/** Returns the number of implicitly fixed variables.
-		 *	\return Number of implicitly fixed variables. */
-		inline int_t getNFV( ) const;
-
-		/** Returns the dimension of null space.
-		 *	\return Dimension of null space. */
-		virtual int_t getNZ( ) const;
-
-
-		/** Returns the optimal objective function value.
-		 *	\return finite value: Optimal objective function value (QP was solved) \n
-		 			+infinity:	  QP was not yet solved */
-		real_t getObjVal( ) const;
-
-		/** Returns the objective function value at an arbitrary point x.
-		 *	\return Objective function value at point x */
-		real_t getObjVal(	const real_t* const _x	/**< Point at which the objective function shall be evaluated. */
-							) const;
-
-		/** Returns the primal solution vector.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_QP_NOT_SOLVED */
-		returnValue getPrimalSolution(	real_t* const xOpt			/**< Output: Primal solution vector (if QP has been solved). */
-										) const;
-
-		/** Returns the dual solution vector.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_QP_NOT_SOLVED */
-		virtual returnValue getDualSolution(	real_t* const yOpt	/**< Output: Dual solution vector (if QP has been solved). */
-												) const;
-
-
-		/** Returns status of the solution process.
-		 *	\return Status of solution process. */
-		inline QProblemStatus getStatus( ) const;
-
-
-		/** Returns if the QProblem object is initialised.
-		 *	\return BT_TRUE:  QProblemB initialised \n
-		 			BT_FALSE: QProblemB not initialised */
-		inline BooleanType isInitialised( ) const;
-
-		/** Returns if the QP has been solved.
-		 *	\return BT_TRUE:  QProblemB solved \n
-		 			BT_FALSE: QProblemB not solved */
-		inline BooleanType isSolved( ) const;
-
-		/** Returns if the QP is infeasible.
-		 *	\return BT_TRUE:  QP infeasible \n
-		 			BT_FALSE: QP feasible (or not known to be infeasible!) */
-		inline BooleanType isInfeasible( ) const;
-
-		/** Returns if the QP is unbounded.
-		 *	\return BT_TRUE:  QP unbounded \n
-		 			BT_FALSE: QP unbounded (or not known to be unbounded!) */
-		inline BooleanType isUnbounded( ) const;
-
-
-		/** Returns Hessian type flag (type is not determined due to this call!).
-		 *	\return Hessian type. */
-		inline HessianType getHessianType( ) const;
-
-		/** Changes the print level.
- 		 *	\return SUCCESSFUL_RETURN */
-		inline returnValue setHessianType(	HessianType _hessianType /**< New Hessian type. */
-											);
-
-		/** Returns if the QP has been internally regularised.
-		 *	\return BT_TRUE:  Hessian is internally regularised for QP solution \n
-		 			BT_FALSE: No internal Hessian regularisation is used for QP solution */
-		inline BooleanType usingRegularisation( ) const;
-
-		/** Returns current options struct.
-		 *	\return Current options struct. */
-		inline Options getOptions( ) const;
-
-		/** Overrides current options with given ones.
- 		 *	\return SUCCESSFUL_RETURN */
-		inline returnValue setOptions(	const Options& _options	/**< New options. */
-										);
-
-		/** Returns the print level.
-		 *	\return Print level. */
-		inline PrintLevel getPrintLevel( ) const;
-
-		/** Changes the print level.
- 		 *	\return SUCCESSFUL_RETURN */
-		returnValue setPrintLevel(	PrintLevel _printlevel	/**< New print level. */
-									);
-
-
-		/** Returns the current number of QP problems solved.
-		 *	\return Number of QP problems solved. */
-		inline uint_t getCount( ) const;
-
-		/** Resets QP problem counter (to zero).
-		 *	\return SUCCESSFUL_RETURN. */
-		inline returnValue resetCounter( );
-
-
-		/** Prints concise list of properties of the current QP.
-		 *	\return  SUCCESSFUL_RETURN \n */
-		virtual returnValue printProperties( );
-
-		/** Prints a list of all options and their current values.
-		 *	\return  SUCCESSFUL_RETURN \n */
-		returnValue printOptions( ) const;
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const QProblemB& rhs	/**< Rhs object. */
-							);
-
-		/** If Hessian type has been set by the user, nothing is done.
-		 *  Otherwise the Hessian type is set to HST_IDENTITY, HST_ZERO, or
-		 *  HST_POSDEF (default), respectively.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HESSIAN_INDEFINITE */
-		returnValue determineHessianType( );
-
-		/** Determines type of existing constraints and bounds (i.e. implicitly fixed, unbounded etc.).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUPSUBJECTTOTYPE_FAILED */
-		virtual returnValue setupSubjectToType( );
-
-		/** Determines type of new constraints and bounds (i.e. implicitly fixed, unbounded etc.).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUPSUBJECTTOTYPE_FAILED */
-		virtual returnValue setupSubjectToType(	const real_t* const lb_new,	/**< New lower bounds. */
-												const real_t* const ub_new	/**< New upper bounds. */
-												);
-
-		/** Computes the Cholesky decomposition of the (simply projected) Hessian
-		 *  (i.e. R^T*R = Z^T*H*Z). It only works in the case where Z is a simple
-		 *  projection matrix!
-		 *  Note: If Hessian turns out not to be positive definite, the Hessian type
-		 *		  is set to HST_SEMIDEF accordingly.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_HESSIAN_NOT_SPD \n
-		 *			RET_INDEXLIST_CORRUPTED */
-		virtual returnValue computeCholesky( );
-
-
-		/** Computes initial Cholesky decomposition of the (simply projected) Hessian
-		 *  making use of the function computeCholesky().
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_HESSIAN_NOT_SPD \n
-		 *			RET_INDEXLIST_CORRUPTED */
-		virtual returnValue setupInitialCholesky( );
-
-		/** Obtains the desired working set for the auxiliary initial QP in
-		 *  accordance with the user specifications
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_OBTAINING_WORKINGSET_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue obtainAuxiliaryWorkingSet(	const real_t* const xOpt,			/**< Optimal primal solution vector.
-																					 *	 If a NULL pointer is passed, all entries are assumed to be zero. */
-												const real_t* const yOpt,			/**< Optimal dual solution vector.
-																					 *	 If a NULL pointer is passed, all entries are assumed to be zero. */
-												const Bounds* const guessedBounds,	/**< Guessed working set for solution (xOpt,yOpt). */
-												Bounds* auxiliaryBounds				/**< Input: Allocated bound object. \n
-																					 *	 Output: Working set for auxiliary QP. */
-												) const;
-
-		/** Decides if lower bounds are smaller than upper bounds
-		 *
-		 * \return SUCCESSFUL_RETURN \n
-		 * 		   RET_QP_INFEASIBLE */
-
-		returnValue areBoundsConsistent(const real_t* const lb, /**< Vector of lower bounds*/
-										const real_t* const ub  /**< Vector of upper bounds*/
-										) const;
-
-		/** Solves the system Ra = b or R^Ta = b where R is an upper triangular matrix.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_DIV_BY_ZERO */
-		virtual returnValue backsolveR(	const real_t* const b,	/**< Right hand side vector. */
-								BooleanType transposed,	/**< Indicates if the transposed system shall be solved. */
-								real_t* const a 		/**< Output: Solution vector */
-								) const;
-
-		/** Solves the system Ra = b or R^Ta = b where R is an upper triangular matrix. \n
-		 *  Special variant for the case that this function is called from within "removeBound()".
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_DIV_BY_ZERO */
-		virtual returnValue backsolveR(	const real_t* const b,		/**< Right hand side vector. */
-								BooleanType transposed,		/**< Indicates if the transposed system shall be solved. */
-								BooleanType removingBound,	/**< Indicates if function is called from "removeBound()". */
-								real_t* const a 			/**< Output: Solution vector */
-								) const;
-
-
-		/** Determines step direction of the shift of the QP data.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue determineDataShift(	const real_t* const g_new,	/**< New gradient vector. */
-										const real_t* const lb_new,	/**< New lower bounds. */
-										const real_t* const ub_new,	/**< New upper bounds. */
-										real_t* const delta_g,	 	/**< Output: Step direction of gradient vector. */
-										real_t* const delta_lb,	 	/**< Output: Step direction of lower bounds. */
-										real_t* const delta_ub,	 	/**< Output: Step direction of upper bounds. */
-										BooleanType& Delta_bB_isZero/**< Output: Indicates if active bounds are to be shifted. */
-										);
-
-
-		/** Sets up internal QP data.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INVALID_ARGUMENTS */
-		returnValue setupQPdata(	SymmetricMatrix *_H,	 	/**< Hessian matrix.*/
-									const real_t* const _g,		/**< Gradient vector. */
-									const real_t* const _lb,	/**< Lower bounds (on variables). \n
-																	 If no lower bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ub		/**< Upper bounds (on variables). \n
-																	 If no upper bounds exist, a NULL pointer can be passed. */
-									);
-
-		/** Sets up internal QP data. If the current Hessian is trivial
-		 *  (i.e. HST_ZERO or HST_IDENTITY) but a non-trivial one is given,
-		 *  memory for Hessian is allocated and it is set to the given one.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INVALID_ARGUMENTS \n
-					RET_NO_HESSIAN_SPECIFIED */
-		returnValue setupQPdata(	const real_t* const _H, 	/**< Hessian matrix. \n
-																     If Hessian matrix is trivial,a NULL pointer can be passed. */
-									const real_t* const _g,		/**< Gradient vector. */
-									const real_t* const _lb,	/**< Lower bounds (on variables). \n
-																	 If no lower bounds exist, a NULL pointer can be passed. */
-									const real_t* const _ub		/**< Upper bounds (on variables). \n
-																	 If no upper bounds exist, a NULL pointer can be passed. */
-									);
-
-		/** Sets up internal QP data by loading it from files. If the current Hessian
-		 *  is trivial (i.e. HST_ZERO or HST_IDENTITY) but a non-trivial one is given,
-		 *  memory for Hessian is allocated and it is set to the given one.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNABLE_TO_OPEN_FILE \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS \n
-					RET_NO_HESSIAN_SPECIFIED */
-		returnValue setupQPdataFromFile(	const char* const H_file, 	/**< Name of file where Hessian matrix, of neighbouring QP to be solved, is stored. \n
-																     		 If Hessian matrix is trivial,a NULL pointer can be passed. */
-											const char* const g_file, 	/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-											const char* const lb_file, 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower bounds exist, a NULL pointer can be passed. */
-											const char* const ub_file 	/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper bounds exist, a NULL pointer can be passed. */
-											);
-
-		/** Loads new QP vectors from files (internal members are not affected!).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNABLE_TO_OPEN_FILE \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue loadQPvectorsFromFile(	const char* const g_file, 	/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-											const char* const lb_file, 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no lower bounds exist, a NULL pointer can be passed. */
-											const char* const ub_file, 	/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-												 			 				 If no upper bounds exist, a NULL pointer can be passed. */
-											real_t* const g_new,		/**< Output: Gradient of neighbouring QP to be solved. */
-											real_t* const lb_new,		/**< Output: Lower bounds of neighbouring QP to be solved */
-											real_t* const ub_new		/**< Output: Upper bounds of neighbouring QP to be solved */
-											) const;
-
-
-		/** Sets internal infeasibility flag and throws given error in case the far bound
-		 *	strategy is not enabled (as QP might actually not be infeasible in this case).
-		 *	\return RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_ENSURELI_FAILED_CYCLING \n
-					RET_ENSURELI_FAILED_NOINDEX */
-		returnValue setInfeasibilityFlag(	returnValue returnvalue,			/**< Returnvalue to be tunneled. */
-											BooleanType doThrowError = BT_FALSE	/**< Flag forcing to throw an error. */
-											);
-
-
-		/** Determines if next QP iteration can be performed within given CPU time limit.
-		 *	\return BT_TRUE: CPU time limit is exceeded, stop QP solution. \n
-					BT_FALSE: Sufficient CPU time for next QP iteration. */
-		BooleanType isCPUtimeLimitExceeded(	const real_t* const cputime,	/**< Maximum CPU time allowed for QP solution. */
-											real_t starttime,				/**< Start time of current QP solution. */
-											int_t nWSR						/**< Number of working set recalculations performed so far. */
-											) const;
-
-
-		/** Regularise Hessian matrix by adding a scaled identity matrix to it.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HESSIAN_ALREADY_REGULARISED */
-		returnValue regulariseHessian( );
-
-
-		/** Sets Hessian matrix of the QP.
-		 *	\return SUCCESSFUL_RETURN */
-		inline returnValue setH(	SymmetricMatrix* H_new	/**< New Hessian matrix (a shallow copy is made). */
-									);
-
-		/** Sets dense Hessian matrix of the QP.
-		 *  If a null pointer is passed and
-		 *  a) hessianType is HST_IDENTITY, nothing is done,
-		 *  b) hessianType is not HST_IDENTITY, Hessian matrix is set to zero.
-		 *	\return SUCCESSFUL_RETURN */
-		inline returnValue setH(	const real_t* const H_new	/**< New dense Hessian matrix (with correct dimension!), a shallow copy is made. */
-									);
-
-		/** Changes gradient vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_INVALID_ARGUMENTS */
-		inline returnValue setG(	const real_t* const g_new	/**< New gradient vector (with correct dimension!). */
-									);
-
-		/** Changes lower bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue setLB(	const real_t* const lb_new	/**< New lower bound vector (with correct dimension!). */
-									);
-
-		/** Changes single entry of lower bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP \n
-		 *			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setLB(	int_t number,	/**< Number of entry to be changed. */
-									real_t value	/**< New value for entry of lower bound vector. */
-									);
-
-		/** Changes upper bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP */
-		inline returnValue setUB(	const real_t* const ub_new	/**< New upper bound vector (with correct dimension!). */
-									);
-
-		/** Changes single entry of upper bound vector of the QP.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QPOBJECT_NOT_SETUP \n
-		 *			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setUB(	int_t number,	/**< Number of entry to be changed. */
-									real_t value	/**< New value for entry of upper bound vector. */
-									);
-
-
-		/** Computes parameters for the Givens matrix G for which [x,y]*G = [z,0]
-		 *	\return SUCCESSFUL_RETURN */
-		inline void computeGivens(	real_t xold,	/**< Matrix entry to be normalised. */
-									real_t yold,	/**< Matrix entry to be annihilated. */
-									real_t& xnew,	/**< Output: Normalised matrix entry. */
-									real_t& ynew,	/**< Output: Annihilated matrix entry. */
-									real_t& c,		/**< Output: Cosine entry of Givens matrix. */
-									real_t& s 		/**< Output: Sine entry of Givens matrix. */
-									) const;
-
-		/** Applies Givens matrix determined by c and s (cf. computeGivens).
-		 *	\return SUCCESSFUL_RETURN */
-		inline void applyGivens(	real_t c,		/**< Cosine entry of Givens matrix. */
-									real_t s,		/**< Sine entry of Givens matrix. */
-									real_t nu, 		/**< Further factor: s/(1+c). */
-									real_t xold,	/**< Matrix entry to be transformed corresponding to
-													 *	 the normalised entry of the original matrix. */
-									real_t yold, 	/**< Matrix entry to be transformed corresponding to
-													 *	 the annihilated entry of the original matrix. */
-									real_t& xnew,	/**< Output: Transformed matrix entry corresponding to
-													 *	 the normalised entry of the original matrix. */
-									real_t& ynew	/**< Output: Transformed matrix entry corresponding to
-													 *	 the annihilated entry of the original matrix. */
-									) const;
-
-
-
-		/** Compute relative length of homotopy in data space for termination
-		 *  criterion.
-		 *  \return Relative length in data space. */
-		real_t getRelativeHomotopyLength(	const real_t* const g_new,		/**< Final gradient. */
-											const real_t* const lb_new,		/**< Final lower variable bounds. */
-											const real_t* const ub_new		/**< Final upper variable bounds. */
-											);
-
-		/** Ramping Strategy to avoid ties. Modifies homotopy start without
-		 *  changing current active set.
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue performRamping( );
-
-
-		/** ... */
-		returnValue updateFarBounds(	real_t curFarBound,					/**< ... */
-                                        int_t nRamp,						/**< ... */
-                                        const real_t* const lb_new,			/**< ... */
-                                        real_t* const lb_new_far,			/**< ... */
-                                        const real_t* const ub_new,			/**< ... */
-                                        real_t* const ub_new_far			/**< ... */
-                                        ) const;
-
-
-		/** Performs robustified ratio test yield the maximum possible step length
-		 *  along the homotopy path.
-		 *	\return  SUCCESSFUL_RETURN */
-		returnValue performRatioTest(	int_t nIdx, 						/**< Number of ratios to be checked. */
-										const int_t* const idxList, 		/**< Array containing the indices of all ratios to be checked. */
-										const SubjectTo* const subjectTo,	/**< Bound/Constraint object corresponding to ratios to be checked. */
-										const real_t* const num,	 		/**< Array containing all numerators for performing the ratio test. */
-										const real_t* const den,		 	/**< Array containing all denominators for performing the ratio test. */
-										real_t epsNum,						/**< Numerator tolerance. */
-										real_t epsDen,						/**< Denominator tolerance. */
-										real_t& t,							/**< Output: Maximum possible step length along the homotopy path. */
-										int_t& BC_idx 						/**< Output: Index of blocking constraint. */
-										) const;
-
-		/** Checks whether given ratio is blocking, i.e. limits the maximum step length
-		 *  along the homotopy path to a value lower than given one.
-		 *	\return  SUCCESSFUL_RETURN */
-		inline BooleanType isBlocking(	real_t num,					 		/**< Numerator for performing the ratio test. */
-										real_t den,		 					/**< Denominator for performing the ratio test. */
-										real_t epsNum,						/**< Numerator tolerance. */
-										real_t epsDen,						/**< Denominator tolerance. */
-										real_t& t							/**< Input: Current maximum step length along the homotopy path,
-																			 *   Output: Updated maximum possible step length along the homotopy path. */
-										) const;
-
-
-		/** Creates a sparse diagonal (square-)matrix which is a given
-		 *  multiple of the identity matrix.
-		 *  \return Diagonal matrix \n
-		 */
-		SymSparseMat* createDiagSparseMat(	int_t n,				/**< Row/column dimension of matrix to be created. */
-											real_t diagVal = 1.0	/**< Value of all diagonal entries. */
-											);
-
-
-	/*
-	 *	PRIVATE MEMBER FUNCTIONS
-	 */
-	private:
-		/** Solves a QProblemB whose QP data is assumed to be stored in the member variables.
-		 *  A guess for its primal/dual optimal solution vectors and the corresponding
-		 *  optimal working set can be provided.
-		 *  Note: This function is internally called by all init functions!
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_INIT_FAILED \n
-					RET_INIT_FAILED_CHOLESKY \n
-					RET_INIT_FAILED_HOTSTART \n
-					RET_INIT_FAILED_INFEASIBILITY \n
-					RET_INIT_FAILED_UNBOUNDEDNESS \n
-					RET_MAX_NWSR_REACHED */
-		returnValue solveInitialQP(	const real_t* const xOpt,			/**< Optimal primal solution vector.*/
-									const real_t* const yOpt,			/**< Optimal dual solution vector. */
-									const Bounds* const guessedBounds,	/**< Optimal working set of bounds for solution (xOpt,yOpt). */
-									const real_t* const _R,				/**< Pre-computed (upper triangular) Cholesky factor of Hessian matrix. */
-									int_t& nWSR, 						/**< Input: Maximum number of working set recalculations; \n
-																 		 *	 Output: Number of performed working set recalculations. */
-									real_t* const cputime				/**< Input: Maximum CPU time allowed for QP solution. \n
-																 			 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-									);
-
-		/** Solves an initialised QProblemB using online active set strategy.
-		 *  Note: This function is internally called by all hotstart functions!
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_MAX_NWSR_REACHED \n
-					RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue solveQP(	const real_t* const g_new,			/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const lb_new,			/**< Lower bounds of neighbouring QP to be solved. \n
-													 					 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,			/**< Upper bounds of neighbouring QP to be solved. \n
-													 					 If no upper bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,						/**< Input: Maximum number of working set recalculations; \n
-																		 Output: Number of performed working set recalculations. */
-								real_t* const cputime,				/**< Input: Maximum CPU time allowed for QP solution. \n
-																		 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								int_t  nWSRperformed = 0,			/**< Number of working set recalculations already performed to solve
-																		 this QP within previous solveQP() calls. This number is
-																		 always zero, except for successive calls from solveRegularisedQP()
-																		 or when using the far bound strategy. */
-								BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-								);
-
-
-		/** Solves an initialised QProblemB using online active set strategy.
-		 *  Note: This function is internally called by all hotstart functions!
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_MAX_NWSR_REACHED \n
-					RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue solveRegularisedQP(	const real_t* const g_new,			/**< Gradient of neighbouring QP to be solved. */
-										const real_t* const lb_new,			/**< Lower bounds of neighbouring QP to be solved. \n
-															 					 If no lower bounds exist, a NULL pointer can be passed. */
-										const real_t* const ub_new,			/**< Upper bounds of neighbouring QP to be solved. \n
-															 					 If no upper bounds exist, a NULL pointer can be passed. */
-										int_t& nWSR,						/**< Input: Maximum number of working set recalculations; \n
-																				 Output: Number of performed working set recalculations. */
-										real_t* const cputime,				/**< Input: Maximum CPU time allowed for QP solution. \n
-																				 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-										int_t nWSRperformed = 0,			/**< Number of working set recalculations already performed to solve
-																				 this QP within previous solveRegularisedQP() calls. This number is
-																				 always zero, except for successive calls when using the far bound strategy. */
-										BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-										);
-
-
-		/** Sets up bound data structure according to auxiliaryBounds.
-		 *  (If the working set shall be setup afresh, make sure that
-		 *  bounds data structure has been resetted!)
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUP_WORKINGSET_FAILED \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNOWN_BUG */
-		returnValue setupAuxiliaryWorkingSet(	const Bounds* const auxiliaryBounds,	/**< Working set for auxiliary QP. */
-												BooleanType setupAfresh					/**< Flag indicating if given working set shall be
-																						 *    setup afresh or by updating the current one. */
-												);
-
-		/** Sets up the optimal primal/dual solution of the auxiliary initial QP.
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue setupAuxiliaryQPsolution(	const real_t* const xOpt,			/**< Optimal primal solution vector.
-																				 	*	 If a NULL pointer is passed, all entries are set to zero. */
-												const real_t* const yOpt			/**< Optimal dual solution vector.
-																					 *	 If a NULL pointer is passed, all entries are set to zero. */
-												);
-
-		/** Sets up gradient of the auxiliary initial QP for given
-		 *  optimal primal/dual solution and given initial working set
-		 *  (assumes that members X, Y and BOUNDS have already been initialised!).
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue setupAuxiliaryQPgradient( );
-
-		/** Sets up bounds of the auxiliary initial QP for given
-		 *  optimal primal/dual solution and given initial working set
-		 *  (assumes that members X, Y and BOUNDS have already been initialised!).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_UNKNOWN_BUG */
-		returnValue setupAuxiliaryQPbounds( BooleanType useRelaxation	/**< Flag indicating if inactive bounds shall be relaxed. */
-											);
-
-
-	protected:
-		/** Updates QP vectors, working sets and internal data structures in order to
-			start from an optimal solution corresponding to initial guesses of the working
-			set for bounds
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_SETUP_AUXILIARYQP_FAILED */
-		virtual returnValue setupAuxiliaryQP(	const Bounds* const guessedBounds	/**< Initial guess for working set of bounds. */
-												);
-
-	private:
-		/** Determines step direction of the homotopy path.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_STEPDIRECTION_FAILED_CHOLESKY */
-		returnValue determineStepDirection(	const real_t* const delta_g,	/**< Step direction of gradient vector. */
-											const real_t* const delta_lb,	/**< Step direction of lower bounds. */
-											const real_t* const delta_ub,	/**< Step direction of upper bounds. */
-											BooleanType Delta_bB_isZero,	/**< Indicates if active bounds are to be shifted. */
-											real_t* const delta_xFX, 		/**< Output: Primal homotopy step direction of fixed variables. */
-											real_t* const delta_xFR,	 	/**< Output: Primal homotopy step direction of free variables. */
-											real_t* const delta_yFX 		/**< Output: Dual homotopy step direction of fixed variables' multiplier. */
-											);
-
-		/** Determines the maximum possible step length along the homotopy path
-		 *  and performs this step (without changing working set).
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_QP_INFEASIBLE \n
-		 */
-		returnValue performStep(	const real_t* const delta_g,	/**< Step direction of gradient. */
-									const real_t* const delta_lb,	/**< Step direction of lower bounds. */
-									const real_t* const delta_ub,	/**< Step direction of upper bounds. */
-									const real_t* const delta_xFX, 	/**< Primal homotopy step direction of fixed variables. */
-									const real_t* const delta_xFR,	/**< Primal homotopy step direction of free variables. */
-									const real_t* const delta_yFX,	/**< Dual homotopy step direction of fixed variables' multiplier. */
-									int_t& BC_idx, 					/**< Output: Index of blocking constraint. */
-									SubjectToStatus& BC_status		/**< Output: Status of blocking constraint. */
-									);
-
-		/** Updates active set.
-		 *	\return  SUCCESSFUL_RETURN \n
-		 			 RET_REMOVE_FROM_ACTIVESET_FAILED \n
-					 RET_ADD_TO_ACTIVESET_FAILED */
-		returnValue changeActiveSet(	int_t BC_idx, 						/**< Index of blocking constraint. */
-										SubjectToStatus BC_status 			/**< Status of blocking constraint. */
-										);
-
-		/** Drift correction at end of each active set iteration
-		 *  \return SUCCESSFUL_RETURN */
-		virtual returnValue performDriftCorrection( );
-
-		/** Determines if it is more efficient to refactorise the matrices when
-		 *  hotstarting or not (i.e. better to update the existing factorisations).
-		 *	\return BT_TRUE iff matrices shall be refactorised afresh
-		 */
-		BooleanType shallRefactorise(	const Bounds* const guessedBounds	/**< Guessed new working set. */
-										) const;
-
-
-		/** Adds a bound to active set (specialised version for the case where no constraints exist).
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDBOUND_FAILED */
-		returnValue addBound(	int_t number,				/**< Number of bound to be added to active set. */
-								SubjectToStatus B_status,	/**< Status of new active bound. */
-								BooleanType updateCholesky	/**< Flag indicating if Cholesky decomposition shall be updated. */
-								);
-
-		/** Removes a bounds from active set (specialised version for the case where no constraints exist).
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HESSIAN_NOT_SPD \n
-					RET_REMOVEBOUND_FAILED */
-		returnValue removeBound(	int_t number,				/**< Number of bound to be removed from active set. */
-									BooleanType updateCholesky	/**< Flag indicating if Cholesky decomposition shall be updated. */
-									);
-
-
-		/** Prints concise information on the current iteration.
-		 *	\return  SUCCESSFUL_RETURN \n */
-		returnValue printIteration(	int_t iter,							/**< Number of current iteration. */
-									int_t BC_idx, 						/**< Index of blocking bound. */
-									SubjectToStatus BC_status,			/**< Status of blocking bound. */
-									real_t homotopyLength,				/**< Current homotopy distance. */
-									BooleanType isFirstCall = BT_TRUE	/**< Indicating whether this is the first call for current QP. */
-									);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		BooleanType freeHessian;	/**< Flag indicating whether the Hessian matrix needs to be de-allocated. */
-		SymmetricMatrix* H;			/**< Hessian matrix. */
-
-		real_t* g;					/**< Gradient. */
-		real_t* lb;					/**< Lower bound vector (on variables). */
-		real_t* ub;					/**< Upper bound vector (on variables). */
-
-		Bounds bounds;				/**< Data structure for problem's bounds. */
-
-		real_t* R;					/**< Cholesky factor of H (i.e. H = R^T*R). */
-		BooleanType haveCholesky;	/**< Flag indicating whether Cholesky decomposition has already been setup. */
-
-		real_t* x;					/**< Primal solution vector. */
-		real_t* y;					/**< Dual solution vector. */
-
-		real_t tau;					/**< Last homotopy step length. */
-
-		QProblemStatus status;		/**< Current status of the solution process. */
-
-		BooleanType infeasible;		/**< QP infeasible? */
-		BooleanType unbounded;		/**< QP unbounded? */
-
-		HessianType hessianType;	/**< Type of Hessian matrix. */
-		real_t regVal;				/**< Holds the offset used to regularise Hessian matrix (zero by default). */
-
-		uint_t count;				/**< Counts the number of hotstart function calls. */
-
-		real_t *delta_xFR_TMP;		/**< Temporary for determineStepDirection */
-
-		real_t ramp0;				/**< Start value for Ramping Strategy. */
-		real_t ramp1;				/**< Final value for Ramping Strategy. */
-		int_t rampOffset;			/**< Offset index for Ramping. */
-
-		Options options;			/**< Struct containing all user-defined options for solving QPs. */
-
-		Flipper flipper;			/**< Struct for making a temporary copy of the matrix factorisations. */
-
-		TabularOutput tabularOutput;	/**< Struct storing information for tabular output (printLevel == PL_TABULAR). */
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/QProblemB.ipp>
-
-#endif	/* QPOASES_QPROBLEMB_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.ipp
deleted file mode 100644
index 464f1ae..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/QProblemB.ipp
+++ /dev/null
@@ -1,496 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/QProblemB.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the QProblemB class which
- *	is able to use the newly developed online active set strategy for
- *	parametric quadratic programming.
- */
-
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-/*
- *	g e t B o u n d s
- */
-inline returnValue QProblemB::getBounds( Bounds& _bounds ) const
-{
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	_bounds = bounds;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t N V
- */
-inline int_t QProblemB::getNV( ) const
-{
-	return bounds.getNV( );
-}
-
-
-/*
- *	g e t N F R
- */
-inline int_t QProblemB::getNFR( ) const
-{
-	return bounds.getNFR( );
-}
-
-
-/*
- *	g e t N F X
- */
-inline int_t QProblemB::getNFX( ) const
-{
-	return bounds.getNFX( );
-}
-
-
-/*
- *	g e t N F V
- */
-inline int_t QProblemB::getNFV( ) const
-{
-	return bounds.getNFV( );
-}
-
-
-/*
- *	g e t S t a t u s
- */
-inline QProblemStatus QProblemB::getStatus( ) const
-{
-	return status;
-}
-
-
-/*
- *	i s I n i t i a l i s e d
- */
-inline BooleanType QProblemB::isInitialised( ) const
-{
-	if ( status == QPS_NOTINITIALISED )
-		return BT_FALSE;
-	else
-		return BT_TRUE;
-}
-
-
-/*
- *	i s S o l v e d
- */
-inline BooleanType QProblemB::isSolved( ) const
-{
-	if ( status == QPS_SOLVED )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *	i s I n f e a s i b l e
- */
-inline BooleanType QProblemB::isInfeasible( ) const
-{
-	return infeasible;
-}
-
-
-/*
- *	i s U n b o u n d e d
- */
-inline BooleanType QProblemB::isUnbounded( ) const
-{
-	return unbounded;
-}
-
-
-/*
- *	g e t H e s s i a n T y p e
- */
-inline HessianType QProblemB::getHessianType( ) const
-{
-	return hessianType;
-}
-
-
-/*
- *	s e t H e s s i a n T y p e
- */
-inline returnValue QProblemB::setHessianType( HessianType _hessianType )
-{
-	hessianType = _hessianType;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	u s i n g R e g u l a r i s a t i o n
- */
-inline BooleanType QProblemB::usingRegularisation( ) const
-{
-	if ( regVal > ZERO )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *	g e t O p t i o n s
- */
-inline Options QProblemB::getOptions( ) const
-{
-	return options;
-}
-
-
-/*
- *	s e t O p t i o n s
- */
-inline returnValue QProblemB::setOptions(	const Options& _options
-											)
-{
-	options = _options;
-	options.ensureConsistency( );
-
-	setPrintLevel( options.printLevel );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t P r i n t L e v e l
- */
-inline PrintLevel QProblemB::getPrintLevel( ) const
-{
-	return options.printLevel;
-}
-
-
-
-/*
- *	g e t C o u n t
- */
-inline uint_t QProblemB::getCount( ) const
-{
-	return count;
-}
-
-
-/*
- *	r e s e t C o u n t e r
- */
-inline returnValue QProblemB::resetCounter( )
-{
-	count = 0;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	s e t H
- */
-inline returnValue QProblemB::setH( SymmetricMatrix* H_new )
-{
-	if ( ( freeHessian == BT_TRUE ) && ( H != 0 ) )
-	{
-		delete H;
-		H = 0;
-	}
-
-	H = H_new;
-	freeHessian = BT_FALSE;
-	
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t H
- */
-inline returnValue QProblemB::setH( const real_t* const H_new )
-{
-	int_t nV = getNV();
-	SymDenseMat* dH;
-
-	/* if null pointer is passed, Hessian is set to zero matrix
-	 *                            (or stays identity matrix) */
-	if ( H_new == 0 )
-	{
-		if ( hessianType == HST_IDENTITY )
-			return SUCCESSFUL_RETURN;
-
-		hessianType = HST_ZERO;
-
-		if ( ( freeHessian == BT_TRUE ) && ( H != 0 ) )
-			delete H;
-
-		H = 0;
-		freeHessian = BT_FALSE;
-	}
-	else
-	{
-		if ( ( freeHessian == BT_TRUE ) && ( H != 0 ) )
-			delete H;
-
-		H = dH = new SymDenseMat( nV, nV, nV, (real_t*) H_new );
-		freeHessian = BT_TRUE;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t G
- */
-inline returnValue QProblemB::setG( const real_t* const g_new )
-{
-	uint_t nV = (uint_t)getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( g_new == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	memcpy( g,g_new,nV*sizeof(real_t) );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t L B
- */
-inline returnValue QProblemB::setLB( const real_t* const lb_new )
-{
-	uint_t i;
-	uint_t nV = (uint_t)getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( lb_new != 0 )
-	{
-		memcpy( lb,lb_new,nV*sizeof(real_t) );
-	}
-	else
-	{
-		/* if no lower bounds are specified, set them to -infinity */
-		for( i=0; i<nV; ++i )
-			lb[i] = -INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t L B
- */
-inline returnValue QProblemB::setLB( int_t number, real_t value )
-{
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ( number >= 0 ) && ( number < nV ) )
-	{
-		lb[number] = value;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-	{
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-	}
-}
-
-
-/*
- *	s e t U B
- */
-inline returnValue QProblemB::setUB( const real_t* const ub_new )
-{
-	uint_t i;
-	uint_t nV = (uint_t)getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ub_new != 0 )
-	{
-		memcpy( ub,ub_new,nV*sizeof(real_t) );
-	}
-	else
-	{
-		/* if no upper bounds are specified, set them to infinity */
-		for( i=0; i<nV; ++i )
-			ub[i] = INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t U B
- */
-inline returnValue QProblemB::setUB( int_t number, real_t value )
-{
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	if ( ( number >= 0 ) && ( number < nV ) )
-	{
-		ub[number] = value;
-
-		return SUCCESSFUL_RETURN;
-	}
-	else
-	{
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-	}
-}
-
-
-/*
- *	c o m p u t e G i v e n s
- */
-inline void QProblemB::computeGivens(	real_t xold, real_t yold, real_t& xnew, real_t& ynew,
-										real_t& c, real_t& s
-										) const
-{
-	real_t t, mu;
-
-	if ( isZero( yold ) == BT_TRUE )
-	{
-		c = 1.0;
-		s = 0.0;
-
-		xnew = xold;
-		ynew = yold;
-	}
-	else
-	{
-		mu = getAbs( xold );
-		if ( getAbs( yold ) > mu )
-			mu = getAbs( yold );
-
-		t = mu * getSqrt( (xold/mu)*(xold/mu) + (yold/mu)*(yold/mu) );
-
-		if ( xold < 0.0 )
-		t = -t;
-
-		c = xold/t;
-		s = yold/t;
-		xnew = t;
-		ynew = 0.0;
-	}
-
-	return;
-}
-
-
-/*
- *	a p p l y G i v e n s
- */
-inline void QProblemB::applyGivens(	real_t c, real_t s, real_t /*nu*/, real_t xold, real_t yold,
-									real_t& xnew, real_t& ynew
-									) const
-{
-	#ifdef __USE_THREE_MULTS_GIVENS__
-
-	/* Givens plane rotation requiring only three multiplications,
-	 * cf. Hammarling, S.: A note on modifications to the givens plane rotation.
-	 * J. Inst. Maths Applics, 13:215-218, 1974. */
-	xnew = xold*c + yold*s;
-	ynew = (xnew+xold)*nu - yold;
-
-	#else
-
-	/* Usual Givens plane rotation requiring four multiplications. */
-	xnew =  c*xold + s*yold;
-	ynew = -s*xold + c*yold;
-
-	#endif
-
-	return;
-}
-
-
-/*
- * i s B l o c k i n g
- */
-inline BooleanType QProblemB::isBlocking(	real_t num,
-											real_t den,
-											real_t epsNum,
-											real_t epsDen,
-											real_t& t
-											) const
-{
-	if ( ( den >= epsDen ) && ( num >= epsNum ) )
-	{
-		if ( num < t*den )
-			return BT_TRUE;
-	}
-
-	return BT_FALSE;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.hpp
deleted file mode 100644
index f1e3552..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.hpp
+++ /dev/null
@@ -1,358 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SQProblem.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the SQProblem class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming
- *	with varying matrices.
- */
-
-
-
-#ifndef QPOASES_SQPROBLEM_HPP
-#define QPOASES_SQPROBLEM_HPP
-
-
-#include <qpOASES/QProblem.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Implements the online active set strategy for QPs with varying matrices.
- *
- *	A class for setting up and solving quadratic programs with varying QP matrices.
- *	The main feature is the possibily to use the newly developed online active set strategy
- *	for parametric quadratic programming.
- *
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- */
-class SQProblem : public QProblem
-{
-	/* allow SolutionAnalysis class to access private members */
-	friend class SolutionAnalysis;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		SQProblem( );
-
-		/** Constructor which takes the QP dimension and Hessian type
-		 *  information. If the Hessian is the zero (i.e. HST_ZERO) or the
-		 *  identity matrix (i.e. HST_IDENTITY), respectively, no memory
-		 *  is allocated for it and a NULL pointer can be passed for it
-		 *  to the init() functions. */
-		SQProblem(	int_t _nV,	  							/**< Number of variables. */
-					int_t _nC,  							/**< Number of constraints. */
-					HessianType _hessianType = HST_UNKNOWN	/**< Type of Hessian matrix. */
-					);
-
-		/** Copy constructor (deep copy). */
-		SQProblem(	const SQProblem& rhs	/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~SQProblem( );
-
-		/** Assignment operator (deep copy). */
-		virtual SQProblem& operator=(	const SQProblem& rhs	/**< Rhs object. */
-								);
-
-
-		/** Solves an initialised QP sequence with matrix shift using
-		 *	the online active set strategy.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_MATRIX_SHIFT_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_SETUP_AUXILIARYQP_FAILED */
-		returnValue hotstart(	SymmetricMatrix *H_new,							/**< Hessian matrix of neighbouring QP to be solved (a shallow copy is made). \n
-																					 If Hessian matrix is trivial, a NULL pointer can be passed. */
-								const real_t* const g_new,						/**< Gradient of neighbouring QP to be solved. */
-								Matrix *A_new,									/**< Constraint matrix of neighbouring QP to be solved (a shallow copy is made). \n
-																					 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-								const real_t* const lb_new,						/**< Lower bounds of neighbouring QP to be solved. \n
-													 								 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,						/**< Upper bounds of neighbouring QP to be solved. \n
-													 		 						 If no upper bounds exist, a NULL pointer can be passed. */
-								const real_t* const lbA_new,					/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-													 		 						 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const real_t* const ubA_new,					/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-												 			 						 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,									/**< Input: Maximum number of working set recalculations; \n
-																					 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																					 Output: CPU time spen for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-		/** Solves an initialised QP sequence with matrix shift using
-		 *	the online active set strategy.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_MATRIX_SHIFT_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_SETUP_AUXILIARYQP_FAILED */
-		returnValue hotstart(	const real_t* const H_new,						/**< Hessian matrix of neighbouring QP to be solved (a shallow copy is made). \n
-																					 If Hessian matrix is trivial, a NULL pointer can be passed. */
-								const real_t* const g_new,						/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const A_new,						/**< Constraint matrix of neighbouring QP to be solved (a shallow copy is made). \n
-																					 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-								const real_t* const lb_new,						/**< Lower bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,						/**< Upper bounds of neighbouring QP to be solved. \n
-													 							 	 If no upper bounds exist, a NULL pointer can be passed. */
-								const real_t* const lbA_new,					/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const real_t* const ubA_new,					/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-												 								 	 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,									/**< Input: Maximum number of working set recalculations; \n
-																					 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																					 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-		/** Solves an initialised QP sequence with matrix shift using
-		 *	the online active set strategy, where QP data is read from files.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_MATRIX_SHIFT_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_SETUP_AUXILIARYQP_FAILED \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue hotstart(	const char* const H_file,						/**< Name of file where Hessian matrix is stored. \n
-																					 If Hessian matrix is trivial, a NULL pointer can be passed. */
-								const char* const g_file,						/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-								const char* const A_file,						/**< Name of file where constraint matrix is stored. \n
-																					 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-								const char* const lb_file,						/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower bounds exist, a NULL pointer can be passed. */
-								const char* const ub_file, 						/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper bounds exist, a NULL pointer can be passed. */
-								const char* const lbA_file,						/**< Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const char* const ubA_file,						/**< Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,									/**< Input: Maximum number of working set recalculations; \n
-																					 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																					 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-		/** Solves an initialised QP sequence (without matrix shift) using
-		 *	the online active set strategy.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This functions just forwards to the corresponding
-		 *  	  QProblem::hotstart member function.
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS */
-		returnValue hotstart(	const real_t* const g_new,						/**< Gradient of neighbouring QP to be solved. */
-								const real_t* const lb_new,						/**< Lower bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower bounds exist, a NULL pointer can be passed. */
-								const real_t* const ub_new,						/**< Upper bounds of neighbouring QP to be solved. \n
-													 							 	 If no upper bounds exist, a NULL pointer can be passed. */
-								const real_t* const lbA_new,					/**< Lower constraints' bounds of neighbouring QP to be solved. \n
-													 							 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const real_t* const ubA_new,					/**< Upper constraints' bounds of neighbouring QP to be solved. \n
-													 							 	 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR,									/**< Input: Maximum number of working set recalculations; \n
-																			 		 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																				 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-		/** Solves an initialised QP sequence (without matrix shift) using
-		 *  the online active set strategy, where QP data is read from files.
-		 *	By default, QP solution is started from previous solution. If a guess
-		 *	for the working set is provided, an initialised homotopy is performed.
-		 *
-		 *  Note: This functions just forwards to the corresponding
-		 *  	  QProblem::hotstart member function.
-		 *
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_MAX_NWSR_REACHED \n
-		 			RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED \n
-					RET_HOTSTART_FAILED \n
-					RET_SHIFT_DETERMINATION_FAILED \n
-					RET_STEPDIRECTION_DETERMINATION_FAILED \n
-					RET_STEPLENGTH_DETERMINATION_FAILED \n
-					RET_HOMOTOPY_STEP_FAILED \n
-					RET_HOTSTART_STOPPED_INFEASIBILITY \n
-					RET_HOTSTART_STOPPED_UNBOUNDEDNESS \n
-					RET_UNABLE_TO_READ_FILE \n
-					RET_INVALID_ARGUMENTS */
-		returnValue hotstart(	const char* const g_file,						/**< Name of file where gradient, of neighbouring QP to be solved, is stored. */
-								const char* const lb_file,					 	/**< Name of file where lower bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower bounds exist, a NULL pointer can be passed. */
-								const char* const ub_file,						/**< Name of file where upper bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper bounds exist, a NULL pointer can be passed. */
-								const char* const lbA_file,						/**< Name of file where lower constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-								const char* const ubA_file,						/**< Name of file where upper constraints' bounds, of neighbouring QP to be solved, is stored. \n
-													 								 If no upper constraints' bounds exist, a NULL pointer can be passed. */
-								int_t& nWSR, 									/**< Input: Maximum number of working set recalculations; \n
-																					 Output: Number of performed working set recalculations. */
-								real_t* const cputime = 0,						/**< Input: Maximum CPU time allowed for QP solution. \n
-																				 	 Output: CPU time spent for QP solution (or to perform nWSR iterations). */
-								const Bounds* const guessedBounds = 0,			/**< Optimal working set of bounds for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of bounds is kept!) */
-								const Constraints* const guessedConstraints = 0	/**< Optimal working set of constraints for solution (xOpt,yOpt). \n
-																					 (If a null pointer is passed, the previous working set of constraints is kept!) */
-								);
-
-
-		#ifdef __MATLAB__
-		/** Sets pointer of Hessian and constraint matrix to zero.
-		 *  QUICK HACK FOR MAKING THE MATLAB INTERFACE RUN! TO BE REMOVED!
-		 *	\return SUCCESSFUL_RETURN */
-		returnValue resetMatrixPointers( );
-		#endif
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-
-		/** Sets new matrices and calculates their factorisations. If the
-		 *  current Hessian is trivial (i.e. HST_ZERO or HST_IDENTITY) but a
-		 *  non-trivial one is given, memory for Hessian is allocated and
-		 *  it is set to the given one. Afterwards, all QP vectors are
-		 *  transformed in order to start from an optimal solution.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_MATRIX_FACTORISATION_FAILED \n
-		 * 			RET_NO_HESSIAN_SPECIFIED */
-		virtual returnValue setupNewAuxiliaryQP(	SymmetricMatrix *H_new,		/**< New Hessian matrix. \n
-																					 If Hessian matrix is trivial, a NULL pointer can be passed. */
-													Matrix *A_new,				/**< New constraint matrix. \n
-																					 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-													const real_t *lb_new,		/**< New lower bounds. \n
-														 						 	 If no lower bounds exist, a NULL pointer can be passed. */
-													const real_t *ub_new,		/**< New upper bounds. \n
-														 						 	 If no lower bounds exist, a NULL pointer can be passed. */
-													const real_t *lbA_new,		/**< New lower constraints' bounds. \n
-														 						 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-													const real_t *ubA_new		/**< New lower constraints' bounds. \n
-														 						 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-													);
-
-		/** Sets new matrices and calculates their factorisations. If the
-		 *  current Hessian is trivial (i.e. HST_ZERO or HST_IDENTITY) but a
-		 *  non-trivial one is given, memory for Hessian is allocated and
-		 *  it is set to the given one. Afterwards, all QP vectors are
-		 *  transformed in order to start from an optimal solution.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_MATRIX_FACTORISATION_FAILED \n
-		 * 			RET_NO_HESSIAN_SPECIFIED */
-		virtual returnValue setupNewAuxiliaryQP(	const real_t* const H_new,	/**< New Hessian matrix. \n
-																	     		 	 If Hessian matrix is trivial, a NULL pointer can be passed. */
-													const real_t* const A_new,	/**< New constraint matrix. \n
-																	     		 	 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-													const real_t *lb_new,		/**< New lower bounds. \n
-														 						 	 If no lower bounds exist, a NULL pointer can be passed. */
-													const real_t *ub_new,		/**< New upper bounds. \n
-														 						 	 If no lower bounds exist, a NULL pointer can be passed. */
-													const real_t *lbA_new,		/**< New lower constraints' bounds. \n
-														 						 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-													const real_t *ubA_new		/**< New lower constraints' bounds. \n
-														 						 	 If no lower constraints' bounds exist, a NULL pointer can be passed. */
-													);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/SQProblem.ipp>
-
-#endif	/* QPOASES_SQPROBLEM_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.ipp
deleted file mode 100644
index d56c42a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblem.ipp
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SQProblem.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of inlined member functions of the SQProblem class which
- *	is able to use the newly developed online active set strategy for
- *	parametric quadratic programming with varying matrices.
- */
-
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.hpp
deleted file mode 100644
index 7f09695..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.hpp
+++ /dev/null
@@ -1,475 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2014 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SQProblemSchur.hpp
- *	\author Andreas Waechter and Dennis Janka, based on QProblem.hpp by Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2012-2015
- *
- *	Declaration of the SQProblemSchur class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming
- *	with varying matrices and uses a Schur Complement approach to solve
- *	the linear systems.
- */
-
-
-#ifndef QPOASES_SQPROBLEMSCHUR_HPP
-#define QPOASES_SQPROBLEMSCHUR_HPP
-
-
-#include <qpOASES/SQProblem.hpp>
-#include <qpOASES/SparseSolver.hpp>
-
-#ifdef __USE_SINGLE_PRECISION__
-
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	//#define GEQRF sgeqrf_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	//#define ORMQR sormqr_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define TRTRS strtrs_
-	/** Macro for calling level 3 BLAS operation in single precision. */
-	#define TRCON strcon_
-
-#else
-
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	//#define GEQRF dgeqrf_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	//#define ORMQR dormqr_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define TRTRS dtrtrs_
-	/** Macro for calling level 3 BLAS operation in double precision. */
-	#define TRCON dtrcon_
-
-#endif /* __USE_SINGLE_PRECISION__ */
-
-extern "C" {
-	/** Compute a QR factorization of a real M-by-N matrix A in double precision */
-	//void dgeqrf_(	const unsigned long *M, const unsigned long *N, double *A, const unsigned long *LDA,
-					//double *TAU, double *WORK, const unsigned long *LWORK, int *INFO );
-	/** Compute a QR factorization of a real M-by-N matrix A in single precision */
-	//void sgeqrf_(	const unsigned long *M, const unsigned long *N, float *A, const unsigned long *LDA,
-					//float *TAU, float *WORK, const unsigned long *LWORK, int *INFO );
-
-	/** Multiply C with orthogonal matrix Q**T as returned by geqrf (double precision) */
-	//void dormqr_(	const char *SIDE, const char *TRANS, const unsigned long *M, const unsigned long *N, const unsigned long *K,
-					//double *A, const unsigned long *LDA, double *TAU, double *C, const unsigned long *LDC,
-					//double *WORK, const unsigned long *LWORK, int *INFO );
-	/** Multiply C with orthogonal matrix Q**T as returned by geqrf (single precision) */
-	//void sormqr_(	const char *SIDE, const char *TRANS, const unsigned long *M, const unsigned long *N, const unsigned long *K,
-					//float *A, const unsigned long *LDA, float *TAU, float *C, const unsigned long *LDC,
-					//float *WORK, const unsigned long *LWORK, int *INFO );
-
-	/** Solve a triangular system (double precision) */
-	void dtrtrs_(	const char *UPLO, const char *TRANS, const char *DIAG, const unsigned long *N, const unsigned long *NRHS,
-					double *A, const unsigned long *LDA, double *B, const unsigned long *LDB, long *INFO );
-	/** Solve a triangular system (single precision) */
-	void strtrs_(	const char *UPLO, const char *TRANS, const char *DIAG, const unsigned long *N, const unsigned long *NRHS,
-					float *A, const unsigned long *LDA, float *B, const unsigned long *LDB, long *INFO );
-
-	/** Estimate the reciprocal of the condition number of a triangular matrix in double precision */
-	void dtrcon_(	const char *NORM, const char *UPLO, const char *DIAG, const unsigned long *N, double *A, const unsigned long *LDA,
-					double *RCOND, double *WORK, const unsigned long *IWORK, long *INFO );
-	/** Estimate the reciprocal of the condition number of a triangular matrix in single precision */
-	void strcon_(	const char *NORM, const char *UPLO, const char *DIAG, const unsigned long *N, float *A, const unsigned long *LDA,
-					float *RCOND, float *WORK, const unsigned long *IWORK, long *INFO );
-}
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Implements the online active set strategy for QPs with varying, sparse matrices.
- *
- *	A class for setting up and solving quadratic programs with varying,
- *	sparse QP matrices. Here, sparsity is exploited by means of a
- *	Schur complement approach to solve the linear systems.
- *
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- */
-class SQProblemSchur : public SQProblem
-{
-	/* allow SolutionAnalysis class to access private members */
-	friend class SolutionAnalysis;
-
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		SQProblemSchur( );
-
-		/** Constructor which takes the QP dimension and Hessian type
-		 *  information. If the Hessian is the zero (i.e. HST_ZERO) or the
-		 *  identity matrix (i.e. HST_IDENTITY), respectively, no memory
-		 *  is allocated for it and a NULL pointer can be passed for it
-		 *  to the init() functions. */
-		SQProblemSchur(	int_t _nV,	  								/**< Number of variables. */
-						int_t _nC,		  							/**< Number of constraints. */
-						HessianType _hessianType = HST_UNKNOWN,	/**< Type of Hessian matrix. */
-						int_t maxSchurUpdates = 75					/**< Maximal number of Schur updates */
-						);
-
-		/** Copy constructor (deep copy). */
-		SQProblemSchur(	const SQProblemSchur& rhs		/**< Rhs object. */
-						);
-
-		/** Destructor. */
-		virtual ~SQProblemSchur( );
-
-		/** Assignment operator (deep copy). */
-		virtual SQProblemSchur& operator=(	const SQProblemSchur& rhs	/**< Rhs object. */
-											);
-
-		/** Clears all data structures of QProblem except for QP data.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_RESET_FAILED */
-		virtual returnValue reset( );
-
-		/** Resets Schur complement.  This sets up the KKT matrix for the
-			current activities, copies the activities, etc. TODO: Return values */
-		returnValue resetSchurComplement( BooleanType allowInertiaCorrection );
-
-		/** Return the total number of sparse matrix factorizations performed so far. */
-		inline int_t getNumFactorizations( ) const;
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const SQProblemSchur& rhs	/**< Rhs object. */
-							);
-
-		/** Computes the Cholesky decomposition of the projected Hessian (i.e. R^T*R = Z^T*H*Z).
-		 *  For the Schur complement version, this function only returns SUCCESSFUL_RETURN. */
-		virtual returnValue computeProjectedCholesky( );
-
-		/** Computes initial Cholesky decomposition of the projected Hessian making
-		 *  use of the function setupCholeskyDecomposition() or setupCholeskyDecompositionProjected().
-		 *  For the Schur complement version, this function only returns SUCCESSFUL_RETURN. */
-		virtual returnValue computeInitialCholesky( );
-
-		/** Initialises TQ factorisation of A (i.e. A*Q = [0 T]) if NO constraint is active.
-		 *  For the Schur complement version, this function only returns SUCCESSFUL_RETURN. */
-		virtual returnValue setupTQfactorisation( );
-
-		/** This method is overloaded from SQProblem.
-		 *  Sets new matrices and calculates their factorisations. If the
-		 *  current Hessian is trivial (i.e. HST_ZERO or HST_IDENTITY) but a
-		 *  non-trivial one is given, memory for Hessian is allocated and
-		 *  it is set to the given one. Afterwards, all QP vectors are
-		 *  transformed in order to start from an optimal solution.
-		 *	\return SUCCESSFUL_RETURN \n
-		 *			RET_MATRIX_FACTORISATION_FAILED \n
-		 * 			RET_NO_HESSIAN_SPECIFIED */
-		virtual returnValue setupAuxiliaryQP(	SymmetricMatrix *H_new,		/**< New Hessian matrix. \n
-																				 If Hessian matrix is trivial, a NULL pointer can be passed. */
-												Matrix *A_new,				/**< New constraint matrix. \n
-																				 If QP sequence does not involve constraints, a NULL pointer can be passed. */
-												const real_t *lb_new,
-												const real_t *ub_new,
-												const real_t *lbA_new,
-												const real_t *ubA_new
-												);
-
-		/** Setup bounds and constraints data structures according to auxiliaryBounds/Constraints.
-		 *  Calls the sparse solver to obtain the factorization for the initial active set.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_SETUP_WORKINGSET_FAILED \n
-					RET_INVALID_ARGUMENTS \n
-					RET_UNKNOWN_BUG */
-		virtual returnValue setupAuxiliaryWorkingSet(	const Bounds* const auxiliaryBounds,
-														const Constraints* const auxiliaryConstraints,
-														BooleanType setupAfresh
-														);
-
-
-		/** Adds a constraint to active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDCONSTRAINT_FAILED \n
-					RET_ADDCONSTRAINT_FAILED_INFEASIBILITY \n
-					RET_ENSURELI_FAILED */
-		virtual returnValue addConstraint(	int_t number,					/**< Number of constraint to be added to active set. */
-											SubjectToStatus C_status,		/**< Status of new active constraint. */
-											BooleanType updateCholesky,		/**< Flag indicating if Cholesky decomposition shall be updated. */
-											BooleanType ensureLI = BT_TRUE	/**< Ensure linear independence by exchange rules by default. */
-											);
-
-		/** Checks if new active constraint to be added is linearly dependent from
-		 *	from row of the active constraints matrix.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT \n
-					 RET_INDEXLIST_CORRUPTED */
-		virtual returnValue addConstraint_checkLI(	int_t number	/**< Number of constraint to be added to active set. */
-											);
-
-		/** Ensures linear independence of constraint matrix when a new constraint is added.
-		 * 	To this end a bound or constraint is removed simultaneously if necessary.
-		 *	\return	 SUCCESSFUL_RETURN \n
-		 			 RET_LI_RESOLVED \n
-					 RET_ENSURELI_FAILED \n
-					 RET_ENSURELI_FAILED_TQ \n
-					 RET_ENSURELI_FAILED_NOINDEX \n
-					 RET_REMOVE_FROM_ACTIVESET */
-		virtual returnValue addConstraint_ensureLI(	int_t number,				/**< Number of constraint to be added to active set. */
-														SubjectToStatus C_status	/**< Status of new active bound. */
-														);
-
-		/** Adds a bound to active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDBOUND_FAILED \n
-					RET_ADDBOUND_FAILED_INFEASIBILITY \n
-					RET_ENSURELI_FAILED */
-		virtual returnValue addBound(	int_t number,					/**< Number of bound to be added to active set. */
-										SubjectToStatus B_status,		/**< Status of new active bound. */
-										BooleanType updateCholesky,		/**< Flag indicating if Cholesky decomposition shall be updated. */
-										BooleanType ensureLI = BT_TRUE	/**< Ensure linear independence by exchange rules by default. */
-										);
-
-		/** Checks if new active bound to be added is linearly dependent from
-		 *	from row of the active constraints matrix.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT */
-		virtual returnValue addBound_checkLI(	int_t number	/**< Number of bound to be added to active set. */
-												);
-
-		/** Ensures linear independence of constraint matrix when a new bound is added.
-		 *	To this end a bound or constraint is removed simultaneously if necessary.
-		 *	\return	 SUCCESSFUL_RETURN \n
-		 			 RET_LI_RESOLVED \n
-					 RET_ENSURELI_FAILED \n
-					 RET_ENSURELI_FAILED_TQ \n
-					 RET_ENSURELI_FAILED_NOINDEX \n
-					 RET_REMOVE_FROM_ACTIVESET */
-		virtual returnValue addBound_ensureLI(	int_t number,				/**< Number of bound to be added to active set. */
-												SubjectToStatus B_status	/**< Status of new active bound. */
-												);
-
-		/** Removes a constraint from active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_CONSTRAINT_NOT_ACTIVE \n
-					RET_REMOVECONSTRAINT_FAILED \n
-					RET_HESSIAN_NOT_SPD */
-		virtual returnValue removeConstraint(	int_t number,							/**< Number of constraint to be removed from active set. */
-												BooleanType updateCholesky,				/**< Flag indicating if Cholesky decomposition shall be updated. */
-												BooleanType allowFlipping = BT_FALSE,	/**< Flag indicating if flipping bounds are allowed. */
-												BooleanType ensureNZC = BT_FALSE		/**< Flag indicating if non-zero curvature is ensured by exchange rules. */
-												);
-
-		/** Removes a bounds from active set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_BOUND_NOT_ACTIVE \n
-					RET_HESSIAN_NOT_SPD \n
-					RET_REMOVEBOUND_FAILED */
-		virtual returnValue removeBound(	int_t number,							/**< Number of bound to be removed from active set. */
-											BooleanType updateCholesky,				/**< Flag indicating if Cholesky decomposition shall be updated. */
-											BooleanType allowFlipping = BT_FALSE,	/**< Flag indicating if flipping bounds are allowed. */
-											BooleanType ensureNZC = BT_FALSE		/**< Flag indicating if non-zero curvature is ensured by exchange rules. */
-											);
-
-		/** Solves the system Ta = b or T^Ta = b where T is a reverse upper triangular matrix.
-		 *	 This must not be called for the Schur complement version. */
-		virtual returnValue backsolveT( 	const real_t* const b,	/**< Right hand side vector. */
-											BooleanType transposed,	/**< Indicates if the transposed system shall be solved. */
-											real_t* const a 		/**< Output: Solution vector */
-											) const;
-
-		/** Solves the system Ra = b or R^Ta = b where R is an upper triangular matrix.
-		 *	This must not be called for the Schur complement version. */
-		virtual returnValue backsolveR( 	const real_t* const b,	/**< Right hand side vector. */
-											BooleanType transposed,	/**< Indicates if the transposed system shall be solved. */
-											real_t* const a 		/**< Output: Solution vector */
-											) const;
-
-		/** Solves the system Ra = b or R^Ta = b where R is an upper triangular matrix. \n
-		 *	This must not be called for the Schur complement version. */
-		virtual returnValue backsolveR( 	const real_t* const b,		/**< Right hand side vector. */
-											BooleanType transposed,		/**< Indicates if the transposed system shall be solved. */
-											BooleanType removingBound,	/**< Indicates if function is called from "removeBound()". */
-											real_t* const a 			/**< Output: Solution vector */
-											) const;
-
-
-		/** Determines step direction of the homotopy path.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_STEPDIRECTION_FAILED_TQ \n
-					RET_STEPDIRECTION_FAILED_CHOLESKY */
-		virtual returnValue determineStepDirection(	const real_t* const delta_g,	/**< Step direction of gradient vector. */
-														const real_t* const delta_lbA,	/**< Step direction of lower constraints' bounds. */
-														const real_t* const delta_ubA,	/**< Step direction of upper constraints' bounds. */
-														const real_t* const delta_lb,	/**< Step direction of lower bounds. */
-														const real_t* const delta_ub,	/**< Step direction of upper bounds. */
-														BooleanType Delta_bC_isZero, 	/**< Indicates if active constraints' bounds are to be shifted. */
-														BooleanType Delta_bB_isZero,	/**< Indicates if active bounds are to be shifted. */
-														real_t* const delta_xFX, 		/**< Output: Primal homotopy step direction of fixed variables. */
-														real_t* const delta_xFR,	 	/**< Output: Primal homotopy step direction of free variables. */
-														real_t* const delta_yAC, 		/**< Output: Dual homotopy step direction of active constraints' multiplier. */
-														real_t* const delta_yFX 		/**< Output: Dual homotopy step direction of fixed variables' multiplier. */
-														);
-
-		virtual returnValue determineStepDirection2(	const real_t* const delta_g,	/**< Step direction of gradient vector. */
-														const real_t* const delta_lbA,	/**< Step direction of lower constraints' bounds. */
-														const real_t* const delta_ubA,	/**< Step direction of upper constraints' bounds. */
-														const real_t* const delta_lb,	/**< Step direction of lower bounds. */
-														const real_t* const delta_ub,	/**< Step direction of upper bounds. */
-														BooleanType Delta_bC_isZero, 	/**< Indicates if active constraints' bounds are to be shifted. */
-														BooleanType Delta_bB_isZero,	/**< Indicates if active bounds are to be shifted. */
-														real_t* const delta_xFX, 		/**< Output: Primal homotopy step direction of fixed variables. */
-														real_t* const delta_xFR,	 	/**< Output: Primal homotopy step direction of free variables. */
-														real_t* const delta_yAC, 		/**< Output: Dual homotopy step direction of active constraints' multiplier. */
-														real_t* const delta_yFX 		/**< Output: Dual homotopy step direction of fixed variables' multiplier. */
-														);
-
-	/*
-	 *	PRIVATE MEMBER FUNCTION
-	 */
-	private:
-		/** Checks if new active bound to be added is linearly dependent from
-		 *	from row of the active constraints matrix.  This version computes
-		 *	the multipliers in the (full) test.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT */
-		returnValue addBound_checkLISchur(	int_t number,			/**< Number of bound to be added to active set. */
-											real_t* const xiC, 		/**< Output: Multipliers in linear independence test for active constraints. */
-											real_t* const xiX 		/**< Output: Multipliers in linear independence test for fixed variables. */
-											);
-
-		/** Checks if new active bound to be added is linearly dependent from
-		 *	from row of the active constraints matrix.  This version computes
-		 *	the multipliers in the (full) test.
-		 *	\return	 RET_LINEARLY_DEPENDENT \n
-		 			 RET_LINEARLY_INDEPENDENT */
-		returnValue addConstraint_checkLISchur(	int_t number,		/**< Number of bound to be added to active set. */
-													real_t* const xiC, 	/**< Output: Multipliers in linear independence test for active constraints. */
-													real_t* const xiX 	/**< Output: Multipliers in linear independence test for fixed variables. */
-													);
-
-		/** Compute product of "M" matrix (additional columns in KKT
-			matrix) with vector.  y = alpha * M * x + beta * y */
-		returnValue computeMTimes( real_t alpha, const real_t* const x, real_t beta, real_t* const y );
-
-		/** Compute product of transpose of "M" matrix (additional columns in KKT
-			matrix) with vector.  y = alpha * M^T * x + beta * y */
-		returnValue computeMTransTimes( real_t alpha, const real_t* const x, real_t beta, real_t* const y );
-
-		/** Add a row/column to the Schur complement. */
-		returnValue addToSchurComplement( int_t number, SchurUpdateType update, int_t numNonzerosM, const sparse_int_t* M_pos, const real_t* const M_vals, int_t numNonzerosN, const sparse_int_t* Npos, const real_t* const Nvals, real_t N_diag );
-
-		/** Remove a row/column from the Schur complement. */
-		returnValue deleteFromSchurComplement( int_t idx, BooleanType allowUndo = BT_FALSE );
-
-		/** Undo the last deletion from the Schur complement by moving the nS+1th row/column to position idx. */
-		returnValue undoDeleteFromSchurComplement( int_t idx );
-
-		/** Compute determinant of new nS*nS Schur complement from old factorization */
-		real_t calcDetSchur( int_t idxDel );
-
-		/** Update QR factorization and determinant of Schur complement after a row and column have been added or removed */
-		returnValue updateSchurQR( int_t idxDel );
-
-		/** Compute the solution to QRx = rhs and store it in sol */
-		returnValue backsolveSchurQR( int_t dimS, const real_t* const rhs, int_t dimRhs, real_t* const sol );
-
-		/** If negative curvature is discovered in the reduced Hessian, add bounds until all eigenvalues are positive */
-		returnValue correctInertia();
-
-		/** If the KKT matrix is declared singular during refactorization, remove linearly dependent constraints or add bounds */
-		returnValue repairSingularWorkingSet( );
-
-		returnValue stepCalcRhs( int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx, real_t& rhs_max, const real_t* const delta_g,
-								const real_t* const delta_lbA, const real_t* const delta_ubA,
-								const real_t* const delta_lb, const real_t* const delta_ub,
-								BooleanType Delta_bC_isZero, BooleanType Delta_bB_isZero,
-								real_t* const delta_xFX, real_t* const delta_xFR,
-								real_t* const delta_yAC, real_t* const delta_yFX
-								 );
-
-		returnValue stepCalcReorder(int_t nFR, int_t nAC, int_t* FR_idx, int_t* AC_idx, int_t nFRStart, int_t nACStart,
-									int_t* FR_idxStart, int_t* AC_idxStart, int_t* FR_iSort, int_t* FR_iSortStart,
-									int_t* AC_iSort, int_t* AC_iSortStart, real_t* rhs);
-
-		returnValue stepCalcBacksolveSchur( int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx,
-											int_t dim, real_t* rhs, real_t* sol );
-
-		returnValue stepCalcReorder2(	int_t nFR, int_t nAC, int_t* FR_idx, int_t* AC_idx, int_t nFRStart, int_t nACStart,
-										int_t* FR_idxStart, int_t* AC_idxStart, int_t* FR_iSort, int_t* FR_iSortStart,
-										int_t* AC_iSort, int_t* AC_iSortStart, real_t* sol, real_t* const delta_xFR, real_t* const delta_yAC);
-
-		returnValue stepCalcResid(	int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx,
-									BooleanType Delta_bC_isZero, real_t* const delta_xFX, real_t* const delta_xFR,
-									real_t* const delta_yAC, const real_t* const delta_g,
-									const real_t* const delta_lbA, const real_t* const delta_ubA, real_t& rnrm);
-
-		returnValue stepCalcDeltayFx(	int_t nFR, int_t nFX, int_t nAC, int_t* FX_idx, const real_t* const delta_g,
-										real_t* const delta_xFX, real_t* const delta_xFR, real_t* const delta_yAC, real_t* const delta_yFX);
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		SparseSolver* sparseSolver;			/**< Interface to the sparse linear solver. */
-
-		real_t* S;							/**< Schur complement matrix. (This is actually the negative of the Schur complement!) */
-		int_t nS;							/**< Current size of Schur complement matrix. -1 means that the Schur complement has not yet been initialized. */
-		int_t nSmax;						/**< Maximum size of Schur complement matrix. */
-
-		real_t* Q_;							/**< QR factorization of S: orthogonal matrix Q */
-		real_t* R_;							/**< QR factorization of S: upper triangular matrix R */
-		real_t detS;						/**< Determinant of Schur complement */
-		real_t rcondS;						/**< Reciprocal of condition number of S (estimate) */
-		int_t numFactorizations;			/**< Total number of factorizations performed */
-
-		int_t* schurUpdateIndex;			/**< Indices of variables or constraints for each update in Schur complement. */
-		SchurUpdateType* schurUpdate;		/**< Type of update for each update in Schur complement. */
-
-		int_t M_physicallength;				/**< Allocated size of the M_vals and M_ir arrays. */
-		real_t* M_vals;						/**< Values of the sparse M matrix containing the vectors with the additional rows defining the Schur complement (length). */
-		sparse_int_t* M_ir;					/**< Row indices (length). */
-		sparse_int_t* M_jc;					/**< Indices in M to first entry of columns (nS+1). */
-
-		Indexlist boundsFreeStart;			/**< Index list for free bounds when major iteration started. */
-		Indexlist constraintsActiveStart;	/**< Index list for active constraints when major iteration started. */
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/SQProblemSchur.ipp>
-
-#endif	/* QPOASES_QPROBLEMSCHUR_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.ipp
deleted file mode 100644
index b08ef59..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SQProblemSchur.ipp
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2013 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SQProblemSchur.ipp
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- *
- *	Implementation of inlined member functions of the SQProblemSchur class which
- *	is able to use the newly developed online active set strategy for
- *	parametric quadratic programming.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-/*
- *	g e t N u m F a c t o r i z a t i o n s
- */
-inline int_t SQProblemSchur::getNumFactorizations( ) const
-{
-	return numFactorizations;
-}
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SparseSolver.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/SparseSolver.hpp
deleted file mode 100644
index 9a2d68b..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SparseSolver.hpp
+++ /dev/null
@@ -1,395 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *
- *	Copyright (C) 2012 by Andreas Waechter. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SparseSolver.hpp
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- *
- *	Interfaces to sparse linear solvers that are used in a Schur-complement
- *	implementation in qpOASES.
- */
-
-#ifndef QPOASES_SPARSESOLVER_HPP
-#define QPOASES_SPARSESOLVER_HPP
-
-#include <qpOASES/Utils.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Base class for linear solvers that are used in a Schur-complement
- *	implementation in qpOASES.
- *
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- */
-class SparseSolver
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		SparseSolver( );
-
-		/** Copy constructor (deep copy). */
-		SparseSolver(	const SparseSolver& rhs		/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~SparseSolver( );
-
-		/** Assignment operator (deep copy). */
-		virtual SparseSolver& operator=(	const SparseSolver& rhs	/**< Rhs object. */
-								);
-
-		/** Set new matrix data.  The matrix is to be provided
-		    in the Harwell-Boeing format.  Only the lower
-		    triangular part should be set. */
-		virtual returnValue setMatrixData( int_t dim,					/**< Dimension of the linear system. */
-										   int_t numNonzeros,			/**< Number of nonzeros in the matrix. */
-										   const int_t* const airn,		/**< Row indices for each matrix entry. */
-										   const int_t* const acjn,		/**< Column indices for each matrix entry. */
-										   const real_t* const avals	/**< Values for each matrix entry. */
-										   ) = 0;
-
-		/** Compute factorization of current matrix.  This method must be called before solve.*/
-		virtual returnValue factorize( ) = 0;
-
-		/** Solve linear system with most recently set matrix data. */
-		virtual returnValue solve( int_t dim, /**< Dimension of the linear system. */
-					   const real_t* const rhs, /**< Values for the right hand side. */
-					   real_t* const sol /**< Solution of the linear system. */
-					   ) = 0;
-
-		/** Clears all data structures. */
-		virtual returnValue reset( );
-
-		/** Return the number of negative eigenvalues. */
-		virtual int_t getNegativeEigenvalues( );
-
-		/** Return the rank after a factorization */
-		virtual int_t getRank( );
-
-		/** Returns the zero pivots in case the matrix is rank deficient */
-		virtual returnValue getZeroPivots( int_t *&zeroPivots );
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const SparseSolver& rhs	/**< Rhs object. */
-							);
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-};
-
-
-#ifdef SOLVER_MA27
-
-/**
- *	\brief Implementation of the linear solver interface using Harwell's MA27.
- *
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- */
-class Ma27SparseSolver: public SparseSolver
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Ma27SparseSolver( );
-
-		/** Copy constructor (deep copy). */
-		Ma27SparseSolver(	const Ma27SparseSolver& rhs		/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~Ma27SparseSolver( );
-
-		/** Assignment operator (deep copy). */
-		virtual Ma27SparseSolver& operator=(	const SparseSolver& rhs	/**< Rhs object. */
-								);
-
-		/** Set new matrix data.  The matrix is to be provided
-		    in the Harwell-Boeing format.  Only the lower
-		    triangular part should be set. */
-		virtual returnValue setMatrixData( int_t dim,					/**< Dimension of the linear system. */
-										   int_t numNonzeros,			/**< Number of nonzeros in the matrix. */
-										   const int_t* const airn,		/**< Row indices for each matrix entry. */
-										   const int_t* const acjn,		/**< Column indices for each matrix entry. */
-										   const real_t* const avals	/**< Values for each matrix entry. */
-										   );
-
-		/** Compute factorization of current matrix.  This method must be called before solve.*/
-		virtual returnValue factorize( );
-
-		/** Solve linear system with most recently set matrix data. */
-		virtual returnValue solve( int_t dim,				/**< Dimension of the linear system. */
-								   const real_t* const rhs, /**< Values for the right hand side. */
-								   real_t* const sol		/**< Solution of the linear system. */
-								   );
-
-		/** Clears all data structures. */
-		virtual returnValue reset( );
-
-		/** Return the number of negative eigenvalues. */
-		virtual int_t getNegativeEigenvalues( );
-
-		/** Return the rank after a factorization */
-		virtual int getRank( );
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Ma27SparseSolver& rhs	/**< Rhs object. */
-							);
-
-	/*
-	 *	PRIVATE MEMBER FUNCTIONS
-	 */
-	private:
-	/*
-	 *	PRIVATE MEMBER VARIABLES
-	 */
-	private:
-		fint dim; /**< Dimension of the current linear system. */
-
-		fint numNonzeros; /**< Number of nonzeros in the current linear system. */
-
-		fint la_ma27; /**< size of a_ma27 (LA in MA27) */
-
-		double* a_ma27; /**< matrix/factor for MA27 (A in MA27).  If have_factorization is false, it contains the matrix entries (and has length numNonzeros), otherwise the factor (and has length la_ma27). */
-
-		fint* irn_ma27; /**< Row entries of matrix (IRN in MA27) */
-
-		fint* jcn_ma27; /**< Column entries of matrix (JCN in MA27) */
-
-		fint icntl_ma27[30];  /**< integer control values (ICNRL in MA27) */
-
-		double cntl_ma27[5];  /**< real control values (CNRL in MA27) */
-
-		fint liw_ma27;  /**< length of integer work space (LIW in MA27) */
-
-		fint* iw_ma27; /**< integer work space (IW in MA27) */
-
-		fint* ikeep_ma27;  /**< IKEEP in MA27 */
-
-		fint nsteps_ma27;  /**< NSTEPS in MA27 */
-
-		fint maxfrt_ma27;  /**< MAXFRT in MA27 */
-
-		bool have_factorization; /**< flag indicating whether factorization for current matrix has already been computed */
-
-		fint neig;	/**< number of negative eigenvalues */
-
-		fint rank;	/**< rank of matrix */
-};
-
-#endif // SOLVER_MA27
-
-
-#ifdef SOLVER_MA57
-
-/**
- *	\brief Implementation of the linear solver interface using Harwell's MA57.
- *
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2013-2015
- */
-class Ma57SparseSolver: public SparseSolver
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		Ma57SparseSolver( );
-
-		/** Copy constructor (deep copy). */
-		Ma57SparseSolver(	const Ma57SparseSolver& rhs		/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~Ma57SparseSolver( );
-
-		/** Assignment operator (deep copy). */
-		virtual Ma57SparseSolver& operator=(	const SparseSolver& rhs	/**< Rhs object. */
-								);
-
-		/** Set new matrix data.  The matrix is to be provided
-		    in the Harwell-Boeing format.  Only the lower
-		    triangular part should be set. */
-		virtual returnValue setMatrixData( int_t dim,					/**< Dimension of the linear system. */
-										   int_t numNonzeros,			/**< Number of nonzeros in the matrix. */
-										   const int_t* const airn,		/**< Row indices for each matrix entry. */
-										   const int_t* const acjn,		/**< Column indices for each matrix entry. */
-										   const real_t* const avals	/**< Values for each matrix entry. */
-										   );
-
-		/** Compute factorization of current matrix.  This method must be called before solve.*/
-		virtual returnValue factorize( );
-
-		/** Solve linear system with most recently set matrix data. */
-		virtual returnValue solve(	int_t dim,					/**< Dimension of the linear system. */
-									const real_t* const rhs,	/**< Values for the right hand side. */
-									real_t* const sol			/**< Solution of the linear system. */
-									);
-
-		/** Clears all data structures. */
-		virtual returnValue reset( );
-
-		/** Return the number of negative eigenvalues. */
-		virtual int_t getNegativeEigenvalues( );
-
-		/** Return the rank after a factorization */
-		virtual int_t getRank( );
-
-		/** Returns the zero pivots in case the matrix is rank deficient */
-		virtual returnValue getZeroPivots( int_t *&zeroPivots );
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const Ma57SparseSolver& rhs	/**< Rhs object. */
-							);
-
-	/*
-	 *	PRIVATE MEMBER FUNCTIONS
-	 */
-	private:
-	/*
-	 *	PRIVATE MEMBER VARIABLES
-	 */
-	private:
-		fint dim;				/**< Dimension of the current linear system. */
-
-		fint numNonzeros;		/**< Number of nonzeros in the current linear system. */
-
-		double* a_ma57;			/**< matrix for MA57 (A in MA57) */
-
-		fint* irn_ma57;			/**< Row entries of matrix (IRN in MA57) */
-
-		fint* jcn_ma57;			/**< Column entries of matrix (JCN in MA57) */
-
-		fint icntl_ma57[30];	/**< integer control values (ICNRL in MA57) */
-
-		double cntl_ma57[5];	/**< real control values (CNRL in MA57) */
-
-		double* fact_ma57;		/**< array for storing the factors */
-
-		fint lfact_ma57;		/**< length of fact_ma57 */
-
-		fint* ifact_ma57;		/**< indexing information about the factors */
-
-		fint lifact_ma57;		/**< length of ifact_ma57 */
-
-		bool have_factorization;/**< flag indicating whether factorization for current matrix has already been computed */
-
-		fint neig;				/**< number of negative eigenvalues */
-
-		fint rank;				/**< rank of matrix */
-
-		fint* pivots;			/**< sequence of pivots used in factorization */
-};
-
-#endif // SOLVER_MA57
-
-
-#ifdef SOLVER_NONE
-
-/**
- *	\brief Implementation of a dummy sparse solver. An error is thrown if a factorization is attempted.
- *
- *	\author Dennis Janka
- *	\version 3.2
- *	\date 2015
- */
-class DummySparseSolver: public SparseSolver
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Set new matrix data.  The matrix is to be provided
-		    in the Harwell-Boeing format.  Only the lower
-		    triangular part should be set. */
-		virtual returnValue setMatrixData(	int_t dim,					/**< Dimension of the linear system. */
-											int_t numNonzeros,			/**< Number of nonzeros in the matrix. */
-											const int_t* const airn,	/**< Row indices for each matrix entry. */
-											const int_t* const acjn,	/**< Column indices for each matrix entry. */
-											const real_t* const avals	/**< Values for each matrix entry. */
-											);
-
-		/** Compute factorization of current matrix.  This method must be called before solve.*/
-		virtual returnValue factorize( );
-
-		/** Solve linear system with most recently set matrix data. */
-		virtual returnValue solve(	int_t dim,					/**< Dimension of the linear system. */
-									const real_t* const rhs,	/**< Values for the right hand side. */
-									real_t* const sol			/**< Solution of the linear system. */
-									);
-};
-
-#endif // SOLVER_NONE
-
-
-END_NAMESPACE_QPOASES
-
-#endif	/* QPOASES_SPARSESOLVER_HPP */
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.hpp
deleted file mode 100644
index 441ed2a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.hpp
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SubjectTo.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of the SubjectTo class designed to manage working sets of
- *	constraints and bounds within a QProblem.
- */
-
-
-#ifndef QPOASES_SUBJECTTO_HPP
-#define QPOASES_SUBJECTTO_HPP
-
-
-#include <qpOASES/Indexlist.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Base class for managing working sets of bounds and constraints.
- *
- *	This class manages working sets of bounds and constraints by storing
- *	index sets and other status information.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- */
-class SubjectTo
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		SubjectTo( );
-
-		/** Constructor which takes the number of constraints or bounds. */
-		SubjectTo(	int_t _n 							/**< Number of constraints or bounds. */
-					);
-
-		/** Copy constructor (deep copy). */
-		SubjectTo(	const SubjectTo& rhs				/**< Rhs object. */
-					);
-
-		/** Destructor. */
-		virtual ~SubjectTo( );
-
-		/** Assignment operator (deep copy). */
-		SubjectTo& operator=(	const SubjectTo& rhs	/**< Rhs object. */
-								);
-
-
-		/** Initialises object with given number of constraints or bounds.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INVALID_ARGUMENTS */
-		returnValue init(	int_t _n = 0				/**< Number of constraints or bounds. */
-							);
-
-
-		/** Returns number of constraints/bounds with given SubjectTo type.
-		 *	\return Number of constraints/bounds with given type. */
-		inline int_t getNumberOfType(	SubjectToType _type	/**< Type of (constraints') bound. */
-										) const;
-
-
-		/** Returns type of (constraints') bound.
-		 *	\return Type of (constraints') bound \n
-		 			RET_INDEX_OUT_OF_BOUNDS */
-		inline SubjectToType getType(	int_t i			/**< Number of (constraints') bound. */
-										) const;
-
-		/** Returns status of (constraints') bound.
-		 *	\return Status of (constraints') bound \n
-		 			ST_UNDEFINED */
-		inline SubjectToStatus getStatus(	int_t i		/**< Number of (constraints') bound. */
-											) const;
-
-
-		/** Sets type of (constraints') bound.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setType(	int_t i,			/**< Number of (constraints') bound. */
-									SubjectToType value	/**< Type of (constraints') bound. */
-									);
-
-		/** Sets status of (constraints') bound.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS */
-		inline returnValue setStatus(	int_t i,				/**< Number of (constraints') bound. */
-										SubjectToStatus value	/**< Status of (constraints') bound. */
-										);
-
-
-		/** Sets status of lower (constraints') bounds. */
-		inline void setNoLower(	BooleanType _status		/**< Status of lower (constraints') bounds. */
-								);
-
-		/** Sets status of upper (constraints') bounds. */
-		inline void setNoUpper(	BooleanType _status		/**< Status of upper (constraints') bounds. */
-								);
-
-
-		/** Returns status of lower (constraints') bounds.
-		 *	\return BT_TRUE if there is no lower (constraints') bound on any variable. */
-		inline BooleanType hasNoLower( ) const;
-
-		/** Returns status of upper bounds.
-		 *	\return BT_TRUE if there is no upper (constraints') bound on any variable. */
-		inline BooleanType hasNoUpper( ) const;
-
-
-		/** Shifts forward type and status of all constraints/bounds by a given
-		 *  offset. This offset has to lie within the range [0,n/2] and has to
-		 *  be an integer divisor of the total number of constraints/bounds n.
-		 *  Type and status of the first \<offset\> constraints/bounds is thrown away,
-		 *  type and status of the last \<offset\> constraints/bounds is doubled,
-		 *  e.g. for offset = 2: \n
-		 *  shift( {c/b1,c/b2,c/b3,c/b4,c/b5,c/b6} ) = {c/b3,c/b4,c/b5,c/b6,c/b5,c/b6}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_INVALID_ARGUMENTS \n
-		 			RET_SHIFTING_FAILED */
-		virtual returnValue shift(	int_t offset	/**< Shift offset within the range [0,n/2] and integer divisor of n. */
-									) = 0;
-
-		/** Rotates forward type and status of all constraints/bounds by a given
-		 *  offset. This offset has to lie within the range [0,n].
-		 *  Example for offset = 2: \n
-		 *  rotate( {c/b1,c/b2,c/b3,c/b4,c/b5,c/b6} ) = {c/b3,c/b4,c/b5,c/b6,c/b1,c/b2}
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_INDEX_OUT_OF_BOUNDS \n
-		 			RET_ROTATING_FAILED */
-		virtual returnValue rotate(	int_t offset	/**< Rotation offset within the range [0,n]. */
-									) = 0;
-
-
-	/*
-	 *	PROTECTED MEMBER FUNCTIONS
-	 */
-	protected:
-		/** Frees all allocated memory.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue clear( );
-		
-		/** Copies all members from given rhs object.
-		 *  \return SUCCESSFUL_RETURN */
-		returnValue copy(	const SubjectTo& rhs	/**< Rhs object. */
-							);
-
-
-		/** Adds the index of a new constraint or bound to index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_ADDINDEX_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue addIndex(	Indexlist* const indexlist,	/**< Index list to which the new index shall be added. */
-								int_t newnumber,			/**< Number of new constraint or bound. */
-								SubjectToStatus newstatus	/**< Status of new constraint or bound. */
-								);
-
-		/** Removes the index of a constraint or bound from index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_REMOVEINDEX_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue removeIndex(	Indexlist* const indexlist,	/**< Index list from which the new index shall be removed. */
-									int_t removenumber			/**< Number of constraint or bound to be removed. */
-									);
-
-		/** Swaps the indices of two constraints or bounds within the index set.
-		 *	\return SUCCESSFUL_RETURN \n
-		 			RET_SWAPINDEX_FAILED \n
-					RET_INVALID_ARGUMENTS */
-		returnValue swapIndex(	Indexlist* const indexlist,	/**< Index list in which the indices shold be swapped. */
-								int_t number1,				/**< Number of first constraint or bound. */
-								int_t number2				/**< Number of second constraint or bound. */
-								);
-
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-		int_t n;					/**< Total number of constraints/bounds. */
-
-		SubjectToType* type; 		/**< Type of constraints/bounds. */
-		SubjectToStatus* status;	/**< Status of constraints/bounds. */
-
-		BooleanType noLower;	 	/**< This flag indicates if there is no lower bound on any variable. */
-		BooleanType noUpper;	 	/**< This flag indicates if there is no upper bound on any variable. */
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/SubjectTo.ipp>
-
-#endif	/* QPOASES_SUBJECTTO_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.ipp
deleted file mode 100644
index 0cc8286..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/SubjectTo.ipp
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/SubjectTo.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the inlined member functions of the SubjectTo class
- *	designed to manage working sets of constraints and bounds within a QProblem.
- */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	g e t N u m b e r O f T y p e
- */
-inline int_t SubjectTo::getNumberOfType( SubjectToType _type ) const
-{
-	int_t i;
-	int_t numberOfType = 0;
-
-	if ( type != 0 )
-	{
-		for( i=0; i<n; ++i )
-			if ( type[i] == _type )
-				++numberOfType;
-	}
-
-	return numberOfType;
-}
-
-
-/*
- *	g e t T y p e
- */
-inline SubjectToType SubjectTo::getType( int_t i ) const
-{
-	if ( ( i >= 0 ) && ( i < n ) )
-		return type[i];
-
-	return ST_UNKNOWN;
-}
-
-
-/*
- *	g e t S t a t u s
- */
-inline SubjectToStatus SubjectTo::getStatus( int_t i ) const
-{
-	if ( ( i >= 0 ) && ( i < n ) )
-		return status[i];
-
-	return ST_UNDEFINED;
-}
-
-
-/*
- *	s e t T y p e
- */
-inline returnValue SubjectTo::setType( int_t i, SubjectToType value )
-{
-	if ( ( i >= 0 ) && ( i < n ) )
-	{
-		type[i] = value;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-}
-
-
-/*
- *	s e t S t a t u s
- */
-inline returnValue SubjectTo::setStatus( int_t i, SubjectToStatus value )
-{
-	if ( ( i >= 0 ) && ( i < n ) )
-	{
-		status[i] = value;
-		return SUCCESSFUL_RETURN;
-	}
-	else
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-}
-
-
-/*
- *	s e t N o L o w e r
- */
-inline void SubjectTo::setNoLower( BooleanType _status )
-{
-	noLower = _status;
-}
-
-
-/*
- *	s e t N o U p p e r
- */
-inline void SubjectTo::setNoUpper( BooleanType _status )
-{
-	noUpper = _status;
-}
-
-
-/*
- *	h a s N o L o w e r
- */
-inline BooleanType SubjectTo::hasNoLower( ) const
-{
-	return noLower;
-}
-
-
-/*
- *	h a s N o U p p p e r
- */
-inline BooleanType SubjectTo::hasNoUpper( ) const
-{
-	return noUpper;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Types.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Types.hpp
deleted file mode 100644
index 9654e3a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Types.hpp
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Types.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of all non-built-in types (except for classes).
- */
-
-
-#ifndef QPOASES_TYPES_HPP
-#define QPOASES_TYPES_HPP
-
-
-/* If your compiler does not support the snprintf() function,
- * uncomment the following line and try to compile again. */
-/* #define __NO_SNPRINTF__ */
-
-
-/* Uncomment the following line for setting the __DSPACE__ flag. */
-/* #define __DSPACE__ */
-
-/* Uncomment the following line for setting the __XPCTARGET__ flag. */
-/* #define __XPCTARGET__ */
-
-
-/* Uncomment the following line for setting the __NO_FMATH__ flag. */
-/* #define __NO_FMATH__ */
-
-/* Uncomment the following line to enable debug information. */
-/* #define __DEBUG__ */
-
-/* Uncomment the following line to enable suppress any kind of console output. */
-/* #define __SUPPRESSANYOUTPUT__ */
-
-
-/** Forces to always include all implicitly fixed bounds and all equality constraints
- *  into the initial working set when setting up an auxiliary QP. */
-#define __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-
-
-/* Uncomment the following line to activate the use of an alternative Givens
- * plane rotation requiring only three multiplications. */
-/* #define __USE_THREE_MULTS_GIVENS__ */
-
-/* Uncomment the following line to activate the use of single precision arithmetic. */
-/* #define __USE_SINGLE_PRECISION__ */
-
-
-
-/* Work-around for Borland BCC 5.5 compiler. */
-#ifdef __BORLANDC__
-#if __BORLANDC__ < 0x0561
-  #define __STDC__ 1
-#endif
-#endif
-
-
-/* Work-around for Microsoft compilers. */
-#ifdef _MSC_VER
-  #define __NO_SNPRINTF__
-  #pragma warning( disable : 4061 4100 4250 4514 4996 )
-#endif
-
-
-#ifdef __DSPACE__
-
-	/** Macro for switching on/off the beginning of the qpOASES namespace definition. */
-	#define BEGIN_NAMESPACE_QPOASES
-
-	/** Macro for switching on/off the end of the qpOASES namespace definition. */
-	#define END_NAMESPACE_QPOASES
-
-	/** Macro for switching on/off the use of the qpOASES namespace. */
-	#define USING_NAMESPACE_QPOASES
-
-	/** Macro for switching on/off references to the qpOASES namespace. */
-	#define REFER_NAMESPACE_QPOASES ::
-
-#else
-
-	/** Macro for switching on/off the beginning of the qpOASES namespace definition. */
-	#define BEGIN_NAMESPACE_QPOASES  namespace qpOASES {
-
-	/** Macro for switching on/off the end of the qpOASES namespace definition. */
-	#define END_NAMESPACE_QPOASES    }
-
-	/** Macro for switching on/off the use of the qpOASES namespace. */
-	#define USING_NAMESPACE_QPOASES  using namespace qpOASES;
-
-	/** Macro for switching on/off references to the qpOASES namespace. */
-	#define REFER_NAMESPACE_QPOASES  qpOASES::
-
-#endif
-
-
-/* Avoid any printing on embedded platforms. */
-#if defined(__DSPACE__) || defined(__XPCTARGET__)
-  #define __SUPPRESSANYOUTPUT__
-  #define __NO_SNPRINTF__
-#endif
-
-
-#ifdef __NO_SNPRINTF__
-  #if (!defined(_MSC_VER)) || defined(__DSPACE__) || defined(__XPCTARGET__)
-    /* If snprintf is not available, provide an empty implementation... */
-    int snprintf( char* s, size_t n, const char* format, ... );
-  #else
-	/* ... or substitute snprintf by _snprintf for Microsoft compilers. */
-    #define snprintf _snprintf
-  #endif
-#endif /* __NO_SNPRINTF__ */
-
-
-
-/** Macro for accessing the Cholesky factor R. */
-#define RR( I,J )  R[(I)+nV*(J)]
-
-/** Macro for accessing the orthonormal matrix Q of the QT factorisation. */
-#define QQ( I,J )  Q[(I)+nV*(J)]
-
-/** Macro for accessing the triangular matrix T of the QT factorisation. */
-#define TT( I,J )  T[(I)*sizeT+(J)]
-
-
-/* If neither MA57 nor MA27 are selected, activate the dummy solver */
-#if !defined(SOLVER_MA27) && !defined(SOLVER_MA57) && !defined(SOLVER_NONE)
-#define SOLVER_NONE
-#endif
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** Defines real_t for facilitating switching between double and float. */
-#ifdef __USE_SINGLE_PRECISION__
-typedef float real_t;
-#else
-typedef double real_t;
-#endif /* __USE_SINGLE_PRECISION__ */
-
-
-/** Defines int_t for facilitating switching between int and long int. */
-#ifdef __USE_LONG_INTEGERS__
-typedef long int_t;
-typedef unsigned long uint_t;
-#else
-typedef int int_t;
-typedef unsigned int uint_t;
-#endif /* __USE_LONG_INTEGERS__ */
-
-
-/** typedef for Fortran INTEGER type. Might be platform dependent! */
-typedef int fint;
-
-
-/**
- * Integer type for sparse matrix row/column entries. Make this "int"
- * for 32 bit entries, and "long" for 64-bit entries on x86_64 platform.
- *
- * Most sparse codes still assume 32-bit entries here (HSL, BQPD, ...)
- */
-typedef int_t sparse_int_t;
-
-
-/** Summarises all possible logical values. */
-enum BooleanType
-{
-	BT_FALSE,					/**< Logical value for "false". */
-	BT_TRUE						/**< Logical value for "true". */
-};
-
-
-/** Summarises all possible print levels. Print levels are used to describe
- *	the desired amount of output during runtime of qpOASES. */
-enum PrintLevel
-{
-	PL_DEBUG_ITER = -2,			/**< Full tabular debugging output. */
-	PL_TABULAR,					/**< Normal tabular output. */
-	PL_NONE,					/**< No output. */
-	PL_LOW,						/**< Print error messages only. */
-	PL_MEDIUM,					/**< Print error and warning messages as well as concise info messages. */
-	PL_HIGH						/**< Print all messages with full details. */
-};
-
-
-/** Defines visibility status of a message. */
-enum VisibilityStatus
-{
-	VS_HIDDEN,					/**< Message not visible. */
-	VS_VISIBLE					/**< Message visible. */
-};
-
-
-/** Summarises all possible states of the (S)QProblem(B) object during the
-solution process of a QP sequence. */
-enum QProblemStatus
-{
-	QPS_NOTINITIALISED,			/**< QProblem object is freshly instantiated or reset. */
-	QPS_PREPARINGAUXILIARYQP,	/**< An auxiliary problem is currently setup, either at the very beginning
-								 *   via an initial homotopy or after changing the QP matrices. */
-	QPS_AUXILIARYQPSOLVED,		/**< An auxilary problem was solved, either at the very beginning
-								 *   via an initial homotopy or after changing the QP matrices. */
-	QPS_PERFORMINGHOMOTOPY,		/**< A homotopy according to the main idea of the online active
-								 *   set strategy is performed. */
-	QPS_HOMOTOPYQPSOLVED,		/**< An intermediate QP along the homotopy path was solved. */
-	QPS_SOLVED					/**< The solution of the actual QP was found. */
-};
-
-
-/** Summarises all possible types of the QP's Hessian matrix. */
-enum HessianType
-{
-	HST_ZERO,				/**< Hessian is zero matrix (i.e. LP formulation). */
-	HST_IDENTITY,			/**< Hessian is identity matrix. */
-	HST_POSDEF,				/**< Hessian is (strictly) positive definite. */
-	HST_POSDEF_NULLSPACE,	/**< Hessian is positive definite on null space of active bounds/constraints. */
-	HST_SEMIDEF,			/**< Hessian is positive semi-definite. */
-	HST_INDEF,				/**< Hessian is indefinite. */
-	HST_UNKNOWN				/**< Hessian type is unknown. */
-};
-
-
-/** Summarises all possible types of bounds and constraints. */
-enum SubjectToType
-{
-	ST_UNBOUNDED,		/**< Bound/constraint is unbounded. */
-	ST_BOUNDED,			/**< Bound/constraint is bounded but not fixed. */
-	ST_EQUALITY,		/**< Bound/constraint is fixed (implicit equality bound/constraint). */
-	ST_DISABLED,		/**< Bound/constraint is disabled (i.e. ignored when solving QP). */
-	ST_UNKNOWN			/**< Type of bound/constraint unknown. */
-};
-
-
-/** Summarises all possible states of bounds and constraints. */
-enum SubjectToStatus
-{
-	ST_LOWER = -1,			/**< Bound/constraint is at its lower bound. */
-	ST_INACTIVE,			/**< Bound/constraint is inactive. */
-	ST_UPPER,				/**< Bound/constraint is at its upper bound. */
-	ST_INFEASIBLE_LOWER,	/**< (to be documented) */
-	ST_INFEASIBLE_UPPER,	/**< (to be documented) */
-	ST_UNDEFINED			/**< Status of bound/constraint undefined. */
-};
-
-/** Flag indicating which type of update generated column in Schur complement. */
-enum SchurUpdateType
-{
-	SUT_VarFixed,			/**< Free variable gets fixed. */
-	SUT_VarFreed,			/**< Fixed variable gets freed. */
-	SUT_ConAdded,			/**< Constraint becomes active. */
-	SUT_ConRemoved,			/**< Constraint becomes inactive. */
-	SUT_UNDEFINED			/**< Type of Schur update is undefined. */
-};
-
-/**
- *	\brief Stores internal information for tabular (debugging) output.
- *
- *	Struct storing internal information for tabular (debugging) output
- *	when using the (S)QProblem(B) objects.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2013-2015
- */
-struct TabularOutput {
-	int_t idxAddB;		/**< Index of bound that has been added to working set. */
-	int_t idxRemB;		/**< Index of bound that has been removed from working set. */
-	int_t idxAddC;		/**< Index of constraint that has been added to working set. */
-	int_t idxRemC;		/**< Index of constraint that has been removed from working set. */
-	int_t excAddB;		/**< Flag indicating whether a bound has been added to working set to keep a regular projected Hessian. */
-	int_t excRemB;		/**< Flag indicating whether a bound has been removed from working set to keep a regular projected Hessian. */
-	int_t excAddC;		/**< Flag indicating whether a constraint has been added to working set to keep a regular projected Hessian. */
-	int_t excRemC;		/**< Flag indicating whether a constraint has been removed from working set to keep a regular projected Hessian. */
-};
-
-
-
-/**
- *	\brief Struct containing the variable header for mat file.
- *
- *	Struct storing the header of a variable to be stored in
- *	Matlab's binary format (using the outdated Level 4 variant
- *  for simplictiy).
- *
- *  Note, this code snippet has been inspired from the document
- *  "Matlab(R) MAT-file Format, R2013b" by MathWorks
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2013-2015
- */
-typedef struct {
-	long numericFormat;		/**< Flag indicating numerical format. */
-	long nRows;				/**< Number of rows. */
-	long nCols;				/**< Number of rows. */
-	long imaginaryPart;		/**< (to be documented) */
-	long nCharName;			/**< Number of character in name. */
-} MatMatrixHeader;
-
-
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_TYPES_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/UnitTesting.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/UnitTesting.hpp
deleted file mode 100644
index c08e0ae..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/UnitTesting.hpp
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/UnitTesting.hpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Definition of auxiliary functions/macros for unit testing.
- */
-
-
-#ifndef QPOASES_UNIT_TESTING_HPP
-#define QPOASES_UNIT_TESTING_HPP
-
-
-#ifndef TEST_TOL_FACTOR
-#define TEST_TOL_FACTOR 1
-#endif
-
-
-/** Return value for tests that passed. */
-#define TEST_PASSED 0
-
-/** Return value for tests that failed. */
-#define TEST_FAILED 1
-
-/** Return value for tests that could not run due to missing external data. */
-#define TEST_DATA_NOT_FOUND 99
-
-
-/** Macro verifying that two numerical values are equal in order to pass unit test. */
-#define QPOASES_TEST_FOR_EQUAL( x,y ) if ( REFER_NAMESPACE_QPOASES isEqual( (x),(y) ) == BT_FALSE ) { return TEST_FAILED; }
-
-/** Macro verifying that two numerical values are close to each other in order to pass unit test. */
-#define QPOASES_TEST_FOR_NEAR( x,y )  if ( REFER_NAMESPACE_QPOASES getAbs((x)-(y)) / REFER_NAMESPACE_QPOASES getMax( 1.0,REFER_NAMESPACE_QPOASES getAbs(x) ) >= 1e-10 ) { return TEST_FAILED; }
-
-/** Macro verifying that first quantity is lower or equal than second one in order to pass unit test. */
-#define QPOASES_TEST_FOR_TOL( x,tol )  if ( (x) > (tol)*(TEST_TOL_FACTOR) ) { return TEST_FAILED; }
-
-/** Macro verifying that a logical expression holds in order to pass unit test. */
-#define QPOASES_TEST_FOR_TRUE( x )  if ( (x) == false ) { return TEST_FAILED; }
-
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_UNIT_TESTING_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.hpp
deleted file mode 100644
index 81e5736..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.hpp
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/Utils.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of some utility functions for working with qpOASES.
- */
-
-
-#ifndef QPOASES_UTILS_HPP
-#define QPOASES_UTILS_HPP
-
-
-#include <qpOASES/MessageHandling.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** Prints a (possibly named) vector.
- * \return SUCCESSFUL_RETURN */
-returnValue print(	const real_t* const v,	/**< Vector to be printed. */
-					int_t n,				/**< Length of vector. */
-					const char* name = 0	/**< Name of vector. */
-					);
-
-/** Prints a (possibly named) permuted vector.
- * \return SUCCESSFUL_RETURN */
-returnValue print(	const real_t* const v,		/**< Vector to be printed. */
-					int_t n,					/**< Length of vector. */
-					const int_t* const V_idx,	/**< Pemutation vector. */
-					const char* name = 0		/**< Name of vector. */
-					);
-
-/** Prints a (possibly named) matrix.
- * \return SUCCESSFUL_RETURN */
-returnValue print(	const real_t* const M,	/**< Matrix to be printed. */
-					int_t nrow,				/**< Row number of matrix. */
-					int_t ncol,				/**< Column number of matrix. */
-					const char* name = 0	/**< Name of matrix. */
-					);
-
-/** Prints a (possibly named) permuted matrix.
- * \return SUCCESSFUL_RETURN */
-returnValue print(	const real_t* const M,		/**< Matrix to be printed. */
-					int_t nrow,					/**< Row number of matrix. */
-					int_t ncol	,				/**< Column number of matrix. */
-					const int_t* const ROW_idx,	/**< Row pemutation vector. */
-					const int_t* const COL_idx,	/**< Column pemutation vector. */
-					const char* name = 0		/**< Name of matrix. */
-					);
-
-/** Prints a (possibly named) index array.
- * \return SUCCESSFUL_RETURN */
-returnValue print(	const int_t* const index,	/**< Index array to be printed. */
-					int_t n,					/**< Length of index array. */
-					const char* name = 0		/**< Name of index array. */
-					);
-
-
-/** Prints a string to desired output target (useful also for MATLAB output!).
- * \return SUCCESSFUL_RETURN */
-returnValue myPrintf(	const char* s	/**< String to be written. */
-						);
-
-
-/** Prints qpOASES copyright notice.
- * \return SUCCESSFUL_RETURN */
-returnValue printCopyrightNotice( );
-
-
-/** Reads a real_t matrix from file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE \n
-		   RET_UNABLE_TO_READ_FILE */
-returnValue readFromFile(	real_t* data,				/**< Matrix to be read from file. */
-							int_t nrow,					/**< Row number of matrix. */
-							int_t ncol,					/**< Column number of matrix. */
-							const char* datafilename	/**< Data file name. */
-							);
-
-/** Reads a real_t vector from file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE \n
-		   RET_UNABLE_TO_READ_FILE */
-returnValue readFromFile(	real_t* data,				/**< Vector to be read from file. */
-							int_t n,					/**< Length of vector. */
-							const char* datafilename	/**< Data file name. */
-							);
-
-/** Reads an integer (column) vector from file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE \n
-		   RET_UNABLE_TO_READ_FILE */
-returnValue readFromFile(	int_t* data,				/**< Vector to be read from file. */
-							int_t n,					/**< Length of vector. */
-							const char* datafilename	/**< Data file name. */
-							);
-
-
-/** Writes a real_t matrix into a file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE  */
-returnValue writeIntoFile(	const real_t* const data,		/**< Matrix to be written into file. */
-							int_t nrow,						/**< Row number of matrix. */
-							int_t ncol,						/**< Column number of matrix. */
-							const char* datafilename,		/**< Data file name. */
-							BooleanType append = BT_FALSE	/**< Indicates if data shall be appended if the file already exists (otherwise it is overwritten). */
-							);
-
-/** Writes a real_t vector into a file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE  */
-returnValue writeIntoFile(	const real_t* const data,		/**< Vector to be written into file. */
-							int_t n,						/**< Length of vector. */
-							const char* datafilename,		/**< Data file name. */
-							BooleanType append = BT_FALSE	/**< Indicates if data shall be appended if the file already exists (otherwise it is overwritten). */
-							);
-
-/** Writes an integer (column) vector into a file.
- * \return SUCCESSFUL_RETURN \n
- 		   RET_UNABLE_TO_OPEN_FILE */
-returnValue writeIntoFile(	const int_t* const integer,		/**< Integer vector to be written into file. */
-							int_t n,						/**< Length of vector. */
-							const char* datafilename,		/**< Data file name. */
-							BooleanType append = BT_FALSE	/**< Indicates if integer shall be appended if the file already exists (otherwise it is overwritten). */
-							);
-
-/** Writes a real_t matrix/vector into a Matlab binary file.
- * \return SUCCESSFUL_RETURN \n
-		   RET_INVALID_ARGUMENTS
- 		   RET_UNABLE_TO_WRITE_FILE */
-returnValue writeIntoMatFile(	FILE* const matFile,		/**< Pointer to Matlab binary file. */
-								const real_t* const data,	/**< Data to be written into file. */
-								int_t nRows,				/**< Row number of matrix. */
-								int_t nCols, 				/**< Column number of matrix. */
-								const char* name			/**< Matlab name of matrix/vector to be stored. */
-								);
-
-/** Writes in integer matrix/vector into a Matlab binary file.
- * \return SUCCESSFUL_RETURN \n
-		   RET_INVALID_ARGUMENTS
- 		   RET_UNABLE_TO_WRITE_FILE */
-returnValue writeIntoMatFile(	FILE* const matFile,		/**< Pointer to Matlab binary file. */
-								const int_t* const data,	/**< Data to be written into file. */
-								int_t nRows,				/**< Row number of matrix. */
-								int_t nCols,				/**< Column number of matrix. */
-								const char* name			/**< Matlab name of matrix/vector to be stored. */
-								);
-
-
-/** Returns the current system time.
- * \return current system time */
-real_t getCPUtime( );
-
-
-/** Returns the N-norm of a vector.
- * \return >= 0.0: successful */
-real_t getNorm(	const real_t* const v,	/**< Vector. */
-				int_t n,				/**< Vector's dimension. */
-				int_t type = 2			/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-				);
-
-
-/** Tests whether two real_t-valued arguments are (numerically) equal.
- * \return	BT_TRUE:  arguments differ not more than TOL \n
-		 	BT_FALSE: arguments differ more than TOL */
-inline BooleanType isEqual(	real_t x,			/**< First real number. */
-							real_t y,			/**< Second real number. */
-							real_t TOL = ZERO	/**< Tolerance for comparison. */
-							);
-
-
-/** Tests whether a real-valued argument is (numerically) zero.
- * \return	BT_TRUE:  argument differs from 0.0 not more than TOL \n
-		 	BT_FALSE: argument differs from 0.0 more than TOL */
-inline BooleanType isZero(	real_t x,			/**< Real number. */
-							real_t TOL = ZERO	/**< Tolerance for comparison. */
-							);
-
-
-/** Returns sign of a real-valued argument.
- * \return	 1.0: argument is non-negative \n
-		 	-1.0: argument is negative */
-inline real_t getSign(	real_t arg	/**< real-valued argument whose sign is to be determined. */
-						);
-
-
-/** Returns maximum of two integers.
- * \return	Maximum of two integers */
-inline int_t getMax(	int_t x,	/**< First integer. */
-						int_t y		/**< Second integer. */
-						);
-					
-/** Returns minimum of two integers.
- * \return	Minimum of two integers */
-inline int_t getMin(	int_t x,	/**< First integer. */
-						int_t y		/**< Second integer. */
-						);
-
-	
-/** Returns maximum of two reals.
- * \return	Maximum of two reals */
-inline real_t getMax(	real_t x,	/**< First real number. */
-						real_t y	/**< Second real number. */
-						);
-
-/** Returns minimum of two reals.
- * \return	Minimum of two reals */
-inline real_t getMin(	real_t x,	/**< First real number. */
-						real_t y	/**< Second real number. */
-						);
-
-/** Returns the absolute value of a real number.
- * \return	Absolute value of a real number */
-inline real_t getAbs(	real_t x	/**< Real number. */
-						);
-
-/** Returns the square-root of a real number.
- * \return	Square-root of a real number */
-inline real_t getSqrt(	real_t x	/**< Non-negative real number. */
-						);
-
-
-/** Computes the maximum violation of the KKT optimality conditions
- *	of given iterate for given QP data. */
-returnValue getKktViolation(	int_t nV,									/**< Number of variables. */
-								int_t nC,									/**< Number of constraints. */
-								const real_t* const H,						/**< Hessian matrix (may be NULL if Hessian is zero or identity matrix). */
-								const real_t* const g,						/**< Gradient vector. */
-								const real_t* const A,						/**< Constraint matrix. */
-								const real_t* const lb,						/**< Lower bound vector (on variables). */
-								const real_t* const ub,						/**< Upper bound vector (on variables). */
-								const real_t* const lbA,					/**< Lower constraints' bound vector. */
-								const real_t* const ubA,					/**< Upper constraints' bound vector. */
-								const real_t* const x,						/**< Primal trial vector. */
-								const real_t* const y,						/**< Dual trial vector. */
-								real_t& stat,								/**< Output: maximum value of stationarity condition residual. */
-								real_t& feas,								/**< Output: maximum value of primal feasibility violation. */
-								real_t& cmpl,								/**< Output: maximum value of complementarity residual. */
-								const real_t* const workingSetB = 0,		/**< Working set of bounds (used to determine active bounds). */
-								const real_t* const workingSetC = 0,		/**< Working set of constraints (used to determine active constraints). */
-								BooleanType hasIdentityHessian = BT_FALSE	/**< Indicating whether Hessian matrix is identity matrix or not if NULL pointer is passed. */
-								);
-
-/** Computes the maximum violation of the KKT optimality conditions
- *	of given iterate for given QP data. */
-returnValue getKktViolation(	int_t nV,									/**< Number of variables. */
-								const real_t* const H,						/**< Hessian matrix (may be NULL if Hessian is zero or identity matrix). */
-								const real_t* const g,						/**< Gradient vector. */
-								const real_t* const lb,						/**< Lower bound vector (on variables). */
-								const real_t* const ub,						/**< Upper bound vector (on variables). */
-								const real_t* const x,						/**< Primal trial vector. */
-								const real_t* const y,						/**< Dual trial vector. */
-								real_t& stat,								/**< Output: maximum value of stationarity condition residual. */
-								real_t& feas,								/**< Output: maximum value of primal feasibility violation. */
-								real_t& cmpl,								/**< Output: maximum value of complementarity residual. */
-								const real_t* const workingSetB = 0,		/**< Working set of bounds (used to determine active bounds). */
-								BooleanType hasIdentityHessian = BT_FALSE	/**< Indicating whether Hessian matrix is identity matrix or not if NULL pointer is passed */
-								);
-
-
-/** Writes a value of BooleanType into a string.
- * \return SUCCESSFUL_RETURN */
-returnValue convertBooleanTypeToString(	BooleanType value, 		/**< Value to be written. */
-										char* const string		/**< Input: String of sufficient size, \n
-																	 Output: String containing value. */
-										);
-
-/** Writes a value of SubjectToStatus into a string.
- * \return SUCCESSFUL_RETURN */
-returnValue convertSubjectToStatusToString(	SubjectToStatus value,	/**< Value to be written. */
-											char* const string		/**< Input: String of sufficient size, \n
-																		 Output: String containing value. */
-											);
-
-/** Writes a value of PrintLevel into a string.
- * \return SUCCESSFUL_RETURN */
-returnValue convertPrintLevelToString(	PrintLevel value, 		/**< Value to be written. */
-										char* const string		/**< Input: String of sufficient size, \n
-																	 Output: String containing value. */
-										);
-
-
-/** Converts a returnValue from an (S)QProblem(B) object into a more 
- *	simple status flag.
- *
- * \return  0: QP problem solved
- *          1: QP could not be solved within given number of iterations
- *         -1: QP could not be solved due to an internal error
- *         -2: QP is infeasible (and thus could not be solved)
- *         -3: QP is unbounded (and thus could not be solved)
- */
-int_t getSimpleStatus(	returnValue returnvalue, 				/**< ReturnValue to be analysed. */
-						BooleanType doPrintStatus = BT_FALSE	/**< Flag indicating whether simple status shall be printed to screen. */
-						);
-
-
-/** Normalises QP constraints.
- * \return SUCCESSFUL_RETURN \n
- *		   RET_INVALID_ARGUMENTS */
-returnValue normaliseConstraints(	int_t nV,		/**< Number of variables. */
-									int_t nC, 		/**< Number of constraints. */
-									real_t* A,		/**< Input:  Constraint matrix, \n
-														 Output: Normalised constraint matrix. */
-									real_t* lbA,	/**< Input:  Constraints' lower bound vector, \n
-														 Output: Normalised constraints' lower bound vector. */
-									real_t* ubA,	/**< Input:  Constraints' upper bound vector, \n
-														 Output: Normalised constraints' upper bound vector. */
-									int_t type = 1	/**< Norm type, 1: one-norm, 2: Euclidean norm. */
-									);
-
-
-#ifdef __DEBUG__
-/** Writes matrix with given dimension into specified file. */
-extern "C" void gdb_printmat(	const char *fname,			/**< File name. */
-								real_t *M,					/**< Matrix to be written. */
-								int_t n,					/**< Number of rows. */
-								int_t m,					/**< Number of columns. */
-								int_t ldim					/**< Leading dimension. */
-								);
-#endif /* __DEBUG__ */
-
-
-#if defined(__DSPACE__) || defined(__XPCTARGET__) || defined(__C_WRAPPER__)
-extern "C" void __cxa_pure_virtual( void );
-#endif /* __DSPACE__ || __XPCTARGET__*/ 
-
-
-
-END_NAMESPACE_QPOASES
-
-
-#include <qpOASES/Utils.ipp>
-
-#endif	/* QPOASES_UTILS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.ipp
deleted file mode 100644
index ff7482a..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/Utils.ipp
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-
-/**
- *	\file include/qpOASES/Utils.ipp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of some inlined utilities for working with the different QProblem classes.
- */
-
-
-#include <math.h>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*
- *   i s E q u a l
- */
-inline BooleanType isEqual(	real_t x,
-							real_t y,
-							real_t TOL
-							)
-{
-    if ( getAbs(x-y) <= TOL )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *   i s Z e r o
- */
-inline BooleanType isZero(	real_t x,
-							real_t TOL
-							)
-{
-    if ( getAbs(x) <= TOL )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *   g e t S i g n
- */
-inline real_t getSign(	real_t arg
-						)
-{
-	if ( arg >= 0.0 )
-		return 1.0;
-	else
-		return -1.0;
-}
-
-
-
-/*
- *   g e t M a x
- */
-inline int_t getMax(	int_t x,
-						int_t y
-						)
-{
-    return (y<x) ? x : y;
-}
-
-
-/*
- *   g e t M i n
- */
-inline int_t getMin(	int_t x,
-						int_t y
-						)
-{
-    return (y>x) ? x : y;
-}
-
-
-
-/*
- *   g e t M a x
- */
-inline real_t getMax(	real_t x,
-						real_t y
-						)
-{
-	#ifdef __NO_FMATH__
-    return (y<x) ? x : y;
-	#else
-	return (y<x) ? x : y;
-	//return fmax(x,y); /* seems to be slower */
-	#endif
-}
-
-
-/*
- *   g e t M i n
- */
-inline real_t getMin(	real_t x,
-						real_t y
-						)
-{
-	#ifdef __NO_FMATH__
-    return (y>x) ? x : y;
-	#else
-	return (y>x) ? x : y;
-	//return fmin(x,y); /* seems to be slower */
-	#endif
-}
-
-
-/*
- *   g e t A b s
- */
-inline real_t getAbs(	real_t x
-						)
-{
-	#ifdef __NO_FMATH__
-	return (x>=0.0) ? x : -x;
-	#else
-	return fabs(x);
-	#endif
-}
-
-
-/*
- *   g e t S q r t
- */
-inline real_t getSqrt(	real_t x
-						)
-{
-	#ifdef __NO_FMATH__
-	return sqrt(x); /* put your custom sqrt-replacement here */
-	#else
-	return sqrt(x);
-	#endif
-}
-
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/OQPinterface.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/extras/OQPinterface.hpp
deleted file mode 100644
index a34ef2c..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/OQPinterface.hpp
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/extras/OQPinterface.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Declaration of an interface comprising several utility functions
- *	for solving test problems from the Online QP Benchmark Collection
- *	(This collection is no longer maintained, see 
- *	http://www.qpOASES.org/onlineQP for a backup).
- */
-
-
-#ifndef QPOASES_OQPINTERFACE_HPP
-#define QPOASES_OQPINTERFACE_HPP
-
-
-#include <qpOASES/Options.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/** Reads dimensions of an Online QP Benchmark problem from file.
- *
- * \return SUCCESSFUL_RETURN \n
-		   RET_UNABLE_TO_READ_FILE \n
-		   RET_FILEDATA_INCONSISTENT */
-returnValue readOqpDimensions(	const char* path,	/**< Full path of the data files (without trailing slash!). */
-								int_t& nQP,			/**< Output: Number of QPs. */
-								int_t& nV,			/**< Output: Number of variables. */
-								int_t& nC,			/**< Output: Number of constraints. */
-								int_t& nEC			/**< Output: Number of equality constraints. */
-								);
-
-/** Reads data of an Online QP Benchmark problem from file.
- *  This function allocates the required memory for all data; after successfully calling it,
- *  you have to free this memory yourself!
- *
- * \return SUCCESSFUL_RETURN \n
-		   RET_INVALID_ARGUMENTS \n
-		   RET_UNABLE_TO_READ_FILE \n
-		   RET_FILEDATA_INCONSISTENT */
-returnValue readOqpData(	const char* path,	/**< Full path of the data files (without trailing slash!). */
-							int_t& nQP,			/**< Output: Number of QPs. */
-							int_t& nV,			/**< Output: Number of variables. */
-							int_t& nC,			/**< Output: Number of constraints. */
-							int_t& nEC,			/**< Output: Number of equality constraints. */
-							real_t** H,		 	/**< Output: Hessian matrix. */
-							real_t** g,		 	/**< Output: Sequence of gradient vectors. */
-							real_t** A,		 	/**< Output: Constraint matrix. */
-							real_t** lb,		/**< Output: Sequence of lower bound vectors (on variables). */
-							real_t** ub,		/**< Output: Sequence of upper bound vectors (on variables). */
-							real_t** lbA,		/**< Output: Sequence of lower constraints' bound vectors. */
-							real_t** ubA,		/**< Output: Sequence of upper constraints' bound vectors. */
-							real_t** xOpt,		/**< Output: Sequence of primal solution vectors
-												 *           (not read if a null pointer is passed). */
-							real_t** yOpt,		/**< Output: Sequence of dual solution vectors
-												 *           (not read if a null pointer is passed). */
-							real_t** objOpt		/**< Output: Sequence of optimal objective function values
-												 *           (not read if a null pointer is passed). */
-							);
-
-
-/** Solves an Online QP Benchmark problem as specified by the arguments.
- *  The maximum deviations from the given optimal solution as well as the
- *  maximum CPU time to solve each QP are determined.
- *
- *	Note: This variant is outdated and only kept to ensure 
- *		  backwards-compatibility!
- *
- * \return SUCCESSFUL_RETURN \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue solveOqpBenchmark(	int_t nQP,					/**< Number of QPs. */
-								int_t nV,					/**< Number of variables. */
-								int_t nC,					/**< Number of constraints. */
-								int_t nEC,					/**< Number of equality constraints. */
-								const real_t* const _H,		/**< Hessian matrix. */
-								const real_t* const g,		/**< Sequence of gradient vectors. */
-								const real_t* const _A,		/**< Constraint matrix. */
-								const real_t* const lb,		/**< Sequence of lower bound vectors (on variables). */
-								const real_t* const ub,		/**< Sequence of upper bound vectors (on variables). */
-								const real_t* const lbA,	/**< Sequence of lower constraints' bound vectors. */
-								const real_t* const ubA,	/**< Sequence of upper constraints' bound vectors. */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t& nWSR, 				/**< Input: Maximum number of working set recalculations; \n
-																 Output: Maximum number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-/** Solves an Online QP Benchmark problem as specified by the arguments.
- *  The maximum deviations from the given optimal solution as well as the
- *  maximum CPU time to solve each QP are determined.
- *
- * \return SUCCESSFUL_RETURN \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue solveOqpBenchmark(	int_t nQP,					/**< Number of QPs. */
-								int_t nV,					/**< Number of variables. */
-								int_t nC,					/**< Number of constraints. */
-								int_t nEC,					/**< Number of equality constraints. */
-								const real_t* const _H,		/**< Hessian matrix. */
-								const real_t* const g,		/**< Sequence of gradient vectors. */
-								const real_t* const _A,		/**< Constraint matrix. */
-								const real_t* const lb,		/**< Sequence of lower bound vectors (on variables). */
-								const real_t* const ub,		/**< Sequence of upper bound vectors (on variables). */
-								const real_t* const lbA,	/**< Sequence of lower constraints' bound vectors. */
-								const real_t* const ubA,	/**< Sequence of upper constraints' bound vectors. */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								BooleanType useHotstarts,	/**< Shall QP solution be hotstarted? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t maxAllowedNWSR, 		/**< Maximum number of working set recalculations to be performed. */
-								real_t& maxNWSR,			/**< Output: Maximum number of performed working set recalculations. */
-								real_t& avgNWSR,			/**< Output: Average number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& avgCPUtime,			/**< Output: Average CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-
-/** Solves an Online QP Benchmark problem (without constraints) as specified
- *  by the arguments. The maximum deviations from the given optimal solution
- *  as well as the maximum CPU time to solve each QP are determined.
- *
- *	Note: This variant is outdated and only kept to ensure 
- *		  backwards-compatibility!
- *
- * \return SUCCESSFUL_RETURN \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue solveOqpBenchmark(	int_t nQP,					/**< Number of QPs. */
-								int_t nV,					/**< Number of variables. */
-								const real_t* const _H,		/**< Hessian matrix. */
-								const real_t* const g,		/**< Sequence of gradient vectors. */
-								const real_t* const lb,		/**< Sequence of lower bound vectors (on variables). */
-								const real_t* const ub,		/**< Sequence of upper bound vectors (on variables). */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t& nWSR, 				/**< Input: Maximum number of working set recalculations; \n
-																 Output: Maximum number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-/** Solves an Online QP Benchmark problem (without constraints) as specified
- *  by the arguments. The maximum deviations from the given optimal solution
- *  as well as the maximum CPU time to solve each QP are determined.
- *
- * \return SUCCESSFUL_RETURN \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue solveOqpBenchmark(	int_t nQP,					/**< Number of QPs. */
-								int_t nV,					/**< Number of variables. */
-								const real_t* const _H,		/**< Hessian matrix. */
-								const real_t* const g,		/**< Sequence of gradient vectors. */
-								const real_t* const lb,		/**< Sequence of lower bound vectors (on variables). */
-								const real_t* const ub,		/**< Sequence of upper bound vectors (on variables). */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								BooleanType useHotstarts,	/**< Shall QP solution be hotstarted? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t maxAllowedNWSR, 		/**< Maximum number of working set recalculations to be performed. */
-								real_t& maxNWSR,			/**< Output: Maximum number of performed working set recalculations. */
-								real_t& avgNWSR,			/**< Output: Average number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& avgCPUtime,			/**< Output: Average CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-
-/** Runs an Online QP Benchmark problem and determines the maximum
- *  violation of the KKT optimality conditions as well as the 
- *  maximum CPU time to solve each QP.
- *
- * \return SUCCESSFUL_RETURN \n
-		   RET_UNABLE_TO_READ_BENCHMARK \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue runOqpBenchmark(	const char* path,			/**< Full path of the benchmark files (without trailing slash!). */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t& nWSR, 				/**< Input: Maximum number of working set recalculations; \n
-																 Output: Maximum number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-
-/** Runs an Online QP Benchmark problem and determines the maximum
- *  violation of the KKT optimality conditions as well as the 
- *  maximum and average number of iterations and CPU time to solve 
- *	each QP.
- *
- * \return SUCCESSFUL_RETURN \n
-		   RET_UNABLE_TO_READ_BENCHMARK \n
- 		   RET_BENCHMARK_ABORTED */
-returnValue runOqpBenchmark(	const char* path,			/**< Full path of the benchmark files (without trailing slash!). */
-								BooleanType isSparse,		/**< Shall convert matrices to sparse format before solution? */
-								BooleanType useHotstarts,	/**< Shall QP solution be hotstarted? */
-								const Options& options,		/**< QP solver options to be used while solving benchmark problems. */
-								int_t maxAllowedNWSR, 		/**< Maximum number of working set recalculations to be performed. */
-								real_t& maxNWSR,			/**< Output: Maximum number of performed working set recalculations. */
-								real_t& avgNWSR,			/**< Output: Average number of performed working set recalculations. */
-								real_t& maxCPUtime,			/**< Output: Maximum CPU time required for solving each QP. */
-								real_t& avgCPUtime,			/**< Output: Average CPU time required for solving each QP. */
-								real_t& maxStationarity,	/**< Output: Maximum residual of stationarity condition. */
-								real_t& maxFeasibility,		/**< Output: Maximum residual of primal feasibility condition. */
-								real_t& maxComplementarity	/**< Output: Maximum residual of complementarity condition. */
-								);
-
-END_NAMESPACE_QPOASES
-
-
-#endif	/* QPOASES_OQPINTERFACE_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.hpp b/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.hpp
deleted file mode 100644
index c0988e4..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.hpp
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/extras/SolutionAnalysis.hpp
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Declaration of the SolutionAnalysis class designed to perform
- *	additional analysis after solving a QP with qpOASES.
- */
-
-
-#ifndef QPOASES_SOLUTIONANALYSIS_HPP
-#define QPOASES_SOLUTIONANALYSIS_HPP
-
-
-#include <qpOASES/SQProblem.hpp>
-#include <qpOASES/SQProblemSchur.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/**
- *	\brief Provides additional tools for analysing QP solutions.
- *
- *	This class is intended to provide additional tools for analysing
- *  a QP solution obtained with qpOASES.
- *
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- */
-class SolutionAnalysis
-{
-	/*
-	 *	PUBLIC MEMBER FUNCTIONS
-	 */
-	public:
-		/** Default constructor. */
-		SolutionAnalysis( );
-
-		/** Copy constructor (deep copy). */
-		SolutionAnalysis(	const SolutionAnalysis& rhs		/**< Rhs object. */
-							);
-
-		/** Destructor. */
-		~SolutionAnalysis( );
-
-		/** Assignment operator (deep copy). */
-		SolutionAnalysis& operator=(	const SolutionAnalysis& rhs		/**< Rhs object. */
-										);
-
-
-		/** Computes the maximum violation of the KKT optimality conditions
-		 *  of the current iterate within the QProblemB object.
-		 *	\return Maximum violation of the KKT conditions (or INFTY on error). */
-		real_t getKktViolation(	QProblemB* const qp,		/**< QProblemB to be analysed. */
-								real_t* const maxStat = 0,	/**< Output: maximum value of stationarity condition residual. */
-								real_t* const maxFeas = 0,	/**< Output: maximum value of primal feasibility violation. */
-								real_t* const maxCmpl = 0	/**< Output: maximum value of complementarity residual. */
-								) const;
-
-		/** Computes the maximum violation of the KKT optimality conditions
-		 *  of the current iterate within the QProblem object.
-		 *	\return Maximum violation of the KKT conditions (or INFTY on error). */
-		real_t getKktViolation(	QProblem* const qp,			/**< QProblem to be analysed. */
-								real_t* const maxStat = 0,	/**< Output: maximum value of stationarity condition residual. */
-								real_t* const maxFeas = 0,	/**< Output: maximum value of primal feasibility violation. */
-								real_t* const maxCmpl = 0	/**< Output: maximum value of complementarity residual. */
-								) const;
-
-		/** Computes the maximum violation of the KKT optimality conditions
-		 *  of the current iterate within the SQProblem object.
-		 *	\return Maximum violation of the KKT conditions (or INFTY on error). */
-		real_t getKktViolation(	SQProblem* const qp,		/**< SQProblem to be analysed. */
-								real_t* const maxStat = 0,	/**< Output: maximum value of stationarity condition residual. */
-								real_t* const maxFeas = 0,	/**< Output: maximum value of primal feasibility violation. */
-								real_t* const maxCmpl = 0	/**< Output: maximum value of complementarity residual. */
-								) const;
-
-
-		/** Computes the variance-covariance matrix of the QP output for uncertain
-			inputs.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HOTSTART_FAILED \n
-		 			RET_STEPDIRECTION_FAILED_TQ \n
-					RET_STEPDIRECTION_FAILED_CHOLESKY */
-		returnValue getVarianceCovariance(	QProblemB* const qp,			/**< QProblemB to be analysed. */
-											const real_t* const g_b_bA_VAR,	/**< Input:  Variance-covariance of g, the bounds lb and ub, 
-																			 *			 and lbA and ubA respectively. Dimension: 2nV x 2nV */
-											real_t* const Primal_Dual_VAR	/**< Output: The result for the variance-covariance of the primal 
-																			 *			 and dual variables. Dimension: 2nV x 2nV */
-											) const;
-
-		/** Computes the variance-covariance matrix of the QP output for uncertain
-			inputs.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HOTSTART_FAILED \n
-		 			RET_STEPDIRECTION_FAILED_TQ \n
-					RET_STEPDIRECTION_FAILED_CHOLESKY */
-		returnValue getVarianceCovariance(	QProblem* const qp,				/**< QProblem to be analysed. */
-											const real_t* const g_b_bA_VAR,	/**< Input:  Variance-covariance of g, the bounds lb and ub, 
-																			 *			 and lbA and ubA respectively. Dimension:  (2nV+nC) x (2nV+nC) */
-											real_t* const Primal_Dual_VAR	/**< Output: The result for the variance-covariance of the primal 
-																			 *			 and dual variables. Dimension:  (2nV+nC) x (2nV+nC) */
-											) const;
-
-		/** Computes the variance-covariance matrix of the QP output for uncertain
-			inputs.
-		 *	\return SUCCESSFUL_RETURN \n
-					RET_HOTSTART_FAILED \n
-		 			RET_STEPDIRECTION_FAILED_TQ \n
-					RET_STEPDIRECTION_FAILED_CHOLESKY */
-		returnValue getVarianceCovariance(	SQProblem* const qp,			/**< SQProblem to be analysed. */
-											const real_t* const g_b_bA_VAR,	/**< Input:  Variance-covariance of g, the bounds lb and ub, 
-																			 *			 and lbA and ubA respectively. Dimension:  (2nV+nC) x (2nV+nC) */
-											real_t* const Primal_Dual_VAR	/**< Output: The result for the variance-covariance of the primal 
-																			 *			 and dual variables. Dimension:  (2nV+nC) x (2nV+nC) */
-											) const;
-
-		/** Checks if a direction of negative curvature shows up if we remove all bounds that just recently became active */
-		returnValue checkCurvatureOnStronglyActiveConstraints(	SQProblemSchur* qp );
-		returnValue checkCurvatureOnStronglyActiveConstraints(	SQProblem* qp );
-
-	/*
-	 *	PROTECTED MEMBER VARIABLES
-	 */
-	protected:
-
-};
-
-
-END_NAMESPACE_QPOASES
-
-#include <qpOASES/extras/SolutionAnalysis.ipp>
-
-#endif	/* QPOASES_SOLUTIONANALYSIS_HPP */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.ipp b/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.ipp
deleted file mode 100644
index 3404cbe..0000000
--- a/extlibs/qpOASES-3.2.0/include/qpOASES/extras/SolutionAnalysis.ipp
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file include/qpOASES/extras/SolutionAnalysis.ipp
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Implementation of inlined member functions of the SolutionAnalysis class
- *	designed to perform additional analysis after solving a QP with qpOASES.
- *
- */
-
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/Makefile b/extlibs/qpOASES-3.2.0/interfaces/CUTEst/Makefile
deleted file mode 100644
index 0b74458..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/Makefile
+++ /dev/null
@@ -1,79 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  cutestDriver/Makefile
-##	Author:    Dennis Janka
-##	Version:   3.2
-##	Date:      2015
-##
-
-# include directories, relative
-IDIR = ../../include
-SRCDIR = ../../src
-BINDIR = ../../bin
-CUTESTLIBPATH = ${CUTEST}/objects/${MYARCH}/double
-
-# don't change that (for now) ...
-PROBLEMPATH = ./prob
-
-# file extensions
-CPP = g++
-CPPFLAGS = -Wall -pedantic -Wshadow -O0 -finline-functions -fPIC -DLINUX -g
-FF = gfortran
-FFLAGS =
-
-#link against CUTEst library, qpOASES library and compiled test problem
-LINKOPTS = -L${CUTESTLIBPATH} -L${PROBLEMPATH} -Wl,-rpath=${PROBLEMPATH} \
-		-L${BINDIR} -Wl,-rpath=${BINDIR} -lqpOASES \
-		-lcutest -llapack -lm -lgfortran -lprob
-
-IFLAGS      = -I${IDIR} \
-	      -I${CUTEST}/include
-
-QPOASES_EXES = \
-	qpoasesCutest
-
-##
-##	targets
-##
-
-all: ${QPOASES_EXES}
-
-qpoasesCutest: qpoasesCutest.o
-	@echo "Creating" $@
-	${CPP} -o $@ ${CPPFLAGS} $< ${LINKOPTS}
-
-clean:
-	rm -f *.o ${QPOASES_EXES}
-
-clobber: clean
-
-%.o: %.cpp
-	@echo "Creating" $@
-	@${CPP} -c ${IFLAGS} ${CPPFLAGS} $< -o $@
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/makeprob b/extlibs/qpOASES-3.2.0/interfaces/CUTEst/makeprob
deleted file mode 100755
index 237a895..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/makeprob
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/bin/bash
-
-if [ -z "$1" ]; then
-    echo Usage: $0 problemname
-    exit
-fi
-
-PROBLEMPATH="./prob"
-mkdir -p $PROBLEMPATH
-cd $PROBLEMPATH
-
-# Call sifdecoder (additional parameter for problem size can be passed)
-if [ -z "$2" ]; then
-    sifdecoder $MASTSIF/$1
-else
-    sifdecoder -param N=$2 $MASTSIF/$1
-fi
-
-# Compile objects
-gfortran -c RANGE.f -fPIC -o RANGE.o
-gfortran -c ELFUN.f -fPIC -o ELFUN.o
-gfortran -c GROUP.f -fPIC -o GROUP.o
-
-# Build shared library
-gfortran -shared -o libprob.so RANGE.o ELFUN.o GROUP.o
-
-cd ../
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/qpoasesCutest.cpp b/extlibs/qpOASES-3.2.0/interfaces/CUTEst/qpoasesCutest.cpp
deleted file mode 100644
index 4045b9b..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/qpoasesCutest.cpp
+++ /dev/null
@@ -1,498 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/CUTEst/qpoasesCutest.cpp
- *	\author Dennis Janka
- *	\version 3.2
- *	\date 2015
- *
- *	Solve the CUTEst problem in prob/ subdirectory
- */
-
-/* Choose one or more methods to solve the QP */
-#define SOLVE_DENSE  0          /* Standard qpOASES, matrices passed dense */
-#define SOLVE_SPARSE 0          /* Standard qpOASES, matrices passed sparse */
-#define SOLVE_SCHUR  1          /* Schur complement qpOASES */
-
-
-#include <qpOASES.hpp>
-#include <sys/time.h>
-
-extern "C" {   /* To prevent C++ compilers from mangling symbols */
-#include <cutest.h>
-}
-
-
-int convertTripletToHbf( int m, int n, int nnz,
-                         double *vals, int *iRow, int *jCol,
-                         double *vals_hbf, int *iRow_hbf, int *jCol_hbf )
-{
-    int i, ii, j, k;
-
-    /* Initialize output arrays */
-    for( k=0; k<n+1; k++ )
-        jCol_hbf[k] = 0;
-    for( k=0; k<nnz; k++ )
-    {
-        iRow_hbf[k] = 0;
-        vals_hbf[k] = 0.0;
-    }
-
-    /* Count elements for each column */
-    for( k=0; k<nnz; k++ )
-    {
-        j = jCol[k]-1; // Convert Fortran to C indices!
-        jCol_hbf[j]++;
-    }
-
-    /* Set the column pointers */
-    jCol_hbf[n] = nnz;
-    for( k=n-1; k>-1; k-- )
-        jCol_hbf[k] = jCol_hbf[k+1] - jCol_hbf[k];
-
-    /* Put row indices and values at the right places, use jCol_hbf[j] to track elements of the jth column */
-    for( k=0; k<nnz; k++ )
-    {
-        i = iRow[k]-1; // Convert Fortran to C indices!
-        j = jCol[k]-1;
-        ii = jCol_hbf[j];
-
-        vals_hbf[ii] = vals[k];
-        iRow_hbf[ii] = i;
-        jCol_hbf[j] = ii + 1;
-    }
-
-    /* Shift all column pointers back again */
-    for( k=n-1; k>0; k-- )
-        jCol_hbf[k] = jCol_hbf[k-1];
-    jCol_hbf[0] = 0;
-
-    return 0;
-}
-
-
-
-int main( )
-{
-    /*
-     * PART I: Extract CUTEst problemdata:
-     *
-     * - problem dimension
-     * - variable and constraint bounds
-     * - objective gradient
-     * - sparse and dense Jacobian
-     * - sparse and dense Hessian
-     * - initial values for x and y
-     */
-
-    /* From CUTEst generic c package */
-    char *fname = "prob/OUTSDIF.d"; /* CUTEst data file */
-    int funit = 42;                 /* FORTRAN unit number for OUTSDIF.d */
-    int iout = 6;                   /* FORTRAN unit number for error output */
-    int io_buffer = 11;             /* FORTRAN unit internal input/output */
-    int ierr;                       /* Exit flag from OPEN and CLOSE */
-    int status;                     /* Exit flag from CUTEst tools */
-    int e_order = 0, l_order = 0, v_order = 0;
-
-
-    /* Problem description: the following variables will be set for qpOASES call */
-    int nVar;                       /* number of variables */
-    int nCon;                       /* number of constraints */
-    double *lb, *ub;                /* lower and upper bounds for variables */
-    double *lbA, *ubA;              /* lower and upper bounds for constraints */
-    double *g;                      /* objective gradient */
-#if SOLVE_DENSE
-    double *hesDense, *jacDense;    /* dense Hessian and Jacobian */
-#endif
-#if SOLVE_SCHUR || SOLVE_SPARSE
-                                    /* Sparse Hessian and Jacobian in Harwell-Boeing format: */
-    int nnzj, nnzh;                 /* number of nonzero elements in Jacobian and Hessian */
-    double *hesVal, *jacVal;        /* nonzero elements of Hessian and Jacobian */
-    int *hesIndCol, *hesIndRow;     /* column and row indices of Hessian */
-    int *jacIndCol, *jacIndRow;     /* column and row indices of Jacobian */
-#endif
-
-    /* Additional problem description: these variables are set and may also be used by qpOASES */
-    double obj;                     /* constant objective offset */
-    double *xInit;                  /* initial values for primal variables */
-    double *yInit;                  /* initial values for dual variables */
-    logical *isEq;                  /* logical array to mark equality constraints */
-
-
-    /* Open problem description file OUTSDIF.d */
-    ierr = 0;
-    FORTRAN_open( &funit, fname, &ierr );
-    if( ierr ) {
-        printf("Error opening file OUTSDIF.d.\nAborting.\n");
-        exit(1);
-    }
-
-    /* Determine problem size */
-    CUTEST_cdimen( &status, &funit, &nVar, &nCon );
-    if( status ) {
-        printf("** CUTEst error, status = %d, aborting\n", status);
-        exit(status);
-    }
-
-    /* Reserve memory for variables, bounds, and multipliers */
-    /* and call appropriate initialization routine for CUTEst */
-    logical *isLinear;
-    xInit = new double[nVar];
-    yInit = new double[nCon];
-    lb = new double[nVar];
-    ub = new double[nVar];
-    lbA = new double[nCon];
-    ubA = new double[nCon];
-    isEq = new logical[nCon];
-    isLinear = new logical[nCon];
-
-    CUTEST_csetup( &status, &funit, &iout, &io_buffer,
-                    &nVar, &nCon, xInit, lb, ub,
-                    yInit, lbA, ubA, isEq, isLinear,
-                    &e_order, &l_order, &v_order );
-    if( status ) {
-        printf("** CUTEst_csetup: error, status = %d, aborting\n", status);
-        exit(status);
-    }
-
-    /* Evaluate gradient and objective at x=0 to get g */
-    logical grad = 1;
-    g = new double[nVar];
-    double *xZero = new double[nVar];
-    for( int k=0; k<nVar; k++ ) xZero[k] = 0.0;
-    CUTEST_cofg( &status, &nVar, xZero, &obj, g, &grad );
-    if( status ) {
-        printf("** CUTEst_cofg: error, status = %d, aborting\n", status);
-        exit(status);
-    }
-
-    double *cVal = new double[nCon];
-#if SOLVE_SPARSE || SOLVE_SCHUR
-    /* Evaluate sparse Jacobian in triplet format */
-    int lj = nCon*nVar; // overestimate
-    double *J_val = new double[lj];
-    int *J_var = new int[lj];
-    int *J_fun = new int[lj];
-
-    if( nCon > 0 )
-    {
-        /* Evaluate sparse constraints at x=0 to get the rhs of equality constraints (they are not set by csetup!) */
-        CUTEST_ccfsg( &status, &nVar, &nCon, xZero, cVal, &nnzj, &lj, J_val, J_var, J_fun, &grad );
-        if( status ) {
-            printf("** CUTEst_ccfsg: error, status = %d, aborting\n", status);
-            exit(status);
-        }
-
-        for( int k=0; k<nCon; k++ )
-            if( isEq[k] )
-                lbA[k] = ubA[k] = -cVal[k];
-
-        jacIndCol = new int[nVar+1];
-        jacIndRow = new int[nnzj];
-        jacVal = new double[nnzj];
-        convertTripletToHbf( nCon, nVar, nnzj, J_val, J_fun, J_var, jacVal, jacIndRow, jacIndCol );
-
-    }
-    delete[] J_val;
-    delete[] J_fun;
-    delete[] J_var;
-
-    /* Evaluate sparse Hessian in triplet format */
-    int lh = nVar*nVar; // overestimate
-    double *H_val = new double[lh];
-    int *H_col = new int[lh];
-    int *H_row = new int[lh];
-    CUTEST_csh( &status, &nVar, &nCon, xInit, yInit, &nnzh, &lh, H_val, H_row, H_col );
-    if( status ) {
-        printf("** CUTEst_csh: error, status = %d, aborting\n", status);
-        exit(status);
-    }
-    /* Only upper triangular matrix is returned by CUTEst, to be safe, set H to be the full matrix */
-    int count = 0;
-    for( int k=0; k<nnzh; k++ )
-        if( H_row[k] != H_col[k] )
-        {
-            H_val[nnzh+count] = H_val[k];
-            H_col[nnzh+count] = H_row[k];
-            H_row[nnzh+count] = H_col[k];
-            count++;
-        }
-    nnzh = nnzh + count;
-
-    hesIndCol = new int[nVar+1];
-    hesIndRow = new int[nnzh];
-    hesVal = new double[nnzh];
-    convertTripletToHbf( nVar, nVar, nnzh, H_val, H_row, H_col, hesVal, hesIndRow, hesIndCol );
-
-    delete[] H_val;
-    delete[] H_row;
-    delete[] H_col;
-#endif
-
-#if SOLVE_DENSE
-    if( nCon > 0 )
-    {
-        /* Evaluate dense constraints at x=0 to get the rhs of equality constraints (they are not set by csetup!) */
-        logical trans = 1;
-        jacDense = new double[nCon*nVar];
-        CUTEST_ccfg( &status, &nVar, &nCon, xZero, cVal, &trans, &nVar, &nCon, jacDense, &grad );
-    }
-
-    /* Evaluate dense Hessian */
-    hesDense = new double[nVar*nVar];
-    CUTEST_cdh( &status, &nVar, &nCon, xInit, yInit, &nVar, hesDense );
-    if( status ) {
-        printf("** CUTEst_cdh: error, status = %d, aborting\n", status);
-        exit(status);
-    }
-#endif
-    delete[] xZero;
-
-    /*
-     * End of CUTEst stuff
-     */
-
-
-    /*
-     * PART II: qpOASES
-     */
-
-    USING_NAMESPACE_QPOASES
-
-    Options opts;
-#if SOLVE_DENSE
-    SymDenseMat *H_d;
-    DenseMatrix *A_d;
-#endif
-#if SOLVE_SCHUR || SOLVE_SPARSE
-    SymSparseMat *H_s;
-    SparseMatrix *A_s;
-#endif
-    Bounds bInit( nVar );
-    Constraints cInit( nCon );
-    double *xOpt = new double[nVar];
-    double *yOpt = new double[nVar+nCon];
-    Bounds bOpt( nVar );
-    Constraints cOpt( nCon );
-
-#if SOLVE_DENSE
-    A_d = new DenseMatrix( nCon, nVar, nVar, jacDense );
-    H_d = new SymDenseMat( nVar, nVar, nVar, hesDense );
-#endif
-#if SOLVE_SCHUR || SOLVE_SPARSE
-    A_s = new SparseMatrix( nCon, nVar, jacIndRow, jacIndCol, jacVal );
-    H_s = new SymSparseMat( nVar, nVar, hesIndRow, hesIndCol, hesVal );
-    H_s->createDiagInfo();
-#endif
-
-    /* Set initial working set depending on initial values for x and y */
-    /// \todo I have not tested this
-    double eps = 2.0e-16;
-    for( int k=0; k<nVar; k++ )
-    {
-        if( getAbs( xInit[k] - lb[k] ) < eps )
-            bInit.setStatus( k, ST_LOWER );
-        else if( getAbs( xInit[k] - ub[k] ) < eps )
-            bInit.setStatus( k, ST_UPPER );
-        else
-            bInit.setStatus( k, ST_INACTIVE );
-
-        bInit.setType( k, ST_UNKNOWN );
-    }
-    /// \todo should do this based on yInit (take care of signs of lambda)
-    for( int k=0; k<nCon; k++ )
-    {
-        if( getAbs( cVal[k] - lbA[k] ) < eps )
-            cInit.setStatus( k, ST_LOWER );
-        else if( getAbs( cVal[k] - ubA[k] ) < eps )
-            cInit.setStatus( k, ST_UPPER );
-        else
-            cInit.setStatus( k, ST_INACTIVE );
-
-        if( isEq[k] )
-            cInit.setType( k, ST_EQUALITY );
-        else
-            cInit.setType( k, ST_UNKNOWN );
-    }
-    delete[] cVal;
-
-    /* Set up QProblem object(s). */
-#if SOLVE_SCHUR
-    SQProblemSchur qpSchur( nVar, nCon, HST_UNKNOWN, 75 );
-#endif
-#if SOLVE_DENSE
-    SQProblem qpDense( nVar, nCon, HST_UNKNOWN );
-#endif
-#if SOLVE_SPARSE
-    SQProblem qpSparse( nVar, nCon, HST_UNKNOWN );
-#endif
-
-    /* Set options */
-    returnValue ret;
-    int maxIt = 10000;
-    double maxTime = 100000;
-
-    //opts.setToReliable();
-    opts.setToDefault();
-
-    //opts.printLevel = PL_HIGH;
-    //opts.enableRamping = BT_TRUE;
-    //opts.enableFarBounds = BT_TRUE;
-    //opts.enableFlippingBounds = BT_TRUE;
-    //opts.enableRegularisation = BT_FALSE;
-    //opts.enableFullLITests = BT_TRUE;
-    //opts.enableNZCTests = BT_TRUE;
-    //opts.enableDriftCorrection = 1;
-    //opts.enableCholeskyRefactorisation = 1;
-    opts.enableEqualities = BT_TRUE;
-    //opts.terminationTolerance =  2.2204e-09;
-    //opts.boundTolerance =  2.2204e-10;
-    //opts.boundRelaxation =  10000;
-    //opts.epsNum = -2.2204e-13;
-    //opts.epsDen =  2.2204e-13;
-    //opts.maxPrimalJump =  100000000;
-    //opts.maxDualJump =  100000000;
-    //opts.initialRamping =  0.50000;
-    //opts.finalRamping =  1;
-    //opts.initialFarBounds =  1000000;
-    //opts.growFarBounds =  1000;
-    opts.initialStatusBounds =  ST_INACTIVE;
-    //opts.epsFlipping =  2.2204e-13;
-    //opts.numRegularisationSteps = 4;
-    //opts.epsRegularisation =  2.2204e-13;
-    opts.numRefinementSteps = 3;
-    //opts.epsIterRef =  2.2204e-14;
-    //opts.epsLITests =  2.2204e-09;
-    //opts.epsNZCTests =  6.6613e-13;
-    opts.enableInertiaCorrection = BT_TRUE;
-    opts.rcondSMin = 1.0e-14;
-
-
-    /* Solve QPs. */
-    int nWSR;
-    double time;
-    struct timeval startTime;
-    struct timeval endTime;
-    int elapsedTime;
-    gettimeofday(&startTime, NULL);
-#if SOLVE_DENSE
-    printf( "\n----------Begin Standard version with dense matrices----------\n" );
-    qpDense.setOptions( opts );
-    nWSR = maxIt;
-    time = maxTime;
-
-    for( int k=0; k<nVar; k++ )
-    {
-        xOpt[k] = xInit[k];
-        yOpt[k] = 0.0;
-    }
-    for( int k=0; k<nCon; k++ ) yOpt[k+nVar] = yInit[k]; // what about lambda for bound constraints?
-    bOpt = Bounds( bInit );
-    cOpt = Constraints( cInit );
-    ret = qpDense.init( H_d, g, A_d, lb, ub, lbA, ubA, nWSR, &time, xOpt, yOpt, &bOpt, &cOpt );
-
-    if( ret == SUCCESSFUL_RETURN ) printf("Obj. = %23.16e\n", qpDense.getObjVal() + obj );
-    printf( "\n-----------End Standard version with dense matrices-----------\n" );
-#endif
-
-#if SOLVE_SCHUR
-    printf( "\n----------Begin Schur complement version----------\n" );
-    qpSchur.setOptions( opts );
-    nWSR = maxIt;
-    time = maxTime;
-
-    for( int k=0; k<nVar; k++ )
-    {
-        xOpt[k] = xInit[k];
-        yOpt[k] = 0.0;
-    }
-    for( int k=0; k<nCon; k++ ) yOpt[k+nVar] = yInit[k]; // what about lambda for bound constraints?
-    bOpt = Bounds( bInit );
-    cOpt = Constraints( cInit );
-    //ret = qpSchur.init( H_s, g, A_s, lb, ub, lbA, ubA, nWSR, &time, xOpt, yOpt, &bOpt, &cOpt );
-    ret = qpSchur.init( H_s, g, A_s, lb, ub, lbA, ubA, nWSR, &time );
-
-    if( ret == SUCCESSFUL_RETURN ) printf("Obj. = %23.16e\n", qpSchur.getObjVal() + obj );
-    printf( "\n\n-----------End Schur complement version-----------\n" );
-#endif
-
-#if SOLVE_SPARSE
-    printf( "\n----------Begin Standard version with sparse matrices----------\n" );
-    qpSparse.setOptions( opts );
-    nWSR = maxIt;
-    time = maxTime;
-
-    for( int k=0; k<nVar; k++ )
-    {
-        xOpt[k] = xInit[k];
-        yOpt[k] = 0.0;
-    }
-    for( int k=0; k<nCon; k++ ) yOpt[k+nVar] = yInit[k]; // what about lambda for bound constraints?
-    bOpt = Bounds( bInit );
-    cOpt = Constraints( cInit );
-    ret = qpSparse.init( H_s, g, A_s, lb, ub, lbA, ubA, nWSR, &time, xOpt, yOpt, &bOpt, &cOpt );
-
-    if( ret == SUCCESSFUL_RETURN ) printf("Obj. = %23.16e\n", qpSparse.getObjVal() + obj );
-    printf( "\n-----------End Standard version with sparse matrices-----------\n" );
-#endif
-    gettimeofday(&endTime, NULL);
-
-    elapsedTime = (endTime.tv_sec*1000000  + (endTime.tv_usec)) -
-                  (startTime.tv_sec*1000000  + (startTime.tv_usec));
-    printf( "Took %g seconds.\n", elapsedTime/1000000.0 );
-
-    /* Clean up */
-    delete[] g;
-    delete[] lb;
-    delete[] ub;
-    delete[] lbA;
-    delete[] ubA;
-    delete[] isEq;
-    delete[] isLinear;
-    delete[] xOpt;
-    delete[] yOpt;
-    delete[] xInit;
-    delete[] yInit;
-
-#if SOLVE_SCHUR || SOLVE_SPARSE
-    delete[] hesVal;
-    delete[] hesIndRow;
-    delete[] hesIndCol;
-    if( nCon > 0 )
-    {
-        delete[] jacVal;
-        delete[] jacIndRow;
-        delete[] jacIndCol;
-    }
-#endif
-#if SOLVE_DENSE
-    delete[] hesDense;
-    if( nCon > 0 )
-        delete[] jacDense;
-#endif
-
-    return ret;
-}
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/readme.txt b/extlibs/qpOASES-3.2.0/interfaces/CUTEst/readme.txt
deleted file mode 100644
index 2983489..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/CUTEst/readme.txt
+++ /dev/null
@@ -1,39 +0,0 @@
-CUTEst interface for qpOASES
-by Dennis Janka <dennis.janka@iwr.uni.heidelberg.de>
-
-====================================================
-
-0.) Files included:
-
-    - qpoasesCutest.cpp
-    - Makefile
-    - makeprob
-    - readme.txt
-
-1.) Download and install CUTEst from
-
-    http://ccpforge.cse.rl.ac.uk/gf/project/cutest/wiki/
-
-    Make sure all environment variables are set as instructed.
-    (in particular $CUTEST, $MYARCH and $MASTSIF)
-
-2.) To decode and compile a problem, type:
-
-    ./makeprob <problemname>
-
-    For problems that come in different sizes (e.g. NCVXQP[1-9]) the size
-    parameter ( N=<size> ) may be passed as a second argument:
-
-    ./makeprob <problemname> <size>
-
-    This calls "sifdecoder" to decode the .sif file and creates a shared
-    library libprob.so in prob/ that will be linked against the
-    qpOASES CUTEst interface.
-
-3.) Finally, call "make" to compile and link qpoasesCutest.
-    You may have to set the correct paths for the qpOASES library and
-    header files in the makefile.
-
-4.) The command ./qpoasesCutest runs qpOASES with the latest compiled
-    .sif problem. For solving further problems, only the appropriate
-    "./makeprob" call is required.
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/Makefile b/extlibs/qpOASES-3.2.0/interfaces/c/Makefile
deleted file mode 100644
index 403004e..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/Makefile
+++ /dev/null
@@ -1,128 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  interfaces/c/Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014-2015
-##
-
-
-include ../../make.mk
-
-##
-##	flags
-##
-
-IFLAGS =	-I. \
-		-I${IDIR} \
-		-I${SRCDIR}
-
-QPOASES_WRAPPER_OBJECTS = \
-	${SRCDIR}/SQProblem.${OBJEXT} \
-	${SRCDIR}/QProblem.${OBJEXT} \
-	${SRCDIR}/QProblemB.${OBJEXT} \
-	${SRCDIR}/Bounds.${OBJEXT} \
-	${SRCDIR}/Constraints.${OBJEXT} \
-	${SRCDIR}/SubjectTo.${OBJEXT} \
-	${SRCDIR}/Indexlist.${OBJEXT} \
-	${SRCDIR}/Flipper.${OBJEXT} \
-	${SRCDIR}/Utils.${OBJEXT} \
-	${SRCDIR}/Options.${OBJEXT} \
-	${SRCDIR}/Matrices.${OBJEXT} \
-	${SRCDIR}/MessageHandling.${OBJEXT} \
-	qpOASES_wrapper.${OBJEXT}
-
-QPOASES_DEPENDS = \
-	${IDIR}/qpOASES.hpp \
-	${IDIR}/qpOASES/SQProblem.hpp \
-	${IDIR}/qpOASES/QProblem.hpp \
-	${IDIR}/qpOASES/Flipper.hpp \
-	${IDIR}/qpOASES/QProblemB.hpp \
-	${IDIR}/qpOASES/Bounds.hpp \
-	${IDIR}/qpOASES/Constraints.hpp \
-	${IDIR}/qpOASES/SubjectTo.hpp \
-	${IDIR}/qpOASES/Indexlist.hpp \
-	${IDIR}/qpOASES/Utils.hpp \
-	${IDIR}/qpOASES/Constants.hpp \
-	${IDIR}/qpOASES/Types.hpp \
-	${IDIR}/qpOASES/Options.hpp \
-	${IDIR}/qpOASES/Matrices.hpp \
-	${IDIR}/qpOASES/MessageHandling.hpp \
-	qpOASES_wrapper.h
-
-QPOASES_C_EXAMPLES = \
-	${BINDIR}/c_example1${EXE} \
-	${BINDIR}/c_example1a${EXE} \
-	${BINDIR}/c_example1b${EXE}
-
-
-##
-##	targets
-##
-
-all: ${LINK_DEPENDS_WRAPPER} ${QPOASES_C_EXAMPLES}
-
-
-${BINDIR}/libqpOASES_wrapper.${LIBEXT}: ${QPOASES_WRAPPER_OBJECTS}
-	@${ECHO} "Creating" $@
-	@${AR} r $@ qpOASES_wrapper.${OBJEXT}
-
-${BINDIR}/libqpOASES_wrapper.${DLLEXT}: ${QPOASES_WRAPPER_OBJECTS}
-	@${ECHO} "Creating" $@
-	${CC} ${SHARED} ${DEF_TARGET} qpOASES_wrapper.${OBJEXT} ${LINK_LIBRARIES_WRAPPER}
-
-clean:
-	@${ECHO} "Cleaning up (interfaces/c)"
-	@${RM} -f *.${OBJEXT} ${BINDIR}/*.${LIBEXT} ${BINDIR}/*.${DLLEXT} ${BINDIR}/c_example*${EXE}
-
-clobber: clean
-
-
-%.${OBJEXT}: %.cpp ${QPOASES_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} -D__C_WRAPPER__ $<
-
-c_example1.${OBJEXT}: c_example1.c ${LINK_DEPENDS_WRAPPER}
-	@${ECHO} "Creating" $@
-	@${CC} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-c_example1a.${OBJEXT}: c_example1a.c ${LINK_DEPENDS_WRAPPER}
-	@${ECHO} "Creating" $@
-	@${CC} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-c_example1b.${OBJEXT}: c_example1b.c ${LINK_DEPENDS_WRAPPER}
-	@${ECHO} "Creating" $@
-	@${CC} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-
-${BINDIR}/%${EXE}: %.${OBJEXT} ${LINK_DEPENDS_WRAPPER}
-	@${ECHO} "Creating" $@
-	${CC} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} $< ${QPOASES_LINK_WRAPPER} ${LINK_LIBRARIES_WRAPPER}
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1.c b/extlibs/qpOASES-3.2.0/interfaces/c/c_example1.c
deleted file mode 100644
index 71320e8..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1.c
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/c/c_example1.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using QProblem class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-	int nWSR;
-	qpOASES_Options options;
-	
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	real_t obj;
-	int status;
-
-	qpOASES_Options_init( &options,0 );
-	options.printLevel = PL_MEDIUM;
-
-
-	QProblem_setup(	2,1,HST_UNKNOWN );
-
-	/* Solve first QP. */
-	nWSR = 10;
-	QProblem_init(	H,g,A,lb,ub,lbA,ubA,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	QProblem_hotstart(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-	
-	QProblem_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1a.c b/extlibs/qpOASES-3.2.0/interfaces/c/c_example1a.c
deleted file mode 100644
index 61cb308..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1a.c
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/c/c_example1a.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using SQProblem class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-	int nWSR;
-
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	real_t obj;
-	int status;
-
-	qpOASES_Options options;
-	qpOASES_Options_init( &options,0 );
-
-	
-	SQProblem_setup( 2,1,HST_UNKNOWN );
-	
-	/* Solve first QP. */
-	nWSR = 10;
-	SQProblem_init(	H,g,A,lb,ub,lbA,ubA,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	SQProblem_hotstart(	H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-	
-	SQProblem_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1b.c b/extlibs/qpOASES-3.2.0/interfaces/c/c_example1b.c
deleted file mode 100644
index eca60d6..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/c_example1b.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/c/example1b.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using QProblemB class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-
-	int nWSR;
-	qpOASES_Options options;
-
-	real_t xOpt[2];
-	real_t yOpt[2];
-	real_t obj;
-	int status;
-
-	qpOASES_Options_init( &options,0 );
-	/*options.enableFlippingBounds = 0; */
-	options.initialStatusBounds = ST_INACTIVE;
-	options.numRefinementSteps = 1;
-	options.enableCholeskyRefactorisation = 1;
-
-
-	QProblemB_setup( 2,HST_UNKNOWN );
-
-	/* Solve first QP. */
-	nWSR = 10;
-	QProblemB_init(	H,g,lb,ub,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	QProblemB_hotstart(	g_new,lb_new,ub_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1], obj );
-
-	
-	QProblemB_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.cpp b/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.cpp
deleted file mode 100644
index 4d17c4a..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.cpp
+++ /dev/null
@@ -1,576 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/c/qpOASES_wrapper.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Interface that enables to call qpOASES from plain C.
- *
- */
-
-
-#include <qpOASES.hpp>
-
-USING_NAMESPACE_QPOASES
-
-
-extern "C" {
-#include "qpOASES_wrapper.h"
-}
-
-
-
-
-/*
- *	q p O A S E S _ O p t i o n s _ i n i t
- */
-int_t qpOASES_Options_init(	qpOASES_Options* const options,
-							int_t mode
-							)
-{
-	if ( ( mode < 0 ) || ( mode > 2 ) )
-		return -1;
-
-	if ( options == 0 )
-		return -1;
-
-
-	/* setup default */
-	options->printLevel = PL_MEDIUM;
-	#ifdef __DEBUG__
-	options->printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	options->printLevel = PL_NONE;
-	#endif
-
-	options->enableRamping                 =  BT_TRUE;
-	options->enableFarBounds               =  BT_TRUE;
-	options->enableFlippingBounds          =  BT_TRUE;
-	options->enableRegularisation          =  BT_FALSE;
-	options->enableFullLITests             =  BT_FALSE;
-	options->enableNZCTests                =  BT_TRUE;
-	options->enableDriftCorrection         =  1;
-	options->enableCholeskyRefactorisation =  0;
-	options->enableEqualities              =  BT_FALSE;
-
-	#ifdef __USE_SINGLE_PRECISION__
-	options->terminationTolerance          =  1.0e2 * EPS;
-	options->boundTolerance                =  1.0e2 * EPS;
-	#else
-	options->terminationTolerance          =  5.0e6 * EPS;
-	options->boundTolerance                =  1.0e6 * EPS;
-	#endif
-	options->boundRelaxation               =  1.0e4;
-	#ifdef __USE_SINGLE_PRECISION__
-	options->epsNum                        = -1.0e2 * EPS;
-	options->epsDen                        =  1.0e2 * EPS;
-	#else
-	options->epsNum                        = -1.0e3 * EPS;
-	options->epsDen                        =  1.0e3 * EPS;
-	#endif
-	options->maxPrimalJump                 =  1.0e8;
-	options->maxDualJump                   =  1.0e8;
-
-	options->initialRamping                =  0.5;
-	options->finalRamping                  =  1.0;
-	options->initialFarBounds              =  1.0e6;
-	options->growFarBounds                 =  1.0e3;
- 	options->initialStatusBounds           =  ST_LOWER;
-	#ifdef __USE_SINGLE_PRECISION__
-	options->epsFlipping                   =  5.0e1 * EPS;
-	#else
-	options->epsFlipping                   =  1.0e3 * EPS;
-	#endif
-	options->numRegularisationSteps        =  0;
-	#ifdef __USE_SINGLE_PRECISION__
-	options->epsRegularisation             =  2.0e1 * EPS;
-	options->numRefinementSteps            =  2;
-	#else
-	options->epsRegularisation             =  1.0e3 * EPS;
-	options->numRefinementSteps            =  1;
-	#endif
-	options->epsIterRef                    =  1.0e2 * EPS;
-	#ifdef __USE_SINGLE_PRECISION__
-	options->epsLITests                    =  5.0e1 * EPS;
-	options->epsNZCTests                   =  1.0e2 * EPS;
-	#else
-	options->epsLITests                    =  1.0e5 * EPS;
-	options->epsNZCTests                   =  3.0e3 * EPS;
-	#endif
-
-	options->enableDropInfeasibles         =  BT_FALSE;
-    options->dropBoundPriority             =  1;
-    options->dropEqConPriority             =  1;
-    options->dropIneqConPriority           =  1;
-
-
-	switch ( mode )
-	{
-		case 0:
-			/* default, already set */
-			break;
-
-
-		case 1:
-			/* reliable */
-			options->enableFullLITests             =  BT_TRUE;
-			options->enableCholeskyRefactorisation =  1;
-
-			#ifdef __USE_SINGLE_PRECISION__
-			options->numRefinementSteps            =  3;
-			#else
-			options->numRefinementSteps            =  2;
-			#endif
-
-			
-		case 2:
-			/* MPC */
-			options->enableRamping                 =  BT_FALSE;
-			options->enableFarBounds               =  BT_TRUE;
-			options->enableFlippingBounds          =  BT_FALSE;
-			options->enableRegularisation          =  BT_TRUE;
-			options->enableNZCTests                =  BT_FALSE;
-			options->enableDriftCorrection         =  0;
-			options->enableEqualities              =  BT_TRUE;
-
-			#ifdef __USE_SINGLE_PRECISION__
-			options->terminationTolerance          =  1.0e3 * EPS;
-			#else
-			options->terminationTolerance          =  1.0e9 * EPS;
-			#endif
-
-			options->initialStatusBounds           =  ST_INACTIVE;
-			options->numRegularisationSteps        =  1;
-			#ifdef __USE_SINGLE_PRECISION__
-			options->numRefinementSteps            =  2;
-			#else
-			options->numRefinementSteps            =  0;
-			#endif
-	}
-	
-	return 0;
-}
-
-
-/*
- *	q p O A S E S _ O p t i o n s _ c o p y
- */
-int_t qpOASES_Options_copy(	const qpOASES_Options* const from,
-							Options* const to
-							)
-{
-	if ( ( from == 0 ) || ( to == 0 ) )
-		return -1;
-
-
-	to->printLevel                    =  (PrintLevel)(from->printLevel);
-
-	to->enableRamping                 =  (BooleanType)(from->enableRamping);
-	to->enableFarBounds               =  (BooleanType)(from->enableFarBounds);
-	to->enableFlippingBounds          =  (BooleanType)(from->enableFlippingBounds);
-	to->enableRegularisation          =  (BooleanType)(from->enableRegularisation);
-	to->enableFullLITests             =  (BooleanType)(from->enableFullLITests);
-	to->enableNZCTests                =  (BooleanType)(from->enableNZCTests);
-	to->enableDriftCorrection         =  from->enableDriftCorrection;
-	to->enableCholeskyRefactorisation =  from->enableCholeskyRefactorisation;
-	to->enableEqualities              =  (BooleanType)(from->enableEqualities);
-
-	to->terminationTolerance          =  from->terminationTolerance;
-	to->boundTolerance                =  from->boundTolerance;
-	to->boundRelaxation               =  from->boundRelaxation;
-	to->epsNum                        =  from->epsNum;
-	to->epsDen                        =  from->epsDen;
-	to->maxPrimalJump                 =  from->maxPrimalJump;
-	to->maxDualJump                   =  from->maxDualJump;
-
-	to->initialRamping                =  from->initialRamping;
-	to->finalRamping                  =  from->finalRamping;
-	to->initialFarBounds              =  from->initialFarBounds;
-	to->growFarBounds                 =  from->growFarBounds;
- 	to->initialStatusBounds           =  (SubjectToStatus)(from->initialStatusBounds);
-	to->epsFlipping                   =  from->epsFlipping;
-	to->numRegularisationSteps        =  from->numRegularisationSteps;
-	to->epsRegularisation             =  from->epsRegularisation;
-	to->numRefinementSteps            =  from->numRefinementSteps;
-	to->epsIterRef                    =  from->epsIterRef;
-	to->epsLITests                    =  from->epsLITests;
-	to->epsNZCTests                   =  from->epsNZCTests;
-
-	to->enableDropInfeasibles         =  (BooleanType)(from->enableDropInfeasibles);
-    to->dropBoundPriority             =  from->dropBoundPriority;
-    to->dropEqConPriority             =  from->dropEqConPriority;
-    to->dropIneqConPriority           =  from->dropIneqConPriority;
-
-	return 0;
-}
-
-
-
-/*
- *	q p O A S E S _ o b t a i n O u t p u t s
- */
-int_t qpOASES_obtainOutputs(	const QProblemB* const globalQpObject,
-								returnValue returnvalue,
-								real_t* const x,
-								real_t* const y,
-								real_t* const obj,
-								int_t* const status
-								)
-{
-	if ( globalQpObject == 0 )
-		return -1;
-
-	globalQpObject->getPrimalSolution( x );
-	globalQpObject->getDualSolution( y );
-	*obj = globalQpObject->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m _ s e t u p
- */
-int_t QProblem_setup(	int_t nV,
-						int_t nC,
-						int_t hessianType
-						)
-{
-	if ( ( nV < 1 ) || ( nC < 0 ) )
-		return -1;
-
-	if ( ( hessianType < 0 ) || ( hessianType > 6 ) )
-		return -1;
-
-	if ( QProblem_cleanup() != 0 )
-		return -1;
-
-	globalQProblemObject = new QProblem( nV,nC,(HessianType)hessianType );
-	
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m _ i n i t
- */
-int_t QProblem_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const A,
-						const real_t* const lb,
-						const real_t* const ub,
-						const real_t* const lbA,
-						const real_t* const ubA,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						)
-{
-	/* abort if QProblem_setup has not been called */
-	if ( globalQProblemObject == 0 )
-		return -1;
-
-	/* adjust options if provided */
-	if ( options != 0 )
-	{
-		qpOASES_Options_copy( options,&globalOptionsObject );
-		globalQProblemObject->setOptions( globalOptionsObject );
-	}
-
-	/* actually call solver */
-	returnValue returnvalue = globalQProblemObject->init( H,g,A,lb,ub,lbA,ubA, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalQProblemObject,returnvalue, x,y,obj,status );
-}
-
-
-/*
- *	Q P r o b l e m _ h o t s t a r t
- */
-int_t QProblem_hotstart(	const real_t* const g,
-							const real_t* const lb,
-							const real_t* const ub,
-							const real_t* const lbA,
-							const real_t* const ubA,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							)
-{
-	/* abort if QProblem_setup has not been called */
-	if ( globalQProblemObject == 0 )
-		return -1;
-
-	/* actually call solver */
-	returnValue returnvalue = globalQProblemObject->hotstart( g,lb,ub,lbA,ubA, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalQProblemObject,returnvalue, x,y,obj,status );
-
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m _ c l e a n u p
- */
-int_t QProblem_cleanup( )
-{
-	if ( globalQProblemObject != 0 )
-	{
-		delete globalQProblemObject;
-		globalQProblemObject = 0;
-	}
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m B _ s e t u p
- */
-int_t QProblemB_setup(	int_t nV,
-						int_t hessianType
-						)
-{
-	if ( nV < 1 )
-		return -1;
-
-	if ( ( hessianType < 0 ) || ( hessianType > 6 ) )
-		return -1;
-
-	if ( QProblemB_cleanup() != 0 )
-		return -1;
-
-	globalQProblemBObject = new QProblemB( nV,(HessianType)hessianType );
-	
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m B _ i n i t
- */
-int_t QProblemB_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const lb,
-						const real_t* const ub,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						)
-{
-	/* abort if QProblemB_setup has not been called */
-	if ( globalQProblemBObject == 0 )
-		return -1;
-
-	/* adjust options if provided */
-	if ( options != 0 )
-	{
-		qpOASES_Options_copy( options,&globalOptionsObject );
-		globalQProblemBObject->setOptions( globalOptionsObject );
-	}
-
-	/* actually call solver */
-	returnValue returnvalue = globalQProblemBObject->init( H,g,lb,ub, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalQProblemBObject,returnvalue, x,y,obj,status );
-}
-
-
-/*
- *	Q P r o b l e m B _ h o t s t a r t
- */
-int_t QProblemB_hotstart(	const real_t* const g,
-							const real_t* const lb,
-							const real_t* const ub,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							)
-{
-	/* abort if QProblemB_setup has not been called */
-	if ( globalQProblemBObject == 0 )
-		return -1;
-
-	/* actually call solver */
-	returnValue returnvalue = globalQProblemBObject->hotstart( g,lb,ub, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalQProblemBObject,returnvalue, x,y,obj,status );
-
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m B _ c l e a n u p
- */
-int_t QProblemB_cleanup( )
-{
-	if ( globalQProblemBObject != 0 )
-	{
-		delete globalQProblemBObject;
-		globalQProblemBObject = 0;
-	}
-
-	return 0;
-}
-
-
-
-/*
- *	S Q P r o b l e m _ s e t u p
- */
-int_t SQProblem_setup(	int_t nV,
-						int_t nC,
-						int_t hessianType
-						)
-{
-	if ( ( nV < 1 ) || ( nC < 0 ) )
-		return -1;
-
-	if ( ( hessianType < 0 ) || ( hessianType > 6 ) )
-		return -1;
-
-	if ( SQProblem_cleanup() != 0 )
-		return -1;
-
-	globalSQProblemObject = new SQProblem( nV,nC,(HessianType)hessianType );
-	
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ i n i t
- */
-int_t SQProblem_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const A,
-						const real_t* const lb,
-						const real_t* const ub,
-						const real_t* const lbA,
-						const real_t* const ubA,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						)
-{
-	/* abort if SQProblem_setup has not been called */
-	if ( globalSQProblemObject == 0 )
-		return -1;
-
-	/* adjust options if provided */
-	if ( options != 0 )
-	{
-		qpOASES_Options_copy( options,&globalOptionsObject );
-		globalSQProblemObject->setOptions( globalOptionsObject );
-	}
-
-	/* actually call solver */
-	returnValue returnvalue = globalSQProblemObject->init( H,g,A,lb,ub,lbA,ubA, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalSQProblemObject,returnvalue, x,y,obj,status );
-}
-
-
-/*
- *	S Q P r o b l e m _ h o t s t a r t
- */
-int_t SQProblem_hotstart(	const real_t* const H,
-							const real_t* const g,
-							const real_t* const A,
-							const real_t* const lb,
-							const real_t* const ub,
-							const real_t* const lbA,
-							const real_t* const ubA,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							)
-{
-	/* abort if SQProblem_setup has not been called */
-	if ( globalSQProblemObject == 0 )
-		return -1;
-
-	/* actually call solver */
-	returnValue returnvalue = globalSQProblemObject->hotstart( H,g,A,lb,ub,lbA,ubA, *nWSR,cputime );
-
-	/* assign lhs arguments */
-	return qpOASES_obtainOutputs( globalSQProblemObject,returnvalue, x,y,obj,status );
-
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ c l e a n u p
- */
-int_t SQProblem_cleanup( )
-{
-	if ( globalSQProblemObject != 0 )
-	{
-		delete globalSQProblemObject;
-		globalSQProblemObject = 0;
-	}
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.h b/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.h
deleted file mode 100644
index 0f7b637..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/c/qpOASES_wrapper.h
+++ /dev/null
@@ -1,293 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/c/qpOASES_wrapper.h
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Interface that enables to call qpOASES from plain C.
- *
- */
-
-
-#ifndef QPOASES_WRAPPER_H
-#define QPOASES_WRAPPER_H
-
-
-#ifndef QPOASES_TYPES_HPP
-
-	/** Defines real_t for facilitating switching between double and float. */
-	#ifdef __USE_SINGLE_PRECISION__
-	typedef float real_t;
-	#else
-	typedef double real_t;
-	#endif /* __USE_SINGLE_PRECISION__ */
-
-	/** Defines int_t for facilitating switching between int and long int. */
-	#ifdef __USE_LONG_INTEGERS__
-	typedef long int_t;
-	typedef unsigned long uint_t;
-	#else
-	typedef int int_t;
-	typedef unsigned int uint_t;
-	#endif /* __USE_LONG_INTEGERS__ */
-
-	/* dummy definitions, not used when calling from C */
-	#define QProblemBClass int_t
-	#define OptionsClass int_t
-	#define returnValue int_t
-
-	/* HessianType */
-	#define HST_ZERO             0
-	#define HST_IDENTITY         1
-	#define HST_POSDEF           2
-	#define HST_POSDEF_NULLSPACE 3
-	#define HST_SEMIDEF          4
-	#define HST_INDEF            5
-	#define HST_UNKNOWN	         6
-
-	/* SubjectToStatus */
-	#define ST_LOWER            -1
-	#define ST_INACTIVE          0
-	#define ST_UPPER             1
-	#define ST_INFEASIBLE_LOWER  2
-	#define ST_INFEASIBLE_UPPER  3
-	#define ST_UNDEFINED         4
-
-	/* PrintLevel */
-	#define PL_DEBUG_ITER       -2
-	#define PL_TABULAR          -1
-	#define PL_NONE              0
-	#define PL_LOW               1
-	#define PL_MEDIUM            2
-	#define PL_HIGH              3
-
-#else 
-
-	#define QProblemBClass QProblemB
-	#define OptionsClass REFER_NAMESPACE_QPOASES Options 
-
-	/* only declare when compiling C++ library */
-	static QProblem*  globalQProblemObject  = 0;
-	static QProblemB* globalQProblemBObject = 0;
-	static SQProblem* globalSQProblemObject = 0;
-	static Options globalOptionsObject;
-
-#endif /* QPOASES_TYPES_HPP */
-
-
-
-/**
- *	\brief Manages all user-specified options for solving QPs.
- *
- *	This struct manages all user-specified options used for solving
- *	quadratic programs.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- */
-typedef struct
-{
-	int_t printLevel;						/**< Print level. */
-
-	int_t enableRamping;					/**< Specifies whether ramping shall be enabled or not. */
-	int_t enableFarBounds;					/**< Specifies whether far bounds shall be used or not. */
-	int_t enableFlippingBounds;				/**< Specifies whether flipping bounds shall be used or not. */
-	int_t enableRegularisation;				/**< Specifies whether Hessian matrix shall be regularised in case semi-definiteness is detected. */
-	int_t enableFullLITests;				/**< Specifies whether condition-hardened LI test shall be used or not. */
-	int_t enableNZCTests;					/**< Specifies whether nonzero curvature tests shall be used. */
-	int_t enableDriftCorrection;			/**< Specifies the frequency of drift corrections (0 = off). */
-	int_t enableCholeskyRefactorisation;	/**< Specifies the frequency of full refactorisation of proj. Hessian (otherwise updates). */
-	int_t enableEqualities;					/**< Specifies whether equalities shall be always treated as active constraints. */
-
-	real_t terminationTolerance;			/**< Termination tolerance. */
-	real_t boundTolerance;					/**< Lower/upper (constraints') bound tolerance (an inequality constraint whose lower and 
-												 upper bounds differ by less is regarded to be an equality constraint). */
-	real_t boundRelaxation;					/**< Offset for relaxing (constraints') bounds at beginning of an initial homotopy. It is also as initial value for far bounds. */
-	real_t epsNum;							/**< Numerator tolerance for ratio tests. */
-	real_t epsDen;							/**< Denominator tolerance for ratio tests. */
-	real_t maxPrimalJump;					/**< Maximum allowed jump in primal variables in nonzero curvature tests. */
-	real_t maxDualJump;						/**< Maximum allowed jump in dual variables in linear independence tests. */
-
-	real_t initialRamping;					/**< Start value for Ramping Strategy. */
-	real_t finalRamping;					/**< Final value for Ramping Strategy. */
-	real_t initialFarBounds;				/**< Initial size of Far Bounds. */
-	real_t growFarBounds;					/**< Factor to grow Far Bounds. */
-	int_t initialStatusBounds;				/**< Initial status of bounds at first iteration. */
-	real_t epsFlipping;						/**< Tolerance of squared Cholesky diagonal factor which triggers flipping bound. */
-	int_t numRegularisationSteps;			/**< Maximum number of successive regularisation steps. */
-	real_t epsRegularisation;				/**< Scaling factor of identity matrix used for Hessian regularisation. */
-	int_t numRefinementSteps;				/**< Maximum number of iterative refinement steps. */
-	real_t epsIterRef;						/**< Early termination tolerance for iterative refinement. */
-	real_t epsLITests;						/**< Tolerance for linear independence tests. */
-	real_t epsNZCTests;						/**< Tolerance for nonzero curvature tests. */
-
-	real_t rcondSMin;						/**< Minimum reciprocal condition number of S before refactorization is triggered */
-	int_t enableInertiaCorrection;			/**< Specifies whether the working set should be repaired when negative curvature is discovered during hotstart. */
-
-	int_t enableDropInfeasibles;			/**< ... */
-	int_t dropBoundPriority;				/**< ... */
-	int_t dropEqConPriority;				/**< ... */
-	int_t dropIneqConPriority;				/**< ... */
-	int_t printResiduals;					/**< If true, it will print the internal qpOASES residuals and other information per iteration */
-
-} qpOASES_Options;
-
-
-int_t qpOASES_Options_init(	qpOASES_Options* const options,
-							int_t mode
-							);
-
-int_t qpOASES_Options_copy(	const qpOASES_Options* const from,
-							OptionsClass* const to
-							);
-
-
-int_t qpOASES_obtainOutputs(	const QProblemBClass* const globalQpObject,
-								returnValue returnvalue,
-								real_t* const x,
-								real_t* const y,
-								real_t* const obj,
-								int_t* const status
-								);
-
-
-int_t QProblem_setup(	int_t nV,
-						int_t nC,
-						int_t hessianType
-						);
-
-int_t QProblem_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const A,
-						const real_t* const lb,
-						const real_t* const ub,
-						const real_t* const lbA,
-						const real_t* const ubA,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						);
-
-int_t QProblem_hotstart(	const real_t* const g,
-							const real_t* const lb,
-							const real_t* const ub,
-							const real_t* const lbA,
-							const real_t* const ubA,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							);
-
-int_t QProblem_cleanup( );
-
-
-
-int_t QProblemB_setup(	int_t nV,
-						int_t hessianType
-						);
-
-int_t QProblemB_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const lb,
-						const real_t* const ub,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						);
-
-int_t QProblemB_hotstart(	const real_t* const g,
-							const real_t* const lb,
-							const real_t* const ub,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							);
-
-int_t QProblemB_cleanup( );
-
-
-
-int_t SQProblem_setup(	int_t nV,
-						int_t nC,
-						int_t hessianType
-						);
-
-int_t SQProblem_init(	const real_t* const H,
-						const real_t* const g,
-						const real_t* const A,
-						const real_t* const lb,
-						const real_t* const ub,
-						const real_t* const lbA,
-						const real_t* const ubA,
-						int_t* const nWSR,
-						real_t* const cputime,
-						const qpOASES_Options* const options,
-						real_t* const x,
-						real_t* const y,
-						real_t* const obj,
-						int_t* const status
-						);
-
-int_t SQProblem_hotstart(	const real_t* const H,
-							const real_t* const g,
-							const real_t* const A,
-							const real_t* const lb,
-							const real_t* const ub,
-							const real_t* const lbA,
-							const real_t* const ubA,
-							int_t* const nWSR,
-							real_t* const cputime,
-							real_t* const x,
-							real_t* const y,
-							real_t* const obj,
-							int_t* const status
-							);
-
-int_t SQProblem_cleanup( );
-
-
-#endif /* QPOASES_WRAPPER_H */
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/Makefile b/extlibs/qpOASES-3.2.0/interfaces/matlab/Makefile
deleted file mode 100644
index 7ee3e13..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/Makefile
+++ /dev/null
@@ -1,85 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  src/interfaces/matlab/Makefile
-##	Author:    Christian Kirches, Hans Joachim Ferreau, Andreas Potschka
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-include ../../make.mk
-
-##
-##	flags
-##
-
-IDIR   = ../../include
-
-IFLAGS      =  -I. \
-               -I${IDIR} \
-               -I${MATLAB_IDIR}
-			   
-LINK_MATLAB_LIBS = -L${MATLAB_LIBDIR} -lmex -lmat -lmx
-
-EXTRAFLAGS = -largeArrayDims -O -D__cpluplus -D__MATLAB__ -fexceptions
-
-QPOASES_OBJECT = qpOASES.${OBJEXT}
-QPOASES_SEQUENCE_OBJECT = qpOASES_sequence.${OBJEXT}
-
-##
-##	targets
-##
-
-all: ${BINDIR}/qpOASES.${MEXEXT} ${BINDIR}/qpOASES_sequence.${MEXEXT} copyMs
-
-${BINDIR}/qpOASES.${MEXEXT}: ${QPOASES_OBJECT} 
-	@${ECHO} "Creating" $@
-	@${CPP} -shared -o $@ $? ${QPOASES_LINK} ${LINK_LIBRARIES} ${LINK_MATLAB_LIBS}
-
-${BINDIR}/qpOASES_sequence.${MEXEXT}: ${QPOASES_SEQUENCE_OBJECT} 
-	@${ECHO} "Creating" $@
-	@${CPP} -shared -o $@ $? ${QPOASES_LINK} ${LINK_LIBRARIES} ${LINK_MATLAB_LIBS}
-
-copyMs:
-	@${ECHO} "Copying M files ..."
-	@${CP} qpOASES.m ${BINDIR}
-	@${CP} qpOASES_options.m ${BINDIR}
-	@${CP} qpOASES_sequence.m ${BINDIR}
-
-#@${CP} qpOASES_sequenceVM.m ${BINDIR}
-	
-clean:
-	@${RM} -f *.${OBJEXT} *.mex*
-
-clobber: clean
-
-%.${OBJEXT}: %.cpp 
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} -c ${IFLAGS} ${EXTRAFLAGS} ${CPPFLAGS} $<
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/make.m b/extlibs/qpOASES-3.2.0/interfaces/matlab/make.m
deleted file mode 100644
index 1ba7768..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/make.m
+++ /dev/null
@@ -1,238 +0,0 @@
-function [] = make( varargin )
-%MAKE Compiles the Matlab interface of qpOASES.
-%
-%Type  make            to compile all interfaces that 
-%                      have been modified,
-%type  make clean      to delete all compiled interfaces,
-%type  make clean all  to first delete and then compile 
-%                      all interfaces,
-%type  make 'name'     to compile only the interface with
-%                      the given name (if it has been modified),
-%type  make 'opt'      to compile all interfaces using the 
-%                      given compiler options.
-%
-%Copyright (C) 2013-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-%%
-%%	Filename:  interfaces/matlab/make.m
-%%	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-       
-    %% consistency check
-    if ( exist( [pwd, '/make.m'],'file' ) == 0 )
-        error( ['ERROR (',mfilename '.m): Run this make script directly within the directory', ...
-                '<qpOASES-inst-dir>/interfaces/matlab, please.'] );
-    end
-
-
-    if ( nargin > 2 )
-        error( ['ERROR (',mfilename '.m): At most two make arguments supported!'] );
-    else
-        [ doClean,fcnNames,userFlags ] = analyseMakeArguments( nargin,varargin );
-    end
-
-    
-    %% define compiler settings
-    QPOASESPATH = '../../';
-    
-    DEBUGFLAGS = ' ';
-    %DEBUGFLAGS = ' -g CXXDEBUGFLAGS=''$CXXDEBUGFLAGS -Wall -pedantic -Wshadow'' ';
-
-    IFLAGS = [ '-I. -I',QPOASESPATH,'include',' -I',QPOASESPATH,'src',' ' ];
-    CPPFLAGS = [ IFLAGS, DEBUGFLAGS, '-largeArrayDims -D__cpluplus -D__MATLAB__ -D__SINGLE_OBJECT__',' ' ];
-    defaultFlags = '-O -D__NO_COPYRIGHT__ '; %% -D__SUPPRESSANYOUTPUT__
-
-    if ( ispc == 0 )
-        CPPFLAGS  = [ CPPFLAGS, '-DLINUX ',' ' ]; 
-    else
-        CPPFLAGS  = [ CPPFLAGS, '-DWIN32 ',' ' ];
-    end
-
-    if ( isempty(userFlags) > 0 )
-        CPPFLAGS = [ CPPFLAGS, defaultFlags,' ' ];
-    else
-        CPPFLAGS = [ CPPFLAGS, userFlags,' ' ];
-    end
-
-    mexExt = eval('mexext');
-    
-    
-    %% ensure copyright notice is displayed
-    if ~isempty( strfind( CPPFLAGS,'-D__NO_COPYRIGHT__' ) )
-        printCopyrightNotice( );
-    end
-    
-    
-    %% clean if desired
-    if ( doClean > 0 )
-        
-        eval( 'delete *.o;' );
-        eval( ['delete *.',mexExt,'*;'] );
-        disp( [ 'INFO (',mfilename '.m): Cleaned all compiled files.'] );
-        pause( 0.2 );
-        
-    end
-    
-    
-    if ( ~isempty(userFlags) )
-        disp( [ 'INFO (',mfilename '.m): Compiling all files with user-defined compiler flags (''',userFlags,''')...'] );
-    end
-    
-
-    %% call mex compiler
-    for ii=1:length(fcnNames)
-        
-        cmd = [ 'mex -output ', fcnNames{ii}, ' ', CPPFLAGS, [fcnNames{ii},'.cpp'] ];
-        
-        if ( exist( [fcnNames{ii},'.',mexExt],'file' ) == 0 )
-            
-            eval( cmd );
-            disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            
-        else
-            
-            % check modification time of source/Make files and compiled mex file
-            cppFile = dir( [pwd,'/',fcnNames{ii},'.cpp'] );
-            cppFileTimestamp = getTimestamp( cppFile );
-            
-            utilsFile = dir( [pwd,'/qpOASES_matlab_utils.cpp'] );
-            utilsFileTimestamp = getTimestamp( utilsFile );
-            
-            makeFile = dir( [pwd,'/make.m'] );
-            makeFileTimestamp = getTimestamp( makeFile );
-            
-            mexFile = dir( [pwd,'/',fcnNames{ii},'.',mexExt] );
-            if ( isempty(mexFile) == 0 )
-                mexFileTimestamp = getTimestamp( mexFile );
-            else
-                mexFileTimestamp = 0;
-            end
-            
-            if ( ( cppFileTimestamp   >= mexFileTimestamp ) || ...
-                 ( utilsFileTimestamp >= mexFileTimestamp ) || ...
-                 ( makeFileTimestamp  >= mexFileTimestamp ) )
-                eval( cmd );
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            else            
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' already exists.'] );
-            end
-            
-        end
-        
-    end
-
-    %% add qpOASES directory to path
-    path( path,pwd );
-
-end
-
-
-function [ doClean,fcnNames,userIFlags ] = analyseMakeArguments( nArgs,args )
-
-    doClean = 0;
-    fcnNames = [];
-    userIFlags = [];
-
-    switch ( nArgs )
-        
-        case 1
-            if ( strcmp( args{1},'all' ) > 0 )
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            elseif ( strcmp( args{1},'qpOASES' ) > 0 )
-                fcnNames = { 'qpOASES' };
-            elseif ( strcmp( args{1},'qpOASES_sequence' ) > 0 )
-                fcnNames = { 'qpOASES_sequence' };
-            elseif ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            elseif ( strcmp( args{1}(1),'-' ) > 0 )
-                % make clean all with user-specified compiler flags
-                userIFlags = args{1};
-                doClean = 1;
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid first argument (''',args{1},''')!'] );
-            end
-
-        case 2
-            if ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            else
-                error( ['ERROR (',mfilename '.m): First argument must be ''clean'' if two arguments are provided!'] );
-            end
-            
-            if ( strcmp( args{2},'all' ) > 0 )
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            elseif ( strcmp( args{2},'qpOASES' ) > 0 )
-                fcnNames = { 'qpOASES' };
-            elseif ( strcmp( args{2},'qpOASES_sequence' ) > 0 )
-                fcnNames = { 'qpOASES_sequence' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid second argument (''',args{2},''')!'] );
-            end
-            
-        otherwise
-            fcnNames = { 'qpOASES','qpOASES_sequence' };
-            
-    end
-    
-end
-
-
-function [ timestamp ] = getTimestamp( dateString )
-
-    try 
-        timestamp = dateString.datenum;
-    catch
-        timestamp = Inf;
-    end
-
-end
-
-
-function [ ] = printCopyrightNotice( )
-
-    disp( ' ' );
-    disp( 'qpOASES -- An Implementation of the Online Active Set Strategy.' );
-    disp( 'Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,' );
-    disp( 'Christian Kirches et al. All rights reserved.' );
-    disp( ' ' );
-    disp( 'qpOASES is distributed under the terms of the' );
-    disp( 'GNU Lesser General Public License 2.1 in the hope that it will be' );
-    disp( 'useful, but WITHOUT ANY WARRANTY; without even the implied warranty' );
-    disp( 'of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.' );
-    disp( 'See the GNU Lesser General Public License for more details.' );
-    disp( ' ' );
-    disp( ' ' );
-
-end
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.cpp b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.cpp
deleted file mode 100644
index 957636f..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.cpp
+++ /dev/null
@@ -1,584 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/matlab/qpOASES.cpp
- *	\author Hans Joachim Ferreau, Alexander Buchner (thanks to Aude Perrin)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Matlab(R) that enables to call qpOASES as a MEX function.
- *
- */
-
-
-#include <qpOASES.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-#include "qpOASES_matlab_utils.hpp"
-
-/** initialise handle counter of QPInstance class */
-int_t QPInstance::s_nexthandle = 1;
-
-/** global pointer to QP objects */
-static std::vector<QPInstance *> g_instances;
-
-#include "qpOASES_matlab_utils.cpp"
-
-
-/*
- *	Q P r o b l e m _ q p O A S E S
- */
-int_t QProblem_qpOASES(	int_t nV, int_t nC, HessianType hessianType, int_t nP,
-						SymmetricMatrix* H, double* g, Matrix* A,
-						double* lb, double* ub,
-						double* lbA, double* ubA,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds, const double* const guessedConstraints,
-						const double* const _R
-						)
-{
-	int_t nWSRout;
-	real_t maxCpuTimeOut;
-	
-	/* 1) Setup initial QP. */
-	QProblem QP( nV,nC,hessianType );
-	QP.setOptions( *options );
-
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-
-	Bounds bounds(nV);
-	Constraints constraints(nC);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	if (guessedConstraints != 0) {
-		for (int_t i = 0; i < nC; i++) {
-			if ( isEqual(guessedConstraints[i],-1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_LOWER);
-			} else if ( isEqual(guessedConstraints[i],1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_UPPER);
-			} else if ( isEqual(guessedConstraints[i],0.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of constraints!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	nWSRout = nWSRin;
-	maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	returnvalue = QP.init(	H,g,A,lb,ub,lbA,ubA,
-							nWSRout,&maxCpuTimeOut,
-							x0,0,
-							(guessedBounds != 0) ? &bounds : 0, (guessedConstraints != 0) ? &constraints : 0,
-							_R
-							);
-
-	/* 3) Solve remaining QPs and assign lhs arguments. */
-	/*    Set up pointers to the current QP vectors */
-	real_t* g_current   = g;
-	real_t* lb_current  = lb;
-	real_t* ub_current  = ub;
-	real_t* lbA_current = lbA;
-	real_t* ubA_current = ubA;
-
-	/* Loop through QP sequence. */
-	for ( int_t k=0; k<nP; ++k )
-	{
-		if ( k > 0 )
-		{
-			/* update pointers to the current QP vectors */
-			g_current = &(g[k*nV]);
-			if ( lb != 0 )
-				lb_current = &(lb[k*nV]);
-			if ( ub != 0 )
-				ub_current = &(ub[k*nV]);
-			if ( lbA != 0 )
-				lbA_current = &(lbA[k*nC]);
-			if ( ubA != 0 )
-				ubA_current = &(ubA[k*nC]);
-
-			nWSRout = nWSRin;
-			maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-			returnvalue = QP.hotstart( g_current,lb_current,ub_current,lbA_current,ubA_current, nWSRout,&maxCpuTimeOut );
-		}
-
-		/* write results into output vectors */
-		obtainOutputs(	k,&QP,returnvalue,nWSRout,maxCpuTimeOut,
-						nOutputs,plhs,nV,nC );
-	}
-
-	//QP.writeQpDataIntoMatFile( "qpDataMat0.mat" );
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m B _ q p O A S E S
- */
-int_t QProblemB_qpOASES(	int_t nV, HessianType hessianType, int_t nP,
-							SymmetricMatrix *H, double* g,
-							double* lb, double* ub,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							const double* const x0, Options* options,
-							int_t nOutputs, mxArray* plhs[],
-							const double* const guessedBounds,
-							const double* const _R
-							)
-{
-	int_t nWSRout;
-	real_t maxCpuTimeOut;
-
-	/* 1) Setup initial QP. */
-	QProblemB QP( nV,hessianType );
-	QP.setOptions( *options );
-
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-
-	Bounds bounds(nV);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	nWSRout = nWSRin;
-	maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-	
-	returnvalue = QP.init(	H,g,lb,ub,
-							nWSRout,&maxCpuTimeOut,
-							x0,0,
-							(guessedBounds != 0) ? &bounds : 0,
-							_R
-							);
-
-	/* 3) Solve remaining QPs and assign lhs arguments. */
-	/*    Set up pointers to the current QP vectors */
-	real_t* g_current  = g;
-	real_t* lb_current = lb;
-	real_t* ub_current = ub;
-
-	/* Loop through QP sequence. */
-	for ( int_t k=0; k<nP; ++k )
-	{
-		if ( k > 0 )
-		{
-			/* update pointers to the current QP vectors */
-			g_current = &(g[k*nV]);
-			if ( lb != 0 )
-				lb_current = &(lb[k*nV]);
-			if ( ub != 0 )
-				ub_current = &(ub[k*nV]);
-
-            nWSRout = nWSRin;
-			maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-			returnvalue = QP.hotstart( g_current,lb_current,ub_current, nWSRout,&maxCpuTimeOut );
-		}
-
-		/* write results into output vectors */
-		obtainOutputs(	k,&QP,returnvalue,nWSRout,maxCpuTimeOut,
-						nOutputs,plhs,nV );
-	}
-
-	return 0;
-}
-
-
-
-/*
- *	m e x F u n c t i o n
- */
-void mexFunction( int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[] )
-{
-	/* inputs */
-	SymmetricMatrix *H=0;
-	Matrix *A=0;
-
-	real_t *g=0, *lb=0, *ub=0, *lbA=0, *ubA=0;
-	HessianType hessianType = HST_UNKNOWN;
-	double *x0=0, *R=0, *R_for=0;
-	double *guessedBounds=0, *guessedConstraints=0;
-
-	int H_idx=-1, g_idx=-1, A_idx=-1, lb_idx=-1, ub_idx=-1, lbA_idx=-1, ubA_idx=-1;
-	int options_idx=-1, x0_idx=-1, auxInput_idx=-1;
-
-    /* Setup default options */
-	Options options;
-	options.printLevel = PL_LOW;
-	#ifdef __DEBUG__
-	options.printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	options.printLevel = PL_NONE;
-	#endif
-
-	/* dimensions */
-	uint_t nV=0, nC=0, nP=0;
-	BooleanType isSimplyBoundedQp = BT_FALSE;
-
-	/* sparse matrix indices and values */
-	sparse_int_t *Hir=0, *Hjc=0, *Air=0, *Ajc=0;
-	real_t *Hv=0, *Av=0;
-
-	/* I) CONSISTENCY CHECKS: */
-	/* 1a) Ensure that qpOASES is called with a feasible number of input arguments. */
-	if ( ( nrhs < 4 ) || ( nrhs > 9 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES' for further information." );
-		return;
-	}
-    
-	/* 2) Check for proper number of output arguments. */
-	if ( nlhs > 6 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): At most six output arguments are allowed: \n    [x,fval,exitflag,iter,lambda,auxOutput]!" );
-		return;
-	}
-	if ( nlhs < 1 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): At least one output argument is required: [x,...]!" );
-		return;
-	}
-
-
-	/* II) PREPARE RESPECTIVE QPOASES FUNCTION CALL: */
-	/*     Choose between QProblem and QProblemB object and assign the corresponding
-	 *     indices of the input pointer array in to order to access QP data correctly. */
-	g_idx = 1;
-
-	if ( mxIsEmpty(prhs[0]) == 1 )
-	{
-		H_idx = -1;
-		nV = (int_t)mxGetM( prhs[ g_idx ] ); /* if Hessian is empty, row number of gradient vector */
-	}
-	else
-	{
-		H_idx = 0;
-		nV = (int_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-	}
-	
-	nP = (int_t)mxGetN( prhs[ g_idx ] ); /* number of columns of the gradient matrix (vectors series have to be stored columnwise!) */
-
-	if ( nrhs <= 6 )
-        isSimplyBoundedQp = BT_TRUE;
-	else
-		isSimplyBoundedQp = BT_FALSE;
-
-
-	/* 0) Check whether options are specified .*/
-	if ( isSimplyBoundedQp == BT_TRUE )
-	{
-		if ( ( nrhs >= 5 ) && ( !mxIsEmpty(prhs[4]) ) && ( mxIsStruct(prhs[4]) ) )
-			options_idx = 4;
-	}
-	else
-	{
-		/* Consistency check */
-		if ( ( !mxIsEmpty(prhs[4]) ) && ( mxIsStruct(prhs[4]) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Fifth input argument must not be a struct when solving QP with general constraints!\nType 'help qpOASES' for further information." );
-			return;
-		}
-
-		if ( ( nrhs >= 8 ) && ( !mxIsEmpty(prhs[7]) ) && ( mxIsStruct(prhs[7]) ) )
-			options_idx = 7;
-	}
-
-	// Is the third argument constraint Matrix A?
-	int_t numberOfColumns = (int_t)mxGetN(prhs[2]);
-
-	/* 1) Simply bounded QP. */
-	if ( ( isSimplyBoundedQp == BT_TRUE ) ||
-		 ( ( numberOfColumns == 1 ) && ( nV != 1 ) ) )
-	{
-		lb_idx   = 2;
-		ub_idx   = 3;
-
-		if ( ( nrhs >= 6 ) && ( !mxIsEmpty(prhs[5]) ) )
-		{ 
-			/* auxInput specified */
-			if ( mxIsStruct(prhs[5]) )
-			{
-				auxInput_idx = 5;
-				x0_idx = -1;
-			}
-			else
-			{
-				auxInput_idx = -1;
-				x0_idx = 5;
-			}
-		}
-		else
-		{
-			auxInput_idx = -1;
-			x0_idx = -1;
-		}
-	}
-	else
-	{
-		A_idx = 2;
-
-		/* If constraint matrix is empty, use a QProblemB object! */
-		if ( mxIsEmpty( prhs[ A_idx ] ) )
-		{
-			lb_idx   = 3;
-			ub_idx   = 4;
-
-			nC = 0;
-		}
-		else
-		{
-			lb_idx   = 3;
-			ub_idx   = 4;
-			lbA_idx  = 5;
-			ubA_idx  = 6;
-
-			nC = (int_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-		}
-
-		if ( ( nrhs >= 9 ) && ( !mxIsEmpty(prhs[8]) ) )
-		{ 
-			/* auxInput specified */
-			if ( mxIsStruct(prhs[8]) )
-			{
-				auxInput_idx = 8;
-				x0_idx = -1;
-			}
-			else
-			{
-				auxInput_idx = -1;
-				x0_idx = 8;
-			}
-		}
-		else
-		{
-			auxInput_idx = -1;
-			x0_idx = -1;
-		}
-	}
-
-
-	/* ensure that data is given in real_t precision */
-	if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[ H_idx ] ) == 0 ) ) ||
-		 ( mxIsDouble( prhs[ g_idx ] ) == 0 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-		return;
-	}
-
-	/* check if supplied data contains 'NaN' or 'Inf' */
-	if (containsNaNorInf( prhs,H_idx, 0 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-		return;
-
-	/* Check inputs dimensions and assign pointers to inputs. */
-	if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-	{
-		char msg[MAX_STRING_LENGTH]; 
-		snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Hessian matrix dimension mismatch (%ld != %d)!", 
-				(long int)mxGetN(prhs[H_idx]), (int)nV);
-		myMexErrMsgTxt(msg);
-		return;
-	}
-
-	if ( nC > 0 )
-	{
-		/* ensure that data is given in real_t precision */
-		if ( mxIsDouble( prhs[ A_idx ] ) == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in real_t precision!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		if ( mxGetN( prhs[ A_idx ] ) != nV )
-		{
-			char msg[MAX_STRING_LENGTH]; 
-			snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Constraint matrix input dimension mismatch (%ld != %d)!", 
-					(long int)mxGetN(prhs[A_idx]), (int)nV);
-			myMexErrMsgTxt(msg);
-			return;
-		}
-
-		if (containsNaNorInf(prhs,A_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf(prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf(prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-	}
-
-	/* check dimensions and copy auxInputs */
-	if ( smartDimensionCheck( &g,nV,nP, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &lb,nV,nP, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &ub,nV,nP, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &x0,nV,1, BT_TRUE,prhs,x0_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( nC > 0 )
-	{
-		if ( smartDimensionCheck( &lbA,nC,nP, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,nP, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-	}
-
-	if ( auxInput_idx >= 0 )
-		setupAuxiliaryInputs( prhs[auxInput_idx],nV,nC, &hessianType,&x0,&guessedBounds,&guessedConstraints,&R_for );
-
-	/* convert Cholesky factor to C storage format */
-	if ( R_for != 0 )
-	{
-		R = new real_t[nV*nV];
-		convertFortranToC( R_for, nV,nV, R );
-	}
-	
-	/* III) ACTUALLY PERFORM QPOASES FUNCTION CALL: */
-	int_t nWSRin = 5*(nV+nC);
-	real_t maxCpuTimeIn = -1.0;
-
-	if ( options_idx > 0 )
-		setupOptions( &options,prhs[options_idx],nWSRin,maxCpuTimeIn );
-
-	/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-	if ( H_idx >= 0 )
-		setupHessianMatrix(	prhs[H_idx],nV, &H,&Hir,&Hjc,&Hv );
-	
-	/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-	if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-		setupConstraintMatrix( prhs[A_idx],nV,nC, &A,&Air,&Ajc,&Av );
-
-	allocateOutputs( nlhs,plhs,nV,nC,nP );
-
-	if ( nC == 0 )
-	{
-		/* Call qpOASES (using QProblemB class). */
-		QProblemB_qpOASES(	nV,hessianType, nP,
-							H,g,
-							lb,ub,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,R
-							);
-		
-        if (R != 0) delete R;
-		if (H != 0) delete H;
-		if (Hv != 0) delete[] Hv;
-		if (Hjc != 0) delete[] Hjc;
-		if (Hir != 0) delete[] Hir;
-		return;
-	}
-	else
-	{
-		if ( A == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Internal interface error related to constraint matrix!" );
-			return;
-		}
-
-		/* Call qpOASES (using QProblem class). */
-		QProblem_qpOASES(	nV,nC,hessianType, nP,
-							H,g,A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,guessedConstraints,R
-							);
-		
-		if (R != 0) delete R;
-		if (A != 0) delete A;
-		if (H != 0) delete H;
-		if (Av != 0) delete[] Av;
-		if (Ajc != 0) delete[] Ajc;
-		if (Air != 0) delete[] Air;
-		if (Hv != 0) delete[] Hv;
-		if (Hjc != 0) delete[] Hjc;
-		if (Hir != 0) delete[] Hir;
-		return;
-	}
-}
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.m b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.m
deleted file mode 100644
index 4692b60..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES.m
+++ /dev/null
@@ -1,75 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%qpOASES solves (a series) of quadratic programming (QP) problems of the
-%following form:
-%
-%                min   1/2*x'Hx + x'g
-%                s.t.  lb  <=  x <= ub
-%                      lbA <= Ax <= ubA  {optional}
-%
-%Call
-%
-%    [x,fval,exitflag,iter,lambda,auxOutput] = 
-%                     qpOASES( H,g,A,lb,ub,lbA,ubA{,options{,auxInput}} )
-%
-%for solving the above-mentioned QP. H must be a symmetric (but possibly 
-%indefinite) matrix and all vectors g, lb, ub, lbA, ubA have to be given
-%as column vectors. Options can be generated using the qpOASES_options command, 
-%otherwise default values are used. Optionally, further auxiliary inputs
-%may be generated using qpOASES_auxInput command and passed to the solver.
-%Both matrices H or A may be passed in sparse matrix format.
-%
-%Call
-%
-%    [x,fval,exitflag,iter,lambda,auxOutput] =
-%                     qpOASES( H,g,lb,ub{,options{,auxInput}} )
-%
-%for solving the above-mentioned QP without general constraints.
-%
-%
-%Optional outputs (only x is mandatory):
-%    x            -  Optimal primal solution vector (if exitflag==0).
-%    fval         -  Optimal objective function value (if exitflag==0).
-%    exitflag     -   0: QP problem solved,
-%                     1: QP could not be solved within given number of iterations,
-%                    -1: QP could not be solved due to an internal error,
-%                    -2: QP is infeasible (and thus could not be solved),
-%                    -3: QP is unbounded (and thus could not be solved).
-%    iter         -  Number of active set iterations actually performed.
-%    lambda       -  Optimal dual solution vector (if exitflag==0).
-%    auxOutput    -  Struct containing auxiliary outputs as described below.
-%
-%The auxOutput struct contains the following entries:
-%    workingSetB  -  Working set of bounds at point x.
-%    workingSetC  -  Working set of constraints at point x.
-%                    The working set is a subset of the active set (indices
-%                    of bounds/constraints that hold with equality) yielding
-%                    a set linearly independent of bounds/constraints.
-%                    The working sets are encoded as follows:
-%                     1: bound/constraint at its upper bound
-%                     0: bound/constraint not at any bound
-%                    -1: bound/constraint at its lower bound
-%    cpuTime      -  Internally measured CPU time for solving QP problem.
-%
-%
-%If not a single QP but a sequence of QPs with varying vectors is to be solved,
-%the i-th QP is given by the i-th columns of the QP vectors g, lb, ub, lbA, ubA
-%(i.e. they are matrices in this case). Both matrices H and A remain constant.
-%
-%See also QPOASES_OPTIONS, QPOASES_AUXINPUT, QPOASES_SEQUENCE
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_auxInput.m b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_auxInput.m
deleted file mode 100644
index 74c9d93..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_auxInput.m
+++ /dev/null
@@ -1,118 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%Returns a struct containing all possible auxiliary inputs to be passed 
-%to qpOASES.
-%
-%Call
-%    auxInput = qpOASES_auxInput();
-%to obtain a struct with all auxiliary inputs empty.
-%
-%Call
-%    auxInput = qpOASES_auxInput( 'input1',value1,'input2',value2,... )
-%to obtain a struct with 'input1' set to value1 etc. and all remaining
-%auxiliary inputs empty.
-%
-%Call
-%    auxInput = qpOASES_auxInput( oldInputs,'input1',value1,... )
-%to obtain a copy of the options struct oldInputs but with 'input1' set to 
-%value1 etc.
-%
-%
-%qpOASES features the following auxiliary inputs:
-%  hessianType          -  Provide information on Hessian matrix:
-%                          0: Hessian is zero matrix (i.e. LP formulation)
-%                          1: Hessian is identity matrix
-%                          2: Hessian is (strictly) positive definite
-%                          3: Hessian is positive definite on null space 
-%                             of active bounds/constraints
-%                          4: Hessian is positive semi-definite.
-%                          5: Hessian is indefinite
-%                          Leave hessianType empty if Hessian type is unknown.
-%  x0                   -  Initial guess for optimal primal solution.
-%  guessedWorkingSetB   -  Initial guess for working set of bounds at 
-%                          optimal solution (nV elements or empty).
-%  guessedWorkingSetC   -  Initial guess for working set of constraints at 
-%                          optimal solution (nC elements or empty).
-%                          The working sets needs to be encoded as follows:
-%                           1: bound/constraint at its upper bound
-%                           0: bound/constraint not at any bound
-%                          -1: bound/constraint at its lower bound
-%  R                    -  Cholesky factor of Hessian matrix (upper-triangular);
-%                          only used if both guessedWorkingSets are empty
-%                          and option initialStatusBounds is set to 0.
-%
-%
-%See also QPOASES, QPOASES_SEQUENCE, QPOASES_OPTIONS
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
-function [ auxInput ] = qpOASES_auxInput( varargin )
-
-	firstIsStruct = 0;
-
-	if ( nargin == 0 ) 
-		auxInput = qpOASES_emptyAuxInput();
-	else
-		if ( isstruct( varargin{1} ) )
-			if ( mod( nargin,2 ) ~= 1 )
-				error('ERROR (qpOASES_auxInput): Auxiliary inputs must be specified in pairs!');
-			end
-			auxInput = varargin{1};
-			firstIsStruct = 1;
-        else
-            if ( mod( nargin,2 ) ~= 0 )
-				error('ERROR (qpOASES_auxInput): Auxiliary inputs must be specified in pairs!');
-            end
-            auxInput = qpOASES_emptyAuxInput();
-		end
-	end
-
-	% set options to user-defined values  
-	for i=(1+firstIsStruct):2:nargin
-
-		argName  = varargin{i};
-		argValue = varargin{i+1};
-
-        if ( ( isempty( argName ) ) || ( ~ischar( argName ) ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d has to be a non-empty string!',i );
-        end
-			
-        if ( ( ischar(argValue) ) || ( ~isnumeric( argValue ) ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d has to be a numerical constant!',i+1 );
-        end
-
-        if ( ~isfield( auxInput,argName ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d is not a valid auxiliary input!',i );
-        end
-
-		eval( ['auxInput.',argName,' = argValue;'] );
-
-	end
-
-end
-
-
-function [ auxInput ] = qpOASES_emptyAuxInput( )
-
-	% setup auxiliary input struct with all entries empty
-	auxInput = struct(	'hessianType',        [], ...
-                        'x0',                 [], ...
-						'guessedWorkingSetB', [], ...
-                        'guessedWorkingSetC', [], ...
-                        'R',                  []  ...
-                        );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.cpp b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.cpp
deleted file mode 100644
index ee96ee2..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.cpp
+++ /dev/null
@@ -1,950 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/matlab/qpOASES_matlab_utils.cpp
- *	\author Hans Joachim Ferreau, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Collects utility functions for Interface to Matlab(R) that
- *	enables to call qpOASES as a MEX function.
- *
- */
-
-
-
-QPInstance::QPInstance(	uint_t _nV, uint_t _nC, HessianType _hessianType,
-						BooleanType _isSimplyBounded
-						)
-{
-	handle = s_nexthandle++;
-
-	if ( _nC > 0 )
-		isSimplyBounded = BT_FALSE;
-	else
-		isSimplyBounded = _isSimplyBounded;
-	
-	if ( isSimplyBounded == BT_TRUE )
-	{
-		sqp = 0;
-		qpb = new QProblemB( _nV,_hessianType );
-	}
-	else
-	{
-		sqp = new SQProblem( _nV,_nC,_hessianType );
-		qpb = 0;
-	}
-
-	H = 0;
-	A = 0;
-	Hir = 0; 
-	Hjc = 0; 
-	Air = 0; 
-	Ajc = 0;
-	Hv = 0;
-	Av = 0;
-}	
-
-
-QPInstance::~QPInstance( )
-{		
-	deleteQPMatrices();
-
-	if ( sqp != 0 )
-	{
-		delete sqp;
-		sqp = 0;
-	}
-
-	if ( qpb != 0 )
-	{
-		delete qpb;
-		qpb = 0;
-	}
-}
-
-
-returnValue QPInstance::deleteQPMatrices( )
-{
-	if ( H != 0 )
-	{
-		delete H;
-		H = 0;
-	}
-
-	if ( Hv != 0 )
-	{
-		delete[] Hv;
-		Hv = 0;
-	}
-	
-	if ( Hjc != 0 )
-	{
-		delete[] Hjc;
-		Hjc = 0;
-	}
-	
-	if ( Hir != 0 )
-	{
-		delete[] Hir;
-		Hir = 0;
-	}
-	
-	if ( A != 0 )
-	{
-		delete A;
-		A = 0;
-	}
-
-	if ( Av != 0 )
-	{
-		delete[] Av;
-		Av = 0;
-	}
-	
-	if ( Ajc != 0 )
-	{
-		delete[] Ajc;
-		Ajc = 0;
-	}
-	
-	if ( Air != 0 )
-	{
-		delete[] Air;
-		Air = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-int_t QPInstance::getNV() const
-{
-    if ( sqp != 0 )
-        return sqp->getNV();
-    
-    if ( qpb != 0 )
-        return qpb->getNV();
-    
-    return 0;
-}
-
-
-int_t QPInstance::getNC() const
-{
-    if ( sqp != 0 )
-        return sqp->getNC();
-   
-    return 0;
-}
-
-
-
-/*
- *	m x I s S c a l a r
- */
-bool mxIsScalar( const mxArray *pm )
-{
-	if ( ( mxGetM(pm) == 1 ) && ( mxGetN(pm) == 1 ) )
-		return true;
-	else
-		return false;
-}
-
-
-
-/*
- *	a l l o c a t e Q P r o b l e m I n s t a n c e
- */
-int_t allocateQPInstance(	int_t nV, int_t nC, HessianType hessianType,
-							BooleanType isSimplyBounded, const Options* options
-							)
-{
-	QPInstance* inst = new QPInstance( nV,nC,hessianType, isSimplyBounded );
-
-	if ( ( inst->sqp != 0 ) && ( options != 0 ) )
-		inst->sqp->setOptions( *options );
-	
-	if ( ( inst->qpb != 0 ) && ( options != 0 ) )
-		inst->qpb->setOptions( *options );
-
-	g_instances.push_back(inst);
-	return inst->handle;
-}
-
-
-/*
- *  g e t Q P r o b l e m I n s t a n c e
- */
-QPInstance* getQPInstance( int_t handle )
-{
-	uint_t ii;
-	// TODO: this may become slow ...
-	for (ii = 0; ii < g_instances.size (); ++ii)
-		if (g_instances[ii]->handle == handle)
-			return g_instances[ii];
-	return 0;
-}
-
-
-/*
- *	d e l e t e Q P r o b l e m I n s t a n c e
- */
-void deleteQPInstance( int_t handle )
-{
-	QPInstance *instance = getQPInstance (handle);
-	if (instance != 0) {
-		for (std::vector<QPInstance*>::iterator itor = g_instances.begin ();
-		     itor != g_instances.end (); ++itor)
-		     if ((*itor)->handle == handle) {
-				g_instances.erase (itor);
-				break;
-			}
-		delete instance;
-	}
-}
-
-
-
-/*
- *	s m a r t D i m e n s i o n C h e c k
- */
-returnValue smartDimensionCheck(	real_t** input, uint_t m, uint_t n, BooleanType emptyAllowed,
-									const mxArray* prhs[], int_t idx
-									)
-{
-	/* If index is negative, the input does not exist. */
-	if ( idx < 0 )
-	{
-		*input = 0;
-		return SUCCESSFUL_RETURN;
-	}
-
-	/* Otherwise the input has been passed by the user. */
-	if ( mxIsEmpty( prhs[ idx ] ) )
-	{
-		/* input is empty */
-		if ( ( emptyAllowed == BT_TRUE ) || ( idx == 0 ) ) /* idx==0 used for auxInput */
-		{
-			*input = 0;
-			return SUCCESSFUL_RETURN;
-		}
-		else
-		{
-			char msg[MAX_STRING_LENGTH];
-			if ( idx > 0 )
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Empty argument %d not allowed!", idx+1);
-			myMexErrMsgTxt( msg );
-			return RET_INVALID_ARGUMENTS;
-		}
-	}
-	else
-	{
-		/* input is non-empty */
-        if ( mxIsSparse( prhs[ idx ] ) == 0 )
-        {
-            if ( ( mxGetM( prhs[ idx ] ) == m ) && ( mxGetN( prhs[ idx ] ) == n ) )
-            {
-                *input = (real_t*) mxGetPr( prhs[ idx ] );
-                return SUCCESSFUL_RETURN;
-            }
-            else
-            {
-                char msg[MAX_STRING_LENGTH];
-				if ( idx > 0 )
-					snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Input dimension mismatch for argument %d ([%ld,%ld] ~= [%d,%d]).",
-							 idx+1, (long int)mxGetM(prhs[idx]), (long int)mxGetN(prhs[idx]), (int)m,(int)n);
-				else /* idx==0 used for auxInput */
-					snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Input dimension mismatch for some auxInput entry ([%ld,%ld] ~= [%d,%d]).",
-							 (long int)mxGetM(prhs[idx]), (long int)mxGetN(prhs[idx]), (int)m,(int)n);
-                myMexErrMsgTxt( msg );
-                return RET_INVALID_ARGUMENTS;
-            }
-        }
-        else
-        {
-            char msg[MAX_STRING_LENGTH];
-			if ( idx > 0 )
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Vector argument %d must not be in sparse format!", idx+1);
-			else /* idx==0 used for auxInput */
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): auxInput entries must not be in sparse format!" );
-			myMexErrMsgTxt( msg );
-			return RET_INVALID_ARGUMENTS;
-        }
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	c o n t a i n s N a N
- */
-BooleanType containsNaN( const real_t* const data, uint_t dim )
-{
-	uint_t i;
-
-	if ( data == 0 )
-		return BT_FALSE;
-
-	for ( i = 0; i < dim; ++i )
-		if ( mxIsNaN(data[i]) == 1 )
-			return BT_TRUE;
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n t a i n s I n f
- */
-BooleanType containsInf( const real_t* const data, uint_t dim )
-{
-	uint_t i;
-
-	if ( data == 0 )
-		return BT_FALSE;
-
-	for ( i = 0; i < dim; ++i )
-		if ( mxIsInf(data[i]) == 1 )
-			return BT_TRUE;
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n t a i n s N a N o r I n f
- */
-BooleanType containsNaNorInf(	const mxArray* prhs[], int_t rhs_index,
-								bool mayContainInf
-								)
-{
-	uint_t dim;
-	char msg[MAX_STRING_LENGTH];
-
-	if ( rhs_index < 0 )
-		return BT_FALSE;
-
-	/* overwrite dim for sparse matrices */
-	if (mxIsSparse(prhs[rhs_index]) == 1)
-		dim = (uint_t)mxGetNzmax(prhs[rhs_index]);
-	else
-		dim = (uint_t)(mxGetM(prhs[rhs_index]) * mxGetN(prhs[rhs_index]));
-
-	if (containsNaN((real_t*) mxGetPr(prhs[rhs_index]), dim) == BT_TRUE) {
-		snprintf(msg, MAX_STRING_LENGTH,
-				"ERROR (qpOASES): Argument %d contains 'NaN' !", rhs_index + 1);
-		myMexErrMsgTxt(msg);
-		return BT_TRUE;
-	}
-
-	if (mayContainInf == 0) {
-		if (containsInf((real_t*) mxGetPr(prhs[rhs_index]), dim) == BT_TRUE) {
-			snprintf(msg, MAX_STRING_LENGTH,
-					"ERROR (qpOASES): Argument %d contains 'Inf' !",
-					rhs_index + 1);
-			myMexErrMsgTxt(msg);
-			return BT_TRUE;
-		}
-	}
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n v e r t F o r t r a n T o C
- */
-returnValue convertFortranToC( const real_t* const M_for, int_t nV, int_t nC, real_t* const M )
-{
-	int_t i,j;
-
-	if ( ( M_for == 0 ) || ( M == 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	if ( ( nV < 0 ) || ( nC < 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	for ( i=0; i<nC; ++i )
-		for ( j=0; j<nV; ++j )
-			M[i*nV + j] = M_for[j*nC + i];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	h a s O p t i o n s V a l u e
- */
-BooleanType hasOptionsValue( const mxArray* optionsPtr, const char* const optionString, double** optionValue )
-{
-	mxArray* optionName = mxGetField( optionsPtr,0,optionString );
-
-	if ( optionName == 0 )
-	{
-		char msg[MAX_STRING_LENGTH];
-		snprintf(msg, MAX_STRING_LENGTH, "Option struct does not contain entry '%s', using default value instead!", optionString );
-		mexWarnMsgTxt( msg );
-		return BT_FALSE;
-	}
-
-	if ( ( mxIsEmpty(optionName) == false ) && ( mxIsScalar( optionName ) == true ) )
-	{
-		*optionValue = mxGetPr( optionName );
-		return BT_TRUE;
-	}
-	else
-	{
-		char msg[MAX_STRING_LENGTH];
-		snprintf(msg, MAX_STRING_LENGTH, "Option '%s' is not a scalar, using default value instead!", optionString );
-		mexWarnMsgTxt( msg );
-		return BT_FALSE;
-	}
-}
-
-
-/*
- *	s e t u p O p t i o n s
- */
-returnValue setupOptions( Options* options, const mxArray* optionsPtr, int_t& nWSRin, real_t& maxCpuTime )
-{
-	double* optionValue;
-	int_t optionValueInt;
-
-	/* Check for correct number of option entries;
-	 * may occur, e.g., if user types options.<misspelledName> = <someValue>; */
-	if ( mxGetNumberOfFields(optionsPtr) != 31 )
-		mexWarnMsgTxt( "Options might be set incorrectly as struct has wrong number of entries!\n         Type 'help qpOASES_options' for further information." );
-
-
-	if ( hasOptionsValue( optionsPtr,"maxIter",&optionValue ) == BT_TRUE )
-		if ( *optionValue >= 0.0 )
-			nWSRin = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxCpuTime",&optionValue ) == BT_TRUE )
-		if ( *optionValue >= 0.0 )
-			maxCpuTime = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"printLevel",&optionValue ) == BT_TRUE )
-	{
-        #ifdef __SUPPRESSANYOUTPUT__
-        options->printLevel = PL_NONE;
-        #else
-		optionValueInt = (int_t)*optionValue;
-		options->printLevel = (REFER_NAMESPACE_QPOASES PrintLevel)optionValueInt;
-        if ( options->printLevel < PL_DEBUG_ITER )
-            options->printLevel = PL_DEBUG_ITER;
-        if ( options->printLevel > PL_HIGH )
-            options->printLevel = PL_HIGH;       
-        #endif
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableRamping",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableRamping = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFarBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFarBounds = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFlippingBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFlippingBounds = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableRegularisation",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableRegularisation = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFullLITests",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFullLITests = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableNZCTests",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableNZCTests = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableDriftCorrection",&optionValue ) == BT_TRUE )
-		options->enableDriftCorrection = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"enableCholeskyRefactorisation",&optionValue ) == BT_TRUE )
-		options->enableCholeskyRefactorisation = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"enableEqualities",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableEqualities = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-
-	if ( hasOptionsValue( optionsPtr,"terminationTolerance",&optionValue ) == BT_TRUE )
-		options->terminationTolerance = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"boundTolerance",&optionValue ) == BT_TRUE )
-		options->boundTolerance = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"boundRelaxation",&optionValue ) == BT_TRUE )
-		options->boundRelaxation = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsNum",&optionValue ) == BT_TRUE )
-		options->epsNum = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsDen",&optionValue ) == BT_TRUE )
-		options->epsDen = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxPrimalJump",&optionValue ) == BT_TRUE )
-		options->maxPrimalJump = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxDualJump",&optionValue ) == BT_TRUE )
-		options->maxDualJump = *optionValue;
-
-
-	if ( hasOptionsValue( optionsPtr,"initialRamping",&optionValue ) == BT_TRUE )
-		options->initialRamping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"finalRamping",&optionValue ) == BT_TRUE )
-		options->finalRamping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"initialFarBounds",&optionValue ) == BT_TRUE )
-		options->initialFarBounds = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"growFarBounds",&optionValue ) == BT_TRUE )
-		options->growFarBounds = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"initialStatusBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		if ( optionValueInt < -1 ) 
-			optionValueInt = -1;
-		if ( optionValueInt > 1 ) 
-			optionValueInt = 1;
-		options->initialStatusBounds = (REFER_NAMESPACE_QPOASES SubjectToStatus)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"epsFlipping",&optionValue ) == BT_TRUE )
-		options->epsFlipping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"numRegularisationSteps",&optionValue ) == BT_TRUE )
-		options->numRegularisationSteps = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsRegularisation",&optionValue ) == BT_TRUE )
-		options->epsRegularisation = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"numRefinementSteps",&optionValue ) == BT_TRUE )
-		options->numRefinementSteps = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsIterRef",&optionValue ) == BT_TRUE )
-		options->epsIterRef = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsLITests",&optionValue ) == BT_TRUE )
-		options->epsLITests = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsNZCTests",&optionValue ) == BT_TRUE )
-		options->epsNZCTests = *optionValue;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p A u x i l i a r y I n p u t s
- */
-returnValue setupAuxiliaryInputs(	const mxArray* auxInput, uint_t nV, uint_t nC,
-									HessianType* hessianType, double** x0, double** guessedBounds, double** guessedConstraints, double** R
-									)
-{
-	mxArray* curField = 0;
-
-	/* hessianType */
-	curField = mxGetField( auxInput,0,"hessianType" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'hessianType'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		if ( mxIsEmpty(curField) == true )
-		{
-			*hessianType = HST_UNKNOWN;
-		}
-		else
-		{
-			if ( mxIsScalar(curField) == false )
-				return RET_INVALID_ARGUMENTS;
-
-			double* hessianTypeTmp = mxGetPr(curField);
-			int_t hessianTypeInt = (int_t)*hessianTypeTmp;
-			if ( hessianTypeInt < 0 ) 
-				hessianTypeInt = 6; /* == HST_UNKNOWN */
-			if ( hessianTypeInt > 5 ) 
-				hessianTypeInt = 6; /* == HST_UNKNOWN */
-			*hessianType = (REFER_NAMESPACE_QPOASES HessianType)hessianTypeInt;
-		}
-	}
-
-	/* x0 */
-	curField = mxGetField( auxInput,0,"x0" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'x0'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*x0 = mxGetPr(curField);
-		if ( smartDimensionCheck( x0,nV,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* guessedWorkingSetB */
-	curField = mxGetField( auxInput,0,"guessedWorkingSetB" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'guessedWorkingSetB'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*guessedBounds = mxGetPr(curField);
-		if ( smartDimensionCheck( guessedBounds,nV,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* guessedWorkingSetC */
-	curField = mxGetField( auxInput,0,"guessedWorkingSetC" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'guessedWorkingSetC'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*guessedConstraints = mxGetPr(curField);
-		if ( smartDimensionCheck( guessedConstraints,nC,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* R */
-	curField = mxGetField( auxInput,0,"R" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'R'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*R = mxGetPr(curField);
-		if ( smartDimensionCheck( R,nV,nV, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	a l l o c a t e O u t p u t s
- */
-returnValue allocateOutputs(	int nlhs, mxArray* plhs[], int_t nV, int_t nC = 0, int_t nP = 1, int_t handle = -1
-								)
-{
-	/* Create output vectors and assign pointers to them. */
-	int_t curIdx = 0;
-
-	/* handle */
-	if ( handle >= 0 )
-		plhs[curIdx++] = mxCreateDoubleMatrix( 1, 1, mxREAL );
-
-	/* x */
-	plhs[curIdx++] = mxCreateDoubleMatrix( nV, nP, mxREAL );
-
-	if ( nlhs > curIdx )
-	{
-		/* fval */
-		plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-		if ( nlhs > curIdx )
-		{
-			/* exitflag */
-			plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-			if ( nlhs > curIdx )
-			{
-				/* iter */
-				plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-				if ( nlhs > curIdx )
-				{
-					/* lambda */
-					plhs[curIdx++] = mxCreateDoubleMatrix( nV+nC, nP, mxREAL );
-
-					if ( nlhs > curIdx )
-					{
-						/* setup auxiliary output struct */
-						mxArray* auxOutput = mxCreateStructMatrix( 1,1,0,0 );
-						int_t curFieldNum;
-						
-						/* working set */
-						curFieldNum = mxAddField( auxOutput,"workingSetB" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( nV, nP, mxREAL ) );
-
-						curFieldNum = mxAddField( auxOutput,"workingSetC" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( nC, nP, mxREAL ) );
-
-						curFieldNum = mxAddField( auxOutput,"cpuTime" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( 1, nP, mxREAL ) );
-
-						plhs[curIdx] = auxOutput;
-					}
-				}
-			}
-		}
-	}
-	
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	o b t a i n O u t p u t s
- */
-returnValue obtainOutputs(	int_t k, QProblemB* qp, returnValue returnvalue, int_t _nWSRout, double _cpuTime,
-							int nlhs, mxArray* plhs[], int_t nV, int_t nC = 0, int_t handle = -1
-							)
-{
-	/* Create output vectors and assign pointers to them. */
-	int_t curIdx = 0;
-
-	/* handle */
-	if ( handle >= 0 )
-		plhs[curIdx++] = mxCreateDoubleScalar( handle );
-
-	/* x */
-	double* x = mxGetPr( plhs[curIdx++] );
-	qp->getPrimalSolution( &(x[k*nV]) );
-
-	if ( nlhs > curIdx )
-	{
-		/* fval */
-		double* obj = mxGetPr( plhs[curIdx++] );
-		obj[k] = qp->getObjVal( );
-
-		if ( nlhs > curIdx )
-		{
-			/* exitflag */
-			double* status = mxGetPr( plhs[curIdx++] );
-			status[k] = (double)getSimpleStatus( returnvalue );
-
-			if ( nlhs > curIdx )
-			{
-				/* iter */
-				double* nWSRout = mxGetPr( plhs[curIdx++] );
-				nWSRout[k] = (double) _nWSRout;
-
-				if ( nlhs > curIdx )
-				{
-					/* lambda */
-					double* y = mxGetPr( plhs[curIdx++] );
-					qp->getDualSolution( &(y[k*(nV+nC)]) );
-
-					/* auxOutput */
-					if ( nlhs > curIdx )
-					{
-						QProblem* problemPointer;
-						problemPointer = dynamic_cast<QProblem*>(qp);
-
-						mxArray* auxOutput = plhs[curIdx];
-						mxArray* curField = 0;
-
-						/* working set bounds */
-						if ( nV > 0 )
-						{
-							curField = mxGetField( auxOutput,0,"workingSetB" );
-							double* workingSetB = mxGetPr(curField);
-
-							/* cast successful? */
-							if (problemPointer != NULL) {
-								problemPointer->getWorkingSetBounds( &(workingSetB[k*nV]) );
-							} else {
-								qp->getWorkingSetBounds( &(workingSetB[k*nV]) );
-							}
-						}
-
-						/* working set constraints */
-						if ( nC > 0 )
-						{
-							curField = mxGetField( auxOutput,0,"workingSetC" );
-							double* workingSetC = mxGetPr(curField);
-
-							/* cast successful? */
-							if (problemPointer != NULL) {
-								problemPointer->getWorkingSetConstraints( &(workingSetC[k*nC]) );
-							} else {
-								qp->getWorkingSetConstraints( &(workingSetC[k*nC]) );
-							}
-						}
-
-						/* cpu time */
-						curField = mxGetField( auxOutput,0,"cpuTime" );
-						double* cpuTime = mxGetPr(curField);
-						cpuTime[0] = (double) _cpuTime;
-					}
-				}
-			}
-		}
-	}
-	
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p H e s s i a n M a t r i x
- */
-returnValue setupHessianMatrix(	const mxArray* prhsH, int_t nV,
-								SymmetricMatrix** H, sparse_int_t** Hir, sparse_int_t** Hjc, real_t** Hv
-								)
-{
-	if ( prhsH == 0 )
-		return SUCCESSFUL_RETURN;
-
-	if ( mxIsSparse( prhsH ) != 0 )
-	{
-		mwIndex *mat_ir = mxGetIr( prhsH );
-		mwIndex *mat_jc = mxGetJc( prhsH );
-		double *v = (double*)mxGetPr( prhsH );
-		sparse_int_t nfill = 0;
-		mwIndex i, j;
-		BooleanType needInsertDiag;
-
-		/* copy indices to avoid 64/32-bit integer confusion */
-		/* also add explicit zeros on diagonal for regularization strategy */
-		/* copy values, too */
-		*Hir = new sparse_int_t[mat_jc[nV] + nV];
-		*Hjc = new sparse_int_t[nV+1];
-		*Hv = new real_t[mat_jc[nV] + nV];
-        for (j = 0; j < nV; j++) 
-		{
-            needInsertDiag = BT_TRUE;
-                
-            (*Hjc)[j] = (sparse_int_t)(mat_jc[j]) + nfill;
-            /* fill up to diagonal */
-            for (i = mat_jc[j]; i < mat_jc[j+1]; i++) 
-			{
-                if ( mat_ir[i] == j )
-                    needInsertDiag = BT_FALSE;
-                    
-                /* add zero diagonal element if not present */
-                if ( ( mat_ir[i] > j ) && ( needInsertDiag == BT_TRUE ) )
-                {
-                    (*Hir)[i + nfill] = (sparse_int_t)j;
-                    (*Hv)[i + nfill] = 0.0;
-                    nfill++;
-                    /* only add diag once */
-                    needInsertDiag = BT_FALSE;
-                }
-                        
-				(*Hir)[i + nfill] = (sparse_int_t)(mat_ir[i]);
-				(*Hv)[i + nfill] = (real_t)(v[i]);
-			}
-		}
-		(*Hjc)[nV] = (sparse_int_t)(mat_jc[nV]) + nfill;
-
-		SymSparseMat *sH;
-		*H = sH = new SymSparseMat(nV, nV, *Hir, *Hjc, *Hv);
-		sH->createDiagInfo();
-	}
-	else
-	{
-		/* make a deep-copy in order to avoid modifying input data when regularising */
-		real_t* H_for = (real_t*) mxGetPr( prhsH );
-		real_t* H_mem = new real_t[nV*nV];
-		memcpy( H_mem,H_for, nV*nV*sizeof(real_t) );
-
-		*H = new SymDenseMat( nV,nV,nV, H_mem );
-		(*H)->doFreeMemory( );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p C o n s t r a i n t M a t r i x
- */
-returnValue setupConstraintMatrix(	const mxArray* prhsA, int_t nV, int_t nC,
-									Matrix** A, sparse_int_t** Air, sparse_int_t** Ajc, real_t** Av
-									)
-{
-	if ( prhsA == 0 )
-		return SUCCESSFUL_RETURN;
-
-	if ( mxIsSparse( prhsA ) != 0 )
-	{
-		mwIndex i;
-		long j;
-
-		mwIndex *mat_ir = mxGetIr( prhsA );
-		mwIndex *mat_jc = mxGetJc( prhsA );
-		double *v = (double*)mxGetPr( prhsA );
-
-		/* copy indices to avoid 64/32-bit integer confusion */
-		*Air = new sparse_int_t[mat_jc[nV]];
-		*Ajc = new sparse_int_t[nV+1];
-		for (i = 0; i < mat_jc[nV]; i++)
-			(*Air)[i] = (sparse_int_t)(mat_ir[i]);
-		for (i = 0; i < nV + 1; i++)
-			(*Ajc)[i] = (sparse_int_t)(mat_jc[i]);
-		
-		/* copy values, too */
-		*Av = new real_t[(*Ajc)[nV]];
-		for (j = 0; j < (*Ajc)[nV]; j++)
-			(*Av)[j] = (real_t)(v[j]);
-
-		*A = new SparseMatrix(nC, nV, *Air, *Ajc, *Av);
-	}
-	else
-	{
-		/* Convert constraint matrix A from FORTRAN to C style
-		* (not necessary for H as it should be symmetric!). */
-		real_t* A_for = (real_t*) mxGetPr( prhsA );
-		real_t* A_mem = new real_t[nC*nV];
-		convertFortranToC( A_for,nV,nC, A_mem );
-		*A = new DenseMatrix(nC, nV, nV, A_mem );
-		(*A)->doFreeMemory();
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.hpp b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.hpp
deleted file mode 100644
index 135cdb9..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_matlab_utils.hpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/matlab/qpOASES_matlab_utils.hpp
- *	\author Hans Joachim Ferreau, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Collects utility functions for Interface to Matlab(R) that
- *	enables to call qpOASES as a MEX function.
- *
- */
-
-
-
-/* Work-around for settings where mexErrMsgTxt causes unexpected behaviour. */
-#ifdef __AVOID_MEXERRMSGTXT__
-	#define myMexErrMsgTxt( TEXT ) mexPrintf( "%s\n\n",(TEXT) );
-#else
-	#define myMexErrMsgTxt mexErrMsgTxt
-#endif
-
-
-#include "mex.h"
-#include "matrix.h"
-#include "string.h"
-#include <vector>
-
-
-/*
- * QProblem instance class
- */
-class QPInstance
-{
-	private:
-		static int_t s_nexthandle;
-
-	public:
-		QPInstance(	uint_t _nV = 0,
-					uint_t _nC = 0,
-					HessianType _hessianType = HST_UNKNOWN,
-					BooleanType _isSimplyBounded = BT_FALSE
-					);
-
-		~QPInstance( );
-	
-		returnValue deleteQPMatrices();
-		
-		int_t getNV() const;
-		int_t getNC() const;
-
-		int_t handle;
-
-		SQProblem* sqp;
-		QProblemB* qpb;
-		BooleanType isSimplyBounded;
-
-		SymmetricMatrix* H;
-		Matrix* A;
-		sparse_int_t* Hir; 
-		sparse_int_t* Hjc; 
-		sparse_int_t* Air; 
-		sparse_int_t* Ajc;
-		real_t* Hv;
-		real_t* Av;
-};
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_options.m b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_options.m
deleted file mode 100644
index 0f37b97..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_options.m
+++ /dev/null
@@ -1,251 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%Returns a struct containing values for all options to be used within qpOASES.
-%
-%Call
-%    options = qpOASES_options( 'default' );
-%    options = qpOASES_options( 'reliable' );
-%    options = qpOASES_options( 'MPC' );
-%to obtain a set of default options or a pre-defined set of options tuned
-%for reliable or fast QP solution, respectively.
-%
-%Call
-%    options = qpOASES_options( 'option1',value1,'option2',value2,... )
-%to obtain a set of default options but with 'option1' set to value1 etc.
-%
-%Call
-%    options = qpOASES_options( oldOptions,'option1',value1,... )
-%to obtain a copy of the options struct oldOptions but with 'option1' set
-%to value1 etc.
-%
-%Call
-%    options = qpOASES_options( 'default', 'option1',value1,... )
-%    options = qpOASES_options( 'reliable','option1',value1,... )
-%    options = qpOASES_options( 'MPC',     'option1',value1,... )
-%to obtain a set of default options or a pre-defined set of options tuned
-%for reliable or fast QP solution, respectively, but with 'option1' set to 
-%value1 etc.
-%
-%
-%qpOASES features the following options:
-%  maxIter                    -  Maximum number of iterations (if set
-%                                to -1, a value is chosen heuristically)
-%  maxCpuTime                 -  Maximum CPU time in seconds (if set
-%                                to -1, only iteration limit is used)
-%  printLevel                 -  0: no printed output,
-%                                1: only error messages are printed,
-%                                2: iterations and error messages are printed,
-%                                3: all available messages are printed.
-%
-%  enableRamping              -  Enables (1) or disables (0) ramping.
-%  enableFarBounds            -  Enables (1) or disables (0) the use of 
-%                                far bounds.
-%  enableFlippingBounds       -  Enables (1) or disables (0) the use of 
-%                                flipping bounds.
-%  enableRegularisation       -  Enables (1) or disables (0) automatic 
-%                                Hessian regularisation.
-%  enableFullLITests          -  Enables (1) or disables (0) condition-hardened 
-%                                (but more expensive) LI test.
-%  enableNZCTests             -  Enables (1) or disables (0) nonzero curvature 
-%                                tests.
-%  enableDriftCorrection      -  Specifies the frequency of drift corrections:
-%                                0: turns them off, 
-%                                1: uses them at each iteration etc.
-%  enableCholeskyRefactorisation - Specifies the frequency of a full re-
-%                                factorisation of projected Hessian matrix:
-%                                0: turns them off, 
-%                                1: uses them at each iteration etc.
-%  enableEqualities           -  Specifies whether equalities should be treated 
-%                                as always active (1) or not (0)
-%
-%  terminationTolerance       -  Relative termination tolerance to stop homotopy.
-%  boundTolerance             -  If upper and lower bounds differ less than this
-%                                tolerance, they are regarded equal, i.e. as 
-%                                equality constraint.
-%  boundRelaxation            -  Initial relaxation of bounds to start homotopy 
-%                                and initial value for far bounds.
-%  epsNum                     -  Numerator tolerance for ratio tests.
-%  epsDen                     -  Denominator tolerance for ratio tests.
-%  maxPrimalJump              -  Maximum allowed jump in primal variables in 
-%                                nonzero curvature tests.
-%  maxDualJump                -  Maximum allowed jump in dual variables in 
-%                                linear independence tests.
-%
-%  initialRamping             -  Start value for ramping strategy.
-%  finalRamping               -  Final value for ramping strategy.
-%  initialFarBounds           -  Initial size for far bounds.
-%  growFarBounds              -  Factor to grow far bounds.
-%  initialStatusBounds        -  Initial status of bounds at first iteration:
-%                                 0: all bounds inactive,
-%                                -1: all bounds active at their lower bound,
-%                                +1: all bounds active at their upper bound.
-%  epsFlipping                -  Tolerance of squared Cholesky diagonal factor 
-%                                which triggers flipping bound.
-%  numRegularisationSteps     -  Maximum number of successive regularisation steps.
-%  epsRegularisation          -  Scaling factor of identity matrix used for 
-%                                Hessian regularisation.
-%  numRefinementSteps         -  Maximum number of iterative refinement steps.
-%  epsIterRef                 -  Early termination tolerance for iterative 
-%                                refinement.
-%  epsLITests                 -  Tolerance for linear independence tests.
-%  epsNZCTests                -  Tolerance for nonzero curvature tests.
-%
-%
-%See also QPOASES, QPOASES_SEQUENCE, QPOASES_AUXINPUT
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
-function [ options ] = qpOASES_options( varargin )
-
-	firstIsStructOrScheme = 0;
-
-	if ( nargin == 0 ) 
-		options = qpOASES_default_options();
-	else
-		if ( isstruct( varargin{1} ) )
-			if ( mod( nargin,2 ) ~= 1 )
-				error('ERROR (qpOASES_options): Options must be specified in pairs!');
-			end
-			options = varargin{1};
-			firstIsStructOrScheme = 1;
-		else
-			if ( ischar( varargin{1} ) )
-				if ( mod( nargin,2 ) == 0 )
-					options = qpOASES_default_options();
-				else
-					if ( ( nargin > 1 ) && ( ischar( varargin{nargin} ) ) )
-						error('ERROR (qpOASES_options): Options must be specified in pairs!');
-					end
-
-					switch ( varargin{1} )
-						case 'default'
-							options = qpOASES_default_options();
-						case 'reliable'
-							options = qpOASES_reliable_options();
-						case {'MPC','mpc','fast'}
-							options = qpOASES_MPC_options();
-						otherwise
-							error( ['ERROR (qpOASES_options): Only the following option schemes are defined: ''default'', ''reliable'', ''MPC''!'] );
-							
-					end
-					firstIsStructOrScheme = 1;
-				end
-			else
-				error('ERROR (qpOASES_options): First argument needs to be a string or an options struct!');
-			end
-		end
-	end
-
-	% set options to user-defined values  
-	for i=(1+firstIsStructOrScheme):2:nargin
-
-		argName  = varargin{i};
-		argValue = varargin{i+1};
-
-		if ( ( isempty( argName ) ) || ( ~ischar( argName ) ) )
-			error('ERROR (qpOASES_options): Argmument no. %d has to be a non-empty string!',i );
-        end
-			
-		if ( ( ischar(argValue) ) || ( ~isscalar( argValue ) ) )
-			error('ERROR (qpOASES_options): Argmument no. %d has to be a scalar constant!',i+1 );
-        end
-
-		if ( ~isfield( options,argName ) )
-			error('ERROR (qpOASES_options): Argmument no. %d is an invalid option!',i );
-		end
-
-		eval( ['options.',argName,' = ',num2str(argValue),';'] );
-
-	end
-
-end
-
-
-function [ options ] = qpOASES_default_options( )
-
-	% setup options struct with default values
-	options = struct(	'maxIter',                       -1, ...
-						'maxCpuTime',                    -1, ...
-						'printLevel',                     1, ...
-						...
-						'enableRamping',                  1, ...
-						'enableFarBounds',                1, ...
-						'enableFlippingBounds',           1, ...
-						'enableRegularisation',           0, ...
-						'enableFullLITests',              0, ...
-						'enableNZCTests',                 1, ...
-						'enableDriftCorrection',          1, ...
-						'enableCholeskyRefactorisation',  0, ...
-						'enableEqualities',               0, ...
-						...
-						'terminationTolerance',           5.0e6*eps, ...
-						'boundTolerance',                 1.0e6*eps, ...
-						'boundRelaxation',                1.0e4, ...
-						'epsNum',                        -1.0e3*eps, ...
-						'epsDen',                         1.0e3*eps, ...
-						'maxPrimalJump',                  1.0e8, ...
-						'maxDualJump',                    1.0e8, ...
-						...
-    					'initialRamping',                 0.5, ...
-						'finalRamping',                   1.0, ...
-						'initialFarBounds',               1.0e6, ...
-						'growFarBounds',                  1.0e3, ...
-						'initialStatusBounds',            -1, ...
-						'epsFlipping',                    1.0e3*eps, ...
-						'numRegularisationSteps',         0, ...
-						'epsRegularisation',              1.0e3*eps, ...
-						'numRefinementSteps',             1, ...
-						'epsIterRef',                     1.0e2*eps, ...
-						'epsLITests',                     1.0e5*eps, ...
-						'epsNZCTests',                    3.1e3*eps );
-
-end
-
-
-
-function [ options ] = qpOASES_reliable_options( )
-
-	% setup options struct with values for most reliable QP solution
-	options = qpOASES_default_options( );
-
-	options.enableFullLITests             =  1;
-	options.enableCholeskyRefactorisation =  1;
-
-	options.numRefinementSteps            =  2;
-
-end
-
-
-function [ options ] = qpOASES_MPC_options( )
-
-	% setup options struct with values for most reliable QP solution
-	options = qpOASES_default_options( );
-
-	options.enableRamping                 =  0;
-	options.enableFarBounds               =  1;
-	options.enableFlippingBounds          =  0;
-	options.enableRegularisation          =  1;
-	options.enableNZCTests                =  0;
-	options.enableDriftCorrection         =  0;
-	options.enableEqualities              =  1;
-
-	options.terminationTolerance          =  1.0e9*eps;
-	
-	options.initialStatusBounds           =  0;
-	options.numRegularisationSteps        =  1;
-	options.numRefinementSteps            =  0;
-
-end
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.cpp b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.cpp
deleted file mode 100644
index 95b3038..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.cpp
+++ /dev/null
@@ -1,1104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/matlab/qpOASES_sequence.cpp
- *	\author Hans Joachim Ferreau, Christian Kirches, Andreas Potschka, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Matlab(R) that enables to call qpOASES as a MEX function
- *  (variant for solving QP sequences).
- *
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-
-#include "qpOASES_matlab_utils.hpp"
-
-/** initialise handle counter of QPInstance class */
-int_t QPInstance::s_nexthandle = 1;
-
-/** global pointer to QP objects */
-static std::vector<QPInstance *> g_instances;
-
-#include "qpOASES_matlab_utils.cpp"
-
-
-/*
- *	Q P r o b l e m B _ i n i t
- */
-int_t QProblemB_init(	int_t handle, 
-						SymmetricMatrix* H, real_t* g,
-						const real_t* const lb, const real_t* const ub,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds,
-						const double* const _R
-						)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	/* 1) setup initial QP. */
-	QProblemB* globalQPB = getQPInstance(handle)->qpb;
-
-	if ( globalQPB == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-		return -1;
-	}
-
-	globalQPB->setOptions( *options );
-	
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-	int_t nV = globalQPB->getNV();
-	
-	/* 3) Fill the working set. */
-	Bounds bounds(nV);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	returnvalue = globalQPB->init(	H,g,lb,ub,
-									nWSRout,&maxCpuTimeOut,
-									x0,0,
-									(guessedBounds != 0) ? &bounds : 0,
-									_R
-									);
-
-	/* 3) Assign lhs arguments. */
-	obtainOutputs(	0,globalQPB,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,0,handle );
-
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ i n i t
- */
-int_t SQProblem_init(	int_t handle, 
-						SymmetricMatrix* H, real_t* g, Matrix* A,
-						const real_t* const lb, const real_t* const ub,
-						const real_t* const lbA, const real_t* const ubA,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds, const double* const guessedConstraints,
-						const double* const _R
-						)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	/* 1) setup initial QP. */
-	SQProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-		return -1;
-	}
-
-	globalSQP->setOptions( *options );
-	
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-	
-	/* 3) Fill the working set. */
-	Bounds bounds(nV);
-	Constraints constraints(nC);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	if (guessedConstraints != 0) {
-		for (int_t i = 0; i < nC; i++) {
-			if ( isEqual(guessedConstraints[i],-1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_LOWER);
-			} else if ( isEqual(guessedConstraints[i],1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_UPPER);
-			} else if ( isEqual(guessedConstraints[i],0.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of constraints!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-	
-	returnvalue = globalSQP->init(	H,g,A,lb,ub,lbA,ubA,
-									nWSRout,&maxCpuTimeOut,
-									x0,0,
-									(guessedBounds != 0) ? &bounds : 0, (guessedConstraints != 0) ? &constraints : 0,
-									_R
-									);
-
-	/* 3) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC,handle );
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m B _ h o t s t a r t
- */
-int_t QProblemB_hotstart(	int_t handle,
-							const real_t* const g,
-							const real_t* const lb, const real_t* const ub,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	QProblemB* globalQPB = getQPInstance(handle)->qpb;
-
-	if ( globalQPB == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalQPB->getNV();
-
-	/* 1) Solve QP with given options. */
-	globalQPB->setOptions( *options );
-	returnValue returnvalue = globalQPB->hotstart( g,lb,ub, nWSRout,&maxCpuTimeOut );
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalQPB,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,0 );
-
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m _ h o t s t a r t
- */
-int_t QProblem_hotstart(	int_t handle,
-							const real_t* const g,
-							const real_t* const lb, const real_t* const ub,
-							const real_t* const lbA, const real_t* const ubA,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	QProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-
-	/* 1) Solve QP with given options. */
-	globalSQP->setOptions( *options );
-	returnValue returnvalue = globalSQP->hotstart( g,lb,ub,lbA,ubA, nWSRout,&maxCpuTimeOut );
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC );
-
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ h o t s t a r t
- */
-int_t SQProblem_hotstart(	int_t handle,
-							SymmetricMatrix* H, real_t* g, Matrix* A,
-							const real_t* const lb, const real_t* const ub, const real_t* const lbA, const real_t* const ubA,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	SQProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-
-	/* 1) Solve QP. */
-	globalSQP->setOptions( *options );
-	returnValue returnvalue = globalSQP->hotstart( H,g,A,lb,ub,lbA,ubA, nWSRout,&maxCpuTimeOut );
-
-	switch (returnvalue)
-	{
-		case SUCCESSFUL_RETURN:
-		case RET_QP_UNBOUNDED:
-		case RET_QP_INFEASIBLE:
-			break;
-
-		default:
-			myMexErrMsgTxt( "ERROR (qpOASES): Hotstart failed." );
-			return -1;
-	}
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC );
-
-	return 0;
-}
-
-
-
-/*
- *	m e x F u n c t i o n
- */
-void mexFunction( int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[] )
-{
-	/* inputs */
-	char typeString[2];
-
-	real_t *g=0, *lb=0, *ub=0, *lbA=0, *ubA=0;
-	HessianType hessianType = HST_UNKNOWN;
-	double *x0=0, *R=0, *R_for=0;
-	double *guessedBounds=0, *guessedConstraints=0;
-
-	int_t H_idx=-1, g_idx=-1, A_idx=-1, lb_idx=-1, ub_idx=-1, lbA_idx=-1, ubA_idx=-1;
-	int_t x0_idx=-1, auxInput_idx=-1;
-
-	BooleanType isSimplyBoundedQp = BT_FALSE;
-
-	Options options;
-	options.printLevel = PL_LOW;
-	#ifdef __DEBUG__
-	options.printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	options.printLevel = PL_NONE;
-	#endif
-
-	/* dimensions */
-	uint_t nV=0, nC=0, handle=0;
-	int_t nWSRin;
-	real_t maxCpuTimeIn = -1.0;
-	QPInstance* globalQP = 0;
-
-	/* I) CONSISTENCY CHECKS: */
-	/* 1) Ensure that qpOASES is called with a feasible number of input arguments. */
-	if ( ( nrhs < 5 ) || ( nrhs > 10 ) )
-	{
-		if ( nrhs != 2 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-	}
-	
-	/* 2) Ensure that first input is a string ... */
-	if ( mxIsChar( prhs[0] ) != 1 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): First input argument must be a string!" );
-		return;
-	}
-
-	mxGetString( prhs[0], typeString, 2 );
-
-	/*    ... and if so, check if it is an allowed one. */
-	if ( ( strcmp( typeString,"i" ) != 0 ) && ( strcmp( typeString,"I" ) != 0 ) &&
-		 ( strcmp( typeString,"h" ) != 0 ) && ( strcmp( typeString,"H" ) != 0 ) &&
-		 ( strcmp( typeString,"m" ) != 0 ) && ( strcmp( typeString,"M" ) != 0 ) &&
-		 ( strcmp( typeString,"e" ) != 0 ) && ( strcmp( typeString,"E" ) != 0 ) &&
-		 ( strcmp( typeString,"c" ) != 0 ) && ( strcmp( typeString,"C" ) != 0 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Undefined first input argument!\nType 'help qpOASES_sequence' for further information." );
-		return;
-	}
-
-
-	/* II) SELECT RESPECTIVE QPOASES FUNCTION CALL: */
-	/* 1) Init (without or with initial guess for primal solution). */
-	if ( ( strcmp( typeString,"i" ) == 0 ) || ( strcmp( typeString,"I" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 7 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 5 ) || ( nrhs > 10 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		g_idx = 2;
-
-		if ( mxIsEmpty(prhs[1]) == 1 )
-		{
-			H_idx = -1;
-			nV = (uint_t)mxGetM( prhs[ g_idx ] ); /* row number of Hessian matrix */
-		}
-		else
-		{
-			H_idx = 1;
-			nV = (uint_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-		}
-
-
-		/* ensure that data is given in double precision */
-		if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[ H_idx ] ) == 0 ) ) ||
-		     ( mxIsDouble( prhs[ g_idx ] ) == 0 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-			return;
-		}
-
-		if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Hessian matrix dimension mismatch!" );
-			return;
-		}
-
-
-		/* Check for 'Inf' and 'Nan' in Hessian */
-		if (containsNaNorInf( prhs,H_idx, 0 ) == BT_TRUE)
-			return;
-
-		/* Check for 'Inf' and 'Nan' in gradient */
-		if (containsNaNorInf(prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		/* determine whether is it a simply bounded QP */
-		if ( nrhs <= 7 )
-			isSimplyBoundedQp = BT_TRUE;
-		else
-			isSimplyBoundedQp = BT_FALSE;
-
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			lb_idx = 3;
-			ub_idx = 4;
-
-			if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-				return;
-
-			/* Check inputs dimensions and assign pointers to inputs. */
-			nC = 0; /* row number of constraint matrix */
-
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,2 ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,3 ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,4 ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*nV;
-
-			/* Check whether x0 and options are specified .*/
-			if ( nrhs >= 6 )
-			{
-				if ((!mxIsEmpty(prhs[5])) && (mxIsStruct(prhs[5])))
-					setupOptions( &options,prhs[5],nWSRin,maxCpuTimeIn );
-
-				if ( ( nrhs >= 7 ) && ( !mxIsEmpty(prhs[6]) ) )
-				{ 
-					/* auxInput specified */
-					if ( mxIsStruct(prhs[6]) )
-					{
-						auxInput_idx = 6;
-						x0_idx = -1;
-					}
-					else
-					{
-						auxInput_idx = -1;
-						x0_idx = 6;
-					}
-				}
-				else
-				{
-					auxInput_idx = -1;
-					x0_idx = -1;
-				}
-			}
-		}
-		else
-		{
-			A_idx = 3;
-
-			/* ensure that data is given in double precision */
-			if ( mxIsDouble( prhs[ A_idx ] ) == 0 )
-			{
-				myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-				return;
-			}
-		
-			/* Check inputs dimensions and assign pointers to inputs. */
-			nC = (uint_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-
-			lb_idx = 4;
-			ub_idx = 5;
-			lbA_idx = 6;
-			ubA_idx = 7;
-
-			if (containsNaNorInf( prhs,A_idx, 0 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if ( ( mxGetN( prhs[ A_idx ] ) != 0 ) && ( mxGetN( prhs[ A_idx ] ) != nV ) )
-			{
-				myMexErrMsgTxt( "ERROR (qpOASES): Constraint matrix dimension mismatch!" );
-				return;
-			}
-		
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-				return;
-			
-			if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*(nV+nC);
-
-			/* Check whether x0 and options are specified .*/
-			if ( nrhs >= 9 )
-			{
-				if ((!mxIsEmpty(prhs[8])) && (mxIsStruct(prhs[8])))
-					setupOptions( &options,prhs[8],nWSRin,maxCpuTimeIn );
-
-				if ( ( nrhs >= 10 ) && ( !mxIsEmpty(prhs[9]) ) )
-				{ 
-					/* auxInput specified */
-					if ( mxIsStruct(prhs[9]) )
-					{
-						auxInput_idx = 9;
-						x0_idx = -1;
-					}
-					else
-					{
-						auxInput_idx = -1;
-						x0_idx = 9;
-					}
-				}
-				else
-				{
-					auxInput_idx = -1;
-					x0_idx = -1;
-				}
-			}
-		}
-
-
-		/* check dimensions and copy auxInputs */
-		if ( smartDimensionCheck( &x0,nV,1, BT_TRUE,prhs,x0_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( auxInput_idx >= 0 )
-			setupAuxiliaryInputs( prhs[auxInput_idx],nV,nC, &hessianType,&x0,&guessedBounds,&guessedConstraints,&R_for );
-
-		/* convert Cholesky factor to C storage format */
-		if ( R_for != 0 )
-		{
-			R = new real_t[nV*nV];
-			convertFortranToC( R_for, nV,nV, R );
-		}
-		
-		/* allocate instance */
-		handle = allocateQPInstance( nV,nC,hessianType, isSimplyBoundedQp,&options );	
-		globalQP = getQPInstance( handle );
-
-		/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-		if ( H_idx >= 0 )
-			setupHessianMatrix(	prhs[H_idx],nV, &(globalQP->H),&(globalQP->Hir),&(globalQP->Hjc),&(globalQP->Hv) );
-		
-		/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-		if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-			setupConstraintMatrix( prhs[A_idx],nV,nC, &(globalQP->A),&(globalQP->Air),&(globalQP->Ajc),&(globalQP->Av) );
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC,1,handle );
-
-		/* Call qpOASES. */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			QProblemB_init(	handle,
-							globalQP->H,g,
-							lb,ub,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,R
-							);
-		}
-		else
-		{
-			SQProblem_init(	handle,
-							globalQP->H,g,globalQP->A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,guessedConstraints,R
-							);
-		}
-
-		if (R != 0) delete R;
-		return;
-	}
-
-	/* 2) Hotstart. */
-	if ( ( strcmp( typeString,"h" ) == 0 ) || ( strcmp( typeString,"H" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 6 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 5 ) || ( nrhs > 8 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* determine whether is it a simply bounded QP */
-		if ( nrhs < 7 )
-			isSimplyBoundedQp = BT_TRUE;
-		else
-			isSimplyBoundedQp = BT_FALSE;
-
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		nV = globalQP->getNV();
-
-		g_idx = 2;
-		lb_idx = 3;
-		ub_idx = 4;
-
-		if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			nC = 0;
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*nV;
-
-			/* Check whether options are specified .*/
-			if ( nrhs == 6 )
-				if ( ( !mxIsEmpty( prhs[5] ) ) && ( mxIsStruct( prhs[5] ) ) )
-					setupOptions( &options,prhs[5],nWSRin,maxCpuTimeIn );
-		}
-		else
-		{
-			nC = globalQP->getNC( );
-
-			lbA_idx = 5;
-			ubA_idx = 6;
-
-			if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*(nV+nC);
-
-			/* Check whether options are specified .*/
-			if ( nrhs == 8 )
-				if ( ( !mxIsEmpty( prhs[7] ) ) && ( mxIsStruct( prhs[7] ) ) )
-					setupOptions( &options,prhs[7],nWSRin,maxCpuTimeIn );
-		}
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC );
-
-		/* call qpOASES */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			QProblemB_hotstart(	handle, g,
-								lb,ub,
-								nWSRin,maxCpuTimeIn,
-								&options,
-								nlhs,plhs
-								);
-		}
-		else
-		{
-			QProblem_hotstart(	handle, g,
-								lb,ub,lbA,ubA,
-								nWSRin,maxCpuTimeIn,
-								&options,
-								nlhs,plhs
-								);
-		}
-
-		return;
-	}
-
-	/* 3) Modify matrices. */
-	if ( ( strcmp( typeString,"m" ) == 0 ) || ( strcmp( typeString,"M" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 6 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 9 ) || ( nrhs > 10 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		g_idx = 3;
-		
-		if ( mxIsEmpty(prhs[2]) == 1 )
-		{
-			H_idx = -1;
-			nV = (uint_t)mxGetM( prhs[ g_idx ] ); /* if Hessian is empty, row number of gradient vector */
-		}
-		else
-		{
-			H_idx = 2;
-			nV = (uint_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-		}
-		
-		A_idx = 4;
-		nC = (uint_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-				
-		lb_idx = 5;
-		ub_idx = 6;
-		lbA_idx = 7;
-		ubA_idx = 8;
-
-
-		/* ensure that data is given in double precision */
-		if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[H_idx] ) == 0 ) ) ||
-			 ( mxIsDouble( prhs[g_idx] ) == 0 ) ||
-			 ( mxIsDouble( prhs[A_idx] ) == 0 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in real_t precision!" );
-			return;
-		}
-
-		/* check if supplied data contains 'NaN' or 'Inf' */
-		if (containsNaNorInf(prhs,H_idx, 0) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,A_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-
-		/* Check that dimensions are consistent with existing QP instance */
-		if (nV != (uint_t) globalQP->getNV () || nC != (uint_t) globalQP->getNC ())
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): QP dimensions must be constant during a sequence! Try creating a new QP instance instead." );
-			return;
-		}
-
-		if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Hessian matrix dimension mismatch!" );
-			return;
-		}
-
-		if ( ( mxGetN( prhs[ A_idx ] ) != 0 ) && ( mxGetN( prhs[ A_idx ] ) != nV ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Constraint matrix dimension mismatch!" );
-			return;
-		}
-
-		if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		/* default value for nWSR */
-		nWSRin = 5*(nV+nC);
-
-		/* Check whether options are specified .*/
-		if ( nrhs > 9 )
-			if ( ( !mxIsEmpty( prhs[9] ) ) && ( mxIsStruct( prhs[9] ) ) )
-				setupOptions( &options,prhs[9],nWSRin,maxCpuTimeIn );
-
-		globalQP->deleteQPMatrices( );
-
-		/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-		if ( H_idx >= 0 )
-			setupHessianMatrix(	prhs[H_idx],nV, &(globalQP->H),&(globalQP->Hir),&(globalQP->Hjc),&(globalQP->Hv) );
-
-		/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-		if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-			setupConstraintMatrix( prhs[A_idx],nV,nC, &(globalQP->A),&(globalQP->Air),&(globalQP->Ajc),&(globalQP->Av) );
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC );
-
-		/* Call qpOASES */
-		SQProblem_hotstart(	handle, globalQP->H,g,globalQP->A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							&options,
-							nlhs,plhs
-							);
-
-		return;
-	}
-
-	/* 4) Solve current equality constrained QP. */
-	if ( ( strcmp( typeString,"e" ) == 0 ) || ( strcmp( typeString,"E" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 4 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 7 ) || ( nrhs > 8 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		int_t nRHS = (int_t)mxGetN(prhs[2]);
-		nV = globalQP->getNV( );
-		nC = globalQP->getNC( );
-		real_t *x_out, *y_out;
-
-		g_idx = 2;
-		lb_idx = 3;
-		ub_idx = 4;
-		lbA_idx = 5;
-		ubA_idx = 6;
-
-		/* check if supplied data contains 'NaN' or 'Inf' */
-		if (containsNaNorInf(prhs,g_idx, 0) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if ( smartDimensionCheck( &g,nV,nRHS, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lb,nV,nRHS, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ub,nV,nRHS, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lbA,nC,nRHS, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,nRHS, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		/* Check whether options are specified .*/
-		if ( ( nrhs == 8 ) && ( !mxIsEmpty( prhs[7] ) ) && ( mxIsStruct( prhs[7] ) ) )
-		{
-			nWSRin = 5*(nV+nC);
-			setupOptions( &options,prhs[7],nWSRin,maxCpuTimeIn );
-			globalQP->sqp->setOptions( options );
-		}
-
-		/* Create output vectors and assign pointers to them. */
-		plhs[0] = mxCreateDoubleMatrix( nV, nRHS, mxREAL );
-		x_out = mxGetPr(plhs[0]);
-		if (nlhs >= 2)
-		{
-			plhs[1] = mxCreateDoubleMatrix( nV+nC, nRHS, mxREAL );
-			y_out = mxGetPr(plhs[1]);
-
-			if (nlhs >= 3)
-			{
-				plhs[2] = mxCreateDoubleMatrix( nV, nRHS, mxREAL );
-				real_t* workingSetB = mxGetPr(plhs[2]);
-				globalQP->sqp->getWorkingSetBounds(workingSetB);
-
-				if ( nlhs >= 4 )
-				{
-					plhs[3] = mxCreateDoubleMatrix( nC, nRHS, mxREAL );
-					real_t* workingSetC = mxGetPr(plhs[3]);
-					globalQP->sqp->getWorkingSetConstraints(workingSetC);
-				}
-			}
-		}
-		else
-			y_out = new real_t[nV+nC];
-
-		/* Solve equality constrained QP */
-		returnValue returnvalue = globalQP->sqp->solveCurrentEQP( nRHS,g,lb,ub,lbA,ubA, x_out,y_out );
-
-		if (nlhs < 2)
-			delete[] y_out;
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-		{
-			char msg[MAX_STRING_LENGTH];
-			snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Couldn't solve current EQP (code %d)!", returnvalue);
-			myMexErrMsgTxt(msg);
-			return;
-		}
-
-		return;
-	}
-
-	/* 5) Cleanup. */
-	if ( ( strcmp( typeString,"c" ) == 0 ) || ( strcmp( typeString,"C" ) == 0 ) )
-	{		
-		/* consistency checks */
-		if ( nlhs != 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( nrhs != 2 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* Cleanup SQProblem instance. */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		deleteQPInstance( handle );
-		
-		return;
-	}
-
-}
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.m b/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.m
deleted file mode 100644
index b02b7c0..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/matlab/qpOASES_sequence.m
+++ /dev/null
@@ -1,111 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%qpOASES_sequence is intended to solve a sequence of quadratic
-%programming (QP) problems of the following form:
-%
-%                min   1/2*x'Hx + x'g
-%                s.t.  lb  <=  x <= ub
-%                      lbA <= Ax <= ubA  {optional}
-%
-%I) Call
-%
-%    [QP,x,fval,exitflag,iter,lambda,auxOutput] = ...
-%               qpOASES_sequence( 'i',H,g,A,lb,ub,lbA,ubA{,options{,auxInput}} )
-%or 
-%    [QP,x,fval,exitflag,iter,lambda,auxOutput] = ...
-%               qpOASES_sequence( 'i',H,g,lb,ub{,options{,auxInput}} )
-%
-%for initialising and solving the first above-mentioned QP of the sequence
-%starting from an initial guess x0. H must be a symmetric (possibly indefinite) 
-%matrix and all vectors g, lb, ub, lbA, ubA have to be given as column vectors. 
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used. Optionally, further auxiliary inputs may be generated 
-%using qpOASES_auxInput command and passed to the solver.
-%Both matrices H or A may be passed in sparse matrix format.
-%
-%II) Call
-%
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                      qpOASES_sequence( 'h',QP,g,lb,ub,lbA,ubA{,options} )
-%or
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                      qpOASES_sequence( 'h',QP,g,lb,ub{,options} )
-%
-%for hotstarting from the previous QP solution to the one of the next QP
-%given by the vectors g, lb, ub, lbA, ubA. Options can be generated using the 
-%qpOASES_options command, otherwise default values are used.
-%
-%III) Call
-%
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                     qpOASES_sequence( 'm',QP,H,g,A,lb,ub,lbA,ubA{,options} )
-%
-%for hotstarting from the previous QP solution to the one of the next QP
-%given by the matrices H, A and the vectors g, lb, ub, lbA, ubA. The previous
-%active set serves as a starting guess. If the new projected Hessian matrix
-%turns out to be not positive definite, qpOASES recedes to a safe initial active
-%set guess automatically. This can result in a high number of iterations iter.
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used.
-%
-%IV) Call
-%
-%     [x,lambda,workingSetB,workingSetC] = ...
-%                     qpOASES_sequence( 'e',QP,g,lb,ub,lbA,ubA{,options} )
-%
-%for solving the equality constrained QP with constraints determined by the
-%current active set. All inequalities and bounds which were not active in the
-%previous solution might be violated. This command does not alter the internal
-%state of qpOASES. Instead of calling this command multiple times, it is
-%possible to supply several columns simultaneously in g, lb, ub, lbA, and ubA.
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used.
-%
-%V) Having solved the last QP of your sequence, call
-%
-%     qpOASES_sequence( 'c',QP )
-%
-%in order to cleanup the internal memory.
-%
-%
-%Optional outputs (only x is mandatory):
-%    x            -  Optimal primal solution vector (if exitflag==0).
-%    fval         -  Optimal objective function value (if exitflag==0).
-%    exitflag     -   0: QP solved,
-%                     1: QP could not be solved within given number of iterations,
-%                    -1: QP could not be solved due to an internal error,
-%                    -2: QP is infeasible (and thus could not be solved),
-%                    -3: QP is unbounded (and thus could not be solved).
-%    iter         -  Number of active set iterations actually performed.
-%    lambda       -  Optimal dual solution vector (if exitflag==0).
-%    auxOutput    -  Struct containing auxiliary outputs as described below.
-%
-%The auxOutput struct contains the following entries:
-%    workingSetB  -  Working set of bounds at point x.
-%    workingSetC  -  Working set of constraints at point x.
-%                    The working set is a subset of the active set (indices
-%                    of bounds/constraints that hold with equality) yielding
-%                    a set linearly independent of bounds/constraints.
-%                    The working sets are encoded as follows:
-%                     1: bound/constraint at its upper bound
-%                     0: bound/constraint not at any bound
-%                    -1: bound/constraint at its lower bound
-%    cpuTime      -  Internally measured CPU time for solving QP problem.
-%
-%See also QPOASES_OPTIONS, QPOASES_AUXINPUT, QPOASES
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/clean b/extlibs/qpOASES-3.2.0/interfaces/octave/clean
deleted file mode 100644
index 2957397..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/clean
+++ /dev/null
@@ -1,3 +0,0 @@
-rm *.*~
-rm *.o
-rm qpOASES qpOASES_sequence
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/clean.sh b/extlibs/qpOASES-3.2.0/interfaces/octave/clean.sh
deleted file mode 100644
index 2957397..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/clean.sh
+++ /dev/null
@@ -1,3 +0,0 @@
-rm *.*~
-rm *.o
-rm qpOASES qpOASES_sequence
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/make.m b/extlibs/qpOASES-3.2.0/interfaces/octave/make.m
deleted file mode 100644
index 2040563..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/make.m
+++ /dev/null
@@ -1,238 +0,0 @@
-function [] = make( varargin )
-%MAKE Compiles the octave interface of qpOASES.
-%
-%Type  make            to compile all interfaces that 
-%                      have been modified,
-%type  make clean      to delete all compiled interfaces,
-%type  make clean all  to first delete and then compile 
-%                      all interfaces,
-%type  make 'name'     to compile only the interface with
-%                      the given name (if it has been modified),
-%type  make 'opt'      to compile all interfaces using the 
-%                      given compiler options.
-%
-%Copyright (C) 2013-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-%%
-%%	Filename:  interfaces/octave/make.m
-%%	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-       
-    %% consistency check
-    if ( exist( [pwd, '/make.m'],'file' ) == 0 )
-        error( ['ERROR (',mfilename '.m): Run this make script directly within the directory', ...
-                '<qpOASES-inst-dir>/interfaces/octave, please.'] );
-    end
-
-
-    if ( nargin > 2 )
-        error( ['ERROR (',mfilename '.m): At most two make arguments supported!'] );
-    else
-        [ doClean,fcnNames,userFlags ] = analyseMakeArguments( nargin,varargin );
-    end
-
-    
-    %% define compiler settings
-    QPOASESPATH = '../../';
-    
-    DEBUGFLAGS = ' ';
-    %DEBUGFLAGS = ' -g CXXDEBUGFLAGS=''$CXXDEBUGFLAGS -Wall -pedantic -Wshadow'' ';
-
-    IFLAGS = [ '-I. -I',QPOASESPATH,'include',' -I',QPOASESPATH,'src',' ' ];
-    CPPFLAGS = [ IFLAGS, DEBUGFLAGS, '-D__cpluplus -D__SINGLE_OBJECT__',' ' ];  %%removed: -largeArrayDims
-    defaultFlags = '-D__NO_COPYRIGHT__ '; %% -D__SUPPRESSANYOUTPUT__                         %%removed: -O
-
-    if ( ispc == 0 )
-        CPPFLAGS  = [ CPPFLAGS, '-DLINUX ',' ' ]; 
-    else
-        CPPFLAGS  = [ CPPFLAGS, '-DWIN32 ',' ' ];
-    end
-
-    if ( isempty(userFlags) > 0 )
-        CPPFLAGS = [ CPPFLAGS, defaultFlags,' ' ];
-    else
-        CPPFLAGS = [ CPPFLAGS, userFlags,' ' ];
-    end
-
-    mexExt = mexext();
-    
-    
-    %% ensure copyright notice is displayed
-    if ~isempty( strfind( CPPFLAGS,'-D__NO_COPYRIGHT__' ) )
-        printCopyrightNotice( );
-    end
-    
-    
-    %% clean if desired
-    if ( doClean > 0 )
-        
-        eval( 'delete *.o;' );
-        eval( ['delete *.',mexExt,'*;'] );
-        disp( [ 'INFO (',mfilename '.m): Cleaned all compiled files.'] );
-        pause( 0.2 );
-        
-    end
-    
-    
-    if ( ~isempty(userFlags) )
-        disp( [ 'INFO (',mfilename '.m): Compiling all files with user-defined compiler flags (''',userFlags,''')...'] );
-    end
-    
-
-    %% call mex compiler
-    for ii=1:length(fcnNames)
-        
-        cmd = [ 'mkoctfile --mex --output ', fcnNames{ii}, '.', mexext(), ' ', CPPFLAGS, [fcnNames{ii},'.cpp'] ];
-        
-        if ( exist( [fcnNames{ii},'.',mexExt],'file' ) == 0 )
-            
-            eval( cmd );
-            disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            
-        else
-            
-            % check modification time of source/Make files and compiled mex file
-            cppFile = dir( [pwd,'/',fcnNames{ii},'.cpp'] );
-            cppFileTimestamp = getTimestamp( cppFile.date ); 
-            
-            utilsFile = dir( [pwd,'/qpOASES_octave_utils.cpp'] );
-            utilsFileTimestamp = getTimestamp( utilsFile.date );
-            
-            makeFile = dir( [pwd,'/make.m'] );
-            makeFileTimestamp = getTimestamp( makeFile.date );
-            
-            mexFile = dir( [pwd,'/',fcnNames{ii},'.',mexExt] );
-            if ( isempty(mexFile) == 0 )
-                mexFileTimestamp = getTimestamp( mexFile.date );
-            else
-                mexFileTimestamp = 0;
-            end
-            
-            if ( ( cppFileTimestamp   >= mexFileTimestamp ) || ...
-                 ( utilsFileTimestamp >= mexFileTimestamp ) || ...
-                 ( makeFileTimestamp  >= mexFileTimestamp ) )
-                eval( cmd );
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            else            
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' already exists.'] );
-            end
-            
-        end
-        
-    end
-
-    %% add qpOASES directory to path
-    path( path,pwd );
-
-end
-
-
-function [ doClean,fcnNames,userIFlags ] = analyseMakeArguments( nArgs,args )
-
-    doClean = 0;
-    fcnNames = [];
-    userIFlags = [];
-
-    switch ( nArgs )
-        
-        case 1
-            if ( strcmp( args{1},'all' ) > 0 )
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            elseif ( strcmp( args{1},'qpOASES' ) > 0 )
-                fcnNames = { 'qpOASES' };
-            elseif ( strcmp( args{1},'qpOASES_sequence' ) > 0 )
-                fcnNames = { 'qpOASES_sequence' };
-            elseif ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            elseif ( strcmp( args{1}(1),'-' ) > 0 )
-                % make clean all with user-specified compiler flags
-                userIFlags = args{1};
-                doClean = 1;
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid first argument (''',args{1},''')!'] );
-            end
-
-        case 2
-            if ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            else
-                error( ['ERROR (',mfilename '.m): First argument must be ''clean'' if two arguments are provided!'] );
-            end
-            
-            if ( strcmp( args{2},'all' ) > 0 )
-                fcnNames = { 'qpOASES','qpOASES_sequence' };
-            elseif ( strcmp( args{2},'qpOASES' ) > 0 )
-                fcnNames = { 'qpOASES' };
-            elseif ( strcmp( args{2},'qpOASES_sequence' ) > 0 )
-                fcnNames = { 'qpOASES_sequence' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid second argument (''',args{2},''')!'] );
-            end
-            
-        otherwise
-            fcnNames = { 'qpOASES','qpOASES_sequence' };
-            
-    end
-    
-end
-
-
-function [ timestamp ] = getTimestamp( dateString )
-
-    try 
-        timestamp = datenum( dateString );
-    catch
-        timestamp = Inf;
-    end
-
-end
-
-
-function [ ] = printCopyrightNotice( )
-
-    disp( ' ' );
-    disp( 'qpOASES -- An Implementation of the Online Active Set Strategy.' );
-    disp( 'Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,' );
-    disp( 'Christian Kirches et al. All rights reserved.' );
-    disp( ' ' );
-    disp( 'qpOASES is distributed under the terms of the' );
-    disp( 'GNU Lesser General Public License 2.1 in the hope that it will be' );
-    disp( 'useful, but WITHOUT ANY WARRANTY; without even the implied warranty' );
-    disp( 'of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.' );
-    disp( 'See the GNU Lesser General Public License for more details.' );
-    disp( ' ' );
-    disp( ' ' );
-
-end
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.cpp b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.cpp
deleted file mode 100644
index 3e51965..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.cpp
+++ /dev/null
@@ -1,584 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/octave/qpOASES.cpp
- *	\author Hans Joachim Ferreau, Alexander Buchner, Andreas Potschka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Matlab(R) that enables to call qpOASES as a MEX function.
- *
- */
-
-
-#include <qpOASES.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-#include "qpOASES_octave_utils.hpp"
-
-/** initialise handle counter of QPInstance class */
-int_t QPInstance::s_nexthandle = 1;
-
-/** global pointer to QP objects */
-static std::vector<QPInstance *> g_instances;
-
-#include "qpOASES_octave_utils.cpp"
-
-
-/*
- *	Q P r o b l e m _ q p O A S E S
- */
-int_t QProblem_qpOASES(	int_t nV, int_t nC, HessianType hessianType, int_t nP,
-						SymmetricMatrix* H, double* g, Matrix* A,
-						double* lb, double* ub,
-						double* lbA, double* ubA,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds, const double* const guessedConstraints,
-						const double* const _R
-						)
-{
-	int_t nWSRout;
-	real_t maxCpuTimeOut;
-	
-	/* 1) Setup initial QP. */
-	QProblem QP( nV,nC,hessianType );
-	QP.setOptions( *options );
-
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-
-	Bounds bounds(nV);
-	Constraints constraints(nC);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	if (guessedConstraints != 0) {
-		for (int_t i = 0; i < nC; i++) {
-			if ( isEqual(guessedConstraints[i],-1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_LOWER);
-			} else if ( isEqual(guessedConstraints[i],1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_UPPER);
-			} else if ( isEqual(guessedConstraints[i],0.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of constraints!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	nWSRout = nWSRin;
-	maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	returnvalue = QP.init(	H,g,A,lb,ub,lbA,ubA,
-							nWSRout,&maxCpuTimeOut,
-							x0,0,
-							(guessedBounds != 0) ? &bounds : 0, (guessedConstraints != 0) ? &constraints : 0,
-							_R
-							);
-
-	/* 3) Solve remaining QPs and assign lhs arguments. */
-	/*    Set up pointers to the current QP vectors */
-	real_t* g_current   = g;
-	real_t* lb_current  = lb;
-	real_t* ub_current  = ub;
-	real_t* lbA_current = lbA;
-	real_t* ubA_current = ubA;
-
-	/* Loop through QP sequence. */
-	for ( int_t k=0; k<nP; ++k )
-	{
-		if ( k > 0 )
-		{
-			/* update pointers to the current QP vectors */
-			g_current = &(g[k*nV]);
-			if ( lb != 0 )
-				lb_current = &(lb[k*nV]);
-			if ( ub != 0 )
-				ub_current = &(ub[k*nV]);
-			if ( lbA != 0 )
-				lbA_current = &(lbA[k*nC]);
-			if ( ubA != 0 )
-				ubA_current = &(ubA[k*nC]);
-
-			nWSRout = nWSRin;
-			maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-			returnvalue = QP.hotstart( g_current,lb_current,ub_current,lbA_current,ubA_current, nWSRout,&maxCpuTimeOut );
-		}
-
-		/* write results into output vectors */
-		obtainOutputs(	k,&QP,returnvalue,nWSRout,maxCpuTimeOut,
-						nOutputs,plhs,nV,nC );
-	}
-
-	//QP.writeQpDataIntoMatFile( "qpDataMat0.mat" );
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m B _ q p O A S E S
- */
-int_t QProblemB_qpOASES(	int_t nV, HessianType hessianType, int_t nP,
-							SymmetricMatrix *H, double* g,
-							double* lb, double* ub,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							const double* const x0, Options* options,
-							int_t nOutputs, mxArray* plhs[],
-							const double* const guessedBounds,
-							const double* const _R
-							)
-{
-	int_t nWSRout;
-	real_t maxCpuTimeOut;
-
-	/* 1) Setup initial QP. */
-	QProblemB QP( nV,hessianType );
-	QP.setOptions( *options );
-
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-
-	Bounds bounds(nV);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	nWSRout = nWSRin;
-	maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-	
-	returnvalue = QP.init(	H,g,lb,ub,
-							nWSRout,&maxCpuTimeOut,
-							x0,0,
-							(guessedBounds != 0) ? &bounds : 0,
-							_R
-							);
-
-	/* 3) Solve remaining QPs and assign lhs arguments. */
-	/*    Set up pointers to the current QP vectors */
-	real_t* g_current  = g;
-	real_t* lb_current = lb;
-	real_t* ub_current = ub;
-
-	/* Loop through QP sequence. */
-	for ( int_t k=0; k<nP; ++k )
-	{
-		if ( k > 0 )
-		{
-			/* update pointers to the current QP vectors */
-			g_current = &(g[k*nV]);
-			if ( lb != 0 )
-				lb_current = &(lb[k*nV]);
-			if ( ub != 0 )
-				ub_current = &(ub[k*nV]);
-
-            nWSRout = nWSRin;
-			maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-			returnvalue = QP.hotstart( g_current,lb_current,ub_current, nWSRout,&maxCpuTimeOut );
-		}
-
-		/* write results into output vectors */
-		obtainOutputs(	k,&QP,returnvalue,nWSRout,maxCpuTimeOut,
-						nOutputs,plhs,nV );
-	}
-
-	return 0;
-}
-
-
-
-/*
- *	m e x F u n c t i o n
- */
-void mexFunction( int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[] )
-{
-	/* inputs */
-	SymmetricMatrix *H=0;
-	Matrix *A=0;
-
-	real_t *g=0, *lb=0, *ub=0, *lbA=0, *ubA=0;
-	HessianType hessianType = HST_UNKNOWN;
-	double *x0=0, *R=0, *R_for=0;
-	double *guessedBounds=0, *guessedConstraints=0;
-
-	int H_idx=-1, g_idx=-1, A_idx=-1, lb_idx=-1, ub_idx=-1, lbA_idx=-1, ubA_idx=-1;
-	int options_idx=-1, x0_idx=-1, auxInput_idx=-1;
-
-    /* Setup default options */
-	Options options;
-	options.printLevel = PL_LOW;
-	#ifdef __DEBUG__
-	options.printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	options.printLevel = PL_NONE;
-	#endif
-
-	/* dimensions */
-	uint_t nV=0, nC=0, nP=0;
-	BooleanType isSimplyBoundedQp = BT_FALSE;
-
-	/* sparse matrix indices and values */
-	sparse_int_t *Hir=0, *Hjc=0, *Air=0, *Ajc=0;
-	real_t *Hv=0, *Av=0;
-
-	/* I) CONSISTENCY CHECKS: */
-	/* 1a) Ensure that qpOASES is called with a feasible number of input arguments. */
-	if ( ( nrhs < 4 ) || ( nrhs > 9 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES' for further information." );
-		return;
-	}
-    
-	/* 2) Check for proper number of output arguments. */
-	if ( nlhs > 6 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): At most six output arguments are allowed: \n    [x,fval,exitflag,iter,lambda,auxOutput]!" );
-		return;
-	}
-	if ( nlhs < 1 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): At least one output argument is required: [x,...]!" );
-		return;
-	}
-
-
-	/* II) PREPARE RESPECTIVE QPOASES FUNCTION CALL: */
-	/*     Choose between QProblem and QProblemB object and assign the corresponding
-	 *     indices of the input pointer array in to order to access QP data correctly. */
-	g_idx = 1;
-
-	if ( mxIsEmpty(prhs[0]) == 1 )
-	{
-		H_idx = -1;
-		nV = (int_t)mxGetM( prhs[ g_idx ] ); /* if Hessian is empty, row number of gradient vector */
-	}
-	else
-	{
-		H_idx = 0;
-		nV = (int_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-	}
-	
-	nP = (int_t)mxGetN( prhs[ g_idx ] ); /* number of columns of the gradient matrix (vectors series have to be stored columnwise!) */
-
-	if ( nrhs <= 6 )
-        isSimplyBoundedQp = BT_TRUE;
-	else
-		isSimplyBoundedQp = BT_FALSE;
-
-
-	/* 0) Check whether options are specified .*/
-	if ( isSimplyBoundedQp == BT_TRUE )
-	{
-		if ( ( nrhs >= 5 ) && ( !mxIsEmpty(prhs[4]) ) && ( mxIsStruct(prhs[4]) ) )
-			options_idx = 4;
-	}
-	else
-	{
-		/* Consistency check */
-		if ( ( !mxIsEmpty(prhs[4]) ) && ( mxIsStruct(prhs[4]) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Fifth input argument must not be a struct when solving QP with general constraints!\nType 'help qpOASES' for further information." );
-			return;
-		}
-
-		if ( ( nrhs >= 8 ) && ( !mxIsEmpty(prhs[7]) ) && ( mxIsStruct(prhs[7]) ) )
-			options_idx = 7;
-	}
-
-	// Is the third argument constraint Matrix A?
-	int_t numberOfColumns = (int_t)mxGetN(prhs[2]);
-
-	/* 1) Simply bounded QP. */
-	if ( ( isSimplyBoundedQp == BT_TRUE ) ||
-		 ( ( numberOfColumns == 1 ) && ( nV != 1 ) ) )
-	{
-		lb_idx   = 2;
-		ub_idx   = 3;
-
-		if ( ( nrhs >= 6 ) && ( !mxIsEmpty(prhs[5]) ) )
-		{ 
-			/* auxInput specified */
-			if ( mxIsStruct(prhs[5]) )
-			{
-				auxInput_idx = 5;
-				x0_idx = -1;
-			}
-			else
-			{
-				auxInput_idx = -1;
-				x0_idx = 5;
-			}
-		}
-		else
-		{
-			auxInput_idx = -1;
-			x0_idx = -1;
-		}
-	}
-	else
-	{
-		A_idx = 2;
-
-		/* If constraint matrix is empty, use a QProblemB object! */
-		if ( mxIsEmpty( prhs[ A_idx ] ) )
-		{
-			lb_idx   = 3;
-			ub_idx   = 4;
-
-			nC = 0;
-		}
-		else
-		{
-			lb_idx   = 3;
-			ub_idx   = 4;
-			lbA_idx  = 5;
-			ubA_idx  = 6;
-
-			nC = (int_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-		}
-
-		if ( ( nrhs >= 9 ) && ( !mxIsEmpty(prhs[8]) ) )
-		{ 
-			/* auxInput specified */
-			if ( mxIsStruct(prhs[8]) )
-			{
-				auxInput_idx = 8;
-				x0_idx = -1;
-			}
-			else
-			{
-				auxInput_idx = -1;
-				x0_idx = 8;
-			}
-		}
-		else
-		{
-			auxInput_idx = -1;
-			x0_idx = -1;
-		}
-	}
-
-
-	/* ensure that data is given in real_t precision */
-	if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[ H_idx ] ) == 0 ) ) ||
-		 ( mxIsDouble( prhs[ g_idx ] ) == 0 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-		return;
-	}
-
-	/* check if supplied data contains 'NaN' or 'Inf' */
-	if (containsNaNorInf( prhs,H_idx, 0 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-		return;
-
-	if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-		return;
-
-	/* Check inputs dimensions and assign pointers to inputs. */
-	if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-	{
-		char msg[MAX_STRING_LENGTH]; 
-		snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Hessian matrix dimension mismatch (%ld != %d)!", 
-				(long int)mxGetN(prhs[H_idx]), (int)nV);
-		myMexErrMsgTxt(msg);
-		return;
-	}
-
-	if ( nC > 0 )
-	{
-		/* ensure that data is given in real_t precision */
-		if ( mxIsDouble( prhs[ A_idx ] ) == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in real_t precision!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		if ( mxGetN( prhs[ A_idx ] ) != nV )
-		{
-			char msg[MAX_STRING_LENGTH]; 
-			snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Constraint matrix input dimension mismatch (%ld != %d)!", 
-					(long int)mxGetN(prhs[A_idx]), (int)nV);
-			myMexErrMsgTxt(msg);
-			return;
-		}
-
-		if (containsNaNorInf(prhs,A_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf(prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf(prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-	}
-
-	/* check dimensions and copy auxInputs */
-	if ( smartDimensionCheck( &g,nV,nP, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &lb,nV,nP, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &ub,nV,nP, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( smartDimensionCheck( &x0,nV,1, BT_TRUE,prhs,x0_idx ) != SUCCESSFUL_RETURN )
-		return;
-
-	if ( nC > 0 )
-	{
-		if ( smartDimensionCheck( &lbA,nC,nP, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,nP, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-	}
-
-	if ( auxInput_idx >= 0 )
-		setupAuxiliaryInputs( prhs[auxInput_idx],nV,nC, &hessianType,&x0,&guessedBounds,&guessedConstraints,&R_for );
-
-	/* convert Cholesky factor to C storage format */
-	if ( R_for != 0 )
-	{
-		R = new real_t[nV*nV];
-		convertFortranToC( R_for, nV,nV, R );
-	}
-	
-	/* III) ACTUALLY PERFORM QPOASES FUNCTION CALL: */
-	int_t nWSRin = 5*(nV+nC);
-	real_t maxCpuTimeIn = -1.0;
-
-	if ( options_idx > 0 )
-		setupOptions( &options,prhs[options_idx],nWSRin,maxCpuTimeIn );
-
-	/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-	if ( H_idx >= 0 )
-		setupHessianMatrix(	prhs[H_idx],nV, &H,&Hir,&Hjc,&Hv );
-	
-	/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-	if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-		setupConstraintMatrix( prhs[A_idx],nV,nC, &A,&Air,&Ajc,&Av );
-
-	allocateOutputs( nlhs,plhs,nV,nC,nP );
-
-	if ( nC == 0 )
-	{
-		/* Call qpOASES (using QProblemB class). */
-		QProblemB_qpOASES(	nV,hessianType, nP,
-							H,g,
-							lb,ub,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,R
-							);
-		
-        if (R != 0) delete R;
-		if (H != 0) delete H;
-		if (Hv != 0) delete[] Hv;
-		if (Hjc != 0) delete[] Hjc;
-		if (Hir != 0) delete[] Hir;
-		return;
-	}
-	else
-	{
-		if ( A == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Internal interface error related to constraint matrix!" );
-			return;
-		}
-
-		/* Call qpOASES (using QProblem class). */
-		QProblem_qpOASES(	nV,nC,hessianType, nP,
-							H,g,A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,guessedConstraints,R
-							);
-		
-		if (R != 0) delete R;
-		if (A != 0) delete A;
-		if (H != 0) delete H;
-		if (Av != 0) delete[] Av;
-		if (Ajc != 0) delete[] Ajc;
-		if (Air != 0) delete[] Air;
-		if (Hv != 0) delete[] Hv;
-		if (Hjc != 0) delete[] Hjc;
-		if (Hir != 0) delete[] Hir;
-		return;
-	}
-}
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.m b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.m
deleted file mode 100644
index 4692b60..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES.m
+++ /dev/null
@@ -1,75 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%qpOASES solves (a series) of quadratic programming (QP) problems of the
-%following form:
-%
-%                min   1/2*x'Hx + x'g
-%                s.t.  lb  <=  x <= ub
-%                      lbA <= Ax <= ubA  {optional}
-%
-%Call
-%
-%    [x,fval,exitflag,iter,lambda,auxOutput] = 
-%                     qpOASES( H,g,A,lb,ub,lbA,ubA{,options{,auxInput}} )
-%
-%for solving the above-mentioned QP. H must be a symmetric (but possibly 
-%indefinite) matrix and all vectors g, lb, ub, lbA, ubA have to be given
-%as column vectors. Options can be generated using the qpOASES_options command, 
-%otherwise default values are used. Optionally, further auxiliary inputs
-%may be generated using qpOASES_auxInput command and passed to the solver.
-%Both matrices H or A may be passed in sparse matrix format.
-%
-%Call
-%
-%    [x,fval,exitflag,iter,lambda,auxOutput] =
-%                     qpOASES( H,g,lb,ub{,options{,auxInput}} )
-%
-%for solving the above-mentioned QP without general constraints.
-%
-%
-%Optional outputs (only x is mandatory):
-%    x            -  Optimal primal solution vector (if exitflag==0).
-%    fval         -  Optimal objective function value (if exitflag==0).
-%    exitflag     -   0: QP problem solved,
-%                     1: QP could not be solved within given number of iterations,
-%                    -1: QP could not be solved due to an internal error,
-%                    -2: QP is infeasible (and thus could not be solved),
-%                    -3: QP is unbounded (and thus could not be solved).
-%    iter         -  Number of active set iterations actually performed.
-%    lambda       -  Optimal dual solution vector (if exitflag==0).
-%    auxOutput    -  Struct containing auxiliary outputs as described below.
-%
-%The auxOutput struct contains the following entries:
-%    workingSetB  -  Working set of bounds at point x.
-%    workingSetC  -  Working set of constraints at point x.
-%                    The working set is a subset of the active set (indices
-%                    of bounds/constraints that hold with equality) yielding
-%                    a set linearly independent of bounds/constraints.
-%                    The working sets are encoded as follows:
-%                     1: bound/constraint at its upper bound
-%                     0: bound/constraint not at any bound
-%                    -1: bound/constraint at its lower bound
-%    cpuTime      -  Internally measured CPU time for solving QP problem.
-%
-%
-%If not a single QP but a sequence of QPs with varying vectors is to be solved,
-%the i-th QP is given by the i-th columns of the QP vectors g, lb, ub, lbA, ubA
-%(i.e. they are matrices in this case). Both matrices H and A remain constant.
-%
-%See also QPOASES_OPTIONS, QPOASES_AUXINPUT, QPOASES_SEQUENCE
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_auxInput.m b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_auxInput.m
deleted file mode 100644
index 74c9d93..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_auxInput.m
+++ /dev/null
@@ -1,118 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%Returns a struct containing all possible auxiliary inputs to be passed 
-%to qpOASES.
-%
-%Call
-%    auxInput = qpOASES_auxInput();
-%to obtain a struct with all auxiliary inputs empty.
-%
-%Call
-%    auxInput = qpOASES_auxInput( 'input1',value1,'input2',value2,... )
-%to obtain a struct with 'input1' set to value1 etc. and all remaining
-%auxiliary inputs empty.
-%
-%Call
-%    auxInput = qpOASES_auxInput( oldInputs,'input1',value1,... )
-%to obtain a copy of the options struct oldInputs but with 'input1' set to 
-%value1 etc.
-%
-%
-%qpOASES features the following auxiliary inputs:
-%  hessianType          -  Provide information on Hessian matrix:
-%                          0: Hessian is zero matrix (i.e. LP formulation)
-%                          1: Hessian is identity matrix
-%                          2: Hessian is (strictly) positive definite
-%                          3: Hessian is positive definite on null space 
-%                             of active bounds/constraints
-%                          4: Hessian is positive semi-definite.
-%                          5: Hessian is indefinite
-%                          Leave hessianType empty if Hessian type is unknown.
-%  x0                   -  Initial guess for optimal primal solution.
-%  guessedWorkingSetB   -  Initial guess for working set of bounds at 
-%                          optimal solution (nV elements or empty).
-%  guessedWorkingSetC   -  Initial guess for working set of constraints at 
-%                          optimal solution (nC elements or empty).
-%                          The working sets needs to be encoded as follows:
-%                           1: bound/constraint at its upper bound
-%                           0: bound/constraint not at any bound
-%                          -1: bound/constraint at its lower bound
-%  R                    -  Cholesky factor of Hessian matrix (upper-triangular);
-%                          only used if both guessedWorkingSets are empty
-%                          and option initialStatusBounds is set to 0.
-%
-%
-%See also QPOASES, QPOASES_SEQUENCE, QPOASES_OPTIONS
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
-function [ auxInput ] = qpOASES_auxInput( varargin )
-
-	firstIsStruct = 0;
-
-	if ( nargin == 0 ) 
-		auxInput = qpOASES_emptyAuxInput();
-	else
-		if ( isstruct( varargin{1} ) )
-			if ( mod( nargin,2 ) ~= 1 )
-				error('ERROR (qpOASES_auxInput): Auxiliary inputs must be specified in pairs!');
-			end
-			auxInput = varargin{1};
-			firstIsStruct = 1;
-        else
-            if ( mod( nargin,2 ) ~= 0 )
-				error('ERROR (qpOASES_auxInput): Auxiliary inputs must be specified in pairs!');
-            end
-            auxInput = qpOASES_emptyAuxInput();
-		end
-	end
-
-	% set options to user-defined values  
-	for i=(1+firstIsStruct):2:nargin
-
-		argName  = varargin{i};
-		argValue = varargin{i+1};
-
-        if ( ( isempty( argName ) ) || ( ~ischar( argName ) ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d has to be a non-empty string!',i );
-        end
-			
-        if ( ( ischar(argValue) ) || ( ~isnumeric( argValue ) ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d has to be a numerical constant!',i+1 );
-        end
-
-        if ( ~isfield( auxInput,argName ) )
-			error('ERROR (qpOASES_auxInput): Argmument no. %d is not a valid auxiliary input!',i );
-        end
-
-		eval( ['auxInput.',argName,' = argValue;'] );
-
-	end
-
-end
-
-
-function [ auxInput ] = qpOASES_emptyAuxInput( )
-
-	% setup auxiliary input struct with all entries empty
-	auxInput = struct(	'hessianType',        [], ...
-                        'x0',                 [], ...
-						'guessedWorkingSetB', [], ...
-                        'guessedWorkingSetC', [], ...
-                        'R',                  []  ...
-                        );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.cpp b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.cpp
deleted file mode 100644
index 2d64025..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.cpp
+++ /dev/null
@@ -1,950 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/octave/qpOASES_octave_utils.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Collects utility functions for Interface to octave that
- *	enables to call qpOASES as a MEX function.
- *
- */
-
-
-
-QPInstance::QPInstance(	uint_t _nV, uint_t _nC, HessianType _hessianType,
-						BooleanType _isSimplyBounded
-						)
-{
-	handle = s_nexthandle++;
-
-	if ( _nC > 0 )
-		isSimplyBounded = BT_FALSE;
-	else
-		isSimplyBounded = _isSimplyBounded;
-	
-	if ( isSimplyBounded == BT_TRUE )
-	{
-		sqp = 0;
-		qpb = new QProblemB( _nV,_hessianType );
-	}
-	else
-	{
-		sqp = new SQProblem( _nV,_nC,_hessianType );
-		qpb = 0;
-	}
-
-	H = 0;
-	A = 0;
-	Hir = 0; 
-	Hjc = 0; 
-	Air = 0; 
-	Ajc = 0;
-	Hv = 0;
-	Av = 0;
-}	
-
-
-QPInstance::~QPInstance( )
-{		
-	deleteQPMatrices();
-
-	if ( sqp != 0 )
-	{
-		delete sqp;
-		sqp = 0;
-	}
-
-	if ( qpb != 0 )
-	{
-		delete qpb;
-		qpb = 0;
-	}
-}
-
-
-returnValue QPInstance::deleteQPMatrices( )
-{
-	if ( H != 0 )
-	{
-		delete H;
-		H = 0;
-	}
-
-	if ( Hv != 0 )
-	{
-		delete[] Hv;
-		Hv = 0;
-	}
-	
-	if ( Hjc != 0 )
-	{
-		delete[] Hjc;
-		Hjc = 0;
-	}
-	
-	if ( Hir != 0 )
-	{
-		delete[] Hir;
-		Hir = 0;
-	}
-	
-	if ( A != 0 )
-	{
-		delete A;
-		A = 0;
-	}
-
-	if ( Av != 0 )
-	{
-		delete[] Av;
-		Av = 0;
-	}
-	
-	if ( Ajc != 0 )
-	{
-		delete[] Ajc;
-		Ajc = 0;
-	}
-	
-	if ( Air != 0 )
-	{
-		delete[] Air;
-		Air = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-int_t QPInstance::getNV() const
-{
-    if ( sqp != 0 )
-        return sqp->getNV();
-    
-    if ( qpb != 0 )
-        return qpb->getNV();
-    
-    return 0;
-}
-
-
-int_t QPInstance::getNC() const
-{
-    if ( sqp != 0 )
-        return sqp->getNC();
-   
-    return 0;
-}
-
-
-
-/*
- *	m x I s S c a l a r
- */
-bool mxIsScalar( const mxArray *pm )
-{
-	if ( ( mxGetM(pm) == 1 ) && ( mxGetN(pm) == 1 ) )
-		return true;
-	else
-		return false;
-}
-
-
-
-/*
- *	a l l o c a t e Q P r o b l e m I n s t a n c e
- */
-int_t allocateQPInstance(	int_t nV, int_t nC, HessianType hessianType,
-							BooleanType isSimplyBounded, const Options* options
-							)
-{
-	QPInstance* inst = new QPInstance( nV,nC,hessianType, isSimplyBounded );
-
-	if ( ( inst->sqp != 0 ) && ( options != 0 ) )
-		inst->sqp->setOptions( *options );
-	
-	if ( ( inst->qpb != 0 ) && ( options != 0 ) )
-		inst->qpb->setOptions( *options );
-
-	g_instances.push_back(inst);
-	return inst->handle;
-}
-
-
-/*
- *  g e t Q P r o b l e m I n s t a n c e
- */
-QPInstance* getQPInstance( int_t handle )
-{
-	uint_t ii;
-	// TODO: this may become slow ...
-	for (ii = 0; ii < g_instances.size (); ++ii)
-		if (g_instances[ii]->handle == handle)
-			return g_instances[ii];
-	return 0;
-}
-
-
-/*
- *	d e l e t e Q P r o b l e m I n s t a n c e
- */
-void deleteQPInstance( int_t handle )
-{
-	QPInstance *instance = getQPInstance (handle);
-	if (instance != 0) {
-		for (std::vector<QPInstance*>::iterator itor = g_instances.begin ();
-		     itor != g_instances.end (); ++itor)
-		     if ((*itor)->handle == handle) {
-				g_instances.erase (itor);
-				break;
-			}
-		delete instance;
-	}
-}
-
-
-
-/*
- *	s m a r t D i m e n s i o n C h e c k
- */
-returnValue smartDimensionCheck(	real_t** input, uint_t m, uint_t n, BooleanType emptyAllowed,
-									const mxArray* prhs[], int_t idx
-									)
-{
-	/* If index is negative, the input does not exist. */
-	if ( idx < 0 )
-	{
-		*input = 0;
-		return SUCCESSFUL_RETURN;
-	}
-
-	/* Otherwise the input has been passed by the user. */
-	if ( mxIsEmpty( prhs[ idx ] ) )
-	{
-		/* input is empty */
-		if ( ( emptyAllowed == BT_TRUE ) || ( idx == 0 ) ) /* idx==0 used for auxInput */
-		{
-			*input = 0;
-			return SUCCESSFUL_RETURN;
-		}
-		else
-		{
-			char msg[MAX_STRING_LENGTH];
-			if ( idx > 0 )
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Empty argument %d not allowed!", idx+1);
-			myMexErrMsgTxt( msg );
-			return RET_INVALID_ARGUMENTS;
-		}
-	}
-	else
-	{
-		/* input is non-empty */
-        if ( mxIsSparse( prhs[ idx ] ) == 0 )
-        {
-            if ( ( mxGetM( prhs[ idx ] ) == m ) && ( mxGetN( prhs[ idx ] ) == n ) )
-            {
-                *input = (real_t*) mxGetPr( prhs[ idx ] );
-                return SUCCESSFUL_RETURN;
-            }
-            else
-            {
-                char msg[MAX_STRING_LENGTH];
-				if ( idx > 0 )
-					snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Input dimension mismatch for argument %d ([%ld,%ld] ~= [%d,%d]).",
-							 idx+1, (long int)mxGetM(prhs[idx]), (long int)mxGetN(prhs[idx]), (int)m,(int)n);
-				else /* idx==0 used for auxInput */
-					snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Input dimension mismatch for some auxInput entry ([%ld,%ld] ~= [%d,%d]).",
-							 (long int)mxGetM(prhs[idx]), (long int)mxGetN(prhs[idx]), (int)m,(int)n);
-                myMexErrMsgTxt( msg );
-                return RET_INVALID_ARGUMENTS;
-            }
-        }
-        else
-        {
-            char msg[MAX_STRING_LENGTH];
-			if ( idx > 0 )
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Vector argument %d must not be in sparse format!", idx+1);
-			else /* idx==0 used for auxInput */
-				snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): auxInput entries must not be in sparse format!" );
-			myMexErrMsgTxt( msg );
-			return RET_INVALID_ARGUMENTS;
-        }
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	c o n t a i n s N a N
- */
-BooleanType containsNaN( const real_t* const data, uint_t dim )
-{
-	uint_t i;
-
-	if ( data == 0 )
-		return BT_FALSE;
-
-	for ( i = 0; i < dim; ++i )
-		if ( mxIsNaN(data[i]) == 1 )
-			return BT_TRUE;
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n t a i n s I n f
- */
-BooleanType containsInf( const real_t* const data, uint_t dim )
-{
-	uint_t i;
-
-	if ( data == 0 )
-		return BT_FALSE;
-
-	for ( i = 0; i < dim; ++i )
-		if ( mxIsInf(data[i]) == 1 )
-			return BT_TRUE;
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n t a i n s N a N o r I n f
- */
-BooleanType containsNaNorInf(	const mxArray* prhs[], int_t rhs_index,
-								bool mayContainInf
-								)
-{
-	uint_t dim;
-	char msg[MAX_STRING_LENGTH];
-
-	if ( rhs_index < 0 )
-		return BT_FALSE;
-
-	/* overwrite dim for sparse matrices */
-	if (mxIsSparse(prhs[rhs_index]) == 1)
-		dim = (uint_t)mxGetNzmax(prhs[rhs_index]);
-	else
-		dim = (uint_t)(mxGetM(prhs[rhs_index]) * mxGetN(prhs[rhs_index]));
-
-	if (containsNaN((real_t*) mxGetPr(prhs[rhs_index]), dim) == BT_TRUE) {
-		snprintf(msg, MAX_STRING_LENGTH,
-				"ERROR (qpOASES): Argument %d contains 'NaN' !", rhs_index + 1);
-		myMexErrMsgTxt(msg);
-		return BT_TRUE;
-	}
-
-	if (mayContainInf == 0) {
-		if (containsInf((real_t*) mxGetPr(prhs[rhs_index]), dim) == BT_TRUE) {
-			snprintf(msg, MAX_STRING_LENGTH,
-					"ERROR (qpOASES): Argument %d contains 'Inf' !",
-					rhs_index + 1);
-			myMexErrMsgTxt(msg);
-			return BT_TRUE;
-		}
-	}
-
-	return BT_FALSE;
-}
-
-
-/*
- *	c o n v e r t F o r t r a n T o C
- */
-returnValue convertFortranToC( const real_t* const M_for, int_t nV, int_t nC, real_t* const M )
-{
-	int_t i,j;
-
-	if ( ( M_for == 0 ) || ( M == 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	if ( ( nV < 0 ) || ( nC < 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	for ( i=0; i<nC; ++i )
-		for ( j=0; j<nV; ++j )
-			M[i*nV + j] = M_for[j*nC + i];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	h a s O p t i o n s V a l u e
- */
-BooleanType hasOptionsValue( const mxArray* optionsPtr, const char* const optionString, double** optionValue )
-{
-	mxArray* optionName = mxGetField( optionsPtr,0,optionString );
-
-	if ( optionName == 0 )
-	{
-		char msg[MAX_STRING_LENGTH];
-		snprintf(msg, MAX_STRING_LENGTH, "Option struct does not contain entry '%s', using default value instead!", optionString );
-		mexWarnMsgTxt( msg );
-		return BT_FALSE;
-	}
-
-	if ( ( mxIsEmpty(optionName) == false ) && ( mxIsScalar( optionName ) == true ) )
-	{
-		*optionValue = mxGetPr( optionName );
-		return BT_TRUE;
-	}
-	else
-	{
-		char msg[MAX_STRING_LENGTH];
-		snprintf(msg, MAX_STRING_LENGTH, "Option '%s' is not a scalar, using default value instead!", optionString );
-		mexWarnMsgTxt( msg );
-		return BT_FALSE;
-	}
-}
-
-
-/*
- *	s e t u p O p t i o n s
- */
-returnValue setupOptions( Options* options, const mxArray* optionsPtr, int_t& nWSRin, real_t& maxCpuTime )
-{
-	double* optionValue;
-	int_t optionValueInt;
-
-	/* Check for correct number of option entries;
-	 * may occur, e.g., if user types options.<misspelledName> = <someValue>; */
-	if ( mxGetNumberOfFields(optionsPtr) != 31 )
-		mexWarnMsgTxt( "Options might be set incorrectly as struct has wrong number of entries!\n         Type 'help qpOASES_options' for further information." );
-
-
-	if ( hasOptionsValue( optionsPtr,"maxIter",&optionValue ) == BT_TRUE )
-		if ( *optionValue >= 0.0 )
-			nWSRin = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxCpuTime",&optionValue ) == BT_TRUE )
-		if ( *optionValue >= 0.0 )
-			maxCpuTime = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"printLevel",&optionValue ) == BT_TRUE )
-	{
-        #ifdef __SUPPRESSANYOUTPUT__
-        options->printLevel = PL_NONE;
-        #else
-		optionValueInt = (int_t)*optionValue;
-		options->printLevel = (REFER_NAMESPACE_QPOASES PrintLevel)optionValueInt;
-        if ( options->printLevel < PL_DEBUG_ITER )
-            options->printLevel = PL_DEBUG_ITER;
-        if ( options->printLevel > PL_HIGH )
-            options->printLevel = PL_HIGH;       
-        #endif
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableRamping",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableRamping = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFarBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFarBounds = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFlippingBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFlippingBounds = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableRegularisation",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableRegularisation = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableFullLITests",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableFullLITests = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableNZCTests",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableNZCTests = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"enableDriftCorrection",&optionValue ) == BT_TRUE )
-		options->enableDriftCorrection = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"enableCholeskyRefactorisation",&optionValue ) == BT_TRUE )
-		options->enableCholeskyRefactorisation = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"enableEqualities",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		options->enableEqualities = (REFER_NAMESPACE_QPOASES BooleanType)optionValueInt;
-	}
-
-
-	if ( hasOptionsValue( optionsPtr,"terminationTolerance",&optionValue ) == BT_TRUE )
-		options->terminationTolerance = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"boundTolerance",&optionValue ) == BT_TRUE )
-		options->boundTolerance = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"boundRelaxation",&optionValue ) == BT_TRUE )
-		options->boundRelaxation = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsNum",&optionValue ) == BT_TRUE )
-		options->epsNum = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsDen",&optionValue ) == BT_TRUE )
-		options->epsDen = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxPrimalJump",&optionValue ) == BT_TRUE )
-		options->maxPrimalJump = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"maxDualJump",&optionValue ) == BT_TRUE )
-		options->maxDualJump = *optionValue;
-
-
-	if ( hasOptionsValue( optionsPtr,"initialRamping",&optionValue ) == BT_TRUE )
-		options->initialRamping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"finalRamping",&optionValue ) == BT_TRUE )
-		options->finalRamping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"initialFarBounds",&optionValue ) == BT_TRUE )
-		options->initialFarBounds = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"growFarBounds",&optionValue ) == BT_TRUE )
-		options->growFarBounds = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"initialStatusBounds",&optionValue ) == BT_TRUE )
-	{
-		optionValueInt = (int_t)*optionValue;
-		if ( optionValueInt < -1 ) 
-			optionValueInt = -1;
-		if ( optionValueInt > 1 ) 
-			optionValueInt = 1;
-		options->initialStatusBounds = (REFER_NAMESPACE_QPOASES SubjectToStatus)optionValueInt;
-	}
-
-	if ( hasOptionsValue( optionsPtr,"epsFlipping",&optionValue ) == BT_TRUE )
-		options->epsFlipping = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"numRegularisationSteps",&optionValue ) == BT_TRUE )
-		options->numRegularisationSteps = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsRegularisation",&optionValue ) == BT_TRUE )
-		options->epsRegularisation = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"numRefinementSteps",&optionValue ) == BT_TRUE )
-		options->numRefinementSteps = (int_t)*optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsIterRef",&optionValue ) == BT_TRUE )
-		options->epsIterRef = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsLITests",&optionValue ) == BT_TRUE )
-		options->epsLITests = *optionValue;
-
-	if ( hasOptionsValue( optionsPtr,"epsNZCTests",&optionValue ) == BT_TRUE )
-		options->epsNZCTests = *optionValue;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p A u x i l i a r y I n p u t s
- */
-returnValue setupAuxiliaryInputs(	const mxArray* auxInput, uint_t nV, uint_t nC,
-									HessianType* hessianType, double** x0, double** guessedBounds, double** guessedConstraints, double** R
-									)
-{
-	mxArray* curField = 0;
-
-	/* hessianType */
-	curField = mxGetField( auxInput,0,"hessianType" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'hessianType'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		if ( mxIsEmpty(curField) == true )
-		{
-			*hessianType = HST_UNKNOWN;
-		}
-		else
-		{
-			if ( mxIsScalar(curField) == false )
-				return RET_INVALID_ARGUMENTS;
-
-			double* hessianTypeTmp = mxGetPr(curField);
-			int_t hessianTypeInt = (int_t)*hessianTypeTmp;
-			if ( hessianTypeInt < 0 ) 
-				hessianTypeInt = 6; /* == HST_UNKNOWN */
-			if ( hessianTypeInt > 5 ) 
-				hessianTypeInt = 6; /* == HST_UNKNOWN */
-			*hessianType = (REFER_NAMESPACE_QPOASES HessianType)hessianTypeInt;
-		}
-	}
-
-	/* x0 */
-	curField = mxGetField( auxInput,0,"x0" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'x0'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*x0 = mxGetPr(curField);
-		if ( smartDimensionCheck( x0,nV,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* guessedWorkingSetB */
-	curField = mxGetField( auxInput,0,"guessedWorkingSetB" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'guessedWorkingSetB'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*guessedBounds = mxGetPr(curField);
-		if ( smartDimensionCheck( guessedBounds,nV,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* guessedWorkingSetC */
-	curField = mxGetField( auxInput,0,"guessedWorkingSetC" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'guessedWorkingSetC'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*guessedConstraints = mxGetPr(curField);
-		if ( smartDimensionCheck( guessedConstraints,nC,1, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	/* R */
-	curField = mxGetField( auxInput,0,"R" );
-	if ( curField == NULL )
-		mexWarnMsgTxt( "auxInput struct does not contain entry 'R'!\n         Type 'help qpOASES_auxInput' for further information." );
-	else
-	{
-		*R = mxGetPr(curField);
-		if ( smartDimensionCheck( R,nV,nV, BT_TRUE,((const mxArray**)&curField),0 ) != SUCCESSFUL_RETURN )
-			return RET_INVALID_ARGUMENTS;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	a l l o c a t e O u t p u t s
- */
-returnValue allocateOutputs(	int nlhs, mxArray* plhs[], int_t nV, int_t nC = 0, int_t nP = 1, int_t handle = -1
-								)
-{
-	/* Create output vectors and assign pointers to them. */
-	int_t curIdx = 0;
-
-	/* handle */
-	if ( handle >= 0 )
-		plhs[curIdx++] = mxCreateDoubleMatrix( 1, 1, mxREAL );
-
-	/* x */
-	plhs[curIdx++] = mxCreateDoubleMatrix( nV, nP, mxREAL );
-
-	if ( nlhs > curIdx )
-	{
-		/* fval */
-		plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-		if ( nlhs > curIdx )
-		{
-			/* exitflag */
-			plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-			if ( nlhs > curIdx )
-			{
-				/* iter */
-				plhs[curIdx++] = mxCreateDoubleMatrix( 1, nP, mxREAL );
-
-				if ( nlhs > curIdx )
-				{
-					/* lambda */
-					plhs[curIdx++] = mxCreateDoubleMatrix( nV+nC, nP, mxREAL );
-
-					if ( nlhs > curIdx )
-					{
-						/* setup auxiliary output struct */
-						mxArray* auxOutput = mxCreateStructMatrix( 1,1,0,0 );
-						int_t curFieldNum;
-						
-						/* working set */
-						curFieldNum = mxAddField( auxOutput,"workingSetB" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( nV, nP, mxREAL ) );
-
-						curFieldNum = mxAddField( auxOutput,"workingSetC" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( nC, nP, mxREAL ) );
-
-						curFieldNum = mxAddField( auxOutput,"cpuTime" );
-						if ( curFieldNum >= 0 )
-							mxSetFieldByNumber( auxOutput,0,curFieldNum,mxCreateDoubleMatrix( 1, nP, mxREAL ) );
-
-						plhs[curIdx] = auxOutput;
-					}
-				}
-			}
-		}
-	}
-	
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	o b t a i n O u t p u t s
- */
-returnValue obtainOutputs(	int_t k, QProblemB* qp, returnValue returnvalue, int_t _nWSRout, double _cpuTime,
-							int nlhs, mxArray* plhs[], int_t nV, int_t nC = 0, int_t handle = -1
-							)
-{
-	/* Create output vectors and assign pointers to them. */
-	int_t curIdx = 0;
-
-	/* handle */
-	if ( handle >= 0 )
-		plhs[curIdx++] = mxCreateDoubleScalar( handle );
-
-	/* x */
-	double* x = mxGetPr( plhs[curIdx++] );
-	qp->getPrimalSolution( &(x[k*nV]) );
-
-	if ( nlhs > curIdx )
-	{
-		/* fval */
-		double* obj = mxGetPr( plhs[curIdx++] );
-		obj[k] = qp->getObjVal( );
-
-		if ( nlhs > curIdx )
-		{
-			/* exitflag */
-			double* status = mxGetPr( plhs[curIdx++] );
-			status[k] = (double)getSimpleStatus( returnvalue );
-
-			if ( nlhs > curIdx )
-			{
-				/* iter */
-				double* nWSRout = mxGetPr( plhs[curIdx++] );
-				nWSRout[k] = (double) _nWSRout;
-
-				if ( nlhs > curIdx )
-				{
-					/* lambda */
-					double* y = mxGetPr( plhs[curIdx++] );
-					qp->getDualSolution( &(y[k*(nV+nC)]) );
-
-					/* auxOutput */
-					if ( nlhs > curIdx )
-					{
-						QProblem* problemPointer;
-						problemPointer = dynamic_cast<QProblem*>(qp);
-
-						mxArray* auxOutput = plhs[curIdx];
-						mxArray* curField = 0;
-
-						/* working set bounds */
-						if ( nV > 0 )
-						{
-							curField = mxGetField( auxOutput,0,"workingSetB" );
-							double* workingSetB = mxGetPr(curField);
-
-							/* cast successful? */
-							if (problemPointer != NULL) {
-								problemPointer->getWorkingSetBounds( &(workingSetB[k*nV]) );
-							} else {
-								qp->getWorkingSetBounds( &(workingSetB[k*nV]) );
-							}
-						}
-
-						/* working set constraints */
-						if ( nC > 0 )
-						{
-							curField = mxGetField( auxOutput,0,"workingSetC" );
-							double* workingSetC = mxGetPr(curField);
-
-							/* cast successful? */
-							if (problemPointer != NULL) {
-								problemPointer->getWorkingSetConstraints( &(workingSetC[k*nC]) );
-							} else {
-								qp->getWorkingSetConstraints( &(workingSetC[k*nC]) );
-							}
-						}
-
-						/* cpu time */
-						curField = mxGetField( auxOutput,0,"cpuTime" );
-						double* cpuTime = mxGetPr(curField);
-						cpuTime[0] = (double) _cpuTime;
-					}
-				}
-			}
-		}
-	}
-	
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p H e s s i a n M a t r i x
- */
-returnValue setupHessianMatrix(	const mxArray* prhsH, int_t nV,
-								SymmetricMatrix** H, sparse_int_t** Hir, sparse_int_t** Hjc, real_t** Hv
-								)
-{
-	if ( prhsH == 0 )
-		return SUCCESSFUL_RETURN;
-
-	if ( mxIsSparse( prhsH ) != 0 )
-	{
-		mwIndex *mat_ir = mxGetIr( prhsH );
-		mwIndex *mat_jc = mxGetJc( prhsH );
-		double *v = (double*)mxGetPr( prhsH );
-		long nfill = 0;
-		mwIndex i, j;
-		BooleanType needInsertDiag;
-
-		/* copy indices to avoid 64/32-bit integer confusion */
-		/* also add explicit zeros on diagonal for regularization strategy */
-		/* copy values, too */
-		*Hir = new sparse_int_t[mat_jc[nV] + nV];
-		*Hjc = new sparse_int_t[nV+1];
-		*Hv = new real_t[mat_jc[nV] + nV];
-        for (j = 0; j < nV; j++) 
-		{
-            needInsertDiag = BT_TRUE;
-                
-            (*Hjc)[j] = (sparse_int_t)(mat_jc[j]) + nfill;
-            /* fill up to diagonal */
-            for (i = mat_jc[j]; i < mat_jc[j+1]; i++) 
-			{
-                if ( mat_ir[i] == j )
-                    needInsertDiag = BT_FALSE;
-                    
-                /* add zero diagonal element if not present */
-                if ( ( mat_ir[i] > j ) && ( needInsertDiag == BT_TRUE ) )
-                {
-                    (*Hir)[i + nfill] = (sparse_int_t)j;
-                    (*Hv)[i + nfill] = 0.0;
-                    nfill++;
-                    /* only add diag once */
-                    needInsertDiag = BT_FALSE;
-                }
-                        
-				(*Hir)[i + nfill] = (sparse_int_t)(mat_ir[i]);
-				(*Hv)[i + nfill] = (real_t)(v[i]);
-			}
-		}
-		(*Hjc)[nV] = (sparse_int_t)(mat_jc[nV]) + nfill;
-
-		SymSparseMat *sH;
-		*H = sH = new SymSparseMat(nV, nV, *Hir, *Hjc, *Hv);
-		sH->createDiagInfo();
-	}
-	else
-	{
-		/* make a deep-copy in order to avoid modifying input data when regularising */
-		real_t* H_for = (real_t*) mxGetPr( prhsH );
-		real_t* H_mem = new real_t[nV*nV];
-		memcpy( H_mem,H_for, nV*nV*sizeof(real_t) );
-
-		*H = new SymDenseMat( nV,nV,nV, H_mem );
-		(*H)->doFreeMemory( );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p C o n s t r a i n t M a t r i x
- */
-returnValue setupConstraintMatrix(	const mxArray* prhsA, int_t nV, int_t nC,
-									Matrix** A, sparse_int_t** Air, sparse_int_t** Ajc, real_t** Av
-									)
-{
-	if ( prhsA == 0 )
-		return SUCCESSFUL_RETURN;
-
-	if ( mxIsSparse( prhsA ) != 0 )
-	{
-		mwIndex i;
-		long j;
-
-		mwIndex *mat_ir = mxGetIr( prhsA );
-		mwIndex *mat_jc = mxGetJc( prhsA );
-		double *v = (double*)mxGetPr( prhsA );
-
-		/* copy indices to avoid 64/32-bit integer confusion */
-		*Air = new sparse_int_t[mat_jc[nV]];
-		*Ajc = new sparse_int_t[nV+1];
-		for (i = 0; i < mat_jc[nV]; i++)
-			(*Air)[i] = (sparse_int_t)(mat_ir[i]);
-		for (i = 0; i < nV + 1; i++)
-			(*Ajc)[i] = (sparse_int_t)(mat_jc[i]);
-		
-		/* copy values, too */
-		*Av = new real_t[(*Ajc)[nV]];
-		for (j = 0; j < (*Ajc)[nV]; j++)
-			(*Av)[j] = (real_t)(v[j]);
-
-		*A = new SparseMatrix(nC, nV, *Air, *Ajc, *Av);
-	}
-	else
-	{
-		/* Convert constraint matrix A from FORTRAN to C style
-		* (not necessary for H as it should be symmetric!). */
-		real_t* A_for = (real_t*) mxGetPr( prhsA );
-		real_t* A_mem = new real_t[nC*nV];
-		convertFortranToC( A_for,nV,nC, A_mem );
-		*A = new DenseMatrix(nC, nV, nV, A_mem );
-		(*A)->doFreeMemory();
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.hpp b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.hpp
deleted file mode 100644
index 610c902..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_octave_utils.hpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/octave/qpOASES_octave_utils.hpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Collects utility functions for Interface to octave that
- *	enables to call qpOASES as a MEX function.
- *
- */
-
-
-
-/* Work-around for settings where mexErrMsgTxt causes unexpected behaviour. */
-#ifdef __AVOID_MEXERRMSGTXT__
-	#define myMexErrMsgTxt( TEXT ) mexPrintf( "%s\n\n",(TEXT) );
-#else
-	#define myMexErrMsgTxt mexErrMsgTxt
-#endif
-
-
-#include "mex.h"
-/* #include "matrix.h" */
-#include "string.h"
-#include <vector>
-
-
-/*
- * QProblem instance class
- */
-class QPInstance
-{
-	private:
-		static int_t s_nexthandle;
-
-	public:
-		QPInstance(	uint_t _nV = 0,
-					uint_t _nC = 0,
-					HessianType _hessianType = HST_UNKNOWN,
-					BooleanType _isSimplyBounded = BT_FALSE
-					);
-
-		~QPInstance( );
-	
-		returnValue deleteQPMatrices();
-		
-		int_t getNV() const;
-		int_t getNC() const;
-
-		int_t handle;
-
-		SQProblem* sqp;
-		QProblemB* qpb;
-		BooleanType isSimplyBounded;
-
-		SymmetricMatrix* H;
-		Matrix* A;
-		sparse_int_t* Hir; 
-		sparse_int_t* Hjc; 
-		sparse_int_t* Air; 
-		sparse_int_t* Ajc;
-		real_t* Hv;
-		real_t* Av;
-};
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_options.m b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_options.m
deleted file mode 100644
index 0f37b97..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_options.m
+++ /dev/null
@@ -1,251 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%Returns a struct containing values for all options to be used within qpOASES.
-%
-%Call
-%    options = qpOASES_options( 'default' );
-%    options = qpOASES_options( 'reliable' );
-%    options = qpOASES_options( 'MPC' );
-%to obtain a set of default options or a pre-defined set of options tuned
-%for reliable or fast QP solution, respectively.
-%
-%Call
-%    options = qpOASES_options( 'option1',value1,'option2',value2,... )
-%to obtain a set of default options but with 'option1' set to value1 etc.
-%
-%Call
-%    options = qpOASES_options( oldOptions,'option1',value1,... )
-%to obtain a copy of the options struct oldOptions but with 'option1' set
-%to value1 etc.
-%
-%Call
-%    options = qpOASES_options( 'default', 'option1',value1,... )
-%    options = qpOASES_options( 'reliable','option1',value1,... )
-%    options = qpOASES_options( 'MPC',     'option1',value1,... )
-%to obtain a set of default options or a pre-defined set of options tuned
-%for reliable or fast QP solution, respectively, but with 'option1' set to 
-%value1 etc.
-%
-%
-%qpOASES features the following options:
-%  maxIter                    -  Maximum number of iterations (if set
-%                                to -1, a value is chosen heuristically)
-%  maxCpuTime                 -  Maximum CPU time in seconds (if set
-%                                to -1, only iteration limit is used)
-%  printLevel                 -  0: no printed output,
-%                                1: only error messages are printed,
-%                                2: iterations and error messages are printed,
-%                                3: all available messages are printed.
-%
-%  enableRamping              -  Enables (1) or disables (0) ramping.
-%  enableFarBounds            -  Enables (1) or disables (0) the use of 
-%                                far bounds.
-%  enableFlippingBounds       -  Enables (1) or disables (0) the use of 
-%                                flipping bounds.
-%  enableRegularisation       -  Enables (1) or disables (0) automatic 
-%                                Hessian regularisation.
-%  enableFullLITests          -  Enables (1) or disables (0) condition-hardened 
-%                                (but more expensive) LI test.
-%  enableNZCTests             -  Enables (1) or disables (0) nonzero curvature 
-%                                tests.
-%  enableDriftCorrection      -  Specifies the frequency of drift corrections:
-%                                0: turns them off, 
-%                                1: uses them at each iteration etc.
-%  enableCholeskyRefactorisation - Specifies the frequency of a full re-
-%                                factorisation of projected Hessian matrix:
-%                                0: turns them off, 
-%                                1: uses them at each iteration etc.
-%  enableEqualities           -  Specifies whether equalities should be treated 
-%                                as always active (1) or not (0)
-%
-%  terminationTolerance       -  Relative termination tolerance to stop homotopy.
-%  boundTolerance             -  If upper and lower bounds differ less than this
-%                                tolerance, they are regarded equal, i.e. as 
-%                                equality constraint.
-%  boundRelaxation            -  Initial relaxation of bounds to start homotopy 
-%                                and initial value for far bounds.
-%  epsNum                     -  Numerator tolerance for ratio tests.
-%  epsDen                     -  Denominator tolerance for ratio tests.
-%  maxPrimalJump              -  Maximum allowed jump in primal variables in 
-%                                nonzero curvature tests.
-%  maxDualJump                -  Maximum allowed jump in dual variables in 
-%                                linear independence tests.
-%
-%  initialRamping             -  Start value for ramping strategy.
-%  finalRamping               -  Final value for ramping strategy.
-%  initialFarBounds           -  Initial size for far bounds.
-%  growFarBounds              -  Factor to grow far bounds.
-%  initialStatusBounds        -  Initial status of bounds at first iteration:
-%                                 0: all bounds inactive,
-%                                -1: all bounds active at their lower bound,
-%                                +1: all bounds active at their upper bound.
-%  epsFlipping                -  Tolerance of squared Cholesky diagonal factor 
-%                                which triggers flipping bound.
-%  numRegularisationSteps     -  Maximum number of successive regularisation steps.
-%  epsRegularisation          -  Scaling factor of identity matrix used for 
-%                                Hessian regularisation.
-%  numRefinementSteps         -  Maximum number of iterative refinement steps.
-%  epsIterRef                 -  Early termination tolerance for iterative 
-%                                refinement.
-%  epsLITests                 -  Tolerance for linear independence tests.
-%  epsNZCTests                -  Tolerance for nonzero curvature tests.
-%
-%
-%See also QPOASES, QPOASES_SEQUENCE, QPOASES_AUXINPUT
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
-function [ options ] = qpOASES_options( varargin )
-
-	firstIsStructOrScheme = 0;
-
-	if ( nargin == 0 ) 
-		options = qpOASES_default_options();
-	else
-		if ( isstruct( varargin{1} ) )
-			if ( mod( nargin,2 ) ~= 1 )
-				error('ERROR (qpOASES_options): Options must be specified in pairs!');
-			end
-			options = varargin{1};
-			firstIsStructOrScheme = 1;
-		else
-			if ( ischar( varargin{1} ) )
-				if ( mod( nargin,2 ) == 0 )
-					options = qpOASES_default_options();
-				else
-					if ( ( nargin > 1 ) && ( ischar( varargin{nargin} ) ) )
-						error('ERROR (qpOASES_options): Options must be specified in pairs!');
-					end
-
-					switch ( varargin{1} )
-						case 'default'
-							options = qpOASES_default_options();
-						case 'reliable'
-							options = qpOASES_reliable_options();
-						case {'MPC','mpc','fast'}
-							options = qpOASES_MPC_options();
-						otherwise
-							error( ['ERROR (qpOASES_options): Only the following option schemes are defined: ''default'', ''reliable'', ''MPC''!'] );
-							
-					end
-					firstIsStructOrScheme = 1;
-				end
-			else
-				error('ERROR (qpOASES_options): First argument needs to be a string or an options struct!');
-			end
-		end
-	end
-
-	% set options to user-defined values  
-	for i=(1+firstIsStructOrScheme):2:nargin
-
-		argName  = varargin{i};
-		argValue = varargin{i+1};
-
-		if ( ( isempty( argName ) ) || ( ~ischar( argName ) ) )
-			error('ERROR (qpOASES_options): Argmument no. %d has to be a non-empty string!',i );
-        end
-			
-		if ( ( ischar(argValue) ) || ( ~isscalar( argValue ) ) )
-			error('ERROR (qpOASES_options): Argmument no. %d has to be a scalar constant!',i+1 );
-        end
-
-		if ( ~isfield( options,argName ) )
-			error('ERROR (qpOASES_options): Argmument no. %d is an invalid option!',i );
-		end
-
-		eval( ['options.',argName,' = ',num2str(argValue),';'] );
-
-	end
-
-end
-
-
-function [ options ] = qpOASES_default_options( )
-
-	% setup options struct with default values
-	options = struct(	'maxIter',                       -1, ...
-						'maxCpuTime',                    -1, ...
-						'printLevel',                     1, ...
-						...
-						'enableRamping',                  1, ...
-						'enableFarBounds',                1, ...
-						'enableFlippingBounds',           1, ...
-						'enableRegularisation',           0, ...
-						'enableFullLITests',              0, ...
-						'enableNZCTests',                 1, ...
-						'enableDriftCorrection',          1, ...
-						'enableCholeskyRefactorisation',  0, ...
-						'enableEqualities',               0, ...
-						...
-						'terminationTolerance',           5.0e6*eps, ...
-						'boundTolerance',                 1.0e6*eps, ...
-						'boundRelaxation',                1.0e4, ...
-						'epsNum',                        -1.0e3*eps, ...
-						'epsDen',                         1.0e3*eps, ...
-						'maxPrimalJump',                  1.0e8, ...
-						'maxDualJump',                    1.0e8, ...
-						...
-    					'initialRamping',                 0.5, ...
-						'finalRamping',                   1.0, ...
-						'initialFarBounds',               1.0e6, ...
-						'growFarBounds',                  1.0e3, ...
-						'initialStatusBounds',            -1, ...
-						'epsFlipping',                    1.0e3*eps, ...
-						'numRegularisationSteps',         0, ...
-						'epsRegularisation',              1.0e3*eps, ...
-						'numRefinementSteps',             1, ...
-						'epsIterRef',                     1.0e2*eps, ...
-						'epsLITests',                     1.0e5*eps, ...
-						'epsNZCTests',                    3.1e3*eps );
-
-end
-
-
-
-function [ options ] = qpOASES_reliable_options( )
-
-	% setup options struct with values for most reliable QP solution
-	options = qpOASES_default_options( );
-
-	options.enableFullLITests             =  1;
-	options.enableCholeskyRefactorisation =  1;
-
-	options.numRefinementSteps            =  2;
-
-end
-
-
-function [ options ] = qpOASES_MPC_options( )
-
-	% setup options struct with values for most reliable QP solution
-	options = qpOASES_default_options( );
-
-	options.enableRamping                 =  0;
-	options.enableFarBounds               =  1;
-	options.enableFlippingBounds          =  0;
-	options.enableRegularisation          =  1;
-	options.enableNZCTests                =  0;
-	options.enableDriftCorrection         =  0;
-	options.enableEqualities              =  1;
-
-	options.terminationTolerance          =  1.0e9*eps;
-	
-	options.initialStatusBounds           =  0;
-	options.numRegularisationSteps        =  1;
-	options.numRefinementSteps            =  0;
-
-end
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.cpp b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.cpp
deleted file mode 100644
index 48bf3d9..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.cpp
+++ /dev/null
@@ -1,1104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/octave/qpOASES_sequence.cpp
- *	\author Hans Joachim Ferreau, Christian Kirches, Andreas Potschka, Alexander Buchner
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for octave that enables to call qpOASES as a MEX function
- *  (variant for solving QP sequences).
- *
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-
-#include "qpOASES_octave_utils.hpp"
-
-/** initialise handle counter of QPInstance class */
-int_t QPInstance::s_nexthandle = 1;
-
-/** global pointer to QP objects */
-static std::vector<QPInstance *> g_instances;
-
-#include "qpOASES_octave_utils.cpp"
-
-
-/*
- *	Q P r o b l e m B _ i n i t
- */
-int_t QProblemB_init(	int_t handle, 
-						SymmetricMatrix* H, real_t* g,
-						const real_t* const lb, const real_t* const ub,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds,
-						const double* const _R
-						)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	/* 1) setup initial QP. */
-	QProblemB* globalQPB = getQPInstance(handle)->qpb;
-
-	if ( globalQPB == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-		return -1;
-	}
-
-	globalQPB->setOptions( *options );
-	
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-	int_t nV = globalQPB->getNV();
-	
-	/* 3) Fill the working set. */
-	Bounds bounds(nV);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	returnvalue = globalQPB->init(	H,g,lb,ub,
-									nWSRout,&maxCpuTimeOut,
-									x0,0,
-									(guessedBounds != 0) ? &bounds : 0,
-									_R
-									);
-
-	/* 3) Assign lhs arguments. */
-	obtainOutputs(	0,globalQPB,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,0,handle );
-
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ i n i t
- */
-int_t SQProblem_init(	int_t handle, 
-						SymmetricMatrix* H, real_t* g, Matrix* A,
-						const real_t* const lb, const real_t* const ub,
-						const real_t* const lbA, const real_t* const ubA,
-						int_t nWSRin, real_t maxCpuTimeIn,
-						const double* const x0, Options* options,
-						int_t nOutputs, mxArray* plhs[],
-						const double* const guessedBounds, const double* const guessedConstraints,
-						const double* const _R
-						)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	/* 1) setup initial QP. */
-	SQProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-		return -1;
-	}
-
-	globalSQP->setOptions( *options );
-	
-	/* 2) Solve initial QP. */
-	returnValue returnvalue;
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-	
-	/* 3) Fill the working set. */
-	Bounds bounds(nV);
-	Constraints constraints(nC);
-	if (guessedBounds != 0) {
-		for (int_t i = 0; i < nV; i++) {
-			if ( isEqual(guessedBounds[i],-1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_LOWER);
-			} else if ( isEqual(guessedBounds[i],1.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_UPPER);
-			} else if ( isEqual(guessedBounds[i],0.0) == BT_TRUE ) {
-				bounds.setupBound(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of bounds!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-
-	if (guessedConstraints != 0) {
-		for (int_t i = 0; i < nC; i++) {
-			if ( isEqual(guessedConstraints[i],-1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_LOWER);
-			} else if ( isEqual(guessedConstraints[i],1.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_UPPER);
-			} else if ( isEqual(guessedConstraints[i],0.0) == BT_TRUE ) {
-				constraints.setupConstraint(i, ST_INACTIVE);
-			} else {
-				char msg[MAX_STRING_LENGTH];
-				snprintf(msg, MAX_STRING_LENGTH,
-						"ERROR (qpOASES): Only {-1, 0, 1} allowed for status of constraints!");
-				myMexErrMsgTxt(msg);
-				return -1;
-			}
-		}
-	}
-	
-	returnvalue = globalSQP->init(	H,g,A,lb,ub,lbA,ubA,
-									nWSRout,&maxCpuTimeOut,
-									x0,0,
-									(guessedBounds != 0) ? &bounds : 0, (guessedConstraints != 0) ? &constraints : 0,
-									_R
-									);
-
-	/* 3) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC,handle );
-
-	return 0;
-}
-
-
-
-/*
- *	Q P r o b l e m B _ h o t s t a r t
- */
-int_t QProblemB_hotstart(	int_t handle,
-							const real_t* const g,
-							const real_t* const lb, const real_t* const ub,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	QProblemB* globalQPB = getQPInstance(handle)->qpb;
-
-	if ( globalQPB == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalQPB->getNV();
-
-	/* 1) Solve QP with given options. */
-	globalQPB->setOptions( *options );
-	returnValue returnvalue = globalQPB->hotstart( g,lb,ub, nWSRout,&maxCpuTimeOut );
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalQPB,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,0 );
-
-	return 0;
-}
-
-
-/*
- *	Q P r o b l e m _ h o t s t a r t
- */
-int_t QProblem_hotstart(	int_t handle,
-							const real_t* const g,
-							const real_t* const lb, const real_t* const ub,
-							const real_t* const lbA, const real_t* const ubA,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	QProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-
-	/* 1) Solve QP with given options. */
-	globalSQP->setOptions( *options );
-	returnValue returnvalue = globalSQP->hotstart( g,lb,ub,lbA,ubA, nWSRout,&maxCpuTimeOut );
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC );
-
-	return 0;
-}
-
-
-/*
- *	S Q P r o b l e m _ h o t s t a r t
- */
-int_t SQProblem_hotstart(	int_t handle,
-							SymmetricMatrix* H, real_t* g, Matrix* A,
-							const real_t* const lb, const real_t* const ub, const real_t* const lbA, const real_t* const ubA,
-							int_t nWSRin, real_t maxCpuTimeIn,
-							Options* options,
-							int_t nOutputs, mxArray* plhs[]
-							)
-{
-	int_t nWSRout = nWSRin;
-	real_t maxCpuTimeOut = (maxCpuTimeIn >= 0.0) ? maxCpuTimeIn : INFTY;
-
-	SQProblem* globalSQP = getQPInstance(handle)->sqp;
-
-	if ( globalSQP == 0 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): QP needs to be initialised first!" );
-		return -1;
-	}
-
-	int_t nV = globalSQP->getNV();
-	int_t nC = globalSQP->getNC();
-
-	/* 1) Solve QP. */
-	globalSQP->setOptions( *options );
-	returnValue returnvalue = globalSQP->hotstart( H,g,A,lb,ub,lbA,ubA, nWSRout,&maxCpuTimeOut );
-
-	switch (returnvalue)
-	{
-		case SUCCESSFUL_RETURN:
-		case RET_QP_UNBOUNDED:
-		case RET_QP_INFEASIBLE:
-			break;
-
-		default:
-			myMexErrMsgTxt( "ERROR (qpOASES): Hotstart failed." );
-			return -1;
-	}
-
-	/* 2) Assign lhs arguments. */
-	obtainOutputs(	0,globalSQP,returnvalue,nWSRout,maxCpuTimeOut,
-					nOutputs,plhs,nV,nC );
-
-	return 0;
-}
-
-
-
-/*
- *	m e x F u n c t i o n
- */
-void mexFunction( int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[] )
-{
-	/* inputs */
-	char typeString[2];
-
-	real_t *g=0, *lb=0, *ub=0, *lbA=0, *ubA=0;
-	HessianType hessianType = HST_UNKNOWN;
-	double *x0=0, *R=0, *R_for=0;
-	double *guessedBounds=0, *guessedConstraints=0;
-
-	int_t H_idx=-1, g_idx=-1, A_idx=-1, lb_idx=-1, ub_idx=-1, lbA_idx=-1, ubA_idx=-1;
-	int_t x0_idx=-1, auxInput_idx=-1;
-
-	BooleanType isSimplyBoundedQp = BT_FALSE;
-
-	Options options;
-	options.printLevel = PL_LOW;
-	#ifdef __DEBUG__
-	options.printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	options.printLevel = PL_NONE;
-	#endif
-
-	/* dimensions */
-	uint_t nV=0, nC=0, handle=0;
-	int_t nWSRin;
-	real_t maxCpuTimeIn = -1.0;
-	QPInstance* globalQP = 0;
-
-	/* I) CONSISTENCY CHECKS: */
-	/* 1) Ensure that qpOASES is called with a feasible number of input arguments. */
-	if ( ( nrhs < 5 ) || ( nrhs > 10 ) )
-	{
-		if ( nrhs != 2 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-	}
-	
-	/* 2) Ensure that first input is a string ... */
-	if ( mxIsChar( prhs[0] ) != 1 )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): First input argument must be a string!" );
-		return;
-	}
-
-	mxGetString( prhs[0], typeString, 2 );
-
-	/*    ... and if so, check if it is an allowed one. */
-	if ( ( strcmp( typeString,"i" ) != 0 ) && ( strcmp( typeString,"I" ) != 0 ) &&
-		 ( strcmp( typeString,"h" ) != 0 ) && ( strcmp( typeString,"H" ) != 0 ) &&
-		 ( strcmp( typeString,"m" ) != 0 ) && ( strcmp( typeString,"M" ) != 0 ) &&
-		 ( strcmp( typeString,"e" ) != 0 ) && ( strcmp( typeString,"E" ) != 0 ) &&
-		 ( strcmp( typeString,"c" ) != 0 ) && ( strcmp( typeString,"C" ) != 0 ) )
-	{
-		myMexErrMsgTxt( "ERROR (qpOASES): Undefined first input argument!\nType 'help qpOASES_sequence' for further information." );
-		return;
-	}
-
-
-	/* II) SELECT RESPECTIVE QPOASES FUNCTION CALL: */
-	/* 1) Init (without or with initial guess for primal solution). */
-	if ( ( strcmp( typeString,"i" ) == 0 ) || ( strcmp( typeString,"I" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 7 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 5 ) || ( nrhs > 10 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		g_idx = 2;
-
-		if ( mxIsEmpty(prhs[1]) == 1 )
-		{
-			H_idx = -1;
-			nV = (uint_t)mxGetM( prhs[ g_idx ] ); /* row number of Hessian matrix */
-		}
-		else
-		{
-			H_idx = 1;
-			nV = (uint_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-		}
-
-
-		/* ensure that data is given in double precision */
-		if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[ H_idx ] ) == 0 ) ) ||
-		     ( mxIsDouble( prhs[ g_idx ] ) == 0 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-			return;
-		}
-
-		if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Hessian matrix dimension mismatch!" );
-			return;
-		}
-
-
-		/* Check for 'Inf' and 'Nan' in Hessian */
-		if (containsNaNorInf( prhs,H_idx, 0 ) == BT_TRUE)
-			return;
-
-		/* Check for 'Inf' and 'Nan' in gradient */
-		if (containsNaNorInf(prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		/* determine whether is it a simply bounded QP */
-		if ( nrhs <= 7 )
-			isSimplyBoundedQp = BT_TRUE;
-		else
-			isSimplyBoundedQp = BT_FALSE;
-
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			lb_idx = 3;
-			ub_idx = 4;
-
-			if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-				return;
-
-			/* Check inputs dimensions and assign pointers to inputs. */
-			nC = 0; /* row number of constraint matrix */
-
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,2 ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,3 ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,4 ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*nV;
-
-			/* Check whether x0 and options are specified .*/
-			if ( nrhs >= 6 )
-			{
-				if ((!mxIsEmpty(prhs[5])) && (mxIsStruct(prhs[5])))
-					setupOptions( &options,prhs[5],nWSRin,maxCpuTimeIn );
-
-				if ( ( nrhs >= 7 ) && ( !mxIsEmpty(prhs[6]) ) )
-				{ 
-					/* auxInput specified */
-					if ( mxIsStruct(prhs[6]) )
-					{
-						auxInput_idx = 6;
-						x0_idx = -1;
-					}
-					else
-					{
-						auxInput_idx = -1;
-						x0_idx = 6;
-					}
-				}
-				else
-				{
-					auxInput_idx = -1;
-					x0_idx = -1;
-				}
-			}
-		}
-		else
-		{
-			A_idx = 3;
-
-			/* ensure that data is given in double precision */
-			if ( mxIsDouble( prhs[ A_idx ] ) == 0 )
-			{
-				myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in double precision!" );
-				return;
-			}
-		
-			/* Check inputs dimensions and assign pointers to inputs. */
-			nC = (uint_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-
-			lb_idx = 4;
-			ub_idx = 5;
-			lbA_idx = 6;
-			ubA_idx = 7;
-
-			if (containsNaNorInf( prhs,A_idx, 0 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if ( ( mxGetN( prhs[ A_idx ] ) != 0 ) && ( mxGetN( prhs[ A_idx ] ) != nV ) )
-			{
-				myMexErrMsgTxt( "ERROR (qpOASES): Constraint matrix dimension mismatch!" );
-				return;
-			}
-		
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-				return;
-			
-			if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*(nV+nC);
-
-			/* Check whether x0 and options are specified .*/
-			if ( nrhs >= 9 )
-			{
-				if ((!mxIsEmpty(prhs[8])) && (mxIsStruct(prhs[8])))
-					setupOptions( &options,prhs[8],nWSRin,maxCpuTimeIn );
-
-				if ( ( nrhs >= 10 ) && ( !mxIsEmpty(prhs[9]) ) )
-				{ 
-					/* auxInput specified */
-					if ( mxIsStruct(prhs[9]) )
-					{
-						auxInput_idx = 9;
-						x0_idx = -1;
-					}
-					else
-					{
-						auxInput_idx = -1;
-						x0_idx = 9;
-					}
-				}
-				else
-				{
-					auxInput_idx = -1;
-					x0_idx = -1;
-				}
-			}
-		}
-
-
-		/* check dimensions and copy auxInputs */
-		if ( smartDimensionCheck( &x0,nV,1, BT_TRUE,prhs,x0_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( auxInput_idx >= 0 )
-			setupAuxiliaryInputs( prhs[auxInput_idx],nV,nC, &hessianType,&x0,&guessedBounds,&guessedConstraints,&R_for );
-
-		/* convert Cholesky factor to C storage format */
-		if ( R_for != 0 )
-		{
-			R = new real_t[nV*nV];
-			convertFortranToC( R_for, nV,nV, R );
-		}
-		
-		/* allocate instance */
-		handle = allocateQPInstance( nV,nC,hessianType, isSimplyBoundedQp,&options );	
-		globalQP = getQPInstance( handle );
-
-		/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-		if ( H_idx >= 0 )
-			setupHessianMatrix(	prhs[H_idx],nV, &(globalQP->H),&(globalQP->Hir),&(globalQP->Hjc),&(globalQP->Hv) );
-		
-		/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-		if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-			setupConstraintMatrix( prhs[A_idx],nV,nC, &(globalQP->A),&(globalQP->Air),&(globalQP->Ajc),&(globalQP->Av) );
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC,1,handle );
-
-		/* Call qpOASES. */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			QProblemB_init(	handle,
-							globalQP->H,g,
-							lb,ub,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,R
-							);
-		}
-		else
-		{
-			SQProblem_init(	handle,
-							globalQP->H,g,globalQP->A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							x0,&options,
-							nlhs,plhs,
-							guessedBounds,guessedConstraints,R
-							);
-		}
-
-		if (R != 0) delete R;
-		return;
-	}
-
-	/* 2) Hotstart. */
-	if ( ( strcmp( typeString,"h" ) == 0 ) || ( strcmp( typeString,"H" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 6 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 5 ) || ( nrhs > 8 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* determine whether is it a simply bounded QP */
-		if ( nrhs < 7 )
-			isSimplyBoundedQp = BT_TRUE;
-		else
-			isSimplyBoundedQp = BT_FALSE;
-
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		nV = globalQP->getNV();
-
-		g_idx = 2;
-		lb_idx = 3;
-		ub_idx = 4;
-
-		if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			nC = 0;
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*nV;
-
-			/* Check whether options are specified .*/
-			if ( nrhs == 6 )
-				if ( ( !mxIsEmpty( prhs[5] ) ) && ( mxIsStruct( prhs[5] ) ) )
-					setupOptions( &options,prhs[5],nWSRin,maxCpuTimeIn );
-		}
-		else
-		{
-			nC = globalQP->getNC( );
-
-			lbA_idx = 5;
-			ubA_idx = 6;
-
-			if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-				return;
-
-			if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-				return;
-
-			/* default value for nWSR */
-			nWSRin = 5*(nV+nC);
-
-			/* Check whether options are specified .*/
-			if ( nrhs == 8 )
-				if ( ( !mxIsEmpty( prhs[7] ) ) && ( mxIsStruct( prhs[7] ) ) )
-					setupOptions( &options,prhs[7],nWSRin,maxCpuTimeIn );
-		}
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC );
-
-		/* call qpOASES */
-		if ( isSimplyBoundedQp == BT_TRUE )
-		{
-			QProblemB_hotstart(	handle, g,
-								lb,ub,
-								nWSRin,maxCpuTimeIn,
-								&options,
-								nlhs,plhs
-								);
-		}
-		else
-		{
-			QProblem_hotstart(	handle, g,
-								lb,ub,lbA,ubA,
-								nWSRin,maxCpuTimeIn,
-								&options,
-								nlhs,plhs
-								);
-		}
-
-		return;
-	}
-
-	/* 3) Modify matrices. */
-	if ( ( strcmp( typeString,"m" ) == 0 ) || ( strcmp( typeString,"M" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 6 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 9 ) || ( nrhs > 10 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		g_idx = 3;
-		
-		if ( mxIsEmpty(prhs[2]) == 1 )
-		{
-			H_idx = -1;
-			nV = (uint_t)mxGetM( prhs[ g_idx ] ); /* if Hessian is empty, row number of gradient vector */
-		}
-		else
-		{
-			H_idx = 2;
-			nV = (uint_t)mxGetM( prhs[ H_idx ] ); /* row number of Hessian matrix */
-		}
-		
-		A_idx = 4;
-		nC = (uint_t)mxGetM( prhs[ A_idx ] ); /* row number of constraint matrix */
-				
-		lb_idx = 5;
-		ub_idx = 6;
-		lbA_idx = 7;
-		ubA_idx = 8;
-
-
-		/* ensure that data is given in double precision */
-		if ( ( ( H_idx >= 0 ) && ( mxIsDouble( prhs[H_idx] ) == 0 ) ) ||
-			 ( mxIsDouble( prhs[g_idx] ) == 0 ) ||
-			 ( mxIsDouble( prhs[A_idx] ) == 0 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): All data has to be provided in real_t precision!" );
-			return;
-		}
-
-		/* check if supplied data contains 'NaN' or 'Inf' */
-		if (containsNaNorInf(prhs,H_idx, 0) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,g_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,A_idx, 0 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-
-		/* Check that dimensions are consistent with existing QP instance */
-		if (nV != (uint_t) globalQP->getNV () || nC != (uint_t) globalQP->getNC ())
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): QP dimensions must be constant during a sequence! Try creating a new QP instance instead." );
-			return;
-		}
-
-		if ( ( H_idx >= 0 ) && ( ( mxGetN( prhs[ H_idx ] ) != nV ) || ( mxGetM( prhs[ H_idx ] ) != nV ) ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Hessian matrix dimension mismatch!" );
-			return;
-		}
-
-		if ( ( mxGetN( prhs[ A_idx ] ) != 0 ) && ( mxGetN( prhs[ A_idx ] ) != nV ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Constraint matrix dimension mismatch!" );
-			return;
-		}
-
-		if ( smartDimensionCheck( &g,nV,1, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lb,nV,1, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ub,nV,1, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lbA,nC,1, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,1, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		/* default value for nWSR */
-		nWSRin = 5*(nV+nC);
-
-		/* Check whether options are specified .*/
-		if ( nrhs > 9 )
-			if ( ( !mxIsEmpty( prhs[9] ) ) && ( mxIsStruct( prhs[9] ) ) )
-				setupOptions( &options,prhs[9],nWSRin,maxCpuTimeIn );
-
-		globalQP->deleteQPMatrices( );
-
-		/* make a deep-copy of the user-specified Hessian matrix (possibly sparse) */
-		if ( H_idx >= 0 )
-			setupHessianMatrix(	prhs[H_idx],nV, &(globalQP->H),&(globalQP->Hir),&(globalQP->Hjc),&(globalQP->Hv) );
-
-		/* make a deep-copy of the user-specified constraint matrix (possibly sparse) */
-		if ( ( nC > 0 ) && ( A_idx >= 0 ) )
-			setupConstraintMatrix( prhs[A_idx],nV,nC, &(globalQP->A),&(globalQP->Air),&(globalQP->Ajc),&(globalQP->Av) );
-
-		/* Create output vectors and assign pointers to them. */
-		allocateOutputs( nlhs,plhs, nV,nC );
-
-		/* Call qpOASES */
-		SQProblem_hotstart(	handle, globalQP->H,g,globalQP->A,
-							lb,ub,lbA,ubA,
-							nWSRin,maxCpuTimeIn,
-							&options,
-							nlhs,plhs
-							);
-
-		return;
-	}
-
-	/* 4) Solve current equality constrained QP. */
-	if ( ( strcmp( typeString,"e" ) == 0 ) || ( strcmp( typeString,"E" ) == 0 ) )
-	{
-		/* consistency checks */
-		if ( ( nlhs < 1 ) || ( nlhs > 4 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( nrhs < 7 ) || ( nrhs > 8 ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* get QP instance */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		globalQP = getQPInstance( handle );
-		if ( globalQP == 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid handle to QP instance!" );
-			return;
-		}
-
-		/* Check inputs dimensions and assign pointers to inputs. */
-		int_t nRHS = (int_t)mxGetN(prhs[2]);
-		nV = globalQP->getNV( );
-		nC = globalQP->getNC( );
-		real_t *x_out, *y_out;
-
-		g_idx = 2;
-		lb_idx = 3;
-		ub_idx = 4;
-		lbA_idx = 5;
-		ubA_idx = 6;
-
-		/* check if supplied data contains 'NaN' or 'Inf' */
-		if (containsNaNorInf(prhs,g_idx, 0) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lb_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ub_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,lbA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if (containsNaNorInf( prhs,ubA_idx, 1 ) == BT_TRUE)
-			return;
-
-		if ( smartDimensionCheck( &g,nV,nRHS, BT_FALSE,prhs,g_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lb,nV,nRHS, BT_TRUE,prhs,lb_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ub,nV,nRHS, BT_TRUE,prhs,ub_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &lbA,nC,nRHS, BT_TRUE,prhs,lbA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		if ( smartDimensionCheck( &ubA,nC,nRHS, BT_TRUE,prhs,ubA_idx ) != SUCCESSFUL_RETURN )
-			return;
-
-		/* Check whether options are specified .*/
-		if ( ( nrhs == 8 ) && ( !mxIsEmpty( prhs[7] ) ) && ( mxIsStruct( prhs[7] ) ) )
-		{
-			nWSRin = 5*(nV+nC);
-			setupOptions( &options,prhs[7],nWSRin,maxCpuTimeIn );
-			globalQP->sqp->setOptions( options );
-		}
-
-		/* Create output vectors and assign pointers to them. */
-		plhs[0] = mxCreateDoubleMatrix( nV, nRHS, mxREAL );
-		x_out = mxGetPr(plhs[0]);
-		if (nlhs >= 2)
-		{
-			plhs[1] = mxCreateDoubleMatrix( nV+nC, nRHS, mxREAL );
-			y_out = mxGetPr(plhs[1]);
-
-			if (nlhs >= 3)
-			{
-				plhs[2] = mxCreateDoubleMatrix( nV, nRHS, mxREAL );
-				real_t* workingSetB = mxGetPr(plhs[2]);
-				globalQP->sqp->getWorkingSetBounds(workingSetB);
-
-				if ( nlhs >= 4 )
-				{
-					plhs[3] = mxCreateDoubleMatrix( nC, nRHS, mxREAL );
-					real_t* workingSetC = mxGetPr(plhs[3]);
-					globalQP->sqp->getWorkingSetConstraints(workingSetC);
-				}
-			}
-		}
-		else
-			y_out = new real_t[nV+nC];
-
-		/* Solve equality constrained QP */
-		returnValue returnvalue = globalQP->sqp->solveCurrentEQP( nRHS,g,lb,ub,lbA,ubA, x_out,y_out );
-
-		if (nlhs < 2)
-			delete[] y_out;
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-		{
-			char msg[MAX_STRING_LENGTH];
-			snprintf(msg, MAX_STRING_LENGTH, "ERROR (qpOASES): Couldn't solve current EQP (code %d)!", returnvalue);
-			myMexErrMsgTxt(msg);
-			return;
-		}
-
-		return;
-	}
-
-	/* 5) Cleanup. */
-	if ( ( strcmp( typeString,"c" ) == 0 ) || ( strcmp( typeString,"C" ) == 0 ) )
-	{		
-		/* consistency checks */
-		if ( nlhs != 0 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of output arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( nrhs != 2 )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Invalid number of input arguments!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		if ( ( mxIsDouble( prhs[1] ) == false ) || ( mxIsScalar( prhs[1] ) == false ) )
-		{
-			myMexErrMsgTxt( "ERROR (qpOASES): Expecting a handle to QP object as second argument!\nType 'help qpOASES_sequence' for further information." );
-			return;
-		}
-
-		/* Cleanup SQProblem instance. */
-		handle = (uint_t)mxGetScalar( prhs[1] );
-		deleteQPInstance( handle );
-		
-		return;
-	}
-
-}
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.m b/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.m
deleted file mode 100644
index b02b7c0..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/octave/qpOASES_sequence.m
+++ /dev/null
@@ -1,111 +0,0 @@
-%qpOASES -- An Implementation of the Online Active Set Strategy.
-%Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-%
-%qpOASES is distributed under the terms of the
-%GNU Lesser General Public License 2.1 in the hope that it will be
-%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%See the GNU Lesser General Public License for more details.
-%
-%---------------------------------------------------------------------------------
-%
-%qpOASES_sequence is intended to solve a sequence of quadratic
-%programming (QP) problems of the following form:
-%
-%                min   1/2*x'Hx + x'g
-%                s.t.  lb  <=  x <= ub
-%                      lbA <= Ax <= ubA  {optional}
-%
-%I) Call
-%
-%    [QP,x,fval,exitflag,iter,lambda,auxOutput] = ...
-%               qpOASES_sequence( 'i',H,g,A,lb,ub,lbA,ubA{,options{,auxInput}} )
-%or 
-%    [QP,x,fval,exitflag,iter,lambda,auxOutput] = ...
-%               qpOASES_sequence( 'i',H,g,lb,ub{,options{,auxInput}} )
-%
-%for initialising and solving the first above-mentioned QP of the sequence
-%starting from an initial guess x0. H must be a symmetric (possibly indefinite) 
-%matrix and all vectors g, lb, ub, lbA, ubA have to be given as column vectors. 
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used. Optionally, further auxiliary inputs may be generated 
-%using qpOASES_auxInput command and passed to the solver.
-%Both matrices H or A may be passed in sparse matrix format.
-%
-%II) Call
-%
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                      qpOASES_sequence( 'h',QP,g,lb,ub,lbA,ubA{,options} )
-%or
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                      qpOASES_sequence( 'h',QP,g,lb,ub{,options} )
-%
-%for hotstarting from the previous QP solution to the one of the next QP
-%given by the vectors g, lb, ub, lbA, ubA. Options can be generated using the 
-%qpOASES_options command, otherwise default values are used.
-%
-%III) Call
-%
-%     [x,fval,exitflag,iter,lambda,auxOutput] = ...
-%                     qpOASES_sequence( 'm',QP,H,g,A,lb,ub,lbA,ubA{,options} )
-%
-%for hotstarting from the previous QP solution to the one of the next QP
-%given by the matrices H, A and the vectors g, lb, ub, lbA, ubA. The previous
-%active set serves as a starting guess. If the new projected Hessian matrix
-%turns out to be not positive definite, qpOASES recedes to a safe initial active
-%set guess automatically. This can result in a high number of iterations iter.
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used.
-%
-%IV) Call
-%
-%     [x,lambda,workingSetB,workingSetC] = ...
-%                     qpOASES_sequence( 'e',QP,g,lb,ub,lbA,ubA{,options} )
-%
-%for solving the equality constrained QP with constraints determined by the
-%current active set. All inequalities and bounds which were not active in the
-%previous solution might be violated. This command does not alter the internal
-%state of qpOASES. Instead of calling this command multiple times, it is
-%possible to supply several columns simultaneously in g, lb, ub, lbA, and ubA.
-%Options can be generated using the qpOASES_options command, otherwise default
-%values are used.
-%
-%V) Having solved the last QP of your sequence, call
-%
-%     qpOASES_sequence( 'c',QP )
-%
-%in order to cleanup the internal memory.
-%
-%
-%Optional outputs (only x is mandatory):
-%    x            -  Optimal primal solution vector (if exitflag==0).
-%    fval         -  Optimal objective function value (if exitflag==0).
-%    exitflag     -   0: QP solved,
-%                     1: QP could not be solved within given number of iterations,
-%                    -1: QP could not be solved due to an internal error,
-%                    -2: QP is infeasible (and thus could not be solved),
-%                    -3: QP is unbounded (and thus could not be solved).
-%    iter         -  Number of active set iterations actually performed.
-%    lambda       -  Optimal dual solution vector (if exitflag==0).
-%    auxOutput    -  Struct containing auxiliary outputs as described below.
-%
-%The auxOutput struct contains the following entries:
-%    workingSetB  -  Working set of bounds at point x.
-%    workingSetC  -  Working set of constraints at point x.
-%                    The working set is a subset of the active set (indices
-%                    of bounds/constraints that hold with equality) yielding
-%                    a set linearly independent of bounds/constraints.
-%                    The working sets are encoded as follows:
-%                     1: bound/constraint at its upper bound
-%                     0: bound/constraint not at any bound
-%                    -1: bound/constraint at its lower bound
-%    cpuTime      -  Internally measured CPU time for solving QP problem.
-%
-%See also QPOASES_OPTIONS, QPOASES_AUXINPUT, QPOASES
-%
-%
-%For additional information see the qpOASES User's Manual or
-%visit http://www.qpOASES.org/.
-%
-%Please send remarks and questions to support@qpOASES.org!
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/README.rst b/extlibs/qpOASES-3.2.0/interfaces/python/README.rst
deleted file mode 100644
index 64911d9..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/README.rst
+++ /dev/null
@@ -1,68 +0,0 @@
-pyqpOASES: a Python interface to qpOASES
-
-:Author: Sebastian F. Walter, Manuel Kudruss
-
-
-Installation
-------------
-
-
-Requirements:
-
-  You'll need numpy and cython. Install for instance with::
-
-      sudo pip install cython
-      sudo pip install numpy
-
-Method 1:
-
-  This is a local installation and creates `./interfaces/python/qpoases.so`::
-
-    make python
-
-  Then, you'll have to update your PYTHONPATH, e.g., on LINUX you have to add::
-
-    export PYTHONPATH=$PYTHONPATH:/home/swalter/projects/qpOASES/interfaces/python
-
-  to your ``~/.bashrc``.
-
-Method 2:
-
-  global installation::
-
-    sudo make pythoninstall
-
-Method 3::
-
-   cd ./interfaces/python/
-   python setup.py build_ext --inplace
-   # or python setup.py install
-
-
-Testing your installation
--------------------------
-
-For a quick test run::
-
-  cd ./interfaces/python
-  python example1.py
-
-
-To run a complete unit test you need ``nose``. Install for instance with::
-
-    sudo pip install nose
-
-Then::
-
-   cd ./interfaces/python/
-   nosestests ./tests
-
-The results of the tests can be found in `./interfaces/python/tests/results`.
-
-Tested setups
--------------
-
-The Python interface is known to work on
-
-* Windows, Python 3
-* Linux (Ubuntu 12.04) using Python 2.7.3, Python 3.2.3. NumPy 1.8, Cython 0.19
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/example1.pyx b/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/example1.pyx
deleted file mode 100644
index e562342..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/example1.pyx
+++ /dev/null
@@ -1,73 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-## Example adapted from examples/example1.cpp.
-## author of this file: Sebastian F. Walter
-
-import numpy as np
-from qpoases import PyQProblem as QProblem
-from qpoases import PyPrintLevel as PrintLevel
-from qpoases import PyOptions as Options
-cimport numpy as np
-
-def run():
-
-    #Setup data of QP.
-
-    cdef np.ndarray[np.double_t, ndim=2] H
-    cdef np.ndarray[np.double_t, ndim=2] A
-    cdef np.ndarray[np.double_t, ndim=1] g
-    cdef np.ndarray[np.double_t, ndim=1] lb
-    cdef np.ndarray[np.double_t, ndim=1] ub
-    cdef np.ndarray[np.double_t, ndim=1] lbA
-    cdef np.ndarray[np.double_t, ndim=1] ubA
-
-    H   = np.array([1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-    A   = np.array([1.0, 1.0 ]).reshape((2,1))
-    g   = np.array([1.5, 1.0 ])
-    lb  = np.array([0.5, -2.0])
-    ub  = np.array([5.0, 2.0 ])
-    lbA = np.array([-1.0 ])
-    ubA = np.array([2.0])
-
-    # Setting up QProblem object.
-
-    cdef example = QProblem(2, 1)
-    cdef options = Options()
-    options.printLevel = PrintLevel.NONE
-    example.setOptions(options)
-
-    # Solve first QP.
-
-    cdef int nWSR = 10
-    example.init(H, g, A, lb, ub, lbA, ubA, nWSR)
-
-    # Solve subsequent QPs
-
-    cdef int i,j
-    for i in range(100000):
-        for j in range(1, 100):
-            g[0] = i%j
-        example.hotstart(g, lb, ub, lbA, ubA, nWSR)
-
-run()
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/setup.py b/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/setup.py
deleted file mode 100644
index d605d2c..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/examples/cython/setup.py
+++ /dev/null
@@ -1,16 +0,0 @@
-from distutils.core import setup
-from distutils.extension import Extension
-from Cython.Distutils import build_ext
-
-ext_module = Extension(
-    "example1",
-    ["example1.pyx"],
-    extra_compile_args=['-fopenmp'],
-    extra_link_args=['-fopenmp'],
-)
-
-setup(
-    name = 'Hello world app',
-    cmdclass = {'build_ext': build_ext},
-    ext_modules = [ext_module],
-)
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1.py b/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1.py
deleted file mode 100644
index afa7c56..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1.py
+++ /dev/null
@@ -1,76 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-## Example adapted from examples/example1.cpp.
-## author of this file: Sebastian F. Walter
-
-import numpy as np
-from qpoases import PyQProblem as QProblem
-from qpoases import PyOptions as Options
-from qpoases import PyPrintLevel as PrintLevel
-
-#Setup data of first QP.
-
-H   = np.array([1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-A   = np.array([1.0, 1.0 ]).reshape((2,1))
-g   = np.array([1.5, 1.0 ])
-lb  = np.array([0.5, -2.0])
-ub  = np.array([5.0, 2.0 ])
-lbA = np.array([-1.0 ])
-ubA = np.array([2.0])
-
-
-# Setup data of second QP.
-
-g_new   = np.array([1.0, 1.5])
-lb_new  = np.array([0.0, -1.0])
-ub_new  = np.array([5.0, -0.5])
-lbA_new = np.array([-2.0])
-ubA_new = np.array([1.0])
-
-
-# Setting up QProblem object.
-
-example = QProblem(2, 1)
-options = Options()
-options.printLevel = PrintLevel.NONE
-example.setOptions(options)
-
-# Solve first QP.
-nWSR = np.array([10])
-example.init(H, g, A, lb, ub, lbA, ubA, nWSR)
-
-
-# Solve second QP.
-nWSR = np.array([10])
-
-for i in range(100000):
-    for j in range(1, 100):
-        g_new[0] = i%j
-    example.hotstart( g_new, lb_new, ub_new, lbA_new, ubA_new, nWSR)
-
-# Get and print solution of second QP.
-
-xOpt = np.zeros(2)
-example.getPrimalSolution(xOpt)
-print("\nxOpt = [ %e, %e ];  objVal = %e\n\n"%(xOpt[0],xOpt[1],example.getObjVal()))
-example.printOptions()
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1b.py b/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1b.py
deleted file mode 100644
index c450add..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example1b.py
+++ /dev/null
@@ -1,72 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-## Example adapted from examples/example1b.cpp.
-## author of this file: Sebastian F. Walter
-
-import numpy as np
-from qpoases import PyQProblemB as QProblemB
-from qpoases import PyBooleanType as BooleanType
-from qpoases import PySubjectToStatus as SubjectToStatus
-from qpoases import PyOptions as Options
-
-# Example for qpOASES main function using the QProblemB class.
-
-#Setup data of first QP.
-
-H   = np.array([1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-g   = np.array([1.5, 1.0 ])
-lb  = np.array([0.5, -2.0])
-ub  = np.array([5.0, 2.0 ])
-
-# Setup data of second QP.
-
-g_new   = np.array([1.0, 1.5])
-lb_new  = np.array([0.0, -1.0])
-ub_new  = np.array([5.0, -0.5])
-
-
-# Setting up QProblemB object.
-example = QProblemB(2)
-
-options = Options()
-options.enableFlippingBounds = BooleanType.FALSE
-options.initialStatusBounds  = SubjectToStatus.INACTIVE
-options.numRefinementSteps   = 1
-
-example.setOptions(options)
-
-# Solve first QP.
-nWSR = np.array([10])
-example.init(H, g, lb, ub, nWSR)
-print("\nnWSR = %d\n\n"%nWSR)
-
-# Solve second QP.
-nWSR = np.array([10])
-example.hotstart(g_new, lb_new, ub_new, nWSR)
-print("\nnWSR = %d\n\n"% nWSR)
-
-# Get and print solution of second QP.
-xOpt = np.zeros(2)
-example.getPrimalSolution(xOpt)
-print("\nxOpt = [ %e, %e ];  objVal = %e\n\n" %(xOpt[0], xOpt[1],
-	                                            example.getObjVal()))
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example2.py b/extlibs/qpOASES-3.2.0/interfaces/python/examples/example2.py
deleted file mode 100644
index fff34d9..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/examples/example2.py
+++ /dev/null
@@ -1,92 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-## Example adapted from examples/example2.cpp.
-## author of this file: Sebastian F. Walter
-
-import numpy as np
-from qpoases import PySQProblem as SQProblem
-from qpoases import PySolutionAnalysis as SolutionAnalysis
-
-
-#  Setup data of first QP.
-H = np.array([ 1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-A = np.array([ 1.0, 1.0 ]).reshape((2,1))
-g = np.array([ 1.5, 1.0 ])
-lb = np.array([ 0.5, -2.0 ])
-ub = np.array([ 5.0, 2.0 ])
-lbA = np.array([ -1.0 ])
-ubA = np.array([ 2.0 ])
-
-#  Setup data of second QP.
-H_new = np.array([ 1.0, 0.5, 0.5, 0.5 ]).reshape((2,2))
-A_new = np.array([ 1.0, 5.0 ]).reshape((2,1))
-g_new = np.array([ 1.0, 1.5 ])
-lb_new = np.array([ 0.0, -1.0 ])
-ub_new = np.array([ 5.0, -0.5 ])
-lbA_new = np.array([ -2.0 ])
-ubA_new = np.array([ 1.0 ])
-
-#  Setting up SQProblem object and solution analyser.
-example = SQProblem(2, 1)
-analyser = SolutionAnalysis()
-
-#  Solve first QP ...
-nWSR = np.array([10])
-example.init(H, g, A, lb, ub, lbA, ubA, nWSR)
-
-#  ... and analyse it.
-maxStat = np.zeros(1)
-maxFeas = np.zeros(1)
-maxCmpl = np.zeros(1)
-
-analyser.getKktViolation(example, maxStat, maxFeas, maxCmpl)
-print("maxStat: %e, maxFeas:%e, maxCmpl: %e\n"%(maxStat, maxFeas, maxCmpl))
-
-#  Solve second QP ...
-nWSR = np.array([10])
-example.hotstart(H_new, g_new, A_new, lb_new, ub_new,
-                 lbA_new, ubA_new, nWSR)
-
-#  ... and analyse it.
-analyser.getKktViolation(example, maxStat, maxFeas, maxCmpl)
-print("maxStat: %e, maxFeas:%e, maxCmpl: %e\n"%(maxStat, maxFeas, maxCmpl))
-
-
-#  ------------ VARIANCE-COVARIANCE EVALUATION --------------------
-
-Var             = np.zeros(5*5)
-Primal_Dual_Var = np.zeros(5*5)
-
-Var.reshape((5,5))[0,0] = 1.
-Var.reshape((5,5))[1,1] = 1.
-
-#                  (  1   0   0   0   0   )
-#                  (  0   1   0   0   0   )
-#     Var     =    (  0   0   0   0   0   )
-#                  (  0   0   0   0   0   )
-#                  (  0   0   0   0   0   )
-
-
-analyser.getVarianceCovariance(example, Var, Primal_Dual_Var)
-print('Primal_Dual_Var=\n', Primal_Dual_Var.reshape((5,5)))
-print("maxStat: %e, maxFeas:%e, maxCmpl: %e\n"%(maxStat, maxFeas, maxCmpl))
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pxd b/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pxd
deleted file mode 100644
index 66f0b8f..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pxd
+++ /dev/null
@@ -1,487 +0,0 @@
-##
-##  This file is part of qpOASES.
-##
-##  qpOASES -- An Implementation of the Online Active Set Strategy.
-##  Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##  Christian Kirches et al. All rights reserved.
-##
-##  qpOASES is free software; you can redistribute it and/or
-##  modify it under the terms of the GNU Lesser General Public
-##  License as published by the Free Software Foundation; either
-##  version 2.1 of the License, or (at your option) any later version.
-##
-##  qpOASES is distributed in the hope that it will be useful,
-##  but WITHOUT ANY WARRANTY; without even the implied warranty of
-##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##  See the GNU Lesser General Public License for more details.
-##
-##  You should have received a copy of the GNU Lesser General Public
-##  License along with qpOASES; if not, write to the Free Software
-##  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-##
-##    Filename:  qpoases.pxd
-##    Author:    Sebastian F. Walter, Manuel Kudruss
-##    Version:   3.2
-##    Date:      2013-2015
-##
-
-cdef extern from "qpOASES.hpp" namespace "qpOASES":
-
-    ctypedef double real_t
-    ctypedef int int_t
-
-    cdef enum BooleanType:
-
-        BT_FALSE
-        BT_TRUE
-
-    cdef enum PrintLevel:
-
-        PL_DEBUG_ITER = -2
-        PL_TABULAR
-        PL_NONE
-        PL_LOW
-        PL_MEDIUM
-        PL_HIGH
-
-    cdef enum VisibilityStatus:
-
-        VS_HIDDEN
-        VS_VISIBLE
-
-    cdef enum QProblemStatus:
-
-        QPS_NOTINITIALISED
-        QPS_PREPARINGAUXILIARYQP
-
-        QPS_AUXILIARYQPSOLVED
-
-        QPS_PERFORMINGHOMOTOPY
-
-        QPS_HOMOTOPYQPSOLVED
-        QPS_SOLVED
-
-    cdef enum HessianType:
-        HST_ZERO
-        HST_IDENTITY
-        HST_POSDEF
-        HST_POSDEF_NULLSPACE
-        HST_SEMIDEF
-        HST_INDEF
-        HST_UNKNOWN
-
-    cdef enum SubjectToType:
-
-        ST_UNBOUNDED
-        ST_BOUNDED
-        ST_EQUALITY
-        ST_DISABLED
-        ST_UNKNOWN
-
-    cdef enum SubjectToStatus:
-
-        ST_LOWER = -1
-        ST_INACTIVE
-        ST_UPPER
-        ST_INFEASIBLE_LOWER
-        ST_INFEASIBLE_UPPER
-        ST_UNDEFINED
-
-    cdef enum  returnValue:
-        TERMINAL_LIST_ELEMENT = -1
-        SUCCESSFUL_RETURN = 0
-        RET_DIV_BY_ZERO
-        RET_INDEX_OUT_OF_BOUNDS
-        RET_INVALID_ARGUMENTS
-        RET_ERROR_UNDEFINED
-        RET_WARNING_UNDEFINED
-        RET_INFO_UNDEFINED
-        RET_EWI_UNDEFINED
-        RET_AVAILABLE_WITH_LINUX_ONLY
-        RET_UNKNOWN_BUG
-        RET_PRINTLEVEL_CHANGED
-        RET_NOT_YET_IMPLEMENTED
-        RET_INDEXLIST_MUST_BE_REORDERD
-        RET_INDEXLIST_EXCEEDS_MAX_LENGTH
-        RET_INDEXLIST_CORRUPTED
-        RET_INDEXLIST_OUTOFBOUNDS
-        RET_INDEXLIST_ADD_FAILED
-        RET_INDEXLIST_INTERSECT_FAILED
-        RET_INDEX_ALREADY_OF_DESIRED_STATUS
-        RET_ADDINDEX_FAILED
-        RET_REMOVEINDEX_FAILED
-        RET_SWAPINDEX_FAILED
-        RET_NOTHING_TO_DO
-        RET_SETUP_BOUND_FAILED
-        RET_SETUP_CONSTRAINT_FAILED
-        RET_MOVING_BOUND_FAILED
-        RET_MOVING_CONSTRAINT_FAILED
-        RET_SHIFTING_FAILED
-        RET_ROTATING_FAILED
-        RET_QPOBJECT_NOT_SETUP
-        RET_QP_ALREADY_INITIALISED
-        RET_NO_INIT_WITH_STANDARD_SOLVER
-        RET_RESET_FAILED
-        RET_INIT_FAILED
-        RET_INIT_FAILED_TQ
-        RET_INIT_FAILED_CHOLESKY
-        RET_INIT_FAILED_HOTSTART
-        RET_INIT_FAILED_INFEASIBILITY
-        RET_INIT_FAILED_UNBOUNDEDNESS
-        RET_INIT_FAILED_REGULARISATION
-        RET_INIT_SUCCESSFUL
-        RET_OBTAINING_WORKINGSET_FAILED
-        RET_SETUP_WORKINGSET_FAILED
-        RET_SETUP_AUXILIARYQP_FAILED
-        RET_NO_CHOLESKY_WITH_INITIAL_GUESS
-        RET_NO_EXTERN_SOLVER
-        RET_QP_UNBOUNDED
-        RET_QP_INFEASIBLE
-        RET_QP_NOT_SOLVED
-        RET_QP_SOLVED
-        RET_UNABLE_TO_SOLVE_QP
-        RET_INITIALISATION_STARTED
-        RET_HOTSTART_FAILED
-        RET_HOTSTART_FAILED_TO_INIT
-        RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED
-        RET_ITERATION_STARTED
-        RET_SHIFT_DETERMINATION_FAILED
-        RET_STEPDIRECTION_DETERMINATION_FAILED
-        RET_STEPLENGTH_DETERMINATION_FAILED
-        RET_OPTIMAL_SOLUTION_FOUND
-        RET_HOMOTOPY_STEP_FAILED
-        RET_HOTSTART_STOPPED_INFEASIBILITY
-        RET_HOTSTART_STOPPED_UNBOUNDEDNESS
-        RET_WORKINGSET_UPDATE_FAILED
-        RET_MAX_NWSR_REACHED
-        RET_CONSTRAINTS_NOT_SPECIFIED
-        RET_INVALID_FACTORISATION_FLAG
-        RET_UNABLE_TO_SAVE_QPDATA
-        RET_STEPDIRECTION_FAILED_TQ
-        RET_STEPDIRECTION_FAILED_CHOLESKY
-        RET_CYCLING_DETECTED
-        RET_CYCLING_NOT_RESOLVED
-        RET_CYCLING_RESOLVED
-        RET_STEPSIZE
-        RET_STEPSIZE_NONPOSITIVE
-        RET_SETUPSUBJECTTOTYPE_FAILED
-        RET_ADDCONSTRAINT_FAILED
-        RET_ADDCONSTRAINT_FAILED_INFEASIBILITY
-        RET_ADDBOUND_FAILED
-        RET_ADDBOUND_FAILED_INFEASIBILITY
-        RET_REMOVECONSTRAINT_FAILED
-        RET_REMOVEBOUND_FAILED
-        RET_REMOVE_FROM_ACTIVESET
-        RET_ADD_TO_ACTIVESET
-        RET_REMOVE_FROM_ACTIVESET_FAILED
-        RET_ADD_TO_ACTIVESET_FAILED
-        RET_CONSTRAINT_ALREADY_ACTIVE
-        RET_ALL_CONSTRAINTS_ACTIVE
-        RET_LINEARLY_DEPENDENT
-        RET_LINEARLY_INDEPENDENT
-        RET_LI_RESOLVED
-        RET_ENSURELI_FAILED
-        RET_ENSURELI_FAILED_TQ
-        RET_ENSURELI_FAILED_NOINDEX
-        RET_ENSURELI_FAILED_CYCLING
-        RET_BOUND_ALREADY_ACTIVE
-        RET_ALL_BOUNDS_ACTIVE
-        RET_CONSTRAINT_NOT_ACTIVE
-        RET_BOUND_NOT_ACTIVE
-        RET_HESSIAN_NOT_SPD
-        RET_HESSIAN_INDEFINITE
-        RET_MATRIX_SHIFT_FAILED
-        RET_MATRIX_FACTORISATION_FAILED
-        RET_PRINT_ITERATION_FAILED
-        RET_NO_GLOBAL_MESSAGE_OUTPUTFILE
-        RET_DISABLECONSTRAINTS_FAILED
-        RET_ENABLECONSTRAINTS_FAILED
-        RET_ALREADY_ENABLED
-        RET_ALREADY_DISABLED
-        RET_NO_HESSIAN_SPECIFIED
-        RET_USING_REGULARISATION
-        RET_EPS_MUST_BE_POSITVE
-        RET_REGSTEPS_MUST_BE_POSITVE
-        RET_HESSIAN_ALREADY_REGULARISED
-        RET_CANNOT_REGULARISE_IDENTITY
-        RET_CANNOT_REGULARISE_SPARSE
-        RET_NO_REGSTEP_NWSR
-        RET_FEWER_REGSTEPS_NWSR
-        RET_CHOLESKY_OF_ZERO_HESSIAN
-        RET_ZERO_HESSIAN_ASSUMED
-        RET_CONSTRAINTS_ARE_NOT_SCALED
-        RET_INITIAL_BOUNDS_STATUS_NYI
-        RET_ERROR_IN_CONSTRAINTPRODUCT
-        RET_FIX_BOUNDS_FOR_LP
-        RET_USE_REGULARISATION_FOR_LP
-        RET_UPDATEMATRICES_FAILED
-        RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED
-        RET_UNABLE_TO_OPEN_FILE
-        RET_UNABLE_TO_WRITE_FILE
-        RET_UNABLE_TO_READ_FILE
-        RET_FILEDATA_INCONSISTENT
-        RET_UNABLE_TO_ANALYSE_QPROBLEM
-        RET_OPTIONS_ADJUSTED
-        RET_NWSR_SET_TO_ONE
-        RET_UNABLE_TO_READ_BENCHMARK
-        RET_BENCHMARK_ABORTED
-        RET_INITIAL_QP_SOLVED
-        RET_QP_SOLUTION_STARTED
-        RET_BENCHMARK_SUCCESSFUL
-        RET_NO_DIAGONAL_AVAILABLE
-        RET_DIAGONAL_NOT_INITIALISED
-        RET_ENSURELI_DROPPED
-        RET_KKT_MATRIX_SINGULAR
-        RET_QR_FACTORISATION_FAILED
-        RET_INERTIA_CORRECTION_FAILED
-        RET_NO_SPARSE_SOLVER
-        RET_SIMPLE_STATUS_P1
-        RET_SIMPLE_STATUS_P0
-        RET_SIMPLE_STATUS_M1
-        RET_SIMPLE_STATUS_M2
-        RET_SIMPLE_STATUS_M3
-
-
-    cdef cppclass Options:
-
-        Options()
-        Options(const Options&)
-        # Options& operator=( const Options&)  # equality operator cannot be overloaded in Python
-        returnValue setToDefault()
-        returnValue setToReliable()
-        returnValue setToMPC()
-        returnValue setToFast()
-        returnValue ensureConsistency()
-        # returnValue print() # print is a reserved keyword in Python
-        returnValue copy(const Options& )
-
-        PrintLevel printLevel
-
-        BooleanType enableRamping
-        BooleanType enableFarBounds
-        BooleanType enableFlippingBounds
-        BooleanType enableRegularisation
-        BooleanType enableFullLITests
-        BooleanType enableNZCTests
-        int_t       enableDriftCorrection
-        int_t       enableCholeskyRefactorisation
-        BooleanType enableEqualities
-
-        real_t terminationTolerance
-        real_t boundTolerance
-        real_t boundRelaxation
-        real_t epsNum
-        real_t epsDen
-        real_t maxPrimalJump
-        real_t maxDualJump
-
-        real_t initialRamping
-        real_t finalRamping
-        real_t initialFarBounds
-        real_t growFarBounds
-        SubjectToStatus initialStatusBounds
-        real_t epsFlipping
-        int_t numRegularisationSteps
-        real_t epsRegularisation
-        int_t numRefinementSteps
-        real_t epsIterRef
-        real_t epsLITests
-        real_t epsNZCTests
-
-        real_t rcondSMin
-        BooleanType enableInertiaCorrection
-
-        BooleanType enableDropInfeasibles
-        int_t dropBoundPriority
-        int_t dropEqConPriority
-        int_t dropIneqConPriority
-
-    cdef cppclass QProblemB:
-        QProblemB()
-        QProblemB(int_t, HessianType)
-
-        QProblemB(const QProblemB&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&,
-                         real_t*)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&,
-                             real_t*)
-
-
-        returnValue getPrimalSolution(real_t*)
-        returnValue getDualSolution(real_t*)
-        returnValue printOptions()
-        real_t getObjVal()
-
-        Options getOptions()
-        returnValue setOptions(Options&)
-
-    cdef cppclass QProblem:
-        QProblem()
-        QProblem(int_t, int_t, HessianType)
-
-        QProblem(const QProblem&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&,
-                         real_t*)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&,
-                             real_t*)
-
-        returnValue getPrimalSolution(real_t*)
-        returnValue getDualSolution(real_t*)
-        returnValue printOptions()
-        real_t getObjVal()
-
-        Options getOptions()
-        returnValue setOptions(Options&)
-
-
-    cdef cppclass SQProblem:
-        SQProblem()
-        SQProblem(int_t, int_t, HessianType)
-
-        SQProblem(const QProblem&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&)
-
-        returnValue init(real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         real_t*,
-                         int_t&,
-                         real_t*)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&)
-
-        returnValue hotstart(real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             real_t*,
-                             int_t&,
-                             real_t*)
-
-        returnValue getPrimalSolution(real_t*)
-        returnValue getDualSolution(real_t*)
-        returnValue printOptions()
-        real_t getObjVal()
-
-        Options getOptions()
-        returnValue setOptions(Options&)
-
-cdef extern from "qpOASES/extras/SolutionAnalysis.hpp" namespace "qpOASES":
-    cdef cppclass SolutionAnalysis:
-        SolutionAnalysis()
-        SolutionAnalysis(const SolutionAnalysis&)
-        # ~SolutionAnalysis()
-        # SolutionAnalysis& operator=(const SolutionAnalysis&)
-        returnValue getKktViolation(const QProblem*,  const real_t*, const real_t*, const real_t*)
-        returnValue getKktViolation(const QProblemB*, const real_t*, const real_t*, const real_t*)
-        returnValue getKktViolation(const SQProblem*, const real_t*, const real_t*, const real_t*)
-        returnValue getVarianceCovariance(QProblem*, real_t*, real_t*)
-        returnValue getVarianceCovariance(QProblemB*, real_t*, real_t*)
-        returnValue getVarianceCovariance(SQProblem*, real_t*, real_t*)
-
-
-cdef extern from "qpOASES/Utils.hpp" namespace "qpOASES":
-    pass
-    #void getKktViolation(int_t nV,                # Number of variables.
-    #                     int_t nC,                # Number of constraints.
-    #                     const real_t* const H,   # Hessian matrix.
-    #                     const real_t* const g,   # Sequence of gradient vectors.
-    #                     const real_t* const A,   # Constraint matrix.
-    #                     const real_t* const lb,  # Sequence of lower bound vectors (on variables).
-    #                     const real_t* const ub,  # Sequence of upper bound vectors (on variables).
-    #                     const real_t* const lbA, # Sequence of lower constraints' bound vectors.
-    #                     const real_t* const ubA, # Sequence of upper constraints' bound vectors.
-    #                     const real_t* const x,   # Sequence of primal trial vectors.
-    #                     const real_t* const y,   # Sequence of dual trial vectors.
-    #                     real_t& stat,            # Maximum value of stationarity condition residual.
-    #                     real_t& feas,            # Maximum value of primal feasibility violation.
-    #                     real_t& cmpl             # Maximum value of complementarity residual.
-    #                     )
-
-
-cdef extern from "qpOASES/extras/OQPinterface.hpp" namespace "qpOASES":
-    returnValue runOqpBenchmark(const char* path,           # Full path of the benchmark files (without trailing slash!).
-                                BooleanType isSparse,       # Shall convert matrices to sparse format before solution?
-                                BooleanType useHotstarts,   # Shall QP solution be hotstarted?
-                                const Options& options,     # QP solver options to be used while solving benchmark problems.
-                                int maxAllowedNWSR,         # Maximum number of working set recalculations to be performed.
-                                real_t& maxNWSR,            # Output: Maximum number of performed working set recalculations.
-                                real_t& avgNWSR,            # Output: Average number of performed working set recalculations.
-                                real_t& maxCPUtime,         # Output: Maximum CPU time required for solving each QP.
-                                real_t& avgCPUtime,         # Output: Average CPU time required for solving each QP.
-                                real_t& maxStationarity,    # Output: Maximum residual of stationarity condition.
-                                real_t& maxFeasibility,     # Output: Maximum residual of primal feasibility condition.
-                                real_t& maxComplementarity  # Output: Maximum residual of complementarity condition.
-                                )
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pyx b/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pyx
deleted file mode 100644
index b9883cc..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/qpoases.pyx
+++ /dev/null
@@ -1,929 +0,0 @@
-##
-##  This file is part of qpOASES.
-##
-##  qpOASES -- An Implementation of the Online Active Set Strategy.
-##  Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##  Christian Kirches et al. All rights reserved.
-##
-##  qpOASES is free software; you can redistribute it and/or
-##  modify it under the terms of the GNU Lesser General Public
-##  License as published by the Free Software Foundation; either
-##  version 2.1 of the License, or (at your option) any later version.
-##
-##  qpOASES is distributed in the hope that it will be useful,
-##  but WITHOUT ANY WARRANTY; without even the implied warranty of
-##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##  See the GNU Lesser General Public License for more details.
-##
-##  You should have received a copy of the GNU Lesser General Public
-##  License along with qpOASES; if not, write to the Free Software
-##  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-## author of this file: Sebastian F. Walter
-
-"""
-Python interface to qpOASES
-using Cython
-:author: Sebastian F. Walter, Manuel Kudruss
-"""
-
-import warnings
-warnings.simplefilter("once", DeprecationWarning)
-import numpy as np
-cimport numpy as np
-
-from cython.operator cimport dereference as deref
-
-cimport qpoases
-
-def deprecation_warning_nWSR():
-    warnings.warn("\nInteger nWSR will be deprecated in qpOASES 4.0.\nUse nWSR = numpy.array([10]) as input to qp.init() and qp.hotstart()", DeprecationWarning, stacklevel=2)
-
-def deprecation_warning_cputime():
-    warnings.warn("\nFloat cputime will be deprecated in qpOASES 4.0.\nUse cputime = numpy.array([2.0]) as input to qp.init() and qp.hotstart()", DeprecationWarning, stacklevel=2)
-
-
-cdef class PyBooleanType:
-    FALSE = BT_FALSE
-    TRUE  = BT_TRUE
-
-cdef class PyPrintLevel:
-    DEBUG_ITER = PL_DEBUG_ITER
-    TABULAR    = PL_TABULAR
-    NONE       = PL_NONE
-    LOW        = PL_LOW
-    MEDIUM     = PL_MEDIUM
-    HIGH       = PL_HIGH
-
-cdef class PyHessianType:
-    ZERO               = HST_ZERO
-    IDENTITY           = HST_IDENTITY
-    POSDEF             = HST_POSDEF
-    POSDEF_NULLSPACE   = HST_POSDEF_NULLSPACE
-    SEMIDEF            = HST_SEMIDEF
-    INDEF              = HST_INDEF
-    UNKNOWN            = HST_UNKNOWN
-
-cdef class PySubjectToStatus:
-    LOWER              = ST_LOWER
-    INACTIVE           = ST_INACTIVE
-    UPPER              = ST_UPPER
-    INFEASIBLE_LOWER   = ST_INFEASIBLE_LOWER
-    INFEASIBLE_UPPER   = ST_INFEASIBLE_UPPER
-    UNDEFINED          = ST_UNDEFINED
-
-cdef class PyReturnValue:
-    TERMINAL_LIST_ELEMENT                 = -1
-    SUCCESSFUL_RETURN                     = 0
-    DIV_BY_ZERO                           = RET_DIV_BY_ZERO
-    INDEX_OUT_OF_BOUNDS                   = RET_INDEX_OUT_OF_BOUNDS
-    INVALID_ARGUMENTS                     = RET_INVALID_ARGUMENTS
-    ERROR_UNDEFINED                       = RET_ERROR_UNDEFINED
-    WARNING_UNDEFINED                     = RET_WARNING_UNDEFINED
-    INFO_UNDEFINED                        = RET_INFO_UNDEFINED
-    EWI_UNDEFINED                         = RET_EWI_UNDEFINED
-    AVAILABLE_WITH_LINUX_ONLY             = RET_AVAILABLE_WITH_LINUX_ONLY
-    UNKNOWN_BUG                           = RET_UNKNOWN_BUG
-    PRINTLEVEL_CHANGED                    = RET_PRINTLEVEL_CHANGED
-    NOT_YET_IMPLEMENTED                   = RET_NOT_YET_IMPLEMENTED
-    INDEXLIST_MUST_BE_REORDERD            = RET_INDEXLIST_MUST_BE_REORDERD
-    INDEXLIST_EXCEEDS_MAX_LENGTH          = RET_INDEXLIST_EXCEEDS_MAX_LENGTH
-    INDEXLIST_CORRUPTED                   = RET_INDEXLIST_CORRUPTED
-    INDEXLIST_OUTOFBOUNDS                 = RET_INDEXLIST_OUTOFBOUNDS
-    INDEXLIST_ADD_FAILED                  = RET_INDEXLIST_ADD_FAILED
-    INDEXLIST_INTERSECT_FAILED            = RET_INDEXLIST_INTERSECT_FAILED
-    INDEX_ALREADY_OF_DESIRED_STATUS       = RET_INDEX_ALREADY_OF_DESIRED_STATUS
-    ADDINDEX_FAILED                       = RET_ADDINDEX_FAILED
-    REMOVEINDEX_FAILED                    = RET_REMOVEINDEX_FAILED
-    SWAPINDEX_FAILED                      = RET_SWAPINDEX_FAILED
-    NOTHING_TO_DO                         = RET_NOTHING_TO_DO
-    SETUP_BOUND_FAILED                    = RET_SETUP_BOUND_FAILED
-    SETUP_CONSTRAINT_FAILED               = RET_SETUP_CONSTRAINT_FAILED
-    MOVING_BOUND_FAILED                   = RET_MOVING_BOUND_FAILED
-    MOVING_CONSTRAINT_FAILED              = RET_MOVING_CONSTRAINT_FAILED
-    SHIFTING_FAILED                       = RET_SHIFTING_FAILED
-    ROTATING_FAILED                       = RET_ROTATING_FAILED
-    QPOBJECT_NOT_SETUP                    = RET_QPOBJECT_NOT_SETUP
-    QP_ALREADY_INITIALISED                = RET_QP_ALREADY_INITIALISED
-    NO_INIT_WITH_STANDARD_SOLVER          = RET_NO_INIT_WITH_STANDARD_SOLVER
-    RESET_FAILED                          = RET_RESET_FAILED
-    INIT_FAILED                           = RET_INIT_FAILED
-    INIT_FAILED_TQ                        = RET_INIT_FAILED_TQ
-    INIT_FAILED_CHOLESKY                  = RET_INIT_FAILED_CHOLESKY
-    INIT_FAILED_HOTSTART                  = RET_INIT_FAILED_HOTSTART
-    INIT_FAILED_INFEASIBILITY             = RET_INIT_FAILED_INFEASIBILITY
-    INIT_FAILED_UNBOUNDEDNESS             = RET_INIT_FAILED_UNBOUNDEDNESS
-    INIT_FAILED_REGULARISATION            = RET_INIT_FAILED_REGULARISATION
-    INIT_SUCCESSFUL                       = RET_INIT_SUCCESSFUL
-    OBTAINING_WORKINGSET_FAILED           = RET_OBTAINING_WORKINGSET_FAILED
-    SETUP_WORKINGSET_FAILED               = RET_SETUP_WORKINGSET_FAILED
-    SETUP_AUXILIARYQP_FAILED              = RET_SETUP_AUXILIARYQP_FAILED
-    NO_CHOLESKY_WITH_INITIAL_GUESS        = RET_NO_CHOLESKY_WITH_INITIAL_GUESS
-    NO_EXTERN_SOLVER                      = RET_NO_EXTERN_SOLVER
-    QP_UNBOUNDED                          = RET_QP_UNBOUNDED
-    QP_INFEASIBLE                         = RET_QP_INFEASIBLE
-    QP_NOT_SOLVED                         = RET_QP_NOT_SOLVED
-    QP_SOLVED                             = RET_QP_SOLVED
-    UNABLE_TO_SOLVE_QP                    = RET_UNABLE_TO_SOLVE_QP
-    INITIALISATION_STARTED                = RET_INITIALISATION_STARTED
-    HOTSTART_FAILED                       = RET_HOTSTART_FAILED
-    HOTSTART_FAILED_TO_INIT               = RET_HOTSTART_FAILED_TO_INIT
-    HOTSTART_FAILED_AS_QP_NOT_INITIALISED = RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED
-    ITERATION_STARTED                     = RET_ITERATION_STARTED
-    SHIFT_DETERMINATION_FAILED            = RET_SHIFT_DETERMINATION_FAILED
-    STEPDIRECTION_DETERMINATION_FAILED    = RET_STEPDIRECTION_DETERMINATION_FAILED
-    STEPLENGTH_DETERMINATION_FAILED       = RET_STEPLENGTH_DETERMINATION_FAILED
-    OPTIMAL_SOLUTION_FOUND                = RET_OPTIMAL_SOLUTION_FOUND
-    HOMOTOPY_STEP_FAILED                  = RET_HOMOTOPY_STEP_FAILED
-    HOTSTART_STOPPED_INFEASIBILITY        = RET_HOTSTART_STOPPED_INFEASIBILITY
-    HOTSTART_STOPPED_UNBOUNDEDNESS        = RET_HOTSTART_STOPPED_UNBOUNDEDNESS
-    WORKINGSET_UPDATE_FAILED              = RET_WORKINGSET_UPDATE_FAILED
-    MAX_NWSR_REACHED                      = RET_MAX_NWSR_REACHED
-    CONSTRAINTS_NOT_SPECIFIED             = RET_CONSTRAINTS_NOT_SPECIFIED
-    INVALID_FACTORISATION_FLAG            = RET_INVALID_FACTORISATION_FLAG
-    UNABLE_TO_SAVE_QPDATA                 = RET_UNABLE_TO_SAVE_QPDATA
-    STEPDIRECTION_FAILED_TQ               = RET_STEPDIRECTION_FAILED_TQ
-    STEPDIRECTION_FAILED_CHOLESKY         = RET_STEPDIRECTION_FAILED_CHOLESKY
-    CYCLING_DETECTED                      = RET_CYCLING_DETECTED
-    CYCLING_NOT_RESOLVED                  = RET_CYCLING_NOT_RESOLVED
-    CYCLING_RESOLVED                      = RET_CYCLING_RESOLVED
-    STEPSIZE                              = RET_STEPSIZE
-    STEPSIZE_NONPOSITIVE                  = RET_STEPSIZE_NONPOSITIVE
-    SETUPSUBJECTTOTYPE_FAILED             = RET_SETUPSUBJECTTOTYPE_FAILED
-    ADDCONSTRAINT_FAILED                  = RET_ADDCONSTRAINT_FAILED
-    ADDCONSTRAINT_FAILED_INFEASIBILITY    = RET_ADDCONSTRAINT_FAILED_INFEASIBILITY
-    ADDBOUND_FAILED                       = RET_ADDBOUND_FAILED
-    ADDBOUND_FAILED_INFEASIBILITY         = RET_ADDBOUND_FAILED_INFEASIBILITY
-    REMOVECONSTRAINT_FAILED               = RET_REMOVECONSTRAINT_FAILED
-    REMOVEBOUND_FAILED                    = RET_REMOVEBOUND_FAILED
-    REMOVE_FROM_ACTIVESET                 = RET_REMOVE_FROM_ACTIVESET
-    ADD_TO_ACTIVESET                      = RET_ADD_TO_ACTIVESET
-    REMOVE_FROM_ACTIVESET_FAILED          = RET_REMOVE_FROM_ACTIVESET_FAILED
-    ADD_TO_ACTIVESET_FAILED               = RET_ADD_TO_ACTIVESET_FAILED
-    CONSTRAINT_ALREADY_ACTIVE             = RET_CONSTRAINT_ALREADY_ACTIVE
-    ALL_CONSTRAINTS_ACTIVE                = RET_ALL_CONSTRAINTS_ACTIVE
-    LINEARLY_DEPENDENT                    = RET_LINEARLY_DEPENDENT
-    LINEARLY_INDEPENDENT                  = RET_LINEARLY_INDEPENDENT
-    LI_RESOLVED                           = RET_LI_RESOLVED
-    ENSURELI_FAILED                       = RET_ENSURELI_FAILED
-    ENSURELI_FAILED_TQ                    = RET_ENSURELI_FAILED_TQ
-    ENSURELI_FAILED_NOINDEX               = RET_ENSURELI_FAILED_NOINDEX
-    ENSURELI_FAILED_CYCLING               = RET_ENSURELI_FAILED_CYCLING
-    BOUND_ALREADY_ACTIVE                  = RET_BOUND_ALREADY_ACTIVE
-    ALL_BOUNDS_ACTIVE                     = RET_ALL_BOUNDS_ACTIVE
-    CONSTRAINT_NOT_ACTIVE                 = RET_CONSTRAINT_NOT_ACTIVE
-    BOUND_NOT_ACTIVE                      = RET_BOUND_NOT_ACTIVE
-    HESSIAN_NOT_SPD                       = RET_HESSIAN_NOT_SPD
-    HESSIAN_INDEFINITE                    = RET_HESSIAN_INDEFINITE
-    MATRIX_SHIFT_FAILED                   = RET_MATRIX_SHIFT_FAILED
-    MATRIX_FACTORISATION_FAILED           = RET_MATRIX_FACTORISATION_FAILED
-    PRINT_ITERATION_FAILED                = RET_PRINT_ITERATION_FAILED
-    NO_GLOBAL_MESSAGE_OUTPUTFILE          = RET_NO_GLOBAL_MESSAGE_OUTPUTFILE
-    DISABLECONSTRAINTS_FAILED             = RET_DISABLECONSTRAINTS_FAILED
-    ENABLECONSTRAINTS_FAILED              = RET_ENABLECONSTRAINTS_FAILED
-    ALREADY_ENABLED                       = RET_ALREADY_ENABLED
-    ALREADY_DISABLED                      = RET_ALREADY_DISABLED
-    NO_HESSIAN_SPECIFIED                  = RET_NO_HESSIAN_SPECIFIED
-    USING_REGULARISATION                  = RET_USING_REGULARISATION
-    EPS_MUST_BE_POSITVE                   = RET_EPS_MUST_BE_POSITVE
-    REGSTEPS_MUST_BE_POSITVE              = RET_REGSTEPS_MUST_BE_POSITVE
-    HESSIAN_ALREADY_REGULARISED           = RET_HESSIAN_ALREADY_REGULARISED
-    CANNOT_REGULARISE_IDENTITY            = RET_CANNOT_REGULARISE_IDENTITY
-    CANNOT_REGULARISE_SPARSE              = RET_CANNOT_REGULARISE_SPARSE
-    NO_REGSTEP_NWSR                       = RET_NO_REGSTEP_NWSR
-    FEWER_REGSTEPS_NWSR                   = RET_FEWER_REGSTEPS_NWSR
-    CHOLESKY_OF_ZERO_HESSIAN              = RET_CHOLESKY_OF_ZERO_HESSIAN
-    ZERO_HESSIAN_ASSUMED                  = RET_ZERO_HESSIAN_ASSUMED
-    CONSTRAINTS_ARE_NOT_SCALED            = RET_CONSTRAINTS_ARE_NOT_SCALED
-    INITIAL_BOUNDS_STATUS_NYI             = RET_INITIAL_BOUNDS_STATUS_NYI
-    ERROR_IN_CONSTRAINTPRODUCT            = RET_ERROR_IN_CONSTRAINTPRODUCT
-    FIX_BOUNDS_FOR_LP                     = RET_FIX_BOUNDS_FOR_LP
-    USE_REGULARISATION_FOR_LP             = RET_USE_REGULARISATION_FOR_LP
-    UPDATEMATRICES_FAILED                 = RET_UPDATEMATRICES_FAILED
-    UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED= RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED
-    UNABLE_TO_OPEN_FILE                   = RET_UNABLE_TO_OPEN_FILE
-    UNABLE_TO_WRITE_FILE                  = RET_UNABLE_TO_WRITE_FILE
-    UNABLE_TO_READ_FILE                   = RET_UNABLE_TO_READ_FILE
-    FILEDATA_INCONSISTENT                 = RET_FILEDATA_INCONSISTENT
-    UNABLE_TO_ANALYSE_QPROBLEM            = RET_UNABLE_TO_ANALYSE_QPROBLEM
-    OPTIONS_ADJUSTED                      = RET_OPTIONS_ADJUSTED
-    NWSR_SET_TO_ONE                       = RET_NWSR_SET_TO_ONE
-    UNABLE_TO_READ_BENCHMARK              = RET_UNABLE_TO_READ_BENCHMARK
-    BENCHMARK_ABORTED                     = RET_BENCHMARK_ABORTED
-    INITIAL_QP_SOLVED                     = RET_INITIAL_QP_SOLVED
-    QP_SOLUTION_STARTED                   = RET_QP_SOLUTION_STARTED
-    BENCHMARK_SUCCESSFUL                  = RET_BENCHMARK_SUCCESSFUL
-    NO_DIAGONAL_AVAILABLE                 = RET_NO_DIAGONAL_AVAILABLE
-    DIAGONAL_NOT_INITIALISED              = RET_DIAGONAL_NOT_INITIALISED
-    ENSURELI_DROPPED                      = RET_ENSURELI_DROPPED
-    KKT_MATRIX_SINGULAR                   = RET_KKT_MATRIX_SINGULAR
-    QR_FACTORISATION_FAILED               = RET_QR_FACTORISATION_FAILED
-    INERTIA_CORRECTION_FAILED             = RET_INERTIA_CORRECTION_FAILED
-    NO_SPARSE_SOLVER                      = RET_NO_SPARSE_SOLVER
-    SIMPLE_STATUS_P1                      = RET_SIMPLE_STATUS_P1
-    SIMPLE_STATUS_P0                      = RET_SIMPLE_STATUS_P0
-    SIMPLE_STATUS_M1                      = RET_SIMPLE_STATUS_M1
-    SIMPLE_STATUS_M2                      = RET_SIMPLE_STATUS_M2
-    SIMPLE_STATUS_M3                      = RET_SIMPLE_STATUS_M3
-
-
-
-cdef class PyOptions:
-    cdef Options *thisptr      # hold a C++ instance which we're wrapping
-    def __cinit__(self):
-        # FIXME: add support for the other constructors
-        self.thisptr = new Options()
-
-    def __dealloc__(self):
-        del self.thisptr
-
-    def setToDefault(self):
-        return self.thisptr.setToDefault()
-
-    def setToReliable(self):
-        return self.thisptr.setToReliable()
-
-    def setToMPC(self):
-        return self.thisptr.setToMPC()
-
-    def setToFast(self):
-        return self.thisptr.setToFast()
-
-    def ensureConsistency(self):
-        return self.thisptr.ensureConsistency()
-
-    property printLevel:
-        def __get__(self): return self.thisptr.printLevel
-        def __set__(self, printLevel): self.thisptr.printLevel = printLevel
-
-    property enableRamping:
-        def __get__(self): return self.thisptr.enableRamping
-        def __set__(self, enableRamping): self.thisptr.enableRamping = enableRamping
-
-    property enableFarBounds:
-        def __get__(self): return self.thisptr.enableFarBounds
-        def __set__(self, enableFarBounds): self.thisptr.enableFarBounds = enableFarBounds
-
-    property enableFlippingBounds:
-        def __get__(self): return self.thisptr.enableFlippingBounds
-        def __set__(self, enableFlippingBounds): self.thisptr.enableFlippingBounds = enableFlippingBounds
-
-    property enableRegularisation:
-        def __get__(self): return self.thisptr.enableRegularisation
-        def __set__(self, enableRegularisation): self.thisptr.enableRegularisation = enableRegularisation
-
-    property enableFullLITests:
-        def __get__(self): return self.thisptr.enableFullLITests
-        def __set__(self, enableFullLITests): self.thisptr.enableFullLITests = enableFullLITests
-
-    property enableNZCTests:
-        def __get__(self): return self.thisptr.enableNZCTests
-        def __set__(self, enableNZCTests): self.thisptr.enableNZCTests = enableNZCTests
-
-    property enableDriftCorrection:
-        def __get__(self): return self.thisptr.enableDriftCorrection
-        def __set__(self, enableDriftCorrection): self.thisptr.enableDriftCorrection = enableDriftCorrection
-
-    property enableCholeskyRefactorisation:
-        def __get__(self): return self.thisptr.enableCholeskyRefactorisation
-        def __set__(self, enableCholeskyRefactorisation): self.thisptr.enableCholeskyRefactorisation = enableCholeskyRefactorisation
-
-    property enableEqualities:
-        def __get__(self): return self.thisptr.enableEqualities
-        def __set__(self, enableEqualities): self.thisptr.enableEqualities = enableEqualities
-
-    property terminationTolerance:
-        def __get__(self): return self.thisptr.terminationTolerance
-        def __set__(self, terminationTolerance): self.thisptr.terminationTolerance = terminationTolerance
-
-    property boundTolerance:
-        def __get__(self): return self.thisptr.boundTolerance
-        def __set__(self, boundTolerance): self.thisptr.boundTolerance = boundTolerance
-
-    property boundRelaxation:
-        def __get__(self): return self.thisptr.boundRelaxation
-        def __set__(self, boundRelaxation): self.thisptr.boundRelaxation = boundRelaxation
-
-    property epsNum:
-        def __get__(self): return self.thisptr.epsNum
-        def __set__(self, epsNum): self.thisptr.epsNum = epsNum
-
-    property epsDen:
-        def __get__(self): return self.thisptr.epsDen
-        def __set__(self, epsDen): self.thisptr.epsDen = epsDen
-
-    property maxPrimalJump:
-        def __get__(self): return self.thisptr.maxPrimalJump
-        def __set__(self, maxPrimalJump): self.thisptr.maxPrimalJump = maxPrimalJump
-
-    property maxDualJump:
-        def __get__(self): return self.thisptr.maxDualJump
-        def __set__(self, maxDualJump): self.thisptr.maxDualJump = maxDualJump
-
-    property initialRamping:
-        def __get__(self): return self.thisptr.initialRamping
-        def __set__(self, initialRamping): self.thisptr.initialRamping = initialRamping
-
-    property finalRamping:
-        def __get__(self): return self.thisptr.finalRamping
-        def __set__(self, finalRamping): self.thisptr.finalRamping = finalRamping
-
-    property initialFarBounds:
-        def __get__(self): return self.thisptr.initialFarBounds
-        def __set__(self, initialFarBounds): self.thisptr.initialFarBounds = initialFarBounds
-
-    property growFarBounds:
-        def __get__(self): return self.thisptr.growFarBounds
-        def __set__(self, growFarBounds): self.thisptr.growFarBounds = growFarBounds
-
-    property initialStatusBounds:
-        def __get__(self): return self.thisptr.initialStatusBounds
-        def __set__(self, initialStatusBounds): self.thisptr.initialStatusBounds = initialStatusBounds
-
-    property epsFlipping:
-        def __get__(self): return self.thisptr.epsFlipping
-        def __set__(self, epsFlipping): self.thisptr.epsFlipping = epsFlipping
-
-    property numRegularisationSteps:
-        def __get__(self): return self.thisptr.numRegularisationSteps
-        def __set__(self, numRegularisationSteps): self.thisptr.numRegularisationSteps = numRegularisationSteps
-
-    property epsRegularisation:
-        def __get__(self): return self.thisptr.epsRegularisation
-        def __set__(self, epsRegularisation): self.thisptr.epsRegularisation = epsRegularisation
-
-    property numRefinementSteps:
-        def __get__(self): return self.thisptr.numRefinementSteps
-        def __set__(self, numRefinementSteps): self.thisptr.numRefinementSteps = numRefinementSteps
-
-    property epsIterRef:
-        def __get__(self): return self.thisptr.epsIterRef
-        def __set__(self, epsIterRef): self.thisptr.epsIterRef = epsIterRef
-
-    property epsLITests:
-        def __get__(self): return self.thisptr.epsLITests
-        def __set__(self, epsLITests): self.thisptr.epsLITests = epsLITests
-
-    property epsNZCTests:
-        def __get__(self): return self.thisptr.epsNZCTests
-        def __set__(self, epsNZCTests): self.thisptr.epsNZCTests = epsNZCTests
-
-    property dropBoundPriority:
-        def __get__(self): return self.thisptr.dropBoundPriority
-        def __set__(self, dropBoundPriority): self.thisptr.dropBoundPriority = dropBoundPriority
-
-    property dropEqConPriority:
-        def __get__(self): return self.thisptr.dropEqConPriority
-        def __set__(self, dropEqConPriority): self.thisptr.dropEqConPriority = dropEqConPriority
-
-    property dropIneqConPriority:
-        def __get__(self): return self.thisptr.dropIneqConPriority
-        def __set__(self, dropIneqConPriority): self.thisptr.dropIneqConPriority = dropIneqConPriority
-
-
-
-cdef class PyQProblemB:
-    cdef QProblemB *thisptr      # hold a C++ instance which we're wrapping
-    def __cinit__(self, int nV):
-        # FIXME: allow other HessianTypes!
-        self.thisptr = new QProblemB(nV, HST_UNKNOWN)
-    def __dealloc__(self):
-        del self.thisptr
-
-    def init(self,
-             np.ndarray[np.double_t, ndim=2] H,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             nWSR,
-             cputime = 0.0
-        ):
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = nWSR
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime
-
-            return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <int&>    nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
-                    )
-
-        return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <int&> nWSR_tmp.data[0]
-                    )
-
-    def hotstart(self,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             nWSR,
-             cputime = 0.0
-        ):
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = nWSR#np.asarray(nWSR, dtype=int)
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime#np.asarray(cputime, dtype=float)
-
-            return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <int&>    nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
-                )
-
-        return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <int&>    nWSR_tmp.data[0]
-            )
-
-    def getPrimalSolution(self, np.ndarray[np.double_t, ndim=1] xOpt):
-        return self.thisptr.getPrimalSolution(<double*> xOpt.data)
-
-    def getDualSolution(self, np.ndarray[np.double_t, ndim=1] yOpt):
-        return self.thisptr.getDualSolution(<double*> yOpt.data)
-
-    def getObjVal(self):
-        return self.thisptr.getObjVal()
-
-    def printOptions(self):
-        return self.thisptr.printOptions()
-
-    def getOptions(self):
-        # FIXME: memory management? who deallocates o
-        cdef Options *o = new Options(self.thisptr.getOptions())
-        retval = PyOptions()
-        retval.thisptr = o
-        return retval
-
-    def setOptions(self, PyOptions options):
-        self.thisptr.setOptions(deref(options.thisptr))
-
-
-cdef class PyQProblem:
-    cdef QProblem *thisptr      # hold a C++ instance which we're wrapping
-    def __cinit__(self, int nV, int nC):
-        self.thisptr = new QProblem(nV, nC, HST_UNKNOWN)
-    def __dealloc__(self):
-        del self.thisptr
-
-    cpdef init(self,
-             np.ndarray[np.double_t, ndim=2] H,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=2] A,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             np.ndarray[np.double_t, ndim=1] lbA,
-             np.ndarray[np.double_t, ndim=1] ubA,
-             nWSR,
-             cputime=0.0):
-
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = nWSR
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime
-
-            return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
-                )
-
-        return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0]
-                )
-
-    cpdef hotstart(self,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             np.ndarray[np.double_t, ndim=1] lbA,
-             np.ndarray[np.double_t, ndim=1] ubA,
-             nWSR,
-             cputime=0.0
-        ):
-
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = nWSR
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime
-
-            return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
-                )
-
-        return self.thisptr.hotstart(
-                    <double*> g.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0]
-                )
-
-    cpdef getPrimalSolution(self, np.ndarray[np.double_t, ndim=1] xOpt):
-        return self.thisptr.getPrimalSolution(<double*> xOpt.data)
-
-    cpdef getDualSolution(self, np.ndarray[np.double_t, ndim=1] yOpt):
-        return self.thisptr.getDualSolution(<double*> yOpt.data)
-
-    cpdef getObjVal(self):
-        return self.thisptr.getObjVal()
-
-    cpdef printOptions(self):
-        return self.thisptr.printOptions()
-
-    cpdef setOptions(self, PyOptions options):
-        self.thisptr.setOptions(deref(options.thisptr))
-
-cdef class PySQProblem:
-    cdef SQProblem *thisptr      # hold a C++ instance which we're wrapping
-    def __cinit__(self, int nV, int nC):
-        self.thisptr = new SQProblem(nV, nC, HST_UNKNOWN)
-    def __dealloc__(self):
-        del self.thisptr
-
-    cpdef init(self,
-             np.ndarray[np.double_t, ndim=2] H,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=2] A,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             np.ndarray[np.double_t, ndim=1] lbA,
-             np.ndarray[np.double_t, ndim=1] ubA,
-             nWSR,
-             cputime=0.0):
-
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = np.asarray(nWSR, dtype=int)
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime
-
-            return self.thisptr.init(
-                        <double*> H.data,
-                        <double*> g.data,
-                        <double*> A.data,
-                        <double*> lb.data,
-                        <double*> ub.data,
-                        <double*> lbA.data,
-                        <double*> ubA.data,
-                        <int&>    nWSR_tmp.data[0],
-                        <double*> &cput_tmp.data[0]
-                )
-
-        return self.thisptr.init(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0],
-        )
-
-    cpdef hotstart(self,
-             np.ndarray[np.double_t, ndim=2] H,
-             np.ndarray[np.double_t, ndim=1] g,
-             np.ndarray[np.double_t, ndim=2] A,
-             np.ndarray[np.double_t, ndim=1] lb,
-             np.ndarray[np.double_t, ndim=1] ub,
-             np.ndarray[np.double_t, ndim=1] lbA,
-             np.ndarray[np.double_t, ndim=1] ubA,
-             nWSR,
-             cputime=0.0):
-
-        # FIXME: add asserts
-        cdef np.ndarray nWSR_tmp
-        cdef np.ndarray cput_tmp
-
-        # enable nWSR as return value in argument list
-        if isinstance(nWSR, int):
-            deprecation_warning_nWSR()
-            nWSR_tmp = np.array([nWSR], dtype=int)
-        else:
-            nWSR_tmp = nWSR
-
-        if cputime > 1.e-16:
-            # enable cputime as return value in argument list
-            if isinstance(cputime, float):
-                deprecation_warning_cputime()
-                cput_tmp = np.array([cputime], dtype=float)
-            else:
-                cput_tmp = cputime
-
-            return self.thisptr.hotstart(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0],
-                    <double*> &cput_tmp.data[0]
-            )
-
-        return self.thisptr.hotstart(
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <int&>    nWSR_tmp.data[0],
-        )
-
-    cpdef getPrimalSolution(self, np.ndarray[np.double_t, ndim=1] xOpt):
-        return self.thisptr.getPrimalSolution(<double*> xOpt.data)
-
-    cpdef getDualSolution(self, np.ndarray[np.double_t, ndim=1] yOpt):
-        return self.thisptr.getDualSolution(<double*> yOpt.data)
-
-    cpdef getObjVal(self):
-        return self.thisptr.getObjVal()
-
-    cpdef printOptions(self):
-        return self.thisptr.printOptions()
-
-    cpdef setOptions(self, PyOptions options):
-        self.thisptr.setOptions(deref(options.thisptr))
-
-
-cdef class PySolutionAnalysis:
-    cdef SolutionAnalysis *thisptr      # hold a C++ instance which we're wrapping
-    def __cinit__(self):
-        self.thisptr = new SolutionAnalysis()
-    def __dealloc__(self):
-        del self.thisptr
-
-    cpdef getKktViolation(self, qp,
-        np.ndarray[np.double_t, ndim=1] maxStat,
-        np.ndarray[np.double_t, ndim=1] maxFeas,
-        np.ndarray[np.double_t, ndim=1] maxCmpl
-    ):
-        """ """
-        if isinstance(qp, PyQProblemB):
-            return self._getKktViolation_QProblemB(qp, maxStat, maxFeas, maxCmpl)
-
-        elif isinstance(qp, PyQProblem):
-            return self._getKktViolation_QProblem(qp, maxStat, maxFeas, maxCmpl)
-
-        elif isinstance(qp, PySQProblem):
-            return self._getKktViolation_SQProblem(qp, maxStat, maxFeas, maxCmpl)
-
-        else:
-            raise ValueError('argument 1 must be QProblemB, QProblem or SQProblem')
-
-    cpdef _getKktViolation_QProblemB(self,
-            PyQProblemB qp,
-            np.ndarray[np.double_t, ndim=1] maxStat,
-            np.ndarray[np.double_t, ndim=1] maxFeas,
-            np.ndarray[np.double_t, ndim=1] maxCmpl
-        ):
-        return self.thisptr.getKktViolation(
-                qp.thisptr,
-                <real_t*> maxStat.data[0],
-                <real_t*> maxFeas.data[0],
-                <real_t*> maxCmpl.data[0]
-            )
-
-    cpdef _getKktViolation_QProblem(self,
-            PyQProblem qp,
-            np.ndarray[np.double_t, ndim=1] maxStat,
-            np.ndarray[np.double_t, ndim=1] maxFeas,
-            np.ndarray[np.double_t, ndim=1] maxCmpl
-        ):
-        return self.thisptr.getKktViolation(
-                qp.thisptr,
-                <real_t*> maxStat.data[0],
-                <real_t*> maxFeas.data[0],
-                <real_t*> maxCmpl.data[0]
-            )
-
-
-    cpdef _getKktViolation_SQProblem(self,
-            PySQProblem qp,
-            np.ndarray[np.double_t, ndim=1] maxStat,
-            np.ndarray[np.double_t, ndim=1] maxFeas,
-            np.ndarray[np.double_t, ndim=1] maxCmpl
-        ):
-        return self.thisptr.getKktViolation(
-                qp.thisptr,
-                <real_t*> maxStat.data[0],
-                <real_t*> maxFeas.data[0],
-                <real_t*> maxCmpl.data[0]
-            )
-
-    cpdef getVarianceCovariance(self,
-                              qp,
-                              np.ndarray[np.double_t, ndim=1] g_b_bA_VAR,
-                              np.ndarray[np.double_t, ndim=1] Primal_Dual_VAR ):
-
-        if isinstance(qp, PyQProblemB):
-            return self._getVarianceCovariance_QProblemB(qp, g_b_bA_VAR, Primal_Dual_VAR)
-
-        elif isinstance(qp, PyQProblem):
-            return self._getVarianceCovariance_QProblem(qp, g_b_bA_VAR, Primal_Dual_VAR)
-
-        elif isinstance(qp, PySQProblem):
-            return self._getVarianceCovariance_SQProblem(qp, g_b_bA_VAR, Primal_Dual_VAR)
-
-        else:
-            raise ValueError('argument 1 must be QProblemB, QProblem or SQProblem')
-
-    cpdef _getVarianceCovariance_QProblemB(self,
-                              PyQProblemB qp,
-                              np.ndarray[np.double_t, ndim=1] g_b_bA_VAR,
-                              np.ndarray[np.double_t, ndim=1] Primal_Dual_VAR ):
-        return self.thisptr.getVarianceCovariance(qp.thisptr,
-                                                  <double*> g_b_bA_VAR.data,
-                                                  <double*> Primal_Dual_VAR.data)
-
-    cpdef _getVarianceCovariance_QProblem(self,
-                              PyQProblem qp,
-                              np.ndarray[np.double_t, ndim=1] g_b_bA_VAR,
-                              np.ndarray[np.double_t, ndim=1] Primal_Dual_VAR ):
-        return self.thisptr.getVarianceCovariance(qp.thisptr,
-                                                  <double*> g_b_bA_VAR.data,
-                                                  <double*> Primal_Dual_VAR.data)
-
-    cpdef _getVarianceCovariance_SQProblem(self,
-                              PySQProblem qp,
-                              np.ndarray[np.double_t, ndim=1] g_b_bA_VAR,
-                              np.ndarray[np.double_t, ndim=1] Primal_Dual_VAR ):
-        return self.thisptr.getVarianceCovariance(qp.thisptr,
-                                                  <double*> g_b_bA_VAR.data,
-                                                  <double*> Primal_Dual_VAR.data)
-
-# Wrapped some utility functions for unit testing
-cpdef py_runOqpBenchmark(path,               # Full path of the benchmark files (without trailing slash!).
-                         isSparse,           # Shall convert matrices to sparse format before solution?
-                         useHotstarts,       # Shall QP solution be hotstarted?
-                         PyOptions options,  # QP solver options to be used while solving benchmark problems.
-                         int maxAllowedNWSR, # Maximum number of working set recalculations to be performed.
-                         double maxCPUTime,  # Maximum allowed CPU time for qp solving.
-                         ):
-    """run a QP benchmark example"""
-    maxNWSR            = 0.0 # Output: Maximum number of performed working set recalculations.
-    avgNWSR            = 0.0 # Output: Average number of performed working set recalculations.
-    maxCPUtime         = 0.0 # Output: Maximum CPU time required for solving each QP.
-    avgCPUtime         = 0.0 # Output: Average CPU time required for solving each QP.
-    maxStationarity    = 0.0 # Output: Maximum residual of stationarity condition.
-    maxFeasibility     = 0.0 # Output: Maximum residual of primal feasibility condition.
-    maxComplementarity = 0.0 # Output: Maximum residual of complementarity condition.
-
-    maxCPUtime = maxCPUTime
-
-    p = path.encode()
-    returnValue = runOqpBenchmark(p,
-                                  isSparse,
-                                  useHotstarts,
-                                  deref(options.thisptr),
-                                  maxAllowedNWSR,
-                                  maxNWSR,
-                                  avgNWSR,
-                                  maxCPUtime,
-                                  avgCPUtime,
-                                  maxStationarity,
-                                  maxFeasibility,
-                                  maxComplementarity)
-
-    return returnValue, maxNWSR, avgNWSR, maxCPUtime, avgCPUtime, \
-           maxStationarity, maxFeasibility, maxComplementarity
-
-"""
-def py_getKktViolation(int nV,                              # Number of variables.
-                       int nC,                              # Number of constraints.
-                       np.ndarray[np.double_t, ndim=2] H,   # Hessian matrix.
-                       np.ndarray[np.double_t, ndim=1] g,   # Sequence of gradient vectors.
-                       np.ndarray[np.double_t, ndim=2] A,   # Constraint matrix.
-                       np.ndarray[np.double_t, ndim=1] lb,  # Sequence of lower bound vectors (on variables).
-                       np.ndarray[np.double_t, ndim=1] ub,  # Sequence of upper bound vectors (on variables).
-                       np.ndarray[np.double_t, ndim=1] lbA, # Sequence of lower constraints' bound vectors.
-                       np.ndarray[np.double_t, ndim=1] ubA, # Sequence of upper constraints' bound vectors.
-                       np.ndarray[np.double_t, ndim=1] x,   # Sequence of primal trial vectors.
-                       np.ndarray[np.double_t, ndim=1] y,   # Sequence of dual trial vectors.
-                       ):
-    stat = 0.0 # Maximum value of stationarity condition residual.
-    feas = 0.0 # Maximum value of primal feasibility violation.
-    cmpl = 0.0 # Maximum value of complementarity residual.
-    getKktViolation(nV,
-                    nC,
-                    <double*> H.data,
-                    <double*> g.data,
-                    <double*> A.data,
-                    <double*> lb.data,
-                    <double*> ub.data,
-                    <double*> lbA.data,
-                    <double*> ubA.data,
-                    <double*> x.data,
-                    <double*> y.data,
-                    stat,
-                    feas,
-                    cmpl
-                    )
-    return stat, feas, cmpl
-    """
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/setup.py b/extlibs/qpOASES-3.2.0/interfaces/python/setup.py
deleted file mode 100755
index a5ef489..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/setup.py
+++ /dev/null
@@ -1,71 +0,0 @@
-#!/usr/bin/env python
-"""qpOASES python distutils setup script."""
-
-#
-#  This file is part of qpOASES.
-#
-#  qpOASES -- An Implementation of the Online Active Set Strategy.
-#  Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-#  Christian Kirches et al. All rights reserved.
-#
-#  qpOASES is free software; you can redistribute it and/or
-#  modify it under the terms of the GNU Lesser General Public
-#  License as published by the Free Software Foundation; either
-#  version 2.1 of the License, or (at your option) any later version.
-#
-#  qpOASES is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-#  See the GNU Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public
-#  License along with qpOASES; if not, write to the Free Software
-#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
-#
-
-#
-#   Filename:  setup.py
-#   Author:    Sebastian F. Walter, Manuel Kudruss
-#   Version:   3.2
-#   Date:      2013-2015
-#
-
-import os
-import numpy as np
-
-from distutils.core import setup
-from distutils.extension import Extension
-from Cython.Distutils import build_ext
-from Cython.Build import cythonize
-
-BASEDIR = os.path.dirname(os.path.abspath(__file__))
-BASEDIR = os.path.dirname(BASEDIR)
-BASEDIR = os.path.dirname(BASEDIR)
-
-extra_params = {}
-extra_params['include_dirs'] = [
-    '/usr/include',
-    os.path.join(BASEDIR, 'include'),
-    os.path.join(BASEDIR, 'include', 'qpOASES'),
-    np.get_include()]
-extra_params['extra_compile_args'] = ["-O2", "-Wno-unused-variable"]
-extra_params['extra_link_args'] = ["-Wl,-O1", "-Wl,--as-needed"]
-
-extra_params = extra_params.copy()
-extra_params['libraries'] = ['qpOASES']
-
-extra_params['library_dirs'] = ['/usr/lib', os.path.join(BASEDIR, 'bin')]
-extra_params['language'] = 'c++'
-
-if os.name == 'posix':
-    extra_params['runtime_library_dirs'] = extra_params['library_dirs']
-
-ext_modules = [
-    Extension("qpoases",  ["qpoases.pyx", "qpoases.pxd"],   **extra_params),
-]
-
-setup(
-    name='qpOASES interface',
-    cmdclass={'build_ext': build_ext},
-    ext_modules=cythonize(ext_modules),
-)
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/tests/__init__.py b/extlibs/qpOASES-3.2.0/interfaces/python/tests/__init__.py
deleted file mode 100644
index 8b13789..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/tests/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/python/tests/test_examples.py b/extlibs/qpOASES-3.2.0/interfaces/python/tests/test_examples.py
deleted file mode 100644
index ba69be6..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/python/tests/test_examples.py
+++ /dev/null
@@ -1,360 +0,0 @@
-"""
-This file is part of qpOASES.
-
-qpOASES -- An Implementation of the Online Active Set Strategy.
-Copyright (C) 2007-2015 by Hans Joachim Ferreau et al. All rights reserved.
-
-qpOASES is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-qpOASES is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-See the GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with qpOASES; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-author Manuel Kudruss
-version 3.2
-date 2013-2015
-"""
-
-import os
-import re
-import numpy as np
-from numpy.testing import *
-from subprocess import Popen, PIPE, STDOUT
-
-from qpoases import PyQProblem as QProblem
-from qpoases import PyQProblemB as QProblemB
-from qpoases import PySQProblem as SQProblem
-from qpoases import PySolutionAnalysis as SolutionAnalysis
-from qpoases import PyBooleanType as BooleanType
-from qpoases import PySubjectToStatus as SubjectToStatus
-from qpoases import PyOptions as Options
-from qpoases import PyPrintLevel as PrintLevel
-
-# get qpOASES path
-qpoases_path = os.path.dirname(os.path.abspath(__file__))
-qpoases_path = os.path.dirname(qpoases_path)
-qpoases_path = os.path.dirname(qpoases_path)
-qpoases_path = os.path.dirname(qpoases_path)
-
-# set qpOASES binary path
-bin_path = os.path.join(qpoases_path, "bin")
-
-class TestExamples(TestCase):
-
-    def test_example1(self):
-        return 0
-        # Example for qpOASES main function using the QProblem class.
-        #Setup data of first QP.
-
-        H   = np.array([1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-        A   = np.array([1.0, 1.0 ]).reshape((2,1))
-        g   = np.array([1.5, 1.0 ])
-        lb  = np.array([0.5, -2.0])
-        ub  = np.array([5.0, 2.0 ])
-        lbA = np.array([-1.0 ])
-        ubA = np.array([2.0])
-
-        # Setup data of second QP.
-
-        g_new   = np.array([1.0, 1.5])
-        lb_new  = np.array([0.0, -1.0])
-        ub_new  = np.array([5.0, -0.5])
-        lbA_new = np.array([-2.0])
-        ubA_new = np.array([1.0])
-
-        # Setting up QProblemB object.
-        qp = QProblem(2, 1)
-        options = Options()
-        options.printLevel = PrintLevel.NONE
-        qp.setOptions(options)
-
-        # Solve first QP.
-        nWSR = 10
-        qp.init(H, g, A, lb, ub, lbA, ubA, nWSR)
-
-        # Solve second QP.
-        nWSR = 10
-        qp.hotstart(g_new, lb_new, ub_new, lbA_new, ubA_new, nWSR)
-
-        # Get and print solution of second QP.
-        xOpt_actual = np.zeros(2)
-        qp.getPrimalSolution(xOpt_actual)
-        xOpt_actual = np.asarray(xOpt_actual, dtype=float)
-        objVal_actual = qp.getObjVal()
-        objVal_actual = np.asarray(objVal_actual, dtype=float)
-
-        cmd = os.path.join(bin_path, "example1")
-        p = Popen(cmd, shell=True, stdout=PIPE)
-        stdout, stderr = p.communicate()
-        stdout = str(stdout).replace('\\n', '\n')
-        stdout = stdout.replace("'", '')
-        print(stdout)
-
-        # get c++ solution from std
-        pattern = re.compile(r'xOpt\s*=\s*\[\s+(?P<xOpt>([0-9., e+-])*)\];')
-        match = pattern.search(stdout)
-        xOpt_expected = match.group('xOpt')
-        xOpt_expected = xOpt_expected.split(",")
-        xOpt_expected = np.asarray(xOpt_expected, dtype=float)
-
-        pattern = re.compile(r'objVal = (?P<objVal>[0-9-+e.]*)')
-        match = pattern.search(stdout)
-        objVal_expected = match.group('objVal')
-        objVal_expected = np.asarray(objVal_expected, dtype=float)
-
-        print("xOpt_actual =", xOpt_actual)
-        print("xOpt_expected =", xOpt_expected)
-        print("objVal_actual = ", objVal_actual)
-        print("objVal_expected = ", objVal_expected)
-
-        assert_almost_equal(xOpt_actual, xOpt_expected, decimal=7)
-        assert_almost_equal(objVal_actual, objVal_expected, decimal=7)
-
-    def test_example1b(self):
-        """Example for qpOASES main function using the QProblemB class."""
-        # Setup data of first QP.
-        H = np.array([1.0, 0.0, 0.0, 0.5]).reshape((2, 2))
-        g = np.array([1.5, 1.0])
-        lb = np.array([0.5, -2.0])
-        ub = np.array([5.0, 2.0])
-
-        # Setup data of second QP.
-
-        g_new = np.array([1.0, 1.5])
-        lb_new = np.array([0.0, -1.0])
-        ub_new = np.array([5.0, -0.5])
-
-        # Setting up QProblemB object.
-        qp = QProblemB(2)
-
-        options = Options()
-        # options.enableFlippingBounds = BooleanType.FALSE
-        options.initialStatusBounds = SubjectToStatus.INACTIVE
-        options.numRefinementSteps = 1
-        options.enableCholeskyRefactorisation = 1
-        options.printLevel = PrintLevel.NONE
-        qp.setOptions(options)
-
-        # Solve first QP.
-        nWSR = 10
-        qp.init(H, g, lb, ub, nWSR)
-
-        xOpt_actual = np.zeros(2)
-        qp.getPrimalSolution(xOpt_actual)
-        xOpt_actual = np.asarray(xOpt_actual, dtype=float)
-        objVal_actual = qp.getObjVal()
-        objVal_actual = np.asarray(objVal_actual, dtype=float)
-        print 'xOpt_actual:', xOpt_actual
-        print 'objVal_actual:', objVal_actual
-
-        # Solve second QP.
-        nWSR = 10
-        qp.hotstart(g_new, lb_new, ub_new, nWSR)
-
-        xOpt_actual = np.zeros(2)
-        qp.getPrimalSolution(xOpt_actual)
-        xOpt_actual = np.asarray(xOpt_actual, dtype=float)
-        objVal_actual = qp.getObjVal()
-        objVal_actual = np.asarray(objVal_actual, dtype=float)
-        print 'xOpt_actual:', xOpt_actual
-        print 'objVal_actual:', objVal_actual
-
-        # Get and print solution of second QP.
-        xOpt_actual = np.zeros(2)
-        qp.getPrimalSolution(xOpt_actual)
-        xOpt_actual = np.asarray(xOpt_actual, dtype=float)
-        objVal_actual = qp.getObjVal()
-        objVal_actual = np.asarray(objVal_actual, dtype=float)
-
-        cmd = os.path.join(bin_path, "example1b")
-        p = Popen(cmd, shell=True, stdout=PIPE)
-        stdout, stderr = p.communicate()
-        stdout = str(stdout).replace('\\n', '\n')
-        stdout = stdout.replace("'", '')
-
-        # get c++ solution from std
-        pattern = re.compile(r'xOpt\s*=\s*\[\s+(?P<xOpt>([0-9., e+-])*)\];')
-        match = pattern.findall(stdout)
-        xOpt_expected = match[-1][0]
-        xOpt_expected = xOpt_expected.split(",")
-        xOpt_expected = np.asarray(xOpt_expected, dtype=float)
-
-        pattern = re.compile(r'objVal = (?P<objVal>[0-9-+e.]*)')
-        match = pattern.findall(stdout)
-        print match
-        objVal_expected = match[-1]
-        objVal_expected = np.asarray(objVal_expected, dtype=float)
-
-        print("xOpt_actual =", xOpt_actual)
-        print("xOpt_expected =", xOpt_expected)
-        print("objVal_actual = ", objVal_actual)
-        print("objVal_expected = ", objVal_expected)
-
-        assert_almost_equal(xOpt_actual, xOpt_expected, decimal=7)
-        assert_almost_equal(objVal_actual, objVal_expected, decimal=7)
-
-
-    def test_example2(self):
-        # Example for qpOASES main function using the SQProblem class.
-        #  Setup data of first QP.
-        H = np.array([ 1.0, 0.0, 0.0, 0.5 ]).reshape((2,2))
-        A = np.array([ 1.0, 1.0 ]).reshape((2,1))
-        g = np.array([ 1.5, 1.0 ])
-        lb = np.array([ 0.5, -2.0 ])
-        ub = np.array([ 5.0, 2.0 ])
-        lbA = np.array([ -1.0 ])
-        ubA = np.array([ 2.0 ])
-
-        #  Setup data of second QP.
-        H_new = np.array([ 1.0, 0.5, 0.5, 0.5 ]).reshape((2,2))
-        A_new = np.array([ 1.0, 5.0 ]).reshape((2,1))
-        g_new = np.array([ 1.0, 1.5 ])
-        lb_new = np.array([ 0.0, -1.0 ])
-        ub_new = np.array([ 5.0, -0.5 ])
-        lbA_new = np.array([ -2.0 ])
-        ubA_new = np.array([ 1.0 ])
-
-        #  Setting up SQProblem object and solution analyser.
-        qp = SQProblem(2, 1)
-        options = Options()
-        options.printLevel = PrintLevel.NONE
-        qp.setOptions(options)
-
-        analyser = SolutionAnalysis()
-
-        # get c++ solution from std
-        cmd = os.path.join(bin_path, "example2")
-        p = Popen(cmd, shell=True, stdout=PIPE)
-        stdout, stderr = p.communicate()
-        stdout = str(stdout).replace('\\n', '\n')
-        stdout = stdout.replace("'", '')
-        print(stdout)
-
-        #  Solve first QP ...
-        nWSR = 10
-        qp.init(H, g, A, lb, ub, lbA, ubA, nWSR)
-
-        #  ... and analyse it.
-        maxViol = np.zeros(1)
-        maxStat = np.zeros(1)
-        maxFeas = np.zeros(1)
-        maxCmpl = np.zeros(1)
-        maxViol[0] = analyser.getKktViolation(
-            qp, maxStat, maxFeas, maxCmpl
-        )
-        print("maxViol: %e\n" % maxViol)
-        actual = np.asarray(maxViol)
-
-        pattern = re.compile(
-            r'maxKktViolation: (?P<KktViolation>[0-9+-e.]*)'
-        )
-
-        match = pattern.findall(stdout)
-        expected = np.asarray(match[0], dtype=float)
-
-        assert_almost_equal(actual, expected, decimal=7)
-
-        #  Solve second QP ...
-        nWSR = 10
-        qp.hotstart(
-            H_new, g_new, A_new,
-            lb_new, ub_new,
-            lbA_new, ubA_new,
-            nWSR
-        )
-
-        #  ... and analyse it.
-        maxViol = np.zeros(1)
-        maxStat = np.zeros(1)
-        maxFeas = np.zeros(1)
-        maxCmpl = np.zeros(1)
-        maxViol[0] = analyser.getKktViolation(
-            qp, maxStat, maxFeas, maxCmpl
-        )
-        print("maxViol: %e\n" % maxViol)
-        actual = np.asarray(maxViol)
-
-        expected = np.asarray(match[1], dtype=float)
-
-        assert_almost_equal(actual, expected, decimal=7)
-
-        # ------------ VARIANCE-COVARIANCE EVALUATION --------------------
-
-        Var = np.zeros(5*5)
-        Primal_Dual_Var = np.zeros(5*5)
-
-        Var.reshape((5, 5))[0, 0] = 1.
-        Var.reshape((5, 5))[1, 1] = 1.
-
-        #                  (  1   0   0   0   0   )
-        #                  (  0   1   0   0   0   )
-        #     Var     =    (  0   0   0   0   0   )
-        #                  (  0   0   0   0   0   )
-        #                  (  0   0   0   0   0   )
-
-        analyser.getVarianceCovariance(qp, Var, Primal_Dual_Var)
-        print('Primal_Dual_Var=\n', Primal_Dual_Var.reshape((5, 5)))
-        actual = Primal_Dual_Var.reshape((5, 5))
-
-        pattern = re.compile(
-            r'Primal_Dual_VAR = (?P<VAR>.*)',
-            re.DOTALL
-        )
-
-        print(stdout)
-        match = pattern.search(stdout)
-        expected = match.group('VAR').strip().split("\n")
-        expected = [x.strip().split() for x in expected]
-        print(expected)
-        expected = np.asarray(expected, dtype=float)
-
-        assert_almost_equal(actual, expected, decimal=7)
-
-    def test_example7(self):
-        H   = np.array([
-            0.8514828085899353, -0.15739890933036804, -0.081726007163524628, -0.530426025390625, 0.16773293912410736,
-           -0.15739890933036804, 1.1552412509918213, 0.57780224084854126, -0.0072606131434440613, 0.010559185408055782,
-           -0.081726007163524628, 0.57780224084854126, 0.28925251960754395, 5.324830453901086e-006, -3.0256599075073609e-006,
-           -0.530426025390625, -0.0072606131434440613, 5.324830453901086e-006, 0.35609596967697144, -0.15124998986721039,
-            0.16773293912410736, 0.010559185408055782, -3.0256599075073609e-006, -0.15124998986721039, 0.15129712224006653
-            ], dtype=float
-        ).reshape((5, 5))
-        g   = np.array([0.30908384919166565, 0.99325823783874512, 0.49822014570236206, -0.26309865713119507, 0.024296050891280174], dtype=float).reshape((5,))
-        A   = np.array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], dtype=float).reshape((5, 5))
-        lb  = np.array([-0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359938621520996], dtype=float).reshape((5,))
-        ub  = np.array([ 0.052359879016876221, 0.052359879016876221, 0.052359879016876221, 0, 0], dtype=float).reshape((5,))
-        lbA = np.array([-0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359938621520996], dtype=float).reshape((5,))
-        ubA = np.array([0.052359879016876221, 0.052359879016876221, 0.052359879016876221, 0, 0], dtype=float).reshape((5,))
-
-        # Setting up QProblem object.
-        qp = QProblem(5, 5)
-        options = Options()
-        options.printLevel = PrintLevel.NONE
-        qp.setOptions(options)
-
-        # Solve first QP.
-        nWSR = 100
-        qp.init(H, g, A, lb, ub, lbA, ubA,  nWSR)
-
-        result = np.zeros((5,))
-        qp.getPrimalSolution(result)
-
-        # TODO check against what?
-        # Where can I find solution?
-
-if __name__=="__main__":
-    try:
-        import nose
-        nose.runmodule()
-
-    except ImportError:
-        sys.stderr.write("Please install nosestests for python unittesting.\n")
-
diff --git a/extlibs/qpOASES-3.2.0/interfaces/scilab/Makefile b/extlibs/qpOASES-3.2.0/interfaces/scilab/Makefile
deleted file mode 100644
index 4618962..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/scilab/Makefile
+++ /dev/null
@@ -1,93 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  interfaces/scilab/Makefile
-##	Author:    Holger Diedam, Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-
-
-PATH_LIB = .
-PATH_SRC = .
-PATH_OBJ = .
-PATH_QPOASES_INC = ../../include
-PATH_QPOASES_SRC = ../../src
-PATH_QPOASES_OBJ = ../../src
-
-
-##
-##	bins
-##
-
-CC       = gcc
-CPP      = g++
-LD       = g++
-CP       = cp
-
-
-
-##
-##	flags
-##
-
-CFLAGS   = -I$(PATH_QPOASES_INC) -I$(PATH_QPOASES_SRC) -Wall -pedantic -Wshadow -O3 -finline-functions -fPIC
-CPPFLAGS = -I$(PATH_QPOASES_INC) -I$(PATH_QPOASES_SRC) -Wall -pedantic -Wshadow -O3 -finline-functions -fPIC -DLINUX -D__SCILAB__ -D__SINGLE_OBJECT__ 
-LDFLAGS  = -shared
-LIBEXT   = .so
-
-
-LIB = libqpOASESinterface$(LIBEXT)
-
-OBJ = \
-	qpOASESroutines.o \
-	qpOASESinterface.o
-
-
-
-##
-##	targets
-##
-
-all: $(PATH_LIB)/$(LIB)
-
-$(PATH_OBJ)/%.o: $(PATH_SRC)/%.c
-	$(CC) -c -o $(@) $(CFLAGS) $<
-
-$(PATH_OBJ)/%.o: $(PATH_SRC)/%.cpp
-	$(CPP) -c -o $(@) $(CPPFLAGS) $<
-
-$(PATH_LIB)/$(LIB) : $(addprefix $(PATH_OBJ)/, $(OBJ))
-	$(LD) $(LDFLAGS) $^ -o $@
-
-clean:
-	$(RM) $(PATH_OBJ)/*.o $(PATH_LIB)/$(LIB)
-
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.c b/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.c
deleted file mode 100644
index 469041c..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.c
+++ /dev/null
@@ -1,893 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/scilab/qpOASESinterface.c
- *	\author Holger Diedam, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface that enables to call qpOASES from scilab.
- *  (Please excuse a lot of copy and paste...)
- *
- */
-
-
-#include <stdio.h>
-#include <string.h>
-
-#include <scilab/stack-c.h>
-#include <scilab/Scierror.h>
-
-#include "../c/qpOASES_wrapper.h"
-
-
-
-extern int interface_qpOASES( char* fname );
-
-extern int interface_QProblem_init(  char* fname );
-extern int interface_QProblemB_init( char* fname );
-extern int interface_SQProblem_init( char* fname );
-
-extern int interface_QProblem_hotstart(  char* fname );
-extern int interface_QProblemB_hotstart( char* fname );
-extern int interface_SQProblem_hotstart( char* fname );
-
-extern int interface_QProblem_cleanup(  char* fname );
-extern int interface_QProblemB_cleanup( char* fname );
-extern int interface_SQProblem_cleanup( char* fname );
-
-
-typedef int (*gate_function) ( char* );
-extern int sci_gateway( char* name, gate_function f );
-extern int C2F(qpOASESgateway)();
-
-
-/* forward declaration of C++ routines */
-void sci_qpOASES(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-					int_t *nV, int_t* nC, int_t* nWSR,
-					real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-					);
-
-void sci_QProblem_init( real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-						int_t *nV, int_t* nC, int_t* nWSR,
-						real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-						);
-void sci_QProblemB_init(	real_t* H, real_t* g, real_t* lb, real_t* ub,
-							int_t *nV, int_t* nWSR,
-							real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-							);
-void sci_SQProblem_init(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-							int_t *nV, int_t* nC, int_t* nWSR,
-							real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-							);
-
-void sci_QProblem_hotstart(		real_t* g, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-void sci_QProblemB_hotstart(	real_t* g, real_t* lb, real_t* ub,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-void sci_SQProblem_hotstart(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-
-void sci_QProblem_cleanup( );
-void sci_QProblemB_cleanup( );
-void sci_SQProblem_cleanup( );
-
-
-/* global variables containing dimensions of matrices
- * (also used to check whether qpOASES object were initialised) */
-static int_t qp_rowsH = -1;
-static int_t qp_rowsA = -1;
-static int_t qpb_rowsH = -1;
-static int_t sqp_rowsH = -1;
-static int_t sqp_rowsA = -1;
-
-
-/*
- *	i n t e r f a c e _ q p O A S E S
- */
-int interface_qpOASES( char* fname )
-{
-	int_t H, H_rows, H_cols;
-	int_t g, g_rows, g_cols;
-	int_t A, A_rows, A_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t lbA, lbA_rows, lbA_cols;
-	int_t ubA, ubA_rows, ubA_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 8, maxrhs = 8, one = 1, y_size;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &H_rows,&H_cols,&H );
-	if ( ( H_rows != H_cols ) || ( H_rows < 1 ) )
-	{
-		Scierror( 111,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == H_rows ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == H_rows ) ) ) )
-	{
-		Scierror( 112,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &A_rows,&A_cols,&A );
-	if ( ( A_cols != H_rows ) || ( A_rows < 1 ) )
-	{
-		Scierror( 113,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &lb_rows,&lb_cols,&lb);
-	if ( !( ( ( lb_rows == H_rows ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 114,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"d", &ub_rows,&ub_cols,&ub);
-	if ( !( ( ( ub_rows == H_rows ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 115,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 6,"d", &lbA_rows,&lbA_cols,&lbA);
-	if ( !( ( ( lbA_rows == A_rows ) && ( lbA_cols == 1 ) ) || ( ( lbA_rows == 0 ) && ( lbA_cols == 0 ) ) ) )
-	{
-		Scierror( 116,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 7,"d", &ubA_rows,&ubA_cols,&ubA);
-	if ( !( ( ( ubA_rows == A_rows ) && ( ubA_cols == 1 ) ) || ( ( ubA_rows == 0 ) && ( ubA_cols == 0 ) ) ) )
-	{
-		Scierror( 117,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 8,"i", &nWSR_rows,&nWSR_cols,&nWSR);
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 118,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	y_size = H_rows + A_rows;
-
-	CreateVar(  9,"d", &H_rows,&one,&x );
-	CreateVar( 10,"d", &one,&one,&obj );
-	CreateVar( 11,"i", &one,&one,&status );
-	CreateVar( 12,"i", &one,&one,&nWSRout );
-	CreateVar( 13,"d", &y_size,&one,&y );
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_qpOASES(	stk(H),stk(g),stk(A), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0, (lbA_rows!=0) ? stk(lbA) : 0, (ubA_rows!=0) ? stk(ubA) : 0,
-					&H_rows,&A_rows,istk(nWSR),
-					stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-					);
-
-	LhsVar(1) = 9;
-	LhsVar(2) = 10;
-	LhsVar(3) = 11;
-	LhsVar(4) = 12;
-	LhsVar(5) = 13;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m _ i n i t
- */
-int interface_QProblem_init( char* fname )
-{
-	int_t H, H_rows, H_cols;
-	int_t g, g_rows, g_cols;
-	int_t A, A_rows, A_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t lbA, lbA_rows, lbA_cols;
-	int_t ubA, ubA_rows, ubA_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 8, maxrhs = 8, one = 1, y_size;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &H_rows,&H_cols,&H );
-	if ( ( H_rows != H_cols ) || ( H_rows < 1 ) )
-	{
-		Scierror( 211,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == H_rows ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == H_rows ) ) ) )
-	{
-		Scierror( 212,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &A_rows,&A_cols,&A );
-	if ( ( A_cols != H_rows ) || ( A_rows < 1 ) )
-	{
-		Scierror( 213,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &lb_rows,&lb_cols,&lb);
-	if ( !( ( ( lb_rows == H_rows ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 214,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"d", &ub_rows,&ub_cols,&ub);
-	if ( !( ( ( ub_rows == H_rows ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 215,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 6,"d", &lbA_rows,&lbA_cols,&lbA);
-	if ( !( ( ( lbA_rows == A_rows ) && ( lbA_cols == 1 ) ) || ( ( lbA_rows == 0 ) && ( lbA_cols == 0 ) ) ) )
-	{
-		Scierror( 216,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 7,"d", &ubA_rows,&ubA_cols,&ubA);
-	if ( !( ( ( ubA_rows == A_rows ) && ( ubA_cols == 1 ) ) || ( ( ubA_rows == 0 ) && ( ubA_cols == 0 ) ) ) )
-	{
-		Scierror( 217,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 8,"i", &nWSR_rows,&nWSR_cols,&nWSR);
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 218,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	y_size = H_rows + A_rows;
-
-	CreateVar(  9,"d", &H_rows,&one,&x );
-	CreateVar( 10,"d", &one,&one,&obj );
-	CreateVar( 11,"i", &one,&one,&status );
-	CreateVar( 12,"i", &one,&one,&nWSRout );
-	CreateVar( 13,"d", &y_size,&one,&y );
-
-
-	qp_rowsH = H_rows;
-	qp_rowsA = A_rows;
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_QProblem_init(	stk(H),stk(g),stk(A), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0, (lbA_rows!=0) ? stk(lbA) : 0, (ubA_rows!=0) ? stk(ubA) : 0,
-						&H_rows,&A_rows,istk(nWSR),
-						stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-						);
-
-	LhsVar(1) = 9;
-	LhsVar(2) = 10;
-	LhsVar(3) = 11;
-	LhsVar(4) = 12;
-	LhsVar(5) = 13;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m B _ i n i t
- */
-int interface_QProblemB_init( char* fname )
-{
-	int_t H, H_rows, H_cols;
-	int_t g, g_rows, g_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 5, maxrhs = 5, one = 1;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &H_rows,&H_cols,&H );
-	if ( ( H_rows != H_cols ) || ( H_rows < 1 ) )
-	{
-		Scierror( 221,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == H_rows ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == H_rows ) ) ) )
-	{
-		Scierror( 222,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &lb_rows,&lb_cols,&lb);
-	if ( !( ( ( lb_rows == H_rows ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 223,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &ub_rows,&ub_cols,&ub);
-	if ( !( ( ( ub_rows == H_rows ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 224,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"i", &nWSR_rows,&nWSR_cols,&nWSR);
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 225,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	CreateVar(  9,"d", &H_rows,&one,&x );
-	CreateVar( 10,"d", &one,&one,&obj );
-	CreateVar( 11,"i", &one,&one,&status );
-	CreateVar( 12,"i", &one,&one,&nWSRout );
-	CreateVar( 13,"d", &H_rows,&one,&y );
-
-
-	qpb_rowsH = H_rows;
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_QProblemB_init( 	stk(H),stk(g), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0,
-							&H_rows,istk(nWSR),
-							stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-							);
-
-	LhsVar(1) = 9;
-	LhsVar(2) = 10;
-	LhsVar(3) = 11;
-	LhsVar(4) = 12;
-	LhsVar(5) = 13;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ S Q P r o b l e m _ i n i t
- */
-int interface_SQProblem_init( char* fname )
-{
-	int_t H, H_rows, H_cols;
-	int_t g, g_rows, g_cols;
-	int_t A, A_rows, A_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t lbA, lbA_rows, lbA_cols;
-	int_t ubA, ubA_rows, ubA_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 8, maxrhs = 8, one = 1, y_size;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &H_rows,&H_cols,&H );
-	if ( ( H_rows != H_cols ) || ( H_rows < 1 ) )
-	{
-		Scierror( 231,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == H_rows ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == H_rows ) ) ) )
-	{
-		Scierror( 232,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &A_rows,&A_cols,&A );
-	if ( ( A_cols != H_rows ) || ( A_rows < 1 ) )
-	{
-		Scierror( 233,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &lb_rows,&lb_cols,&lb );
-	if ( !( ( ( lb_rows == H_rows ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 234,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"d", &ub_rows,&ub_cols,&ub );
-	if ( !( ( ( ub_rows == H_rows ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 235,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 6,"d", &lbA_rows,&lbA_cols,&lbA );
-	if ( !( ( ( lbA_rows == A_rows ) && ( lbA_cols == 1 ) ) || ( ( lbA_rows == 0 ) && ( lbA_cols == 0 ) ) ) )
-	{
-		Scierror( 236,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 7,"d", &ubA_rows,&ubA_cols,&ubA );
-	if ( !( ( ( ubA_rows == A_rows ) && ( ubA_cols == 1 ) ) || ( ( ubA_rows == 0 ) && ( ubA_cols == 0 ) ) ) )
-	{
-		Scierror( 237,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 8,"i", &nWSR_rows,&nWSR_cols,&nWSR) ;
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 238,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	y_size = H_rows + A_rows;
-
-	CreateVar(  9,"d", &H_rows,&one,&x );
-	CreateVar( 10,"d", &one,&one,&obj );
-	CreateVar( 11,"i", &one,&one,&status );
-	CreateVar( 12,"i", &one,&one,&nWSRout );
-	CreateVar( 13,"d", &y_size,&one,&y );
-
-
-	sqp_rowsH = H_rows;
-	sqp_rowsA = A_rows;
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_SQProblem_init( 	stk(H),stk(g),stk(A), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0, (lbA_rows!=0) ? stk(lbA) : 0, (ubA_rows!=0) ? stk(ubA) : 0,
-							&H_rows,&A_rows,istk(nWSR),
-							stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-							);
-	
-	LhsVar(1) = 9;
-	LhsVar(2) = 10;
-	LhsVar(3) = 11;
-	LhsVar(4) = 12;
-	LhsVar(5) = 13;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m _ h o t s t a r t
- */
-int interface_QProblem_hotstart( char* fname )
-{
-	int_t g, g_rows, g_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t lbA, lbA_rows, lbA_cols;
-	int_t ubA, ubA_rows, ubA_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 6, maxrhs = 6, one = 1, y_size;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	if ( ( qp_rowsH == -1 ) || ( qp_rowsA == -1 ) )
-	{
-		Scierror( 311,"ERROR (qpOASES): Need to call qpOASES_init first!\n" );
-		return 0;
-	}
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == qp_rowsH ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == qp_rowsH ) ) ) )
-	{
-		Scierror( 312,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &lb_rows,&lb_cols,&lb );
-	if ( !( ( ( lb_rows == qp_rowsH ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 313,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &ub_rows,&ub_cols,&ub );
-	if ( !( ( ( ub_rows == qp_rowsH ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 314,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &lbA_rows,&lbA_cols,&lbA );
-	if ( !( ( ( lbA_rows == qp_rowsA ) && ( lbA_cols == 1 ) ) || ( ( lbA_rows == 0 ) && ( lbA_cols == 0 ) ) ) )
-	{
-		Scierror( 315,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"d", &ubA_rows,&ubA_cols,&ubA );
-	if ( !( ( ( ubA_rows == qp_rowsA ) && ( ubA_cols == 1 ) ) || ( ( ubA_rows == 0 ) && ( ubA_cols == 0 ) ) ) )
-	{
-		Scierror( 316,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 6,"i", &nWSR_rows,&nWSR_cols,&nWSR );
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 317,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	y_size = qp_rowsH + qp_rowsA;
-
-	CreateVar(  7,"d", &qp_rowsH,&one,&x );
-	CreateVar(  8,"d", &one,&one,&obj );
-	CreateVar(  9,"i", &one,&one,&status );
-	CreateVar( 10,"i", &one,&one,&nWSRout );
-	CreateVar( 11,"d", &y_size,&one,&y );
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_QProblem_hotstart( 	stk(g), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0, (lbA_rows!=0) ? stk(lbA) : 0, (ubA_rows!=0) ? stk(ubA) : 0,
-							istk(nWSR),
-							stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-							);
-	
-	LhsVar(1) = 7;
-	LhsVar(2) = 8;
-	LhsVar(3) = 9;
-	LhsVar(4) = 10;
-	LhsVar(5) = 11;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m B _ h o t s t a r t
- */
-int interface_QProblemB_hotstart( char* fname )
-{
-	int_t g, g_rows, g_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t x, obj, status, nWSRout, y;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 4, maxrhs = 4, one = 1;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	if ( qpb_rowsH == -1 )
-	{
-		Scierror( 321,"ERROR (qpOASES): Need to call qpOASES_initSB first!\n" );
-		return 0;
-	}
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == qpb_rowsH ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == qpb_rowsH ) ) ) )
-	{
-		Scierror( 322,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &lb_rows,&lb_cols,&lb );
-	if ( !( ( ( lb_rows == qpb_rowsH ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 323,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &ub_rows,&ub_cols,&ub );
-	if ( !( ( ( ub_rows == qpb_rowsH ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 324,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"i", &nWSR_rows,&nWSR_cols,&nWSR );
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 325,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	CreateVar( 5,"d", &qpb_rowsH,&one,&x );
-	CreateVar( 6,"d", &one,&one,&obj );
-	CreateVar( 7,"i", &one,&one,&status );
-	CreateVar( 8,"i", &one,&one,&nWSRout );
-	CreateVar( 9,"d", &qpb_rowsH,&one,&y );
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_QProblemB_hotstart( 	stk(g), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0,
-								istk(nWSR),
-								stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-								);
-
-	LhsVar(1) = 5;
-	LhsVar(2) = 6;
-	LhsVar(3) = 7;
-	LhsVar(4) = 8;
-	LhsVar(5) = 9;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ S Q P r o b l e m _ h o t s t a r t
- */
-int interface_SQProblem_hotstart( char* fname )
-{
-	int_t H, H_rows, H_cols;
-	int_t g, g_rows, g_cols;
-	int_t A, A_rows, A_cols;
-	int_t lb, lb_rows, lb_cols;
-	int_t ub, ub_rows, ub_cols;
-	int_t lbA, lbA_rows, lbA_cols;
-	int_t ubA, ubA_rows, ubA_cols;
-	int_t nWSR, nWSR_rows, nWSR_cols;
-
-	int_t obj, x, y, status, nWSRout;
-
-
-	int minlhs = 1, maxlhs = 5, minrhs = 8, maxrhs = 8, one = 1, y_size;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-
-	if ( ( sqp_rowsH == -1 ) || ( sqp_rowsA == -1 ) )
-	{
-		Scierror( 331,"ERROR (qpOASES): Need to call qpOASES_initVM first!\n" );
-		return 0;
-	}
-
-	/* check dimensions */
-	GetRhsVar( 1,"d", &H_rows,&H_cols,&H );
-	if ( ( H_rows != H_cols ) || ( H_rows < 1 ) )
-	{
-		Scierror( 332,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 2,"d", &g_rows,&g_cols,&g );
-	if ( !( ( ( g_rows == H_rows ) && ( g_cols == 1 ) ) || ( ( g_rows == 1 ) && ( g_cols == H_rows ) ) ) )
-	{
-		Scierror( 333,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 3,"d", &A_rows,&A_cols,&A );
-	if ( ( A_cols != H_rows ) || ( A_rows < 1 ) )
-	{
-		Scierror( 334,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 4,"d", &lb_rows,&lb_cols,&lb);
-	if ( !( ( ( lb_rows == H_rows ) && ( lb_cols == 1 ) ) || ( ( lb_rows == 0 ) && ( lb_cols == 0 ) ) ) )
-	{
-		Scierror( 335,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 5,"d", &ub_rows,&ub_cols,&ub);
-	if ( !( ( ( ub_rows == H_rows ) && ( ub_cols == 1 ) ) || ( ( ub_rows == 0 ) && ( ub_cols == 0 ) ) ) )
-	{
-		Scierror( 399,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 6,"d", &lbA_rows,&lbA_cols,&lbA);
-	if ( !( ( ( lbA_rows == A_rows ) && ( lbA_cols == 1 ) ) || ( ( lbA_rows == 0 ) && ( lbA_cols == 0 ) ) ) )
-	{
-		Scierror( 336,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 7,"d", &ubA_rows,&ubA_cols,&ubA);
-	if ( !( ( ( ubA_rows == A_rows ) && ( ubA_cols == 1 ) ) || ( ( ubA_rows == 0 ) && ( ubA_cols == 0 ) ) ) )
-	{
-		Scierror( 337,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	GetRhsVar( 8,"i", &nWSR_rows,&nWSR_cols,&nWSR);
-	if ( ( nWSR_rows != nWSR_cols ) || ( nWSR_cols != 1 ) )
-	{
-		Scierror( 338,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-	/* have matrices same dimension as last QP? */
-	if ( ( sqp_rowsH != H_rows ) || ( sqp_rowsA != A_rows ) )
-	{
-		Scierror( 339,"ERROR (qpOASES): Dimension mismatch!\n" );
-		return 0;
-	}
-
-
-	y_size = H_rows + A_rows;
-
-	CreateVar(  9,"d", &H_rows,&one,&x );
-	CreateVar( 10,"d", &one,&one,&obj );
-	CreateVar( 11,"i", &one,&one,&status );
-	CreateVar( 12,"i", &one,&one,&nWSRout );
-	CreateVar( 13,"d", &y_size,&one,&y );
-
-
-	/* call interfaced qpOASES routines with appropriate arguments */
-	sci_SQProblem_hotstart( 	stk(H),stk(g),stk(A), (lb_rows!=0) ? stk(lb) : 0, (ub_rows!=0) ? stk(ub) : 0, (lbA_rows!=0) ? stk(lbA) : 0, (ubA_rows!=0) ? stk(ubA) : 0,
-								istk(nWSR),
-								stk(x),stk(obj),istk(status),istk(nWSRout),stk(y)
-								);
-
-	LhsVar(1) = 9;
-	LhsVar(2) = 10;
-	LhsVar(3) = 11;
-	LhsVar(4) = 12;
-	LhsVar(5) = 13;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m _ c l e a n u p
- */
-int interface_QProblem_cleanup( char* fname )
-{
-	const int minlhs = 0, maxlhs = 1, minrhs = 0, maxrhs = 0;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-	sci_QProblem_cleanup( );
-	qp_rowsH = -1;
-	qp_rowsA = -1;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ Q P r o b l e m B _ c l e a n u p
- */
-int interface_QProblemB_cleanup( char* fname )
-{
-	const int minlhs = 0, maxlhs = 1, minrhs = 0, maxrhs = 0;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-	sci_QProblemB_cleanup( );
-	qpb_rowsH = -1;
-
-	return 0;
-}
-
-
-/*
- *	i n t e r f a c e _ S Q P r o b l e m _ c l e a n u p
- */
-int interface_SQProblem_cleanup( char* fname )
-{
-	const int minlhs = 0, maxlhs = 1, minrhs = 0, maxrhs = 0;
-
-	CheckRhs( minrhs,maxrhs );
-	CheckLhs( minlhs,maxlhs );
-
-	sci_SQProblem_cleanup( );
-	sqp_rowsH = -1;
-	sqp_rowsA = -1;
-
-	return 0;
-}
-
-
-/*
- *	q p O A S E S g a t e w a y
- */
-int C2F(qpOASESgateway)( )
-{
-	gate_function function[] = {	interface_qpOASES,
-									interface_QProblem_init,     interface_QProblemB_init,     interface_SQProblem_init,
-									interface_QProblem_hotstart, interface_QProblemB_hotstart, interface_SQProblem_hotstart,
-									interface_QProblem_cleanup,  interface_QProblemB_cleanup,  interface_SQProblem_cleanup
-									};
-	char* name[] = {	"qpOASES",
-						"qpOASES_init",     "qpOASES_initSB",     "qpOASES_initVM",
-						"qpOASES_hotstart", "qpOASES_hotstartSB", "qpOASES_hotstartVM",
-						"qpOASES_cleanup",  "qpOASES_cleanupSB",  "qpOASES_cleanupVM"
-						};
-
-	Rhs = Max( 0,Rhs );
-	sci_gateway( name[Fin-1],function[Fin-1] );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.sce b/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.sce
deleted file mode 100644
index a12b615..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESinterface.sce
+++ /dev/null
@@ -1,41 +0,0 @@
-//
-//	This file is part of qpOASES.
-//
-//	qpOASES -- An Implementation of the Online Active Set Strategy.
-//	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-//	Christian Kirches et al. All rights reserved.
-//
-//	qpOASES is free software; you can redistribute it and/or
-//	modify it under the terms of the GNU Lesser General Public
-//	License as published by the Free Software Foundation; either
-//	version 2.1 of the License, or (at your option) any later version.
-//
-//	qpOASES is distributed in the hope that it will be useful,
-//	but WITHOUT ANY WARRANTY; without even the implied warranty of
-//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-//	Lesser General Public License for more details.
-//
-//	You should have received a copy of the GNU Lesser General Public
-//	License along with qpOASES; if not, write to the Free Software
-//	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-//
-
-
-
-//
-//	Filename:  interfaces/scilab/qpOASESinterface.sci
-//	Author:    Holger Diedam, Hans Joachim Ferreau
-//	Version:   3.2
-//	Date:      2007-2015
-//
-
-
-
-sharedlib = link( './libqpOASESinterface.so' );
-addinter( './libqpOASESinterface.so', 'qpOASESgateway', ["qpOASES", "qpOASES_init","qpOASES_initSB","qpOASES_initVM", "qpOASES_hotstart","qpOASES_hotstartSB","qpOASES_hotstartVM", "qpOASES_cleanup","qpOASES_cleanupSB","qpOASES_cleanupVM"] );
-
-
-
-//
-//	end of file
-//
diff --git a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESroutines.cpp b/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESroutines.cpp
deleted file mode 100644
index bb487c8..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/scilab/qpOASESroutines.cpp
+++ /dev/null
@@ -1,369 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/scilab/qpOASESroutines.cpp
- *	\author Holger Diedam, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface that enables to call qpOASES from scilab
- *  (C++ file to provide an interface between the files that
- *  have to be compiled with gcc and the qpOASES library).
- *
- */
-
-
-#include <scilab/Scierror.h>
-
-#include <qpOASES.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-/*extern "C" {
-#include "../c/qpOASES_wrapper.h"
-}*/
-
-
-/* global pointers to qpOASES objects */
-static QProblem*  qp  = 0;
-static QProblemB* qpb = 0;
-static SQProblem* sqp = 0;
-
-
-extern "C"
-{
-	void sci_qpOASES(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-						int_t *nV, int_t* nC, int_t* nWSR,
-						real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-						);
-
-	void sci_QProblem_init( 	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nV, int_t* nC, int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-	void sci_QProblemB_init(	real_t* H, real_t* g, real_t* lb, real_t* ub,
-								int_t* nV, int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-	void sci_SQProblem_init(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nV, int_t* nC, int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								);
-
-	void sci_QProblem_hotstart( 	real_t* g, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-									int_t* nWSR,
-									real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-									);
-	void sci_QProblemB_hotstart(	real_t* g, real_t* lb, real_t* ub,
-									int_t* nWSR,
-									real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-									);
-	void sci_SQProblem_hotstart(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-									int_t* nWSR,
-									real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-									);
-
-	void sci_QProblem_cleanup( );
-	void sci_QProblemB_cleanup( );
-	void sci_SQProblem_cleanup( );
-} /* extern "C" */
-
-
-
-/*
- *	t r a n s f o r m A
- */
-void transformA( real_t* A, int_t nV, int_t nC )
-{
-	int_t i, j;
-
-	real_t* A_tmp = new real_t[nC*nV];
-
-	for( i=0; i<nV*nC; ++i )
-		A_tmp[i] = A[i];
-
-	for( i=0; i<nC; ++i )
-		for( j=0; j<nV; ++j )
-			A[i*nV + j] = A_tmp[j*nC + i];
-
-	delete[] A_tmp;
-
-	return;
-}
-
-
-/*
- *	q p O A S E S
- */
-void sci_qpOASES(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-					int_t *nV, int_t* nC, int_t* nWSR,
-					real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-					)
-{
-	/* transform A into C style matrix */
-	transformA( A, *nV,*nC );
-	
-	/* setup and solve initial QP */
-	QProblem single_qp( *nV,*nC );
-	single_qp.setPrintLevel( PL_LOW );
-	returnValue returnvalue = single_qp.init( H,g,A,lb,ub,lbA,ubA, *nWSR,0 );
-
-	/* assign lhs arguments */
-	single_qp.getPrimalSolution( x );
-	*obj = single_qp.getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	single_qp.getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m _ i n i t
- */
-void sci_QProblem_init( 	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-							int_t* nV, int_t* nC, int_t* nWSR,
-							real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-							)
-{
-	sci_QProblem_cleanup( );
-
-	/* transform A into C style matrix */
-	transformA( A, *nV,*nC );
-
-	/* setup and solve initial QP */
-	qp = new QProblem( *nV,*nC );
-	qp->setPrintLevel( PL_LOW );
-	returnValue returnvalue = qp->init( H,g,A,lb,ub,lbA,ubA, *nWSR,0 );
-
-	/* assign lhs arguments */
-	qp->getPrimalSolution( x );
-	*obj = qp->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	qp->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m B _ i n i t
- */
-void sci_QProblemB_init(	real_t* H, real_t* g, real_t* lb, real_t* ub,
-							int_t* nV, int_t* nWSR,
-							real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-							)
-{
-	sci_QProblemB_cleanup( );
-
-	/* setup and solve initial QP */
-	qpb = new QProblemB( *nV );
-	qpb->setPrintLevel( PL_LOW );
-	returnValue returnvalue = qpb->init( H,g,lb,ub, *nWSR,0 );
-
-	/* assign lhs arguments */
-	qpb->getPrimalSolution( x );
-	*obj = qpb->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	qpb->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	S Q P r o b l e m _ i n i t
- */
-void sci_SQProblem_init(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-							int_t* nV, int_t* nC, int_t* nWSR,
-							real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-							)
-{
-	sci_SQProblem_cleanup( );
-
-	/* transform A into C style matrix */
-	transformA( A, *nV,*nC );
-
-	/* setup and solve initial QP */
-	sqp = new SQProblem( *nV,*nC );
-	sqp->setPrintLevel( PL_LOW );
-	returnValue returnvalue = sqp->init( H,g,A,lb,ub,lbA,ubA, *nWSR,0 );
-
-	/* assign lhs arguments */
-	sqp->getPrimalSolution( x );
-	*obj = sqp->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	sqp->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m _ h o t s t a r t
- */
-void sci_QProblem_hotstart( 	real_t* g, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								)
-{
-	/* has QP been initialised? */
-	if ( qp == 0 )
-	{
-		*status = -1;
-		Scierror( 999,"ERROR (qpOASES): Need to call qpOASES_init first!\n" );
-		return;
-	}
-
-	/* solve QP */
-	returnValue returnvalue = qp->hotstart( g,lb,ub,lbA,ubA, *nWSR,0 );
-
-	/* assign lhs arguments */
-	qp->getPrimalSolution( x );
-	*obj = qp->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	qp->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m B _ h o t s t a r t
- */
-void sci_QProblemB_hotstart(	real_t* g, real_t* lb, real_t* ub,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								)
-{
-	/* has QP been initialised? */
-	if ( qpb == 0 )
-	{
-		*status = -1;
-		Scierror( 999,"ERROR (qpOASES): Need to call qpOASES_initSB first!\n" );
-		return;
-	}
-
-	/* solve QP */
-	returnValue returnvalue = qpb->hotstart( g,lb,ub, *nWSR,0 );
-
-	/* assign lhs arguments */
-	qpb->getPrimalSolution( x );
-	*obj = qpb->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	qpb->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	S Q P r o b l e m _ h o t s t a r t
- */
-void sci_SQProblem_hotstart(	real_t* H, real_t* g, real_t* A, real_t* lb, real_t* ub, real_t* lbA, real_t* ubA,
-								int_t* nWSR,
-								real_t* x, real_t* obj, int_t* status, int_t* nWSRout, real_t* y
-								)
-{
-	/* has QP been initialised? */
-	if ( sqp == 0 )
-	{
-		*status = -1;
-		Scierror( 999,"ERROR (qpOASES): Need to call qpOASES_initVM first!\n" );
-		return;
-	}
-
-	/* transform A into C style matrix */
-	transformA( A, sqp->getNV( ),sqp->getNC( ) );
-
-	/* solve QP */
-	returnValue returnvalue = sqp->hotstart( H,g,A,lb,ub,lbA,ubA, *nWSR,0 );
-
-	/* assign lhs arguments */
-	sqp->getPrimalSolution( x );
-	*obj = sqp->getObjVal( );
-	*status = getSimpleStatus( returnvalue );
-	*nWSRout = *nWSR;
-	sqp->getDualSolution( y );
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m _ c l e a n u p
- */
-void sci_QProblem_cleanup( )
-{
-	if ( qp != 0 )
-	{
-		delete qp;
-		qp = 0;
-	}
-
-	return;
-}
-
-
-/*
- *	Q P r o b l e m B _ c l e a n u p
- */
-void sci_QProblemB_cleanup( )
-{
-	if ( qpb != 0 )
-	{
-		delete qpb;
-		qpb = 0;
-	}
-
-	return;
-}
-
-
-/*
- *	S Q P r o b l e m _ c l e a n u p
- */
-void sci_SQProblem_cleanup( )
-{
-	if ( sqp != 0 )
-	{
-		delete sqp;
-		sqp = 0;
-	}
-
-	return;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblem.mdl b/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblem.mdl
deleted file mode 100644
index 028dd40..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblem.mdl
+++ /dev/null
@@ -1,762 +0,0 @@
-Model {
-  Name			  "example_QProblem"
-  Version		  7.4
-  MdlSubVersion		  0
-  GraphicalInterface {
-    NumRootInports	    0
-    NumRootOutports	    0
-    ParameterArgumentNames  ""
-    ComputedModelVersion    "1.69"
-    NumModelReferences	    0
-    NumTestPointedSignals   0
-  }
-  SavedCharacterEncoding  "UTF-8"
-  SaveDefaultBlockParams  on
-  ScopeRefreshTime	  0.035000
-  OverrideScopeRefreshTime on
-  DisableAllScopes	  off
-  DataTypeOverride	  "UseLocalSettings"
-  MinMaxOverflowLogging	  "UseLocalSettings"
-  MinMaxOverflowArchiveMode "Overwrite"
-  MaxMDLFileLineLength	  120
-  Created		  "Fri Apr 13 11:08:51 2007"
-  Creator		  "jferreau"
-  UpdateHistory		  "UpdateHistoryNever"
-  ModifiedByFormat	  "%<Auto>"
-  LastModifiedBy	  "chjofer2"
-  ModifiedDateFormat	  "%<Auto>"
-  LastModifiedDate	  "Tue Jan 06 16:16:07 2015"
-  RTWModifiedTimeStamp	  342461745
-  ModelVersionFormat	  "1.%<AutoIncrement:69>"
-  ConfigurationManager	  "None"
-  SampleTimeColors	  off
-  SampleTimeAnnotations	  off
-  LibraryLinkDisplay	  "none"
-  WideLines		  off
-  ShowLineDimensions	  off
-  ShowPortDataTypes	  off
-  ShowLoopsOnError	  on
-  IgnoreBidirectionalLines off
-  ShowStorageClass	  off
-  ShowTestPointIcons	  on
-  ShowSignalResolutionIcons on
-  ShowViewerIcons	  on
-  SortedOrder		  off
-  ExecutionContextIcon	  off
-  ShowLinearizationAnnotations on
-  BlockNameDataTip	  off
-  BlockParametersDataTip  off
-  BlockDescriptionStringDataTip	off
-  ToolBar		  on
-  StatusBar		  on
-  BrowserShowLibraryLinks off
-  BrowserLookUnderMasks	  off
-  SimulationMode	  "normal"
-  LinearizationMsg	  "none"
-  Profile		  off
-  ParamWorkspaceSource	  "MATLABWorkspace"
-  AccelSystemTargetFile	  "accel.tlc"
-  AccelTemplateMakefile	  "accel_default_tmf"
-  AccelMakeCommand	  "make_rtw"
-  TryForcingSFcnDF	  off
-  RecordCoverage	  off
-  CovPath		  "/"
-  CovSaveName		  "covdata"
-  CovMetricSettings	  "dw"
-  CovNameIncrementing	  off
-  CovHtmlReporting	  on
-  CovForceBlockReductionOff on
-  covSaveCumulativeToWorkspaceVar on
-  CovSaveSingleToWorkspaceVar on
-  CovCumulativeVarName	  "covCumulativeData"
-  CovCumulativeReport	  off
-  CovReportOnPause	  on
-  CovModelRefEnable	  "Off"
-  CovExternalEMLEnable	  off
-  ExtModeBatchMode	  off
-  ExtModeEnableFloating	  on
-  ExtModeTrigType	  "manual"
-  ExtModeTrigMode	  "normal"
-  ExtModeTrigPort	  "1"
-  ExtModeTrigElement	  "any"
-  ExtModeTrigDuration	  1000
-  ExtModeTrigDurationFloating "auto"
-  ExtModeTrigHoldOff	  0
-  ExtModeTrigDelay	  0
-  ExtModeTrigDirection	  "rising"
-  ExtModeTrigLevel	  0
-  ExtModeArchiveMode	  "off"
-  ExtModeAutoIncOneShot	  off
-  ExtModeIncDirWhenArm	  off
-  ExtModeAddSuffixToVar	  off
-  ExtModeWriteAllDataToWs off
-  ExtModeArmWhenConnect	  on
-  ExtModeSkipDownloadWhenConnect off
-  ExtModeLogAll		  on
-  ExtModeAutoUpdateStatusClock off
-  BufferReuse		  on
-  ShowModelReferenceBlockVersion off
-  ShowModelReferenceBlockIO off
-  Array {
-    Type		    "Handle"
-    Dimension		    1
-    Simulink.ConfigSet {
-      $ObjectID		      1
-      Version		      "1.6.0"
-      Array {
-	Type			"Handle"
-	Dimension		8
-	Simulink.SolverCC {
-	  $ObjectID		  2
-	  Version		  "1.6.0"
-	  StartTime		  "0.0"
-	  StopTime		  "0.5"
-	  AbsTol		  "auto"
-	  FixedStep		  "auto"
-	  InitialStep		  "auto"
-	  MaxNumMinSteps	  "-1"
-	  MaxOrder		  5
-	  ZcThreshold		  "auto"
-	  ConsecutiveZCsStepRelTol "10*128*eps"
-	  MaxConsecutiveZCs	  "1000"
-	  ExtrapolationOrder	  4
-	  NumberNewtonIterations  1
-	  MaxStep		  "auto"
-	  MinStep		  "auto"
-	  MaxConsecutiveMinStep	  "1"
-	  RelTol		  "1e-3"
-	  SolverMode		  "Auto"
-	  Solver		  "FixedStepDiscrete"
-	  SolverName		  "FixedStepDiscrete"
-	  ShapePreserveControl	  "DisableAll"
-	  ZeroCrossControl	  "UseLocalSettings"
-	  ZeroCrossAlgorithm	  "Nonadaptive"
-	  AlgebraicLoopSolver	  "TrustRegion"
-	  SolverResetMethod	  "Fast"
-	  PositivePriorityOrder	  off
-	  AutoInsertRateTranBlk	  off
-	  SampleTimeConstraint	  "Unconstrained"
-	  InsertRTBMode		  "Whenever possible"
-	}
-	Simulink.DataIOCC {
-	  $ObjectID		  3
-	  Version		  "1.6.0"
-	  Decimation		  "1"
-	  ExternalInput		  "[t, u]"
-	  FinalStateName	  "xFinal"
-	  InitialState		  "xInitial"
-	  LimitDataPoints	  on
-	  MaxDataPoints		  "1000"
-	  LoadExternalInput	  off
-	  LoadInitialState	  off
-	  SaveFinalState	  off
-	  SaveCompleteFinalSimState off
-	  SaveFormat		  "Array"
-	  SaveOutput		  on
-	  SaveState		  off
-	  SignalLogging		  on
-	  InspectSignalLogs	  off
-	  SaveTime		  on
-	  ReturnWorkspaceOutputs  off
-	  StateSaveName		  "xout"
-	  TimeSaveName		  "tout"
-	  OutputSaveName	  "yout"
-	  SignalLoggingName	  "logsout"
-	  OutputOption		  "RefineOutputTimes"
-	  OutputTimes		  "[]"
-	  ReturnWorkspaceOutputsName "out"
-	  Refine		  "1"
-	}
-	Simulink.OptimizationCC {
-	  $ObjectID		  4
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    4
-	    Cell		    "ZeroExternalMemoryAtStartup"
-	    Cell		    "ZeroInternalMemoryAtStartup"
-	    Cell		    "NoFixptDivByZeroProtection"
-	    Cell		    "OptimizeModelRefInitCode"
-	    PropName		    "DisabledProps"
-	  }
-	  BlockReduction	  on
-	  BooleanDataType	  on
-	  ConditionallyExecuteInputs on
-	  InlineParams		  off
-	  UseIntDivNetSlope	  off
-	  InlineInvariantSignals  off
-	  OptimizeBlockIOStorage  on
-	  BufferReuse		  on
-	  EnhancedBackFolding	  off
-	  StrengthReduction	  off
-	  EnforceIntegerDowncast  on
-	  ExpressionFolding	  on
-	  BooleansAsBitfields	  off
-	  EnableMemcpy		  on
-	  MemcpyThreshold	  64
-	  PassReuseOutputArgsAs	  "Structure reference"
-	  ExpressionDepthLimit	  2147483647
-	  FoldNonRolledExpr	  on
-	  LocalBlockOutputs	  on
-	  RollThreshold		  5
-	  SystemCodeInlineAuto	  off
-	  StateBitsets		  off
-	  DataBitsets		  off
-	  UseTempVars		  off
-	  ZeroExternalMemoryAtStartup on
-	  ZeroInternalMemoryAtStartup on
-	  InitFltsAndDblsToZero	  on
-	  NoFixptDivByZeroProtection off
-	  EfficientFloat2IntCast  off
-	  EfficientMapNaN2IntZero on
-	  OptimizeModelRefInitCode off
-	  LifeSpan		  "inf"
-	  BufferReusableBoundary  on
-	  SimCompilerOptimization "Off"
-	  AccelVerboseBuild	  off
-	}
-	Simulink.DebuggingCC {
-	  $ObjectID		  5
-	  Version		  "1.6.0"
-	  RTPrefix		  "error"
-	  ConsistencyChecking	  "none"
-	  ArrayBoundsChecking	  "none"
-	  SignalInfNanChecking	  "none"
-	  SignalRangeChecking	  "none"
-	  ReadBeforeWriteMsg	  "UseLocalSettings"
-	  WriteAfterWriteMsg	  "UseLocalSettings"
-	  WriteAfterReadMsg	  "UseLocalSettings"
-	  AlgebraicLoopMsg	  "warning"
-	  ArtificialAlgebraicLoopMsg "warning"
-	  SaveWithDisabledLinksMsg "warning"
-	  SaveWithParameterizedLinksMsg	"none"
-	  CheckSSInitialOutputMsg on
-	  UnderspecifiedInitializationDetection	"Classic"
-	  MergeDetectMultiDrivingBlocksExec "none"
-	  CheckExecutionContextPreStartOutputMsg off
-	  CheckExecutionContextRuntimeOutputMsg	off
-	  SignalResolutionControl "TryResolveAllWithWarning"
-	  BlockPriorityViolationMsg "warning"
-	  MinStepSizeMsg	  "warning"
-	  TimeAdjustmentMsg	  "none"
-	  MaxConsecutiveZCsMsg	  "error"
-	  SolverPrmCheckMsg	  "warning"
-	  InheritedTsInSrcMsg	  "warning"
-	  DiscreteInheritContinuousMsg "warning"
-	  MultiTaskDSMMsg	  "error"
-	  MultiTaskCondExecSysMsg "error"
-	  MultiTaskRateTransMsg	  "error"
-	  SingleTaskRateTransMsg  "none"
-	  TasksWithSamePriorityMsg "warning"
-	  SigSpecEnsureSampleTimeMsg "warning"
-	  CheckMatrixSingularityMsg "none"
-	  IntegerOverflowMsg	  "warning"
-	  Int32ToFloatConvMsg	  "warning"
-	  ParameterDowncastMsg	  "error"
-	  ParameterOverflowMsg	  "error"
-	  ParameterUnderflowMsg	  "none"
-	  ParameterPrecisionLossMsg "warning"
-	  ParameterTunabilityLossMsg "warning"
-	  FixptConstUnderflowMsg  "none"
-	  FixptConstOverflowMsg	  "none"
-	  FixptConstPrecisionLossMsg "none"
-	  UnderSpecifiedDataTypeMsg "none"
-	  UnnecessaryDatatypeConvMsg "none"
-	  VectorMatrixConversionMsg "none"
-	  InvalidFcnCallConnMsg	  "error"
-	  FcnCallInpInsideContextMsg "Use local settings"
-	  SignalLabelMismatchMsg  "none"
-	  UnconnectedInputMsg	  "warning"
-	  UnconnectedOutputMsg	  "warning"
-	  UnconnectedLineMsg	  "warning"
-	  SFcnCompatibilityMsg	  "none"
-	  UniqueDataStoreMsg	  "none"
-	  BusObjectLabelMismatch  "warning"
-	  RootOutportRequireBusObject "warning"
-	  AssertControl		  "UseLocalSettings"
-	  EnableOverflowDetection off
-	  ModelReferenceIOMsg	  "none"
-	  ModelReferenceVersionMismatchMessage "none"
-	  ModelReferenceIOMismatchMessage "none"
-	  ModelReferenceCSMismatchMessage "none"
-	  UnknownTsInhSupMsg	  "warning"
-	  ModelReferenceDataLoggingMessage "warning"
-	  ModelReferenceSymbolNameMessage "warning"
-	  ModelReferenceExtraNoncontSigs "error"
-	  StateNameClashWarn	  "warning"
-	  SimStateInterfaceChecksumMismatchMsg "warning"
-	  StrictBusMsg		  "Warning"
-	  LoggingUnavailableSignals "error"
-	  BlockIODiagnostic	  "none"
-	}
-	Simulink.HardwareCC {
-	  $ObjectID		  6
-	  Version		  "1.6.0"
-	  ProdBitPerChar	  8
-	  ProdBitPerShort	  16
-	  ProdBitPerInt		  32
-	  ProdBitPerLong	  32
-	  ProdIntDivRoundTo	  "Undefined"
-	  ProdEndianess		  "Unspecified"
-	  ProdWordSize		  32
-	  ProdShiftRightIntArith  on
-	  ProdHWDeviceType	  "32-bit Generic"
-	  TargetBitPerChar	  8
-	  TargetBitPerShort	  16
-	  TargetBitPerInt	  32
-	  TargetBitPerLong	  32
-	  TargetShiftRightIntArith on
-	  TargetIntDivRoundTo	  "Undefined"
-	  TargetEndianess	  "Unspecified"
-	  TargetWordSize	  32
-	  TargetTypeEmulationWarnSuppressLevel 0
-	  TargetPreprocMaxBitsSint 32
-	  TargetPreprocMaxBitsUint 32
-	  TargetHWDeviceType	  "Specified"
-	  TargetUnknown		  off
-	  ProdEqTarget		  on
-	}
-	Simulink.ModelReferenceCC {
-	  $ObjectID		  7
-	  Version		  "1.6.0"
-	  UpdateModelReferenceTargets "IfOutOfDateOrStructuralChange"
-	  CheckModelReferenceTargetMessage "error"
-	  ModelReferenceNumInstancesAllowed "Multi"
-	  ModelReferencePassRootInputsByReference on
-	  ModelReferenceMinAlgLoopOccurrences off
-	}
-	Simulink.SFSimCC {
-	  $ObjectID		  8
-	  Version		  "1.6.0"
-	  SFSimEnableDebug	  on
-	  SFSimOverflowDetection  on
-	  SFSimEcho		  on
-	  SimBlas		  on
-	  SimCtrlC		  on
-	  SimExtrinsic		  on
-	  SimIntegrity		  on
-	  SimUseLocalCustomCode	  off
-	  SimBuildMode		  "sf_incremental_build"
-	}
-	Simulink.RTWCC {
-	  $BackupClass		  "Simulink.RTWCC"
-	  $ObjectID		  9
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    1
-	    Cell		    "IncludeHyperlinkInReport"
-	    PropName		    "DisabledProps"
-	  }
-	  SystemTargetFile	  "grt.tlc"
-	  GenCodeOnly		  off
-	  MakeCommand		  "make_rtw"
-	  GenerateMakefile	  on
-	  TemplateMakefile	  "grt_default_tmf"
-	  GenerateReport	  off
-	  SaveLog		  off
-	  RTWVerbose		  on
-	  RetainRTWFile		  off
-	  ProfileTLC		  off
-	  TLCDebug		  off
-	  TLCCoverage		  off
-	  TLCAssert		  off
-	  ProcessScriptMode	  "Default"
-	  ConfigurationMode	  "Optimized"
-	  ConfigAtBuild		  off
-	  RTWUseLocalCustomCode	  off
-	  RTWUseSimCustomCode	  off
-	  IncludeHyperlinkInReport off
-	  LaunchReport		  off
-	  TargetLang		  "C"
-	  IncludeBusHierarchyInRTWFileBlockHierarchyMap	off
-	  IncludeERTFirstTime	  off
-	  GenerateTraceInfo	  off
-	  GenerateTraceReport	  off
-	  GenerateTraceReportSl	  off
-	  GenerateTraceReportSf	  off
-	  GenerateTraceReportEml  off
-	  GenerateCodeInfo	  off
-	  RTWCompilerOptimization "Off"
-	  CheckMdlBeforeBuild	  "Off"
-	  Array {
-	    Type		    "Handle"
-	    Dimension		    2
-	    Simulink.CodeAppCC {
-	      $ObjectID		      10
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		16
-		Cell			"IgnoreCustomStorageClasses"
-		Cell			"InsertBlockDesc"
-		Cell			"SFDataObjDesc"
-		Cell			"SimulinkDataObjDesc"
-		Cell			"DefineNamingRule"
-		Cell			"SignalNamingRule"
-		Cell			"ParamNamingRule"
-		Cell			"InlinedPrmAccess"
-		Cell			"CustomSymbolStr"
-		Cell			"CustomSymbolStrGlobalVar"
-		Cell			"CustomSymbolStrType"
-		Cell			"CustomSymbolStrField"
-		Cell			"CustomSymbolStrFcn"
-		Cell			"CustomSymbolStrBlkIO"
-		Cell			"CustomSymbolStrTmpVar"
-		Cell			"CustomSymbolStrMacro"
-		PropName		"DisabledProps"
-	      }
-	      ForceParamTrailComments off
-	      GenerateComments	      on
-	      IgnoreCustomStorageClasses on
-	      IgnoreTestpoints	      off
-	      IncHierarchyInIds	      off
-	      MaxIdLength	      31
-	      PreserveName	      off
-	      PreserveNameWithParent  off
-	      ShowEliminatedStatement off
-	      IncAutoGenComments      off
-	      SimulinkDataObjDesc     off
-	      SFDataObjDesc	      off
-	      IncDataTypeInIds	      off
-	      MangleLength	      1
-	      CustomSymbolStrGlobalVar "$R$N$M"
-	      CustomSymbolStrType     "$N$R$M"
-	      CustomSymbolStrField    "$N$M"
-	      CustomSymbolStrFcn      "$R$N$M$F"
-	      CustomSymbolStrFcnArg   "rt$I$N$M"
-	      CustomSymbolStrBlkIO    "rtb_$N$M"
-	      CustomSymbolStrTmpVar   "$N$M"
-	      CustomSymbolStrMacro    "$R$N$M"
-	      DefineNamingRule	      "None"
-	      ParamNamingRule	      "None"
-	      SignalNamingRule	      "None"
-	      InsertBlockDesc	      off
-	      SimulinkBlockComments   on
-	      EnableCustomComments    off
-	      InlinedPrmAccess	      "Literals"
-	      ReqsInCode	      off
-	      UseSimReservedNames     off
-	    }
-	    Simulink.GRTTargetCC {
-	      $BackupClass	      "Simulink.TargetCC"
-	      $ObjectID		      11
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		13
-		Cell			"IncludeMdlTerminateFcn"
-		Cell			"CombineOutputUpdateFcns"
-		Cell			"SuppressErrorStatus"
-		Cell			"ERTCustomFileBanners"
-		Cell			"GenerateSampleERTMain"
-		Cell			"GenerateTestInterfaces"
-		Cell			"MultiInstanceERTCode"
-		Cell			"PurelyIntegerCode"
-		Cell			"SupportNonFinite"
-		Cell			"SupportComplex"
-		Cell			"SupportAbsoluteTime"
-		Cell			"SupportContinuousTime"
-		Cell			"SupportNonInlinedSFcns"
-		PropName		"DisabledProps"
-	      }
-	      TargetFcnLib	      "ansi_tfl_tmw.mat"
-	      TargetLibSuffix	      ""
-	      TargetPreCompLibLocation ""
-	      TargetFunctionLibrary   "ANSI_C"
-	      UtilityFuncGeneration   "Auto"
-	      ERTMultiwordTypeDef     "System defined"
-	      ERTMultiwordLength      256
-	      MultiwordLength	      2048
-	      GenerateFullHeader      on
-	      GenerateSampleERTMain   off
-	      GenerateTestInterfaces  off
-	      IsPILTarget	      off
-	      ModelReferenceCompliant on
-	      ParMdlRefBuildCompliant on
-	      CompOptLevelCompliant   on
-	      IncludeMdlTerminateFcn  on
-	      GeneratePreprocessorConditionals "Disable all"
-	      CombineOutputUpdateFcns off
-	      SuppressErrorStatus     off
-	      ERTFirstTimeCompliant   off
-	      IncludeFileDelimiter    "Auto"
-	      ERTCustomFileBanners    off
-	      SupportAbsoluteTime     on
-	      LogVarNameModifier      "rt_"
-	      MatFileLogging	      on
-	      MultiInstanceERTCode    off
-	      SupportNonFinite	      on
-	      SupportComplex	      on
-	      PurelyIntegerCode	      off
-	      SupportContinuousTime   on
-	      SupportNonInlinedSFcns  on
-	      SupportVariableSizeSignals off
-	      EnableShiftOperators    on
-	      ParenthesesLevel	      "Nominal"
-	      PortableWordSizes	      off
-	      ModelStepFunctionPrototypeControlCompliant off
-	      CPPClassGenCompliant    off
-	      AutosarCompliant	      off
-	      UseMalloc		      off
-	      ExtMode		      off
-	      ExtModeStaticAlloc      off
-	      ExtModeTesting	      off
-	      ExtModeStaticAllocSize  1000000
-	      ExtModeTransport	      0
-	      ExtModeMexFile	      "ext_comm"
-	      ExtModeIntrfLevel	      "Level1"
-	      RTWCAPISignals	      off
-	      RTWCAPIParams	      off
-	      RTWCAPIStates	      off
-	      GenerateASAP2	      off
-	    }
-	    PropName		    "Components"
-	  }
-	}
-	PropName		"Components"
-      }
-      Name		      "Configuration"
-      CurrentDlgPage	      "Solver"
-      ConfigPrmDlgPosition    " [ 200, 197, 1080, 827 ] "
-    }
-    PropName		    "ConfigurationSets"
-  }
-  Simulink.ConfigSet {
-    $PropName		    "ActiveConfigurationSet"
-    $ObjectID		    1
-  }
-  BlockDefaults {
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    NamePlacement	    "normal"
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    ShowName		    on
-    BlockRotation	    0
-    BlockMirror		    off
-  }
-  AnnotationDefaults {
-    HorizontalAlignment	    "center"
-    VerticalAlignment	    "middle"
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    UseDisplayTextAsClickCallback off
-  }
-  LineDefaults {
-    FontName		    "Courier"
-    FontSize		    9
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-  }
-  BlockParameterDefaults {
-    Block {
-      BlockType		      FromWorkspace
-      VariableName	      "simulink_input"
-      SampleTime	      "-1"
-      Interpolate	      on
-      ZeroCross		      off
-      OutputAfterFinalValue   "Extrapolation"
-    }
-    Block {
-      BlockType		      "S-Function"
-      FunctionName	      "system"
-      SFunctionModules	      "''"
-      PortCounts	      "[]"
-      SFunctionDeploymentMode off
-    }
-    Block {
-      BlockType		      Scope
-      ModelBased	      off
-      TickLabels	      "OneTimeTick"
-      ZoomMode		      "on"
-      Grid		      "on"
-      TimeRange		      "auto"
-      YMin		      "-5"
-      YMax		      "5"
-      SaveToWorkspace	      off
-      SaveName		      "ScopeData"
-      LimitDataPoints	      on
-      MaxDataPoints	      "5000"
-      Decimation	      "1"
-      SampleInput	      off
-      SampleTime	      "-1"
-    }
-  }
-  System {
-    Name		    "example_QProblem"
-    Location		    [2, 74, 1918, 1139]
-    Open		    on
-    ModelBrowserVisibility  off
-    ModelBrowserWidth	    200
-    ScreenColor		    "white"
-    PaperOrientation	    "landscape"
-    PaperPositionMode	    "auto"
-    PaperType		    "usletter"
-    PaperUnits		    "inches"
-    TiledPaperMargins	    [0.500000, 0.500000, 0.500000, 0.500000]
-    TiledPageScale	    1
-    ShowPageBoundaries	    off
-    ZoomFactor		    "125"
-    ReportName		    "simulink-default.rpt"
-    SIDHighWatermark	    9
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "g"
-      SID		      2
-      Position		      [200, 158, 265, 182]
-      VariableName	      "g"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "lb"
-      SID		      4
-      Position		      [200, 203, 265, 227]
-      VariableName	      "lb"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "lbA"
-      SID		      6
-      Position		      [200, 293, 265, 317]
-      VariableName	      "lbA"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      "S-Function"
-      Name		      "qpOASES"
-      SID		      9
-      Ports		      [5, 4]
-      Position		      [595, 222, 795, 298]
-      BackgroundColor	      "[1.000000, 0.915850, 0.439000]"
-      FunctionName	      "qpOASES_QProblem"
-      Parameters	      "H,A"
-      EnableBusSupport	      off
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "ub"
-      SID		      5
-      Position		      [200, 248, 265, 272]
-      VariableName	      "ub"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "ubA"
-      SID		      7
-      Position		      [200, 338, 265, 362]
-      VariableName	      "ubA"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      Scope
-      Name		      "x,\nfval,\nexitflag,\niter"
-      SID		      8
-      Ports		      [4]
-      Position		      [945, 222, 1000, 298]
-      Floating		      off
-      Location		      [6, 78, 1276, 993]
-      Open		      off
-      NumInputPorts	      "4"
-      List {
-	ListType		AxesTitles
-	axes1			"%<SignalLabel>"
-	axes2			"%<SignalLabel>"
-	axes3			"%<SignalLabel>"
-	axes4			"%<SignalLabel>"
-      }
-      YMin		      "-5~-5~-5~-5"
-      YMax		      "5~5~5~5"
-      SaveName		      "ScopeData1"
-      DataFormat	      "StructureWithTime"
-      SampleTime	      "0"
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      1
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      2
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      2
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      3
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      3
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      4
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      4
-    }
-    Line {
-      SrcBlock		      "ub"
-      SrcPort		      1
-      DstBlock		      "qpOASES"
-      DstPort		      3
-    }
-    Line {
-      SrcBlock		      "lb"
-      SrcPort		      1
-      Points		      [55, 0; 0, 30]
-      DstBlock		      "qpOASES"
-      DstPort		      2
-    }
-    Line {
-      SrcBlock		      "g"
-      SrcPort		      1
-      Points		      [80, 0; 0, 60]
-      DstBlock		      "qpOASES"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "lbA"
-      SrcPort		      1
-      Points		      [55, 0; 0, -30]
-      DstBlock		      "qpOASES"
-      DstPort		      4
-    }
-    Line {
-      SrcBlock		      "ubA"
-      SrcPort		      1
-      Points		      [80, 0; 0, -60]
-      DstBlock		      "qpOASES"
-      DstPort		      5
-    }
-    Annotation {
-      Position		      [335, 96]
-    }
-    Annotation {
-      Name		      "This file is part of qpOASES.\n\nqpOASES -- An Implementation of the Online Active Set Strategy.\nC"
-      "opyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka, Christian Kirches et al.\nAll rights reserved."
-      Position		      [693, 128]
-    }
-  }
-}
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblemB.mdl b/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblemB.mdl
deleted file mode 100644
index 727602d..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_QProblemB.mdl
+++ /dev/null
@@ -1,728 +0,0 @@
-Model {
-  Name			  "example_QProblemB"
-  Version		  7.4
-  MdlSubVersion		  0
-  GraphicalInterface {
-    NumRootInports	    0
-    NumRootOutports	    0
-    ParameterArgumentNames  ""
-    ComputedModelVersion    "1.67"
-    NumModelReferences	    0
-    NumTestPointedSignals   0
-  }
-  SavedCharacterEncoding  "UTF-8"
-  SaveDefaultBlockParams  on
-  ScopeRefreshTime	  0.035000
-  OverrideScopeRefreshTime on
-  DisableAllScopes	  off
-  DataTypeOverride	  "UseLocalSettings"
-  MinMaxOverflowLogging	  "UseLocalSettings"
-  MinMaxOverflowArchiveMode "Overwrite"
-  MaxMDLFileLineLength	  120
-  Created		  "Fri Apr 13 11:08:51 2007"
-  Creator		  "jferreau"
-  UpdateHistory		  "UpdateHistoryNever"
-  ModifiedByFormat	  "%<Auto>"
-  LastModifiedBy	  "chjofer2"
-  ModifiedDateFormat	  "%<Auto>"
-  LastModifiedDate	  "Tue Jan 06 16:15:23 2015"
-  RTWModifiedTimeStamp	  342461721
-  ModelVersionFormat	  "1.%<AutoIncrement:67>"
-  ConfigurationManager	  "None"
-  SampleTimeColors	  off
-  SampleTimeAnnotations	  off
-  LibraryLinkDisplay	  "none"
-  WideLines		  off
-  ShowLineDimensions	  off
-  ShowPortDataTypes	  off
-  ShowLoopsOnError	  on
-  IgnoreBidirectionalLines off
-  ShowStorageClass	  off
-  ShowTestPointIcons	  on
-  ShowSignalResolutionIcons on
-  ShowViewerIcons	  on
-  SortedOrder		  off
-  ExecutionContextIcon	  off
-  ShowLinearizationAnnotations on
-  BlockNameDataTip	  off
-  BlockParametersDataTip  off
-  BlockDescriptionStringDataTip	off
-  ToolBar		  on
-  StatusBar		  on
-  BrowserShowLibraryLinks off
-  BrowserLookUnderMasks	  off
-  SimulationMode	  "normal"
-  LinearizationMsg	  "none"
-  Profile		  off
-  ParamWorkspaceSource	  "MATLABWorkspace"
-  AccelSystemTargetFile	  "accel.tlc"
-  AccelTemplateMakefile	  "accel_default_tmf"
-  AccelMakeCommand	  "make_rtw"
-  TryForcingSFcnDF	  off
-  RecordCoverage	  off
-  CovPath		  "/"
-  CovSaveName		  "covdata"
-  CovMetricSettings	  "dw"
-  CovNameIncrementing	  off
-  CovHtmlReporting	  on
-  CovForceBlockReductionOff on
-  covSaveCumulativeToWorkspaceVar on
-  CovSaveSingleToWorkspaceVar on
-  CovCumulativeVarName	  "covCumulativeData"
-  CovCumulativeReport	  off
-  CovReportOnPause	  on
-  CovModelRefEnable	  "Off"
-  CovExternalEMLEnable	  off
-  ExtModeBatchMode	  off
-  ExtModeEnableFloating	  on
-  ExtModeTrigType	  "manual"
-  ExtModeTrigMode	  "normal"
-  ExtModeTrigPort	  "1"
-  ExtModeTrigElement	  "any"
-  ExtModeTrigDuration	  1000
-  ExtModeTrigDurationFloating "auto"
-  ExtModeTrigHoldOff	  0
-  ExtModeTrigDelay	  0
-  ExtModeTrigDirection	  "rising"
-  ExtModeTrigLevel	  0
-  ExtModeArchiveMode	  "off"
-  ExtModeAutoIncOneShot	  off
-  ExtModeIncDirWhenArm	  off
-  ExtModeAddSuffixToVar	  off
-  ExtModeWriteAllDataToWs off
-  ExtModeArmWhenConnect	  on
-  ExtModeSkipDownloadWhenConnect off
-  ExtModeLogAll		  on
-  ExtModeAutoUpdateStatusClock off
-  BufferReuse		  on
-  ShowModelReferenceBlockVersion off
-  ShowModelReferenceBlockIO off
-  Array {
-    Type		    "Handle"
-    Dimension		    1
-    Simulink.ConfigSet {
-      $ObjectID		      1
-      Version		      "1.6.0"
-      Array {
-	Type			"Handle"
-	Dimension		8
-	Simulink.SolverCC {
-	  $ObjectID		  2
-	  Version		  "1.6.0"
-	  StartTime		  "0.0"
-	  StopTime		  "0.5"
-	  AbsTol		  "auto"
-	  FixedStep		  "auto"
-	  InitialStep		  "auto"
-	  MaxNumMinSteps	  "-1"
-	  MaxOrder		  5
-	  ZcThreshold		  "auto"
-	  ConsecutiveZCsStepRelTol "10*128*eps"
-	  MaxConsecutiveZCs	  "1000"
-	  ExtrapolationOrder	  4
-	  NumberNewtonIterations  1
-	  MaxStep		  "auto"
-	  MinStep		  "auto"
-	  MaxConsecutiveMinStep	  "1"
-	  RelTol		  "1e-3"
-	  SolverMode		  "Auto"
-	  Solver		  "VariableStepDiscrete"
-	  SolverName		  "VariableStepDiscrete"
-	  ShapePreserveControl	  "DisableAll"
-	  ZeroCrossControl	  "UseLocalSettings"
-	  ZeroCrossAlgorithm	  "Nonadaptive"
-	  AlgebraicLoopSolver	  "TrustRegion"
-	  SolverResetMethod	  "Fast"
-	  PositivePriorityOrder	  off
-	  AutoInsertRateTranBlk	  off
-	  SampleTimeConstraint	  "Unconstrained"
-	  InsertRTBMode		  "Whenever possible"
-	}
-	Simulink.DataIOCC {
-	  $ObjectID		  3
-	  Version		  "1.6.0"
-	  Decimation		  "1"
-	  ExternalInput		  "[t, u]"
-	  FinalStateName	  "xFinal"
-	  InitialState		  "xInitial"
-	  LimitDataPoints	  on
-	  MaxDataPoints		  "1000"
-	  LoadExternalInput	  off
-	  LoadInitialState	  off
-	  SaveFinalState	  off
-	  SaveCompleteFinalSimState off
-	  SaveFormat		  "Array"
-	  SaveOutput		  on
-	  SaveState		  off
-	  SignalLogging		  on
-	  InspectSignalLogs	  off
-	  SaveTime		  on
-	  ReturnWorkspaceOutputs  off
-	  StateSaveName		  "xout"
-	  TimeSaveName		  "tout"
-	  OutputSaveName	  "yout"
-	  SignalLoggingName	  "logsout"
-	  OutputOption		  "RefineOutputTimes"
-	  OutputTimes		  "[]"
-	  ReturnWorkspaceOutputsName "out"
-	  Refine		  "1"
-	}
-	Simulink.OptimizationCC {
-	  $ObjectID		  4
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    4
-	    Cell		    "ZeroExternalMemoryAtStartup"
-	    Cell		    "ZeroInternalMemoryAtStartup"
-	    Cell		    "NoFixptDivByZeroProtection"
-	    Cell		    "OptimizeModelRefInitCode"
-	    PropName		    "DisabledProps"
-	  }
-	  BlockReduction	  on
-	  BooleanDataType	  on
-	  ConditionallyExecuteInputs on
-	  InlineParams		  off
-	  UseIntDivNetSlope	  off
-	  InlineInvariantSignals  off
-	  OptimizeBlockIOStorage  on
-	  BufferReuse		  on
-	  EnhancedBackFolding	  off
-	  StrengthReduction	  off
-	  EnforceIntegerDowncast  on
-	  ExpressionFolding	  on
-	  BooleansAsBitfields	  off
-	  EnableMemcpy		  on
-	  MemcpyThreshold	  64
-	  PassReuseOutputArgsAs	  "Structure reference"
-	  ExpressionDepthLimit	  2147483647
-	  FoldNonRolledExpr	  on
-	  LocalBlockOutputs	  on
-	  RollThreshold		  5
-	  SystemCodeInlineAuto	  off
-	  StateBitsets		  off
-	  DataBitsets		  off
-	  UseTempVars		  off
-	  ZeroExternalMemoryAtStartup on
-	  ZeroInternalMemoryAtStartup on
-	  InitFltsAndDblsToZero	  on
-	  NoFixptDivByZeroProtection off
-	  EfficientFloat2IntCast  off
-	  EfficientMapNaN2IntZero on
-	  OptimizeModelRefInitCode off
-	  LifeSpan		  "inf"
-	  BufferReusableBoundary  on
-	  SimCompilerOptimization "Off"
-	  AccelVerboseBuild	  off
-	}
-	Simulink.DebuggingCC {
-	  $ObjectID		  5
-	  Version		  "1.6.0"
-	  RTPrefix		  "error"
-	  ConsistencyChecking	  "none"
-	  ArrayBoundsChecking	  "none"
-	  SignalInfNanChecking	  "none"
-	  SignalRangeChecking	  "none"
-	  ReadBeforeWriteMsg	  "UseLocalSettings"
-	  WriteAfterWriteMsg	  "UseLocalSettings"
-	  WriteAfterReadMsg	  "UseLocalSettings"
-	  AlgebraicLoopMsg	  "warning"
-	  ArtificialAlgebraicLoopMsg "warning"
-	  SaveWithDisabledLinksMsg "warning"
-	  SaveWithParameterizedLinksMsg	"none"
-	  CheckSSInitialOutputMsg on
-	  UnderspecifiedInitializationDetection	"Classic"
-	  MergeDetectMultiDrivingBlocksExec "none"
-	  CheckExecutionContextPreStartOutputMsg off
-	  CheckExecutionContextRuntimeOutputMsg	off
-	  SignalResolutionControl "TryResolveAllWithWarning"
-	  BlockPriorityViolationMsg "warning"
-	  MinStepSizeMsg	  "warning"
-	  TimeAdjustmentMsg	  "none"
-	  MaxConsecutiveZCsMsg	  "error"
-	  SolverPrmCheckMsg	  "warning"
-	  InheritedTsInSrcMsg	  "warning"
-	  DiscreteInheritContinuousMsg "warning"
-	  MultiTaskDSMMsg	  "error"
-	  MultiTaskCondExecSysMsg "error"
-	  MultiTaskRateTransMsg	  "error"
-	  SingleTaskRateTransMsg  "none"
-	  TasksWithSamePriorityMsg "warning"
-	  SigSpecEnsureSampleTimeMsg "warning"
-	  CheckMatrixSingularityMsg "none"
-	  IntegerOverflowMsg	  "warning"
-	  Int32ToFloatConvMsg	  "warning"
-	  ParameterDowncastMsg	  "error"
-	  ParameterOverflowMsg	  "error"
-	  ParameterUnderflowMsg	  "none"
-	  ParameterPrecisionLossMsg "warning"
-	  ParameterTunabilityLossMsg "warning"
-	  FixptConstUnderflowMsg  "none"
-	  FixptConstOverflowMsg	  "none"
-	  FixptConstPrecisionLossMsg "none"
-	  UnderSpecifiedDataTypeMsg "none"
-	  UnnecessaryDatatypeConvMsg "none"
-	  VectorMatrixConversionMsg "none"
-	  InvalidFcnCallConnMsg	  "error"
-	  FcnCallInpInsideContextMsg "Use local settings"
-	  SignalLabelMismatchMsg  "none"
-	  UnconnectedInputMsg	  "warning"
-	  UnconnectedOutputMsg	  "warning"
-	  UnconnectedLineMsg	  "warning"
-	  SFcnCompatibilityMsg	  "none"
-	  UniqueDataStoreMsg	  "none"
-	  BusObjectLabelMismatch  "warning"
-	  RootOutportRequireBusObject "warning"
-	  AssertControl		  "UseLocalSettings"
-	  EnableOverflowDetection off
-	  ModelReferenceIOMsg	  "none"
-	  ModelReferenceVersionMismatchMessage "none"
-	  ModelReferenceIOMismatchMessage "none"
-	  ModelReferenceCSMismatchMessage "none"
-	  UnknownTsInhSupMsg	  "warning"
-	  ModelReferenceDataLoggingMessage "warning"
-	  ModelReferenceSymbolNameMessage "warning"
-	  ModelReferenceExtraNoncontSigs "error"
-	  StateNameClashWarn	  "warning"
-	  SimStateInterfaceChecksumMismatchMsg "warning"
-	  StrictBusMsg		  "Warning"
-	  LoggingUnavailableSignals "error"
-	  BlockIODiagnostic	  "none"
-	}
-	Simulink.HardwareCC {
-	  $ObjectID		  6
-	  Version		  "1.6.0"
-	  ProdBitPerChar	  8
-	  ProdBitPerShort	  16
-	  ProdBitPerInt		  32
-	  ProdBitPerLong	  32
-	  ProdIntDivRoundTo	  "Undefined"
-	  ProdEndianess		  "Unspecified"
-	  ProdWordSize		  32
-	  ProdShiftRightIntArith  on
-	  ProdHWDeviceType	  "32-bit Generic"
-	  TargetBitPerChar	  8
-	  TargetBitPerShort	  16
-	  TargetBitPerInt	  32
-	  TargetBitPerLong	  32
-	  TargetShiftRightIntArith on
-	  TargetIntDivRoundTo	  "Undefined"
-	  TargetEndianess	  "Unspecified"
-	  TargetWordSize	  32
-	  TargetTypeEmulationWarnSuppressLevel 0
-	  TargetPreprocMaxBitsSint 32
-	  TargetPreprocMaxBitsUint 32
-	  TargetHWDeviceType	  "Specified"
-	  TargetUnknown		  off
-	  ProdEqTarget		  on
-	}
-	Simulink.ModelReferenceCC {
-	  $ObjectID		  7
-	  Version		  "1.6.0"
-	  UpdateModelReferenceTargets "IfOutOfDateOrStructuralChange"
-	  CheckModelReferenceTargetMessage "error"
-	  ModelReferenceNumInstancesAllowed "Multi"
-	  ModelReferencePassRootInputsByReference on
-	  ModelReferenceMinAlgLoopOccurrences off
-	}
-	Simulink.SFSimCC {
-	  $ObjectID		  8
-	  Version		  "1.6.0"
-	  SFSimEnableDebug	  on
-	  SFSimOverflowDetection  on
-	  SFSimEcho		  on
-	  SimBlas		  on
-	  SimCtrlC		  on
-	  SimExtrinsic		  on
-	  SimIntegrity		  on
-	  SimUseLocalCustomCode	  off
-	  SimBuildMode		  "sf_incremental_build"
-	}
-	Simulink.RTWCC {
-	  $BackupClass		  "Simulink.RTWCC"
-	  $ObjectID		  9
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    1
-	    Cell		    "IncludeHyperlinkInReport"
-	    PropName		    "DisabledProps"
-	  }
-	  SystemTargetFile	  "grt.tlc"
-	  GenCodeOnly		  off
-	  MakeCommand		  "make_rtw"
-	  GenerateMakefile	  on
-	  TemplateMakefile	  "grt_default_tmf"
-	  GenerateReport	  off
-	  SaveLog		  off
-	  RTWVerbose		  on
-	  RetainRTWFile		  off
-	  ProfileTLC		  off
-	  TLCDebug		  off
-	  TLCCoverage		  off
-	  TLCAssert		  off
-	  ProcessScriptMode	  "Default"
-	  ConfigurationMode	  "Optimized"
-	  ConfigAtBuild		  off
-	  RTWUseLocalCustomCode	  off
-	  RTWUseSimCustomCode	  off
-	  IncludeHyperlinkInReport off
-	  LaunchReport		  off
-	  TargetLang		  "C"
-	  IncludeBusHierarchyInRTWFileBlockHierarchyMap	off
-	  IncludeERTFirstTime	  off
-	  GenerateTraceInfo	  off
-	  GenerateTraceReport	  off
-	  GenerateTraceReportSl	  off
-	  GenerateTraceReportSf	  off
-	  GenerateTraceReportEml  off
-	  GenerateCodeInfo	  off
-	  RTWCompilerOptimization "Off"
-	  CheckMdlBeforeBuild	  "Off"
-	  Array {
-	    Type		    "Handle"
-	    Dimension		    2
-	    Simulink.CodeAppCC {
-	      $ObjectID		      10
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		16
-		Cell			"IgnoreCustomStorageClasses"
-		Cell			"InsertBlockDesc"
-		Cell			"SFDataObjDesc"
-		Cell			"SimulinkDataObjDesc"
-		Cell			"DefineNamingRule"
-		Cell			"SignalNamingRule"
-		Cell			"ParamNamingRule"
-		Cell			"InlinedPrmAccess"
-		Cell			"CustomSymbolStr"
-		Cell			"CustomSymbolStrGlobalVar"
-		Cell			"CustomSymbolStrType"
-		Cell			"CustomSymbolStrField"
-		Cell			"CustomSymbolStrFcn"
-		Cell			"CustomSymbolStrBlkIO"
-		Cell			"CustomSymbolStrTmpVar"
-		Cell			"CustomSymbolStrMacro"
-		PropName		"DisabledProps"
-	      }
-	      ForceParamTrailComments off
-	      GenerateComments	      on
-	      IgnoreCustomStorageClasses on
-	      IgnoreTestpoints	      off
-	      IncHierarchyInIds	      off
-	      MaxIdLength	      31
-	      PreserveName	      off
-	      PreserveNameWithParent  off
-	      ShowEliminatedStatement off
-	      IncAutoGenComments      off
-	      SimulinkDataObjDesc     off
-	      SFDataObjDesc	      off
-	      IncDataTypeInIds	      off
-	      MangleLength	      1
-	      CustomSymbolStrGlobalVar "$R$N$M"
-	      CustomSymbolStrType     "$N$R$M"
-	      CustomSymbolStrField    "$N$M"
-	      CustomSymbolStrFcn      "$R$N$M$F"
-	      CustomSymbolStrFcnArg   "rt$I$N$M"
-	      CustomSymbolStrBlkIO    "rtb_$N$M"
-	      CustomSymbolStrTmpVar   "$N$M"
-	      CustomSymbolStrMacro    "$R$N$M"
-	      DefineNamingRule	      "None"
-	      ParamNamingRule	      "None"
-	      SignalNamingRule	      "None"
-	      InsertBlockDesc	      off
-	      SimulinkBlockComments   on
-	      EnableCustomComments    off
-	      InlinedPrmAccess	      "Literals"
-	      ReqsInCode	      off
-	      UseSimReservedNames     off
-	    }
-	    Simulink.GRTTargetCC {
-	      $BackupClass	      "Simulink.TargetCC"
-	      $ObjectID		      11
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		13
-		Cell			"IncludeMdlTerminateFcn"
-		Cell			"CombineOutputUpdateFcns"
-		Cell			"SuppressErrorStatus"
-		Cell			"ERTCustomFileBanners"
-		Cell			"GenerateSampleERTMain"
-		Cell			"GenerateTestInterfaces"
-		Cell			"MultiInstanceERTCode"
-		Cell			"PurelyIntegerCode"
-		Cell			"SupportNonFinite"
-		Cell			"SupportComplex"
-		Cell			"SupportAbsoluteTime"
-		Cell			"SupportContinuousTime"
-		Cell			"SupportNonInlinedSFcns"
-		PropName		"DisabledProps"
-	      }
-	      TargetFcnLib	      "ansi_tfl_tmw.mat"
-	      TargetLibSuffix	      ""
-	      TargetPreCompLibLocation ""
-	      TargetFunctionLibrary   "ANSI_C"
-	      UtilityFuncGeneration   "Auto"
-	      ERTMultiwordTypeDef     "System defined"
-	      ERTMultiwordLength      256
-	      MultiwordLength	      2048
-	      GenerateFullHeader      on
-	      GenerateSampleERTMain   off
-	      GenerateTestInterfaces  off
-	      IsPILTarget	      off
-	      ModelReferenceCompliant on
-	      ParMdlRefBuildCompliant on
-	      CompOptLevelCompliant   on
-	      IncludeMdlTerminateFcn  on
-	      GeneratePreprocessorConditionals "Disable all"
-	      CombineOutputUpdateFcns off
-	      SuppressErrorStatus     off
-	      ERTFirstTimeCompliant   off
-	      IncludeFileDelimiter    "Auto"
-	      ERTCustomFileBanners    off
-	      SupportAbsoluteTime     on
-	      LogVarNameModifier      "rt_"
-	      MatFileLogging	      on
-	      MultiInstanceERTCode    off
-	      SupportNonFinite	      on
-	      SupportComplex	      on
-	      PurelyIntegerCode	      off
-	      SupportContinuousTime   on
-	      SupportNonInlinedSFcns  on
-	      SupportVariableSizeSignals off
-	      EnableShiftOperators    on
-	      ParenthesesLevel	      "Nominal"
-	      PortableWordSizes	      off
-	      ModelStepFunctionPrototypeControlCompliant off
-	      CPPClassGenCompliant    off
-	      AutosarCompliant	      off
-	      UseMalloc		      off
-	      ExtMode		      off
-	      ExtModeStaticAlloc      off
-	      ExtModeTesting	      off
-	      ExtModeStaticAllocSize  1000000
-	      ExtModeTransport	      0
-	      ExtModeMexFile	      "ext_comm"
-	      ExtModeIntrfLevel	      "Level1"
-	      RTWCAPISignals	      off
-	      RTWCAPIParams	      off
-	      RTWCAPIStates	      off
-	      GenerateASAP2	      off
-	    }
-	    PropName		    "Components"
-	  }
-	}
-	PropName		"Components"
-      }
-      Name		      "Configuration"
-      CurrentDlgPage	      "Solver"
-      ConfigPrmDlgPosition    " [ 200, 197, 1080, 827 ] "
-    }
-    PropName		    "ConfigurationSets"
-  }
-  Simulink.ConfigSet {
-    $PropName		    "ActiveConfigurationSet"
-    $ObjectID		    1
-  }
-  BlockDefaults {
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    NamePlacement	    "normal"
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    ShowName		    on
-    BlockRotation	    0
-    BlockMirror		    off
-  }
-  AnnotationDefaults {
-    HorizontalAlignment	    "center"
-    VerticalAlignment	    "middle"
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    UseDisplayTextAsClickCallback off
-  }
-  LineDefaults {
-    FontName		    "Courier"
-    FontSize		    9
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-  }
-  BlockParameterDefaults {
-    Block {
-      BlockType		      FromWorkspace
-      VariableName	      "simulink_input"
-      SampleTime	      "-1"
-      Interpolate	      on
-      ZeroCross		      off
-      OutputAfterFinalValue   "Extrapolation"
-    }
-    Block {
-      BlockType		      "S-Function"
-      FunctionName	      "system"
-      SFunctionModules	      "''"
-      PortCounts	      "[]"
-      SFunctionDeploymentMode off
-    }
-    Block {
-      BlockType		      Scope
-      ModelBased	      off
-      TickLabels	      "OneTimeTick"
-      ZoomMode		      "on"
-      Grid		      "on"
-      TimeRange		      "auto"
-      YMin		      "-5"
-      YMax		      "5"
-      SaveToWorkspace	      off
-      SaveName		      "ScopeData"
-      LimitDataPoints	      on
-      MaxDataPoints	      "5000"
-      Decimation	      "1"
-      SampleInput	      off
-      SampleTime	      "-1"
-    }
-  }
-  System {
-    Name		    "example_QProblemB"
-    Location		    [1922, 224, 3598, 1179]
-    Open		    on
-    ModelBrowserVisibility  off
-    ModelBrowserWidth	    200
-    ScreenColor		    "white"
-    PaperOrientation	    "landscape"
-    PaperPositionMode	    "auto"
-    PaperType		    "usletter"
-    PaperUnits		    "inches"
-    TiledPaperMargins	    [0.500000, 0.500000, 0.500000, 0.500000]
-    TiledPageScale	    1
-    ShowPageBoundaries	    off
-    ZoomFactor		    "125"
-    ReportName		    "simulink-default.rpt"
-    SIDHighWatermark	    6
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "g"
-      SID		      2
-      Position		      [170, 153, 235, 177]
-      VariableName	      "g"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "lb"
-      SID		      3
-      Position		      [170, 203, 235, 227]
-      VariableName	      "lb"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      "S-Function"
-      Name		      "qpOASES"
-      SID		      6
-      Ports		      [3, 4]
-      Position		      [505, 180, 700, 245]
-      BackgroundColor	      "yellow"
-      FunctionName	      "qpOASES_QProblemB"
-      Parameters	      "H"
-      EnableBusSupport	      off
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "ub"
-      SID		      4
-      Position		      [170, 253, 235, 277]
-      VariableName	      "ub"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      Scope
-      Name		      "x,\nfval,\nexitflag,\niter"
-      SID		      5
-      Ports		      [4]
-      Position		      [855, 185, 905, 240]
-      Floating		      off
-      Location		      [6, 78, 1276, 993]
-      Open		      off
-      NumInputPorts	      "4"
-      List {
-	ListType		AxesTitles
-	axes1			"%<SignalLabel>"
-	axes2			"%<SignalLabel>"
-	axes3			"%<SignalLabel>"
-	axes4			"%<SignalLabel>"
-      }
-      YMin		      "-5~-5~-5~-5"
-      YMax		      "5~5~5~5"
-      SaveName		      "ScopeData1"
-      DataFormat	      "StructureWithTime"
-      SampleTime	      "0"
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      1
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      2
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      2
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      3
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      3
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      4
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      4
-    }
-    Line {
-      SrcBlock		      "g"
-      SrcPort		      1
-      Points		      [50, 0; 0, 30]
-      DstBlock		      "qpOASES"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "lb"
-      SrcPort		      1
-      DstBlock		      "qpOASES"
-      DstPort		      2
-    }
-    Line {
-      SrcBlock		      "ub"
-      SrcPort		      1
-      Points		      [50, 0; 0, -30]
-      DstBlock		      "qpOASES"
-      DstPort		      3
-    }
-    Annotation {
-      Position		      [335, 96]
-    }
-    Annotation {
-      Name		      "This file is part of qpOASES.\n\nqpOASES -- An Implementation of the Online Active Set Strategy.\nC"
-      "opyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka, Christian Kirches et al.\nAll rights reserved."
-      Position		      [608, 108]
-    }
-  }
-}
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_SQProblem.mdl b/extlibs/qpOASES-3.2.0/interfaces/simulink/example_SQProblem.mdl
deleted file mode 100644
index 1f7a9f3..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/example_SQProblem.mdl
+++ /dev/null
@@ -1,797 +0,0 @@
-Model {
-  Name			  "example_SQProblem"
-  Version		  7.4
-  MdlSubVersion		  0
-  GraphicalInterface {
-    NumRootInports	    0
-    NumRootOutports	    0
-    ParameterArgumentNames  ""
-    ComputedModelVersion    "1.67"
-    NumModelReferences	    0
-    NumTestPointedSignals   0
-  }
-  SavedCharacterEncoding  "UTF-8"
-  SaveDefaultBlockParams  on
-  ScopeRefreshTime	  0.035000
-  OverrideScopeRefreshTime on
-  DisableAllScopes	  off
-  DataTypeOverride	  "UseLocalSettings"
-  MinMaxOverflowLogging	  "UseLocalSettings"
-  MinMaxOverflowArchiveMode "Overwrite"
-  MaxMDLFileLineLength	  120
-  Created		  "Fri Apr 13 11:08:51 2007"
-  Creator		  "jferreau"
-  UpdateHistory		  "UpdateHistoryNever"
-  ModifiedByFormat	  "%<Auto>"
-  LastModifiedBy	  "chjofer2"
-  ModifiedDateFormat	  "%<Auto>"
-  LastModifiedDate	  "Wed Jan 07 09:31:42 2015"
-  RTWModifiedTimeStamp	  342523898
-  ModelVersionFormat	  "1.%<AutoIncrement:67>"
-  ConfigurationManager	  "None"
-  SampleTimeColors	  off
-  SampleTimeAnnotations	  off
-  LibraryLinkDisplay	  "none"
-  WideLines		  off
-  ShowLineDimensions	  off
-  ShowPortDataTypes	  off
-  ShowLoopsOnError	  on
-  IgnoreBidirectionalLines off
-  ShowStorageClass	  off
-  ShowTestPointIcons	  on
-  ShowSignalResolutionIcons on
-  ShowViewerIcons	  on
-  SortedOrder		  off
-  ExecutionContextIcon	  off
-  ShowLinearizationAnnotations on
-  BlockNameDataTip	  off
-  BlockParametersDataTip  off
-  BlockDescriptionStringDataTip	off
-  ToolBar		  on
-  StatusBar		  on
-  BrowserShowLibraryLinks off
-  BrowserLookUnderMasks	  off
-  SimulationMode	  "normal"
-  LinearizationMsg	  "none"
-  Profile		  off
-  ParamWorkspaceSource	  "MATLABWorkspace"
-  AccelSystemTargetFile	  "accel.tlc"
-  AccelTemplateMakefile	  "accel_default_tmf"
-  AccelMakeCommand	  "make_rtw"
-  TryForcingSFcnDF	  off
-  RecordCoverage	  off
-  CovPath		  "/"
-  CovSaveName		  "covdata"
-  CovMetricSettings	  "dw"
-  CovNameIncrementing	  off
-  CovHtmlReporting	  on
-  CovForceBlockReductionOff on
-  covSaveCumulativeToWorkspaceVar on
-  CovSaveSingleToWorkspaceVar on
-  CovCumulativeVarName	  "covCumulativeData"
-  CovCumulativeReport	  off
-  CovReportOnPause	  on
-  CovModelRefEnable	  "Off"
-  CovExternalEMLEnable	  off
-  ExtModeBatchMode	  off
-  ExtModeEnableFloating	  on
-  ExtModeTrigType	  "manual"
-  ExtModeTrigMode	  "normal"
-  ExtModeTrigPort	  "1"
-  ExtModeTrigElement	  "any"
-  ExtModeTrigDuration	  1000
-  ExtModeTrigDurationFloating "auto"
-  ExtModeTrigHoldOff	  0
-  ExtModeTrigDelay	  0
-  ExtModeTrigDirection	  "rising"
-  ExtModeTrigLevel	  0
-  ExtModeArchiveMode	  "off"
-  ExtModeAutoIncOneShot	  off
-  ExtModeIncDirWhenArm	  off
-  ExtModeAddSuffixToVar	  off
-  ExtModeWriteAllDataToWs off
-  ExtModeArmWhenConnect	  on
-  ExtModeSkipDownloadWhenConnect off
-  ExtModeLogAll		  on
-  ExtModeAutoUpdateStatusClock off
-  BufferReuse		  on
-  ShowModelReferenceBlockVersion off
-  ShowModelReferenceBlockIO off
-  Array {
-    Type		    "Handle"
-    Dimension		    1
-    Simulink.ConfigSet {
-      $ObjectID		      1
-      Version		      "1.6.0"
-      Array {
-	Type			"Handle"
-	Dimension		8
-	Simulink.SolverCC {
-	  $ObjectID		  2
-	  Version		  "1.6.0"
-	  StartTime		  "0.0"
-	  StopTime		  "0.5"
-	  AbsTol		  "auto"
-	  FixedStep		  "auto"
-	  InitialStep		  "auto"
-	  MaxNumMinSteps	  "-1"
-	  MaxOrder		  5
-	  ZcThreshold		  "auto"
-	  ConsecutiveZCsStepRelTol "10*128*eps"
-	  MaxConsecutiveZCs	  "1000"
-	  ExtrapolationOrder	  4
-	  NumberNewtonIterations  1
-	  MaxStep		  "auto"
-	  MinStep		  "auto"
-	  MaxConsecutiveMinStep	  "1"
-	  RelTol		  "1e-3"
-	  SolverMode		  "Auto"
-	  Solver		  "VariableStepDiscrete"
-	  SolverName		  "VariableStepDiscrete"
-	  ShapePreserveControl	  "DisableAll"
-	  ZeroCrossControl	  "UseLocalSettings"
-	  ZeroCrossAlgorithm	  "Nonadaptive"
-	  AlgebraicLoopSolver	  "TrustRegion"
-	  SolverResetMethod	  "Fast"
-	  PositivePriorityOrder	  off
-	  AutoInsertRateTranBlk	  off
-	  SampleTimeConstraint	  "Unconstrained"
-	  InsertRTBMode		  "Whenever possible"
-	}
-	Simulink.DataIOCC {
-	  $ObjectID		  3
-	  Version		  "1.6.0"
-	  Decimation		  "1"
-	  ExternalInput		  "[t, u]"
-	  FinalStateName	  "xFinal"
-	  InitialState		  "xInitial"
-	  LimitDataPoints	  on
-	  MaxDataPoints		  "1000"
-	  LoadExternalInput	  off
-	  LoadInitialState	  off
-	  SaveFinalState	  off
-	  SaveCompleteFinalSimState off
-	  SaveFormat		  "Array"
-	  SaveOutput		  on
-	  SaveState		  off
-	  SignalLogging		  on
-	  InspectSignalLogs	  off
-	  SaveTime		  on
-	  ReturnWorkspaceOutputs  off
-	  StateSaveName		  "xout"
-	  TimeSaveName		  "tout"
-	  OutputSaveName	  "yout"
-	  SignalLoggingName	  "logsout"
-	  OutputOption		  "RefineOutputTimes"
-	  OutputTimes		  "[]"
-	  ReturnWorkspaceOutputsName "out"
-	  Refine		  "1"
-	}
-	Simulink.OptimizationCC {
-	  $ObjectID		  4
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    4
-	    Cell		    "ZeroExternalMemoryAtStartup"
-	    Cell		    "ZeroInternalMemoryAtStartup"
-	    Cell		    "NoFixptDivByZeroProtection"
-	    Cell		    "OptimizeModelRefInitCode"
-	    PropName		    "DisabledProps"
-	  }
-	  BlockReduction	  on
-	  BooleanDataType	  on
-	  ConditionallyExecuteInputs on
-	  InlineParams		  off
-	  UseIntDivNetSlope	  off
-	  InlineInvariantSignals  off
-	  OptimizeBlockIOStorage  on
-	  BufferReuse		  on
-	  EnhancedBackFolding	  off
-	  StrengthReduction	  off
-	  EnforceIntegerDowncast  on
-	  ExpressionFolding	  on
-	  BooleansAsBitfields	  off
-	  EnableMemcpy		  on
-	  MemcpyThreshold	  64
-	  PassReuseOutputArgsAs	  "Structure reference"
-	  ExpressionDepthLimit	  2147483647
-	  FoldNonRolledExpr	  on
-	  LocalBlockOutputs	  on
-	  RollThreshold		  5
-	  SystemCodeInlineAuto	  off
-	  StateBitsets		  off
-	  DataBitsets		  off
-	  UseTempVars		  off
-	  ZeroExternalMemoryAtStartup on
-	  ZeroInternalMemoryAtStartup on
-	  InitFltsAndDblsToZero	  on
-	  NoFixptDivByZeroProtection off
-	  EfficientFloat2IntCast  off
-	  EfficientMapNaN2IntZero on
-	  OptimizeModelRefInitCode off
-	  LifeSpan		  "inf"
-	  BufferReusableBoundary  on
-	  SimCompilerOptimization "Off"
-	  AccelVerboseBuild	  off
-	}
-	Simulink.DebuggingCC {
-	  $ObjectID		  5
-	  Version		  "1.6.0"
-	  RTPrefix		  "error"
-	  ConsistencyChecking	  "none"
-	  ArrayBoundsChecking	  "none"
-	  SignalInfNanChecking	  "none"
-	  SignalRangeChecking	  "none"
-	  ReadBeforeWriteMsg	  "UseLocalSettings"
-	  WriteAfterWriteMsg	  "UseLocalSettings"
-	  WriteAfterReadMsg	  "UseLocalSettings"
-	  AlgebraicLoopMsg	  "warning"
-	  ArtificialAlgebraicLoopMsg "warning"
-	  SaveWithDisabledLinksMsg "warning"
-	  SaveWithParameterizedLinksMsg	"none"
-	  CheckSSInitialOutputMsg on
-	  UnderspecifiedInitializationDetection	"Classic"
-	  MergeDetectMultiDrivingBlocksExec "none"
-	  CheckExecutionContextPreStartOutputMsg off
-	  CheckExecutionContextRuntimeOutputMsg	off
-	  SignalResolutionControl "TryResolveAllWithWarning"
-	  BlockPriorityViolationMsg "warning"
-	  MinStepSizeMsg	  "warning"
-	  TimeAdjustmentMsg	  "none"
-	  MaxConsecutiveZCsMsg	  "error"
-	  SolverPrmCheckMsg	  "warning"
-	  InheritedTsInSrcMsg	  "warning"
-	  DiscreteInheritContinuousMsg "warning"
-	  MultiTaskDSMMsg	  "error"
-	  MultiTaskCondExecSysMsg "error"
-	  MultiTaskRateTransMsg	  "error"
-	  SingleTaskRateTransMsg  "none"
-	  TasksWithSamePriorityMsg "warning"
-	  SigSpecEnsureSampleTimeMsg "warning"
-	  CheckMatrixSingularityMsg "none"
-	  IntegerOverflowMsg	  "warning"
-	  Int32ToFloatConvMsg	  "warning"
-	  ParameterDowncastMsg	  "error"
-	  ParameterOverflowMsg	  "error"
-	  ParameterUnderflowMsg	  "none"
-	  ParameterPrecisionLossMsg "warning"
-	  ParameterTunabilityLossMsg "warning"
-	  FixptConstUnderflowMsg  "none"
-	  FixptConstOverflowMsg	  "none"
-	  FixptConstPrecisionLossMsg "none"
-	  UnderSpecifiedDataTypeMsg "none"
-	  UnnecessaryDatatypeConvMsg "none"
-	  VectorMatrixConversionMsg "none"
-	  InvalidFcnCallConnMsg	  "error"
-	  FcnCallInpInsideContextMsg "Use local settings"
-	  SignalLabelMismatchMsg  "none"
-	  UnconnectedInputMsg	  "warning"
-	  UnconnectedOutputMsg	  "warning"
-	  UnconnectedLineMsg	  "warning"
-	  SFcnCompatibilityMsg	  "none"
-	  UniqueDataStoreMsg	  "none"
-	  BusObjectLabelMismatch  "warning"
-	  RootOutportRequireBusObject "warning"
-	  AssertControl		  "UseLocalSettings"
-	  EnableOverflowDetection off
-	  ModelReferenceIOMsg	  "none"
-	  ModelReferenceVersionMismatchMessage "none"
-	  ModelReferenceIOMismatchMessage "none"
-	  ModelReferenceCSMismatchMessage "none"
-	  UnknownTsInhSupMsg	  "warning"
-	  ModelReferenceDataLoggingMessage "warning"
-	  ModelReferenceSymbolNameMessage "warning"
-	  ModelReferenceExtraNoncontSigs "error"
-	  StateNameClashWarn	  "warning"
-	  SimStateInterfaceChecksumMismatchMsg "warning"
-	  StrictBusMsg		  "Warning"
-	  LoggingUnavailableSignals "error"
-	  BlockIODiagnostic	  "none"
-	}
-	Simulink.HardwareCC {
-	  $ObjectID		  6
-	  Version		  "1.6.0"
-	  ProdBitPerChar	  8
-	  ProdBitPerShort	  16
-	  ProdBitPerInt		  32
-	  ProdBitPerLong	  32
-	  ProdIntDivRoundTo	  "Undefined"
-	  ProdEndianess		  "Unspecified"
-	  ProdWordSize		  32
-	  ProdShiftRightIntArith  on
-	  ProdHWDeviceType	  "32-bit Generic"
-	  TargetBitPerChar	  8
-	  TargetBitPerShort	  16
-	  TargetBitPerInt	  32
-	  TargetBitPerLong	  32
-	  TargetShiftRightIntArith on
-	  TargetIntDivRoundTo	  "Undefined"
-	  TargetEndianess	  "Unspecified"
-	  TargetWordSize	  32
-	  TargetTypeEmulationWarnSuppressLevel 0
-	  TargetPreprocMaxBitsSint 32
-	  TargetPreprocMaxBitsUint 32
-	  TargetHWDeviceType	  "Specified"
-	  TargetUnknown		  off
-	  ProdEqTarget		  on
-	}
-	Simulink.ModelReferenceCC {
-	  $ObjectID		  7
-	  Version		  "1.6.0"
-	  UpdateModelReferenceTargets "IfOutOfDateOrStructuralChange"
-	  CheckModelReferenceTargetMessage "error"
-	  ModelReferenceNumInstancesAllowed "Multi"
-	  ModelReferencePassRootInputsByReference on
-	  ModelReferenceMinAlgLoopOccurrences off
-	}
-	Simulink.SFSimCC {
-	  $ObjectID		  8
-	  Version		  "1.6.0"
-	  SFSimEnableDebug	  on
-	  SFSimOverflowDetection  on
-	  SFSimEcho		  on
-	  SimBlas		  on
-	  SimCtrlC		  on
-	  SimExtrinsic		  on
-	  SimIntegrity		  on
-	  SimUseLocalCustomCode	  off
-	  SimBuildMode		  "sf_incremental_build"
-	}
-	Simulink.RTWCC {
-	  $BackupClass		  "Simulink.RTWCC"
-	  $ObjectID		  9
-	  Version		  "1.6.0"
-	  Array {
-	    Type		    "Cell"
-	    Dimension		    1
-	    Cell		    "IncludeHyperlinkInReport"
-	    PropName		    "DisabledProps"
-	  }
-	  SystemTargetFile	  "grt.tlc"
-	  GenCodeOnly		  off
-	  MakeCommand		  "make_rtw"
-	  GenerateMakefile	  on
-	  TemplateMakefile	  "grt_default_tmf"
-	  GenerateReport	  off
-	  SaveLog		  off
-	  RTWVerbose		  on
-	  RetainRTWFile		  off
-	  ProfileTLC		  off
-	  TLCDebug		  off
-	  TLCCoverage		  off
-	  TLCAssert		  off
-	  ProcessScriptMode	  "Default"
-	  ConfigurationMode	  "Optimized"
-	  ConfigAtBuild		  off
-	  RTWUseLocalCustomCode	  off
-	  RTWUseSimCustomCode	  off
-	  IncludeHyperlinkInReport off
-	  LaunchReport		  off
-	  TargetLang		  "C"
-	  IncludeBusHierarchyInRTWFileBlockHierarchyMap	off
-	  IncludeERTFirstTime	  off
-	  GenerateTraceInfo	  off
-	  GenerateTraceReport	  off
-	  GenerateTraceReportSl	  off
-	  GenerateTraceReportSf	  off
-	  GenerateTraceReportEml  off
-	  GenerateCodeInfo	  off
-	  RTWCompilerOptimization "Off"
-	  CheckMdlBeforeBuild	  "Off"
-	  Array {
-	    Type		    "Handle"
-	    Dimension		    2
-	    Simulink.CodeAppCC {
-	      $ObjectID		      10
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		16
-		Cell			"IgnoreCustomStorageClasses"
-		Cell			"InsertBlockDesc"
-		Cell			"SFDataObjDesc"
-		Cell			"SimulinkDataObjDesc"
-		Cell			"DefineNamingRule"
-		Cell			"SignalNamingRule"
-		Cell			"ParamNamingRule"
-		Cell			"InlinedPrmAccess"
-		Cell			"CustomSymbolStr"
-		Cell			"CustomSymbolStrGlobalVar"
-		Cell			"CustomSymbolStrType"
-		Cell			"CustomSymbolStrField"
-		Cell			"CustomSymbolStrFcn"
-		Cell			"CustomSymbolStrBlkIO"
-		Cell			"CustomSymbolStrTmpVar"
-		Cell			"CustomSymbolStrMacro"
-		PropName		"DisabledProps"
-	      }
-	      ForceParamTrailComments off
-	      GenerateComments	      on
-	      IgnoreCustomStorageClasses on
-	      IgnoreTestpoints	      off
-	      IncHierarchyInIds	      off
-	      MaxIdLength	      31
-	      PreserveName	      off
-	      PreserveNameWithParent  off
-	      ShowEliminatedStatement off
-	      IncAutoGenComments      off
-	      SimulinkDataObjDesc     off
-	      SFDataObjDesc	      off
-	      IncDataTypeInIds	      off
-	      MangleLength	      1
-	      CustomSymbolStrGlobalVar "$R$N$M"
-	      CustomSymbolStrType     "$N$R$M"
-	      CustomSymbolStrField    "$N$M"
-	      CustomSymbolStrFcn      "$R$N$M$F"
-	      CustomSymbolStrFcnArg   "rt$I$N$M"
-	      CustomSymbolStrBlkIO    "rtb_$N$M"
-	      CustomSymbolStrTmpVar   "$N$M"
-	      CustomSymbolStrMacro    "$R$N$M"
-	      DefineNamingRule	      "None"
-	      ParamNamingRule	      "None"
-	      SignalNamingRule	      "None"
-	      InsertBlockDesc	      off
-	      SimulinkBlockComments   on
-	      EnableCustomComments    off
-	      InlinedPrmAccess	      "Literals"
-	      ReqsInCode	      off
-	      UseSimReservedNames     off
-	    }
-	    Simulink.GRTTargetCC {
-	      $BackupClass	      "Simulink.TargetCC"
-	      $ObjectID		      11
-	      Version		      "1.6.0"
-	      Array {
-		Type			"Cell"
-		Dimension		13
-		Cell			"IncludeMdlTerminateFcn"
-		Cell			"CombineOutputUpdateFcns"
-		Cell			"SuppressErrorStatus"
-		Cell			"ERTCustomFileBanners"
-		Cell			"GenerateSampleERTMain"
-		Cell			"GenerateTestInterfaces"
-		Cell			"MultiInstanceERTCode"
-		Cell			"PurelyIntegerCode"
-		Cell			"SupportNonFinite"
-		Cell			"SupportComplex"
-		Cell			"SupportAbsoluteTime"
-		Cell			"SupportContinuousTime"
-		Cell			"SupportNonInlinedSFcns"
-		PropName		"DisabledProps"
-	      }
-	      TargetFcnLib	      "ansi_tfl_tmw.mat"
-	      TargetLibSuffix	      ""
-	      TargetPreCompLibLocation ""
-	      TargetFunctionLibrary   "ANSI_C"
-	      UtilityFuncGeneration   "Auto"
-	      ERTMultiwordTypeDef     "System defined"
-	      ERTMultiwordLength      256
-	      MultiwordLength	      2048
-	      GenerateFullHeader      on
-	      GenerateSampleERTMain   off
-	      GenerateTestInterfaces  off
-	      IsPILTarget	      off
-	      ModelReferenceCompliant on
-	      ParMdlRefBuildCompliant on
-	      CompOptLevelCompliant   on
-	      IncludeMdlTerminateFcn  on
-	      GeneratePreprocessorConditionals "Disable all"
-	      CombineOutputUpdateFcns off
-	      SuppressErrorStatus     off
-	      ERTFirstTimeCompliant   off
-	      IncludeFileDelimiter    "Auto"
-	      ERTCustomFileBanners    off
-	      SupportAbsoluteTime     on
-	      LogVarNameModifier      "rt_"
-	      MatFileLogging	      on
-	      MultiInstanceERTCode    off
-	      SupportNonFinite	      on
-	      SupportComplex	      on
-	      PurelyIntegerCode	      off
-	      SupportContinuousTime   on
-	      SupportNonInlinedSFcns  on
-	      SupportVariableSizeSignals off
-	      EnableShiftOperators    on
-	      ParenthesesLevel	      "Nominal"
-	      PortableWordSizes	      off
-	      ModelStepFunctionPrototypeControlCompliant off
-	      CPPClassGenCompliant    off
-	      AutosarCompliant	      off
-	      UseMalloc		      off
-	      ExtMode		      off
-	      ExtModeStaticAlloc      off
-	      ExtModeTesting	      off
-	      ExtModeStaticAllocSize  1000000
-	      ExtModeTransport	      0
-	      ExtModeMexFile	      "ext_comm"
-	      ExtModeIntrfLevel	      "Level1"
-	      RTWCAPISignals	      off
-	      RTWCAPIParams	      off
-	      RTWCAPIStates	      off
-	      GenerateASAP2	      off
-	    }
-	    PropName		    "Components"
-	  }
-	}
-	PropName		"Components"
-      }
-      Name		      "Configuration"
-      CurrentDlgPage	      "Solver"
-      ConfigPrmDlgPosition    " [ 200, 197, 1080, 827 ] "
-    }
-    PropName		    "ConfigurationSets"
-  }
-  Simulink.ConfigSet {
-    $PropName		    "ActiveConfigurationSet"
-    $ObjectID		    1
-  }
-  BlockDefaults {
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    NamePlacement	    "normal"
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    ShowName		    on
-    BlockRotation	    0
-    BlockMirror		    off
-  }
-  AnnotationDefaults {
-    HorizontalAlignment	    "center"
-    VerticalAlignment	    "middle"
-    ForegroundColor	    "black"
-    BackgroundColor	    "white"
-    DropShadow		    off
-    FontName		    "Courier"
-    FontSize		    10
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-    UseDisplayTextAsClickCallback off
-  }
-  LineDefaults {
-    FontName		    "Courier"
-    FontSize		    9
-    FontWeight		    "normal"
-    FontAngle		    "normal"
-  }
-  BlockParameterDefaults {
-    Block {
-      BlockType		      FromWorkspace
-      VariableName	      "simulink_input"
-      SampleTime	      "-1"
-      Interpolate	      on
-      ZeroCross		      off
-      OutputAfterFinalValue   "Extrapolation"
-    }
-    Block {
-      BlockType		      "S-Function"
-      FunctionName	      "system"
-      SFunctionModules	      "''"
-      PortCounts	      "[]"
-      SFunctionDeploymentMode off
-    }
-    Block {
-      BlockType		      Scope
-      ModelBased	      off
-      TickLabels	      "OneTimeTick"
-      ZoomMode		      "on"
-      Grid		      "on"
-      TimeRange		      "auto"
-      YMin		      "-5"
-      YMax		      "5"
-      SaveToWorkspace	      off
-      SaveName		      "ScopeData"
-      LimitDataPoints	      on
-      MaxDataPoints	      "5000"
-      Decimation	      "1"
-      SampleInput	      off
-      SampleTime	      "-1"
-    }
-  }
-  System {
-    Name		    "example_SQProblem"
-    Location		    [122, 122, 1798, 1077]
-    Open		    on
-    ModelBrowserVisibility  off
-    ModelBrowserWidth	    200
-    ScreenColor		    "white"
-    PaperOrientation	    "landscape"
-    PaperPositionMode	    "auto"
-    PaperType		    "usletter"
-    PaperUnits		    "inches"
-    TiledPaperMargins	    [0.500000, 0.500000, 0.500000, 0.500000]
-    TiledPageScale	    1
-    ShowPageBoundaries	    off
-    ZoomFactor		    "125"
-    ReportName		    "simulink-default.rpt"
-    SIDHighWatermark	    14
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "A"
-      SID		      3
-      Position		      [100, 198, 165, 222]
-      VariableName	      "A"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "H"
-      SID		      1
-      Position		      [100, 98, 165, 122]
-      VariableName	      "H"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "g"
-      SID		      2
-      Position		      [100, 148, 165, 172]
-      VariableName	      "g"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "lb"
-      SID		      4
-      Position		      [100, 248, 165, 272]
-      VariableName	      "lb"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "lbA"
-      SID		      6
-      Position		      [100, 348, 165, 372]
-      VariableName	      "lbA"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      "S-Function"
-      Name		      "qpOASES"
-      SID		      9
-      Ports		      [7, 4]
-      Position		      [590, 224, 790, 296]
-      BackgroundColor	      "yellow"
-      FunctionName	      "qpOASES_SQProblem"
-      EnableBusSupport	      off
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "ub"
-      SID		      5
-      Position		      [100, 298, 165, 322]
-      VariableName	      "ub"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      FromWorkspace
-      Name		      "ubA"
-      SID		      7
-      Position		      [100, 398, 165, 422]
-      VariableName	      "ubA"
-      SampleTime	      "0.1"
-      ZeroCross		      on
-      OutputAfterFinalValue   "Holding final value"
-    }
-    Block {
-      BlockType		      Scope
-      Name		      "x,\nfval,\nexitflag,\niter"
-      SID		      8
-      Ports		      [4]
-      Position		      [950, 223, 1005, 297]
-      Floating		      off
-      Location		      [6, 78, 1276, 993]
-      Open		      off
-      NumInputPorts	      "4"
-      List {
-	ListType		AxesTitles
-	axes1			"%<SignalLabel>"
-	axes2			"%<SignalLabel>"
-	axes3			"%<SignalLabel>"
-	axes4			"%<SignalLabel>"
-      }
-      YMin		      "-5~-5~-5~-5"
-      YMax		      "5~5~5~5"
-      SaveName		      "ScopeData1"
-      DataFormat	      "StructureWithTime"
-      SampleTime	      "0"
-    }
-    Line {
-      SrcBlock		      "H"
-      SrcPort		      1
-      Points		      [155, 0; 0, 120]
-      DstBlock		      "qpOASES"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "g"
-      SrcPort		      1
-      Points		      [115, 0; 0, 80]
-      DstBlock		      "qpOASES"
-      DstPort		      2
-    }
-    Line {
-      Labels		      [3, 0]
-      SrcBlock		      "ubA"
-      SrcPort		      1
-      Points		      [160, 0; 0, -120]
-      DstBlock		      "qpOASES"
-      DstPort		      7
-    }
-    Line {
-      SrcBlock		      "ub"
-      SrcPort		      1
-      Points		      [80, 0; 0, -40]
-      DstBlock		      "qpOASES"
-      DstPort		      5
-    }
-    Line {
-      SrcBlock		      "lb"
-      SrcPort		      1
-      DstBlock		      "qpOASES"
-      DstPort		      4
-    }
-    Line {
-      SrcBlock		      "A"
-      SrcPort		      1
-      Points		      [80, 0; 0, 40]
-      DstBlock		      "qpOASES"
-      DstPort		      3
-    }
-    Line {
-      Labels		      [3, 0]
-      SrcBlock		      "lbA"
-      SrcPort		      1
-      Points		      [115, 0; 0, -80]
-      DstBlock		      "qpOASES"
-      DstPort		      6
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      1
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      1
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      2
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      2
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      3
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      3
-    }
-    Line {
-      SrcBlock		      "qpOASES"
-      SrcPort		      4
-      DstBlock		      "x,\nfval,\nexitflag,\niter"
-      DstPort		      4
-    }
-    Annotation {
-      Position		      [350, 96]
-    }
-    Annotation {
-      Name		      "This file is part of qpOASES.\n\nqpOASES -- An Implementation of the Online Active Set Strategy.\nC"
-      "opyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka, Christian Kirches et al.\nAll rights reserved."
-      Position		      [683, 128]
-    }
-  }
-}
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblem.m b/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblem.m
deleted file mode 100644
index f1d8eab..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblem.m
+++ /dev/null
@@ -1,86 +0,0 @@
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-
-
-%%
-%%	Filename:  interfaces/simulink/load_example_QProblem.m
-%%	Author:    Hans Joachim Ferreau (thanks to Aude Perrin)
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-
-
-clear all;
-
-
-%% setup QP data
-simulationTime = [0;0.1];
-
-H = [ 1.0,0.0; ...
-      0.0,0.5 ];
-
-A = [ 1.0,1.0 ];
-
-g.time = simulationTime;
-data1 = [ 1.5,1.0 ];
-data2 = [ 1.0,1.5 ];
-g.signals.values = [data1; data2];
-g.signals.dimensions = numel(data1);
-
-lb.time = simulationTime;
-data1 = [ 0.5,-2.0 ];
-data2 = [ 0.0,-1.0 ];
-lb.signals.values = [data1; data2];
-lb.signals.dimensions = numel(data1);
-
-ub.time = simulationTime;
-data1 = [ 5.0,2.0 ];
-data2 = [ 5.0,-0.5 ];
-ub.signals.values = [data1; data2];
-ub.signals.dimensions = numel(data1);
-
-lbA.time = simulationTime;
-data1 = [ -1.0 ];
-data2 = [ -2.0 ];
-lbA.signals.values = [data1; data2];
-lbA.signals.dimensions = numel(data1);
-
-ubA.time = simulationTime;
-data1 = [ 2.0 ];
-data2 = [ 1.0 ];
-ubA.signals.values = [data1; data2];
-ubA.signals.dimensions = numel(data1);
-
-
-clear simulationTime data1 data2
-
-
-%% open corresponding simulink example
-open( 'example_QProblem.mdl' );
-
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblemB.m b/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblemB.m
deleted file mode 100644
index d0bbd1b..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_QProblemB.m
+++ /dev/null
@@ -1,72 +0,0 @@
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-
-
-%%
-%%	Filename:  interfaces/simulink/load_example_QProblemB.m
-%%	Author:    Hans Joachim Ferreau (thanks to Aude Perrin)
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-
-
-clear all;
-
-
-%% setup QP data
-simulationTime = [0;0.1];
-
-H = [ 1.0,0.0; ...
-      0.0,0.5 ];
-
-g.time = simulationTime;
-data1 = [ 1.5,1.0 ];
-data2 = [ 1.0,1.5 ];
-g.signals.values = [data1; data2];
-g.signals.dimensions = numel(data1);
-
-lb.time = simulationTime;
-data1 = [ 0.5,-2.0 ];
-data2 = [ 0.0,-1.0 ];
-lb.signals.values = [data1; data2];
-lb.signals.dimensions = numel(data1);
-
-ub.time = simulationTime;
-data1 = [ 5.0,2.0 ];
-data2 = [ 5.0,-0.5 ];
-ub.signals.values = [data1; data2];
-ub.signals.dimensions = numel(data1);
-
-
-clear simulationTime data1 data2
-
-
-%% open corresponding simulink example
-open( 'example_QProblemB.mdl' );
-
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_SQProblem.m b/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_SQProblem.m
deleted file mode 100644
index 16c0f16..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/load_example_SQProblem.m
+++ /dev/null
@@ -1,95 +0,0 @@
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-
-
-%%
-%%	Filename:  interfaces/simulink/load_example_SQProblem.m
-%%	Author:    Hans Joachim Ferreau (thanks to Aude Perrin)
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-
-
-clear all;
-
-
-%% setup QP data
-simulationTime = [0;0.1];
-
-H.time = simulationTime;
-data1 = [ 1.0,0.0; ...
-          0.0,0.5 ];
-data2 = [ 1.0,0.5; ...
-          0.5,0.5 ];
-H.signals.values = [ data1(:)'; data2(:)' ];
-H.signals.dimensions = numel(data1);
-
-g.time = simulationTime;
-data1 = [ 1.5,1.0 ];
-data2 = [ 1.0,1.5 ];
-g.signals.values = [data1; data2];
-g.signals.dimensions = numel(data1);
-
-A.time = simulationTime;
-data1 = [ 1.0,1.0 ];
-data2 = [ 1.0,5.0 ];
-A.signals.values = [ data1(:)'; data2(:)' ];
-A.signals.dimensions = numel(data1);
-
-lb.time = simulationTime;
-data1 = [ 0.5,-2.0 ];
-data2 = [ 0.0,-1.0 ];
-lb.signals.values = [data1; data2];
-lb.signals.dimensions = numel(data1);
-
-ub.time = simulationTime;
-data1 = [ 5.0,2.0 ];
-data2 = [ 5.0,-0.5 ];
-ub.signals.values = [data1; data2];
-ub.signals.dimensions = numel(data1);
-
-lbA.time = simulationTime;
-data1 = [ -1.0 ];
-data2 = [ -2.0 ];
-lbA.signals.values = [data1; data2];
-lbA.signals.dimensions = numel(data1);
-
-ubA.time = simulationTime;
-data1 = [ 2.0 ];
-data2 = [ 1.0 ];
-ubA.signals.values = [data1; data2];
-ubA.signals.dimensions = numel(data1);
-
-
-clear simulationTime data1 data2
-
-
-%% open corresponding simulink example
-open( 'example_SQProblem.mdl' );
-
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/make.m b/extlibs/qpOASES-3.2.0/interfaces/simulink/make.m
deleted file mode 100644
index 7a2aa1f..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/make.m
+++ /dev/null
@@ -1,239 +0,0 @@
-function [] = make( varargin )
-%MAKE Compiles the Simulink interface of qpOASES.
-%
-%Type  make            to compile all interfaces that 
-%                      have been modified,
-%type  make clean      to delete all compiled interfaces,
-%type  make clean all  to first delete and then compile 
-%                      all interfaces,
-%type  make 'name'     to compile only the interface with
-%                      the given name (if it has been modified),
-%type  make 'opt'      to compile all interfaces using the 
-%                      given compiler options.
-%
-%Copyright (C) 2013-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%Christian Kirches et al. All rights reserved.
-
-%%
-%%	This file is part of qpOASES.
-%%
-%%	qpOASES -- An Implementation of the Online Active Set Strategy.
-%%	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-%%	Christian Kirches et al. All rights reserved.
-%%
-%%	qpOASES is free software; you can redistribute it and/or
-%%	modify it under the terms of the GNU Lesser General Public
-%%	License as published by the Free Software Foundation; either
-%%	version 2.1 of the License, or (at your option) any later version.
-%%
-%%	qpOASES is distributed in the hope that it will be useful,
-%%	but WITHOUT ANY WARRANTY; without even the implied warranty of
-%%	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-%%	See the GNU Lesser General Public License for more details.
-%%
-%%	You should have received a copy of the GNU Lesser General Public
-%%	License along with qpOASES; if not, write to the Free Software
-%%	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-%%
-
-%%
-%%	Filename:  interfaces/simulink/make.m
-%%	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-%%	Version:   3.2
-%%	Date:      2007-2015
-%%
-
-       
-    %% consistency check
-    if ( exist( [pwd, '/make.m'],'file' ) == 0 )
-        error( ['ERROR (',mfilename '.m): Run this make script directly within the directory', ...
-                '<qpOASES-inst-dir>/interfaces/simulink, please.'] );
-    end
-
-
-    if ( nargin > 2 )
-        error( ['ERROR (',mfilename '.m): At most two make arguments supported!'] );
-    else
-        [ doClean,fcnNames,userFlags ] = analyseMakeArguments( nargin,varargin );
-    end
-
-    
-    %% define compiler settings
-    QPOASESPATH = '../../';
-    
-    DEBUGFLAGS = ' ';
-    %DEBUGFLAGS = ' -g CXXDEBUGFLAGS=''$CXXDEBUGFLAGS -Wall -pedantic -Wshadow'' ';
-
-    IFLAGS = [ '-I. -I',QPOASESPATH,'include',' -I',QPOASESPATH,'src',' ' ];
-    CPPFLAGS = [ IFLAGS, DEBUGFLAGS, '-largeArrayDims -D__cpluplus -D__MATLAB__ -D__SINGLE_OBJECT__',' ' ];
-    defaultFlags = '-O '; %% -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__
-
-    if ( ispc == 0 )
-        CPPFLAGS  = [ CPPFLAGS, '-DLINUX ',' ' ]; 
-    else
-        CPPFLAGS  = [ CPPFLAGS, '-DWIN32 ',' ' ];
-    end
-
-    if ( isempty(userFlags) > 0 )
-        CPPFLAGS = [ CPPFLAGS, defaultFlags,' ' ];
-    else
-        CPPFLAGS = [ CPPFLAGS, userFlags,' ' ];
-    end
-
-    mexExt = eval('mexext');
-    
-    
-    %% ensure copyright notice is displayed
-    if ~isempty( strfind( CPPFLAGS,'-D__NO_COPYRIGHT__' ) )
-        printCopyrightNotice( );
-    end
-    
-    
-    %% clean if desired
-    if ( doClean > 0 )
-        
-        eval( 'delete *.o;' );
-        eval( ['delete *.',mexExt,'*;'] );
-        disp( [ 'INFO (',mfilename '.m): Cleaned all compiled files.'] );
-        pause( 0.2 );
-        
-    end
-    
-    
-    if ( ~isempty(userFlags) )
-        disp( [ 'INFO (',mfilename '.m): Compiling all files with user-defined compiler flags (''',userFlags,''')...'] );
-    end
-    
-
-    %% call mex compiler
-    for ii=1:length(fcnNames)
-        
-        cmd = [ 'mex -output ', fcnNames{ii}, ' ', CPPFLAGS, [fcnNames{ii},'.cpp'] ];
-        
-        if ( exist( [fcnNames{ii},'.',mexExt],'file' ) == 0 )
-            
-            eval( cmd );
-            disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            
-        else
-            
-            % check modification time of source/Make files and compiled mex file
-            cppFile = dir( [pwd,'/',fcnNames{ii},'.cpp'] );
-            cppFileTimestamp = getTimestamp( cppFile );
-
-            makeFile = dir( [pwd,'/make.m'] );
-            makeFileTimestamp = getTimestamp( makeFile );
-            
-            mexFile = dir( [pwd,'/',fcnNames{ii},'.',mexExt] );
-            if ( isempty(mexFile) == 0 )
-                mexFileTimestamp = getTimestamp( mexFile );
-            else
-                mexFileTimestamp = 0;
-            end
-            
-            if ( ( cppFileTimestamp   >= mexFileTimestamp ) || ...
-                 ( makeFileTimestamp  >= mexFileTimestamp ) )
-                eval( cmd );
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' successfully created.'] );
-            else            
-                disp( [ 'INFO (',mfilename '.m): ', fcnNames{ii},'.',mexExt, ' already exists.'] );
-            end
-            
-        end
-        
-    end
-
-    %% add qpOASES directory to path
-    path( path,pwd );
-
-end
-
-
-function [ doClean,fcnNames,userIFlags ] = analyseMakeArguments( nArgs,args )
-
-    doClean = 0;
-    fcnNames = [];
-    userIFlags = [];
-
-    switch ( nArgs )
-        
-        case 1
-            if ( strcmp( args{1},'all' ) > 0 )
-                fcnNames = { 'qpOASES_QProblemB','qpOASES_QProblem','qpOASES_SQProblem' };
-            elseif ( strcmp( args{1},'qpOASES_QProblemB' ) > 0 )
-                fcnNames = { 'qpOASES_QProblemB' };
-            elseif ( strcmp( args{1},'qpOASES_QProblem' ) > 0 )
-                fcnNames = { 'qpOASES_QProblem' };
-            elseif ( strcmp( args{1},'qpOASES_SQProblem' ) > 0 )
-                fcnNames = { 'qpOASES_SQProblem' };
-            elseif ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            elseif ( strcmp( args{1}(1),'-' ) > 0 )
-                % make clean all with user-specified compiler flags
-                userIFlags = args{1};
-                doClean = 1;
-                fcnNames = { 'qpOASES_QProblemB','qpOASES_QProblem','qpOASES_SQProblem' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid first argument (''',args{1},''')!'] );
-            end
-
-        case 2
-            if ( strcmp( args{1},'clean' ) > 0 )
-                doClean = 1;
-            else
-                error( ['ERROR (',mfilename '.m): First argument must be ''clean'' if two arguments are provided!'] );
-            end
-            
-            if ( strcmp( args{2},'all' ) > 0 )
-                fcnNames = { 'qpOASES_QProblemB','qpOASES_QProblem','qpOASES_SQProblem' };
-            elseif ( strcmp( args{2},'qpOASES_QProblemB' ) > 0 )
-                fcnNames = { 'qpOASES_QProblemB' };
-            elseif ( strcmp( args{2},'qpOASES_QProblem' ) > 0 )
-                fcnNames = { 'qpOASES_QProblem' };
-            elseif ( strcmp( args{2},'qpOASES_SQProblem' ) > 0 )
-                fcnNames = { 'qpOASES_SQProblem' };
-            else
-                error( ['ERROR (',mfilename '.m): Invalid second argument (''',args{2},''')!'] );
-            end
-            
-        otherwise
-            doClean = 0;
-            fcnNames = { 'qpOASES_QProblemB','qpOASES_QProblem','qpOASES_SQProblem' };
-            userIFlags = [];            
-    end
-    
-end
-
-
-function [ timestamp ] = getTimestamp( dateString )
-
-    try 
-        timestamp = dateString.datenum;
-    catch
-        timestamp = Inf;
-    end
-
-end
-
-
-function [ ] = printCopyrightNotice( )
-
-    disp( ' ' );
-    disp( 'qpOASES -- An Implementation of the Online Active Set Strategy.' );
-    disp( 'Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,' );
-    disp( 'Christian Kirches et al. All rights reserved.' );
-    disp( ' ' );
-    disp( 'qpOASES is distributed under the terms of the' );
-    disp( 'GNU Lesser General Public License 2.1 in the hope that it will be' );
-    disp( 'useful, but WITHOUT ANY WARRANTY; without even the implied warranty' );
-    disp( 'of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.' );
-    disp( 'See the GNU Lesser General Public License for more details.' );
-    disp( ' ' );
-    disp( ' ' );
-
-end
-
-
-%%
-%%	end of file
-%%
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblem.cpp b/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblem.cpp
deleted file mode 100644
index 735d755..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblem.cpp
+++ /dev/null
@@ -1,506 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/simulink/qpOASES_QProblem.cpp
- *	\author Hans Joachim Ferreau (thanks to Aude Perrin)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Simulink(R) that enables to call qpOASES as a S function
- *  (variant for QPs with fixed matrices).
- *
- */
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "qpOASES_simulink_utils.cpp"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define S_FUNCTION_NAME   qpOASES_QProblem		/**< Name of the S function. */
-#define S_FUNCTION_LEVEL  2						/**< S function level. */
-
-#define MDL_START								/**< Activate call to mdlStart. */
-
-#include "simstruc.h"
-
-
-/* SETTINGS: */
-#define SAMPLINGTIME   -1						/**< Sampling time. */
-#define NCONTROLINPUTS  2						/**< Number of control inputs. */
-#define MAXITER         100						/**< Maximum number of iterations. */
-#define HESSIANTYPE     HST_UNKNOWN				/**< Hessian type, see documentation of QProblem class constructor. */
-
-
-static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
-{
-	int nU = NCONTROLINPUTS;
-
-	/* Specify the number of continuous and discrete states */
-	ssSetNumContStates(S, 0);
-	ssSetNumDiscStates(S, 0);
-
-	/* Specify the number of parameters */
-	ssSetNumSFcnParams(S, 2); /* H, A */
-	if ( ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S) )
-		return;
-
-	/* Specify the number of intput ports */
-	if ( !ssSetNumInputPorts(S, 5) )
-		return;
-
-	/* Specify the number of output ports */
-	if ( !ssSetNumOutputPorts(S, 4) )
-		return;
-
-	/* Specify dimension information for the input ports */
-	ssSetInputPortVectorDimension(S, 0, DYNAMICALLY_SIZED); /* g */
-	ssSetInputPortVectorDimension(S, 1, DYNAMICALLY_SIZED); /* lb */
-	ssSetInputPortVectorDimension(S, 2, DYNAMICALLY_SIZED); /* ub */
-	ssSetInputPortVectorDimension(S, 3, DYNAMICALLY_SIZED); /* lbA */
-	ssSetInputPortVectorDimension(S, 4, DYNAMICALLY_SIZED); /* ubA */
-
-	/* Specify dimension information for the output ports */
-	ssSetOutputPortVectorDimension(S, 0, nU );  /* uOpt */
-	ssSetOutputPortVectorDimension(S, 1, 1 );   /* fval */
-	ssSetOutputPortVectorDimension(S, 2, 1 );   /* exitflag */
-	ssSetOutputPortVectorDimension(S, 3, 1 );   /* iter */
-
-	/* Specify the direct feedthrough status */
-	ssSetInputPortDirectFeedThrough(S, 0, 1);
-	ssSetInputPortDirectFeedThrough(S, 1, 1);
-	ssSetInputPortDirectFeedThrough(S, 2, 1);
-	ssSetInputPortDirectFeedThrough(S, 3, 1);
-	ssSetInputPortDirectFeedThrough(S, 4, 1);
-
-	/* One sample time */
-	ssSetNumSampleTimes(S, 1);
-
-	/* global variables:
-     * 0: problem
-     * 1: H
-     * 2: g
-     * 3: A
-     * 4: lb
-     * 5: ub
-     * 6: lbA
-     * 7: ubA
-     */
-
-	/* Specify the size of the block's pointer work vector */
-    ssSetNumPWork(S, 8);
-}
-
-
-#if defined(MATLAB_MEX_FILE)
-
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-
-static void mdlSetInputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetInputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-static void mdlSetOutputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetOutputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-#endif
-
-
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-	ssSetSampleTime(S, 0, SAMPLINGTIME);
-	ssSetOffsetTime(S, 0, 0.0);
-}
-
-
-static void mdlStart(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int nU = NCONTROLINPUTS;
-	int size_g, size_lb, size_ub, size_lbA, size_ubA;
-	int size_H, nRows_H, nCols_H, size_A, nRows_A, nCols_A;
-	int nV, nC;
-
-	QProblem* problem;
-
-
-	/* get block inputs dimensions */
-	const mxArray* in_H = ssGetSFcnParam(S, 0);
-	const mxArray* in_A = ssGetSFcnParam(S, 1);
-
-	if ( mxIsEmpty(in_H) == 1 )
-	{
-		if ( ( HESSIANTYPE != HST_ZERO ) && ( HESSIANTYPE != HST_IDENTITY ) )
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			mexErrMsgTxt( "ERROR (qpOASES): Hessian can only be empty if type is set to HST_ZERO or HST_IDENTITY!" );
-			#endif
-			return;
-		}
-		
-	    nRows_H = 0;
-		nCols_H = 0;
-		size_H  = 0;
-	}
-	else
-	{
-	    nRows_H = (int)mxGetM(in_H);
-		nCols_H = (int)mxGetN(in_H);
-		size_H  = nRows_H * nCols_H;
-	}
-
-	if ( mxIsEmpty(in_A) == 1 )
-	{
-	    nRows_A = 0;
-		nCols_A = 0;
-		size_A  = 0;
-	}
-	else
-	{
-	    nRows_A = (int)mxGetM(in_A);
-		nCols_A = (int)mxGetN(in_A);
-		size_A  = nRows_A * nCols_A;
-	}
-
-	size_g   = ssGetInputPortWidth(S, 0);
-	size_lb  = ssGetInputPortWidth(S, 1);
-	size_ub  = ssGetInputPortWidth(S, 2);
-	size_lbA = ssGetInputPortWidth(S, 3);
-	size_ubA = ssGetInputPortWidth(S, 4);
-
-
-	/* dimension checks */
-	nV = size_g;
-	nC = nRows_A;
-
-
-	if ( MAXITER < 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Maximum number of iterations must not be negative!" );
-		#endif
-		return;
-	}
-
-	if ( nV <= 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_H != nV*nV ) && ( size_H != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in H!" );
-		#endif
-		return;
-	}
-
-	if ( nRows_H != nCols_H )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Hessian matrix must be square matrix!" );
-		#endif
-		return;
-	}
-
-	if ( ( nU < 1 ) || ( nU > nV ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Invalid number of control inputs!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_lb != nV ) && ( size_lb != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in lb!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_ub != nV ) && ( size_lb != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in ub!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_lbA != nC ) && ( size_lbA != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in lbA!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_ubA != nC ) && ( size_ubA != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in ubA!" );
-		#endif
-		return;
-	}
-
-
-	/* allocate QProblem object */
-	problem = new QProblem( nV,nC,HESSIANTYPE );
-	if ( problem == 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Unable to create QProblem object!" );
-		#endif
-		return;
-	}
-	
-	Options problemOptions;
-	problemOptions.setToMPC();
-	problem->setOptions( problemOptions );
-
-	#ifndef __DEBUG__
-	problem->setPrintLevel( PL_LOW );
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	problem->setPrintLevel( PL_NONE );
-	#endif
-
-	ssGetPWork(S)[0] = (void *) problem;
-
-	/* allocate memory for QP data ... */
-	if ( size_H > 0 )
-		ssGetPWork(S)[1] = (void *) calloc( size_H, sizeof(real_t) );	/* H */
-	else
-		ssGetPWork(S)[1] = 0;
-
-	ssGetPWork(S)[2] = (void *) calloc( size_g, sizeof(real_t) );		/* g */
-	ssGetPWork(S)[3] = (void *) calloc( size_A, sizeof(real_t) );		/* A */
-
-	if ( size_lb > 0 )
-		ssGetPWork(S)[4] = (void *) calloc( size_lb, sizeof(real_t) );	/* lb */
-	else
-		ssGetPWork(S)[4] = 0;
-
-	if ( size_ub > 0 )
-		ssGetPWork(S)[5] = (void *) calloc( size_ub, sizeof(real_t) );	/* ub */
-	else
-		ssGetPWork(S)[5] = 0;
-	
-	if ( size_lbA > 0 )
-		ssGetPWork(S)[6] = (void *) calloc( size_lbA, sizeof(real_t) );	/* lbA */
-	else
-		ssGetPWork(S)[6] = 0;
-
-	if ( size_ubA > 0 )
-		ssGetPWork(S)[7] = (void *) calloc( size_ubA, sizeof(real_t) );	/* ubA */
-	else
-		ssGetPWork(S)[7] = 0;
-}
-
-
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-	int nV, nC;
-	returnValue status;
-
-	int_t nWSR = MAXITER;
-	int nU     = NCONTROLINPUTS;
-
-	InputRealPtrsType in_g, in_lb, in_ub, in_lbA, in_ubA;
-
-	QProblem* problem;
-	real_t *H, *g, *A, *lb, *ub, *lbA, *ubA;
-
-	real_t *xOpt;
-
-	real_T *out_uOpt, *out_objVal, *out_status, *out_nWSR;
-
-
-	/* get pointers to block inputs ... */
-	const mxArray* in_H = ssGetSFcnParam(S, 0);
-	const mxArray* in_A = ssGetSFcnParam(S, 1);
-	in_g   = ssGetInputPortRealSignalPtrs(S, 0);
-	in_lb  = ssGetInputPortRealSignalPtrs(S, 1);
-	in_ub  = ssGetInputPortRealSignalPtrs(S, 2);
-	in_lbA = ssGetInputPortRealSignalPtrs(S, 3);
-	in_ubA = ssGetInputPortRealSignalPtrs(S, 4);
-
-
-	/* ... and to the QP data */
-	problem = (QProblem*)(ssGetPWork(S)[0]);
-
-	H   = (real_t *) ssGetPWork(S)[1];
-	g   = (real_t *) ssGetPWork(S)[2];
-	A   = (real_t *) ssGetPWork(S)[3];
-	lb  = (real_t *) ssGetPWork(S)[4];
-	ub  = (real_t *) ssGetPWork(S)[5];
-	lbA = (real_t *) ssGetPWork(S)[6];
-	ubA = (real_t *) ssGetPWork(S)[7];
-
-
-	/* setup QP data */
-	nV = ssGetInputPortWidth(S, 0); /* nV = size_g */
-	nC = (int)mxGetM(in_A);			/* nC = nRows_A*/
-
-	if ( H != 0 )
-	{
-		/* no conversion from FORTRAN to C as Hessian is symmetric! */
-		for ( i=0; i<nV*nV; ++i )
-			H[i] = (mxGetPr(in_H))[i];
-	}
-
-	convertFortranToC( mxGetPr(in_A),nV,nC, A );
-
-	for ( i=0; i<nV; ++i )
-		g[i] = (*in_g)[i];
-
-	if ( lb != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			lb[i] = (*in_lb)[i];
-	}
-
-	if ( ub != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			ub[i] = (*in_ub)[i];
-	}
-
-	if ( lbA != 0 )
-	{
-		for ( i=0; i<nC; ++i )
-			lbA[i] = (*in_lbA)[i];
-	}
-
-	if ( ubA != 0 )
-	{
-		for ( i=0; i<nC; ++i )
-			ubA[i] = (*in_ubA)[i];
-	}
-
-	xOpt = new real_t[nV];
-
-	if ( problem->getCount() == 0 )
-	{
-		/* initialise and solve first QP */
-		status = problem->init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-		problem->getPrimalSolution( xOpt );
-	}
-	else
-	{
-		/* solve neighbouring QP using hotstart technique */
-		status = problem->hotstart( g,lb,ub,lbA,ubA, nWSR,0 );
-		if ( ( status != SUCCESSFUL_RETURN ) && ( status != RET_MAX_NWSR_REACHED ) )
-		{
-			/* if an error occurs, reset problem data structures ... */
-			problem->reset( );
-            
-            /* ... and initialise/solve again with remaining number of iterations. */
-            int_t nWSR_retry = MAXITER - nWSR;
-			status = problem->init( H,g,A,lb,ub,lbA,ubA, nWSR_retry,0 );
-			nWSR += nWSR_retry;
-			
-		}
-
-		/* obtain optimal solution */
-		problem->getPrimalSolution( xOpt );
-	}
-
-	/* generate block output: status information ... */
-	out_uOpt   = ssGetOutputPortRealSignal(S, 0);
-	out_objVal = ssGetOutputPortRealSignal(S, 1);
-	out_status = ssGetOutputPortRealSignal(S, 2);
-	out_nWSR   = ssGetOutputPortRealSignal(S, 3);
-
-	for ( i=0; i<nU; ++i )
-		out_uOpt[i] = (real_T)(xOpt[i]);
-
-	out_objVal[0] = (real_T)(problem->getObjVal());
-	out_status[0] = (real_t)(getSimpleStatus( status ));
-	out_nWSR[0]   = (real_T)(nWSR);
-
-	removeNaNs( out_uOpt,nU );
-	removeInfs( out_uOpt,nU );
-	removeNaNs( out_objVal,1 );
-	removeInfs( out_objVal,1 );
-
-	delete[] xOpt;
-}
-
-
-static void mdlTerminate(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-	
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-
-	if ( ssGetPWork(S)[0] != 0 )
-		delete ((QProblem*)(ssGetPWork(S)[0]));
-
-	for ( i=1; i<8; ++i )
-	{
-		if ( ssGetPWork(S)[i] != 0 )
-			free( ssGetPWork(S)[i] );
-	}
-}
-
-
-#ifdef  MATLAB_MEX_FILE
-#include "simulink.c"
-#else
-#include "cg_sfun.h"
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblemB.cpp b/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblemB.cpp
deleted file mode 100644
index 5de0a5b..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_QProblemB.cpp
+++ /dev/null
@@ -1,431 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/simulink/qpOASES_QProblemB.cpp
- *	\author Hans Joachim Ferreau (thanks to Aude Perrin)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Simulink(R) that enables to call qpOASES as a S function
- *  (variant for simply bounded QPs with fixed matrices).
- *
- */
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "qpOASES_simulink_utils.cpp"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define S_FUNCTION_NAME   qpOASES_QProblemB		/**< Name of the S function. */
-#define S_FUNCTION_LEVEL  2						/**< S function level. */
-
-#define MDL_START								/**< Activate call to mdlStart. */
-
-#include "simstruc.h"
-
-
-/* SETTINGS */
-#define SAMPLINGTIME   -1						/**< Sampling time. */
-#define NCONTROLINPUTS  2						/**< Number of control inputs. */
-#define MAXITER         100						/**< Maximum number of iteration. */
-#define HESSIANTYPE     HST_UNKNOWN				/**< Hessian type, see documentation of QProblemB class constructor. */
-
-
-static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
-{
-	int nU = NCONTROLINPUTS;
-
-	/* Specify the number of continuous and discrete states */
-	ssSetNumContStates(S, 0);
-	ssSetNumDiscStates(S, 0);
-
-	/* Specify the number of parameters */
-	ssSetNumSFcnParams(S, 1); /* H */
-	if ( ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S) )
-		return;
-
-	/* Specify the number of intput ports */
-	if ( !ssSetNumInputPorts(S, 3) )
-		return;
-
-	/* Specify the number of output ports */
-	if ( !ssSetNumOutputPorts(S, 4) )
-		return;
-
-	/* Specify dimension information for the input ports */
-	ssSetInputPortVectorDimension(S, 0, DYNAMICALLY_SIZED);	/* g */
-	ssSetInputPortVectorDimension(S, 1, DYNAMICALLY_SIZED);	/* lb */
-	ssSetInputPortVectorDimension(S, 2, DYNAMICALLY_SIZED);	/* ub */
-
-	/* Specify dimension information for the output ports */
-	ssSetOutputPortVectorDimension(S, 0, nU );  /* uOpt */
-    ssSetOutputPortVectorDimension(S, 1, 1 );   /* fval */
-	ssSetOutputPortVectorDimension(S, 2, 1 );   /* exitflag */
-	ssSetOutputPortVectorDimension(S, 3, 1 );   /* iter */
-
-	/* Specify the direct feedthrough status */
-	ssSetInputPortDirectFeedThrough(S, 0, 1);
-	ssSetInputPortDirectFeedThrough(S, 1, 1);
-	ssSetInputPortDirectFeedThrough(S, 2, 1);
-
-	/* One sample time */
-	ssSetNumSampleTimes(S, 1);
-
-	/* global variables:
-     * 0: problem
-     * 1: H
-     * 2: g
-     * 3: lb
-     * 4: ub
-     */
-
-	/* Specify the size of the block's pointer work vector */
-    ssSetNumPWork(S, 5);
-}
-
-
-#if defined(MATLAB_MEX_FILE)
-
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-
-static void mdlSetInputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetInputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-static void mdlSetOutputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetOutputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-#endif
-
-
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-	ssSetSampleTime(S, 0, SAMPLINGTIME);
-	ssSetOffsetTime(S, 0, 0.0);
-}
-
-
-static void mdlStart(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int nU = NCONTROLINPUTS;
-	int size_g, size_lb, size_ub;
-	int size_H, nRows_H, nCols_H;
-	int nV;
-
-	QProblemB* problem;
-
-
-	/* get block inputs dimensions */
-	const mxArray* in_H = ssGetSFcnParam(S, 0);
-
-	if ( mxIsEmpty(in_H) == 1 )
-	{
-		if ( ( HESSIANTYPE != HST_ZERO ) && ( HESSIANTYPE != HST_IDENTITY ) )
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			mexErrMsgTxt( "ERROR (qpOASES): Hessian can only be empty if type is set to HST_ZERO or HST_IDENTITY!" );
-			#endif
-			return;
-		}
-		
-	    nRows_H = 0;
-		nCols_H = 0;
-		size_H  = 0;
-	}
-	else
-	{
-	    nRows_H = (int)mxGetM(in_H);
-		nCols_H = (int)mxGetN(in_H);
-		size_H  = nRows_H * nCols_H;
-	}
-
-	size_g   = ssGetInputPortWidth(S, 0);
-	size_lb  = ssGetInputPortWidth(S, 1);
-	size_ub  = ssGetInputPortWidth(S, 2);
-
-
-	/* dimension checks */
-	nV = size_g;
-
-	if ( MAXITER < 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Maximum number of iterations must not be negative!" );
-		#endif
-		return;
-	}
-
-	if ( nV <= 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_H != nV*nV ) && ( size_H != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in H!" );
-		#endif
-		return;
-	}
-
-	if ( nRows_H != nCols_H )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Hessian matrix must be square matrix!" );
-		#endif
-		return;
-	}
-
-	if ( ( nU < 1 ) || ( nU > nV ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Invalid number of control inputs!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_lb != nV ) && ( size_lb != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in lb!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_ub != nV ) && ( size_ub != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in ub!" );
-		#endif
-		return;
-	}
-
-
-	/* allocate QProblemB object */
-	problem = new QProblemB( nV,HESSIANTYPE );
-	if ( problem == 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Unable to create QProblemB object!" );
-		#endif
-		return;
-	}
-
-	Options problemOptions;
-	problemOptions.setToMPC();
-	problem->setOptions( problemOptions );
-	
-	#ifndef __DEBUG__
-	problem->setPrintLevel( PL_LOW );
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	problem->setPrintLevel( PL_NONE );
-	#endif
-
-	ssGetPWork(S)[0] = (void *) problem;
-
-	/* allocate memory for QP data ... */
-	if ( size_H > 0 )
-		ssGetPWork(S)[1] = (void *) calloc( size_H, sizeof(real_t) );	/* H */
-	else
-		ssGetPWork(S)[1] = 0;
-
-	ssGetPWork(S)[2] = (void *) calloc( size_g, sizeof(real_t) );		/* g */
-
-	if ( size_lb > 0 )
-		ssGetPWork(S)[3] = (void *) calloc( size_lb, sizeof(real_t) );	/* lb */
-	else
-		ssGetPWork(S)[3] = 0;
-
-	if ( size_ub > 0 )
-		ssGetPWork(S)[4] = (void *) calloc( size_ub, sizeof(real_t) );	/* ub */
-	else
-		ssGetPWork(S)[4] = 0;
-}
-
-
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-	int nV;
-	returnValue status;
-
-	int_t nWSR = MAXITER;
-	int nU     = NCONTROLINPUTS;
-
-	InputRealPtrsType in_g, in_lb, in_ub;
-
-	QProblemB* problem;
-	real_t *H, *g, *lb, *ub;
-
-	real_t *xOpt;
-
-	real_T *out_uOpt, *out_objVal, *out_status, *out_nWSR;
-
-
-	/* get pointers to block inputs ... */
-	const mxArray* in_H = ssGetSFcnParam(S, 0);
-	in_g  = ssGetInputPortRealSignalPtrs(S, 0);
-	in_lb = ssGetInputPortRealSignalPtrs(S, 1);
-	in_ub = ssGetInputPortRealSignalPtrs(S, 2);
-
-	/* ... and to the QP data */
-	problem = (QProblemB*) ssGetPWork(S)[0];
-
-	H  = (real_t *) ssGetPWork(S)[1];
-	g  = (real_t *) ssGetPWork(S)[2];
-	lb = (real_t *) ssGetPWork(S)[3];
-	ub = (real_t *) ssGetPWork(S)[4];
-
-
-	/* setup QP data */
-	nV = ssGetInputPortWidth(S, 1); /* nV = size_g */
-
-	if ( H != 0 )
-	{
-		/* no conversion from FORTRAN to C as Hessian is symmetric! */
-		for ( i=0; i<nV*nV; ++i )
-			H[i] = (mxGetPr(in_H))[i];
-	}
-
-	for ( i=0; i<nV; ++i )
-		g[i] = (*in_g)[i];
-
-	if ( lb != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			lb[i] = (*in_lb)[i];
-	}
-
-	if ( ub != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			ub[i] = (*in_ub)[i];
-	}
-
-	xOpt = new real_t[nV];
-
-	if ( problem->getCount() == 0 )
-	{
-		/* initialise and solve first QP */
-		status = problem->init( H,g,lb,ub, nWSR,0 );
-		problem->getPrimalSolution( xOpt );
-	}
-	else
-	{
-		/* solve neighbouring QP using hotstart technique */
-		status = problem->hotstart( g,lb,ub, nWSR,0 );
-		if ( ( status != SUCCESSFUL_RETURN ) && ( status != RET_MAX_NWSR_REACHED ) )
-		{
-			/* if an error occurs, reset problem data structures ... */
-			problem->reset( );
-            
-            /* ... and initialise/solve again with remaining number of iterations. */
-            int_t nWSR_retry = MAXITER - nWSR;
-			status = problem->init( H,g,lb,ub, nWSR_retry,0 );
-            nWSR += nWSR_retry;
-		}
-
-		/* obtain optimal solution */
-		problem->getPrimalSolution( xOpt );
-	}
-
-	/* generate block output: status information ... */
-	out_uOpt   = ssGetOutputPortRealSignal(S, 0);
-	out_objVal = ssGetOutputPortRealSignal(S, 1);
-	out_status = ssGetOutputPortRealSignal(S, 2);
-	out_nWSR   = ssGetOutputPortRealSignal(S, 3);
-
-	for ( i=0; i<nU; ++i )
-		out_uOpt[i] = (real_T)(xOpt[i]);
-    
-    out_objVal[0] = (real_T)(problem->getObjVal());
-	out_status[0] = (real_t)(getSimpleStatus( status ));
-	out_nWSR[0]   = (real_T)(nWSR);
-
-	removeNaNs( out_uOpt,nU );
-	removeInfs( out_uOpt,nU );
-	removeNaNs( out_objVal,1 );
-	removeInfs( out_objVal,1 );
-
-	delete[] xOpt;
-}
-
-
-static void mdlTerminate(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-
-	if ( ssGetPWork(S)[0] != 0 )
-		delete ((QProblemB*)(ssGetPWork(S)[0]));
-
-	for ( i=1; i<5; ++i )
-	{
-		if ( ssGetPWork(S)[i] != 0 )
-			free( ssGetPWork(S)[i] );
-	}
-}
-
-
-#ifdef  MATLAB_MEX_FILE
-#include "simulink.c"
-#else
-#include "cg_sfun.h"
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_SQProblem.cpp b/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_SQProblem.cpp
deleted file mode 100644
index b720508..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_SQProblem.cpp
+++ /dev/null
@@ -1,475 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/simulink/qpOASES_SQProblem.cpp
- *	\author Hans Joachim Ferreau (thanks to Aude Perrin)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Interface for Simulink(R) that enables to call qpOASES as a S function
- *  (variant for QPs with varying matrices).
- *
- */
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "qpOASES_simulink_utils.cpp"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define S_FUNCTION_NAME   qpOASES_SQProblem		/**< Name of the S function. */
-#define S_FUNCTION_LEVEL  2						/**< S function level. */
-
-#define MDL_START								/**< Activate call to mdlStart. */
-
-#include "simstruc.h"
-
-
-/* SETTINGS */
-#define SAMPLINGTIME   -1						/**< Sampling time. */
-#define NCONTROLINPUTS  2						/**< Number of control inputs. */
-#define MAXITER         100	    				/**< Maximum number of iterations. */
-#define HESSIANTYPE     HST_UNKNOWN				/**< Hessian type, see documentation of SQProblem class constructor. */
-
-
-static void mdlInitializeSizes (SimStruct *S)   /* Init sizes array */
-{
-	int nU = NCONTROLINPUTS;
-
-	/* Specify the number of continuous and discrete states */
-	ssSetNumContStates(S, 0);
-	ssSetNumDiscStates(S, 0);
-
-	/* Specify the number of parameters */
-	ssSetNumSFcnParams(S, 0);
-	if ( ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S) )
-		return;
-
-	/* Specify the number of intput ports */
-	if ( !ssSetNumInputPorts(S, 7) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Invalid number of input ports!" );
-		#endif
-		return;
-	}
-
-	/* Specify the number of output ports */
-	if ( !ssSetNumOutputPorts(S, 4) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Invalid number of output ports!" );
-		#endif
-		return;
-	}
-
-	/* Specify dimension information for the input ports */
-	ssSetInputPortVectorDimension(S, 0, DYNAMICALLY_SIZED);	/* H */
-	ssSetInputPortVectorDimension(S, 1, DYNAMICALLY_SIZED); /* g */
-	ssSetInputPortVectorDimension(S, 2, DYNAMICALLY_SIZED); /* A */
-	ssSetInputPortVectorDimension(S, 3, DYNAMICALLY_SIZED); /* lb */
-	ssSetInputPortVectorDimension(S, 4, DYNAMICALLY_SIZED); /* ub */
-	ssSetInputPortVectorDimension(S, 5, DYNAMICALLY_SIZED); /* lbA */
-	ssSetInputPortVectorDimension(S, 6, DYNAMICALLY_SIZED); /* ubA */
-
-	/* Specify dimension information for the output ports */
-	ssSetOutputPortVectorDimension(S, 0, nU );  /* uOpt */
-	ssSetOutputPortVectorDimension(S, 1, 1 );   /* fval */
-	ssSetOutputPortVectorDimension(S, 2, 1 );   /* exitflag */
-	ssSetOutputPortVectorDimension(S, 3, 1 );   /* iter */
-
-	/* Specify the direct feedthrough status */
-	ssSetInputPortDirectFeedThrough(S, 0, 1);
-	ssSetInputPortDirectFeedThrough(S, 1, 1);
-	ssSetInputPortDirectFeedThrough(S, 2, 1);
-	ssSetInputPortDirectFeedThrough(S, 3, 1);
-	ssSetInputPortDirectFeedThrough(S, 4, 1);
-	ssSetInputPortDirectFeedThrough(S, 5, 1);
-	ssSetInputPortDirectFeedThrough(S, 6, 1);
-
-	/* One sample time */
-	ssSetNumSampleTimes(S, 1);
-
-	/* global variables:
-     * 0: problem
-     * 1: H
-     * 2: g
-     * 3: A
-     * 4: lb
-     * 5: ub
-     * 6: lbA
-     * 7: ubA
-     */
-
-	/* Specify the size of the block's pointer work vector */
-    ssSetNumPWork(S, 8);
-}
-
-
-#if defined(MATLAB_MEX_FILE)
-
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-
-static void mdlSetInputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetInputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-static void mdlSetOutputPortDimensionInfo(SimStruct *S, int_T port, const DimsInfo_T *dimsInfo)
-{
-	if ( !ssSetOutputPortDimensionInfo(S, port, dimsInfo) )
-		return;
-}
-
-#endif
-
-
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-	ssSetSampleTime(S, 0, SAMPLINGTIME);
-	ssSetOffsetTime(S, 0, 0.0);
-}
-
-
-static void mdlStart(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int nU = NCONTROLINPUTS;
-	int size_H, size_g, size_A, size_lb, size_ub, size_lbA, size_ubA;
-	int nV, nC;
-
-	SQProblem* problem;
-
-
-	/* get block inputs dimensions */
-	size_H   = ssGetInputPortWidth(S, 0);
-	size_g   = ssGetInputPortWidth(S, 1);
-	size_A   = ssGetInputPortWidth(S, 2);
-	size_lb  = ssGetInputPortWidth(S, 3);
-	size_ub  = ssGetInputPortWidth(S, 4);
-	size_lbA = ssGetInputPortWidth(S, 5);
-	size_ubA = ssGetInputPortWidth(S, 6);
-
-
-	/* dimension checks */
-	nV = size_g;
-	nC = (int) ( ((real_t) size_A) / ((real_t) nV) );
-
-	if ( MAXITER < 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Maximum number of iterations must not be negative!" );
-		#endif
-		return;
-	}
-
-	if ( nV <= 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_H != nV*nV ) && ( size_H != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in H!" );
-		#endif
-		return;
-	}
-
-	if ( ( nU < 1 ) || ( nU > nV ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Invalid number of control inputs!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_lb != nV ) && ( size_lb != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in lb!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_ub != nV ) && ( size_ub != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in ub!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_lbA != nC ) && ( size_lbA != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in lbA!" );
-		#endif
-		return;
-	}
-
-	if ( ( size_ubA != nC ) && ( size_ubA != 0 ) )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Dimension mismatch in ubA!" );
-		#endif
-		return;
-	}
-
-
-	/* allocate QProblem object */
-	problem = new SQProblem( nV,nC,HESSIANTYPE );
-	if ( problem == 0 )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		mexErrMsgTxt( "ERROR (qpOASES): Unable to create SQProblem object!" );
-		#endif
-		return;
-	}
-
-	Options problemOptions;
-	problemOptions.setToMPC();
-	problem->setOptions( problemOptions );
-
-	#ifndef __DEBUG__
-	problem->setPrintLevel( PL_LOW );
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	problem->setPrintLevel( PL_NONE );
-	#endif
-
-	ssGetPWork(S)[0] = (void *) problem;
-
-	/* allocate memory for QP data ... */
-	if ( size_H > 0 )
-		ssGetPWork(S)[1] = (void *) calloc( size_H, sizeof(real_t) );	/* H */
-	else
-		ssGetPWork(S)[1] = 0;
-
-	ssGetPWork(S)[2] = (void *) calloc( size_g, sizeof(real_t) );		/* g */
-	ssGetPWork(S)[3] = (void *) calloc( size_A, sizeof(real_t) );		/* A */
-
-	if ( size_lb > 0 )
-		ssGetPWork(S)[4] = (void *) calloc( size_lb, sizeof(real_t) );	/* lb */
-	else
-		ssGetPWork(S)[4] = 0;
-
-	if ( size_ub > 0 )
-		ssGetPWork(S)[5] = (void *) calloc( size_ub, sizeof(real_t) );	/* ub */
-	else
-		ssGetPWork(S)[5] = 0;
-	
-	if ( size_lbA > 0 )
-		ssGetPWork(S)[6] = (void *) calloc( size_lbA, sizeof(real_t) );	/* lbA */
-	else
-		ssGetPWork(S)[6] = 0;
-
-	if ( size_ubA > 0 )
-		ssGetPWork(S)[7] = (void *) calloc( size_ubA, sizeof(real_t) );	/* ubA */
-	else
-		ssGetPWork(S)[7] = 0;
-}
-
-
-
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-	int nV, nC;
-	returnValue status;
-
-	int_t nWSR = MAXITER;
-	int nU     = NCONTROLINPUTS;
-
-	InputRealPtrsType in_H, in_g, in_A, in_lb, in_ub, in_lbA, in_ubA;
-
-	SQProblem* problem;
-	real_t *H, *g, *A, *lb, *ub, *lbA, *ubA;
-
-	real_t *xOpt;
-
-	real_T *out_uOpt, *out_objVal, *out_status, *out_nWSR;
-
-
-	/* get pointers to block inputs ... */
-	in_H   = ssGetInputPortRealSignalPtrs(S, 0);
-	in_g   = ssGetInputPortRealSignalPtrs(S, 1);
-	in_A   = ssGetInputPortRealSignalPtrs(S, 2);
-	in_lb  = ssGetInputPortRealSignalPtrs(S, 3);
-	in_ub  = ssGetInputPortRealSignalPtrs(S, 4);
-	in_lbA = ssGetInputPortRealSignalPtrs(S, 5);
-	in_ubA = ssGetInputPortRealSignalPtrs(S, 6);
-
-
-	/* ... and to the QP data */
-	problem = (SQProblem*) ssGetPWork(S)[0];
-
-	H   = (real_t *) ssGetPWork(S)[1];
-	g   = (real_t *) ssGetPWork(S)[2];
-	A   = (real_t *) ssGetPWork(S)[3];
-	lb  = (real_t *) ssGetPWork(S)[4];
-	ub  = (real_t *) ssGetPWork(S)[5];
-	lbA = (real_t *) ssGetPWork(S)[6];
-	ubA = (real_t *) ssGetPWork(S)[7];
-
-
-	/* setup QP data */
-	nV = ssGetInputPortWidth(S, 1); /* nV = size_g */
-	nC = (int) ( ((real_t) ssGetInputPortWidth(S, 2)) / ((real_t) nV) ); /* nC = size_A / size_g */
-
-	if ( H != 0 )
-	{
-		/* no conversion from FORTRAN to C as Hessian is symmetric! */
-		for ( i=0; i<nV*nV; ++i )
-			H[i] = (*in_H)[i];
-	}
-
-	convertFortranToC( *in_A,nV,nC, A );
-
-	for ( i=0; i<nV; ++i )
-		g[i] = (*in_g)[i];
-
-	if ( lb != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			lb[i] = (*in_lb)[i];
-	}
-
-	if ( ub != 0 )
-	{
-		for ( i=0; i<nV; ++i )
-			ub[i] = (*in_ub)[i];
-	}
-
-	if ( lbA != 0 )
-	{
-		for ( i=0; i<nC; ++i )
-			lbA[i] = (*in_lbA)[i];
-	}
-
-	if ( ubA != 0 )
-	{
-		for ( i=0; i<nC; ++i )
-			ubA[i] = (*in_ubA)[i];
-	}
-
-	xOpt = new real_t[nV];
-
-	if ( problem->getCount() == 0 )
-	{
-		/* initialise and solve first QP */
-		status = problem->init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-		problem->getPrimalSolution( xOpt );
-	}
-	else
-	{
-		/* solve neighbouring QP using hotstart technique */
-		status = problem->hotstart( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-		if ( ( status != SUCCESSFUL_RETURN ) && ( status != RET_MAX_NWSR_REACHED ) )
-		{
-			/* if an error occurs, reset problem data structures ... */
-			problem->reset( );
-            
-            /* ... and initialise/solve again with remaining number of iterations. */
-            int_t nWSR_retry = MAXITER - nWSR;
-			status = problem->init( H,g,A,lb,ub,lbA,ubA, nWSR_retry,0 );
-            nWSR += nWSR_retry;
-		}
-	        
-        /* obtain optimal solution */
-        problem->getPrimalSolution( xOpt );
-	}
-
-	/* generate block output: status information ... */
-	out_uOpt   = ssGetOutputPortRealSignal(S, 0);
-	out_objVal = ssGetOutputPortRealSignal(S, 1);
-	out_status = ssGetOutputPortRealSignal(S, 2);
-	out_nWSR   = ssGetOutputPortRealSignal(S, 3);
-
-	for ( i=0; i<nU; ++i )
-		out_uOpt[i] = (real_T)(xOpt[i]);
-
-	out_objVal[0] = (real_T)(problem->getObjVal( ));
-	out_status[0] = (real_t)(getSimpleStatus( status ));
-	out_nWSR[0]   = (real_T)(nWSR);
-
-	removeNaNs( out_uOpt,nU );
-	removeInfs( out_uOpt,nU );
-	removeNaNs( out_objVal,1 );
-	removeInfs( out_objVal,1 );
-
-	delete[] xOpt;
-}
-
-
-static void mdlTerminate(SimStruct *S)
-{
-	USING_NAMESPACE_QPOASES
-
-	int i;
-
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-
-	if ( ssGetPWork(S)[0] != 0 )
-		delete ((SQProblem*)(ssGetPWork(S)[0]));
-
-	for ( i=1; i<8; ++i )
-	{
-		if ( ssGetPWork(S)[i] != 0 )
-			free( ssGetPWork(S)[i] );
-	}
-}
-
-
-#ifdef  MATLAB_MEX_FILE
-#include "simulink.c"
-#else
-#include "cg_sfun.h"
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_simulink_utils.cpp b/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_simulink_utils.cpp
deleted file mode 100644
index 59c4158..0000000
--- a/extlibs/qpOASES-3.2.0/interfaces/simulink/qpOASES_simulink_utils.cpp
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file interfaces/simulink/qpOASES_simulink_utils.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Collects utility functions for Interface to Simulink(R) that
- *	enables to call qpOASES as a C S function.
- *
- */
-
-#ifndef __SINGLE_OBJECT__
-#include <qpOASES.hpp>
-#endif
-
-
-USING_NAMESPACE_QPOASES
-
-
-/*
- *	i s N a N
- */
-BooleanType isNaN( real_t val )
-{
-	if ( (( val <= 0.0 ) || ( val >= 0.0 )) == 0 )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *	r e m o v e N a N s
- */
-returnValue removeNaNs( real_t* const data, unsigned int dim )
-{
-	unsigned int i;
-
-	if ( data == 0 )
-		return RET_INVALID_ARGUMENTS;
-
-	for ( i=0; i<dim; ++i )
-		if ( isNaN(data[i]) == BT_TRUE )
-			data[i] = INFTY;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e I n f s
- */
-returnValue removeInfs( real_t* const data, unsigned int dim )
-{
-	unsigned int i;
-
-	if ( data == 0 )
-		return RET_INVALID_ARGUMENTS;
-
-	for ( i=0; i<dim; ++i )
-	{
-		if ( data[i] < -INFTY )
-			data[i] = -INFTY;
-
-		if ( data[i] > INFTY )
-			data[i] = INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	c o n v e r t F o r t r a n T o C
- */
-returnValue convertFortranToC( const real_t* const M_for, int nV, int nC, real_t* const M )
-{
-	int i,j;
-
-	if ( ( M_for == 0 ) || ( M == 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	if ( ( nV < 0 ) || ( nC < 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	for ( i=0; i<nC; ++i )
-		for ( j=0; j<nV; ++j )
-			M[i*nV + j] = M_for[j*nC + i];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/libqpOASESConfig.cmake.in b/extlibs/qpOASES-3.2.0/libqpOASESConfig.cmake.in
deleted file mode 100644
index 28ed2f6..0000000
--- a/extlibs/qpOASES-3.2.0/libqpOASESConfig.cmake.in
+++ /dev/null
@@ -1,13 +0,0 @@
-# CMake package configuration file for the plugin '@PROJECT_NAME@'
-
-@PACKAGE_INIT@
-
-if(NOT TARGET @PROJECT_NAME@)
-    include("${CMAKE_CURRENT_LIST_DIR}/@PROJECT_NAME@Targets.cmake")
-endif()
-
-check_required_components(@PROJECT_NAME@)
-
-set(@PROJECT_NAME@_LIBRARY @PROJECT_NAME@)
-set(@PROJECT_NAME@_LIBRARIES @PROJECT_NAME@)
-set(@PROJECT_NAME@_INCLUDE_DIRS @PROJECT_SOURCE_DIR@/include)
\ No newline at end of file
diff --git a/extlibs/qpOASES-3.2.0/make.mk b/extlibs/qpOASES-3.2.0/make.mk
deleted file mode 100644
index 5dcbf66..0000000
--- a/extlibs/qpOASES-3.2.0/make.mk
+++ /dev/null
@@ -1,38 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  make.mk
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-
-TOP = $(realpath $(dir $(lastword $(MAKEFILE_LIST))))
-
-include ${TOP}/make_linux.mk
-#include ${TOP}/make_cygwin.mk
-#include ${TOP}/make_windows.mk
-#include ${TOP}/make_osx.mk
diff --git a/extlibs/qpOASES-3.2.0/make_cygwin.mk b/extlibs/qpOASES-3.2.0/make_cygwin.mk
deleted file mode 100644
index 0279293..0000000
--- a/extlibs/qpOASES-3.2.0/make_cygwin.mk
+++ /dev/null
@@ -1,119 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  make_cygwin.mk
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-################################################################################
-# user configuration
-
-# include directories, relative
-IDIR =   ${TOP}/include
-SRCDIR = ${TOP}/src
-BINDIR = ${TOP}/bin
-
-# Matlab include directory (ADAPT TO YOUR LOCAL SETTINGS!)
-MATLAB_IDIR   = /cygdrive/c/progra~2/matlab/r2009b/extern/include/
-MATLAB_LIBDIR = /cygdrive/c/progra~2/matlab/r2009b/extern/lib/win32/microsoft
-
-# system or replacement BLAS/LAPACK
-REPLACE_LINALG = 1
-
-ifeq ($(REPLACE_LINALG), 1)
-	LIB_BLAS =   ${SRCDIR}/BLASReplacement.o
-	LIB_LAPACK = ${SRCDIR}/LAPACKReplacement.o
-else
-	LIB_BLAS =   /usr/lib/lapack/cygblas-0.dll
-	LIB_LAPACK = /usr/lib/lapack/cyglapack-0.dll
-endif
-
-# choice of sparse solver: NONE, MA27, or MA57
-# If choice is not 'NONE', BLAS and LAPACK replacements must not be used
-USE_SOLVER = NONE
-
-ifeq ($(USE_SOLVER), MA57)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma57.a /usr/local/lib/libfakemetis.a
-	DEF_SOLVER = SOLVER_MA57
-else ifeq ($(USE_SOLVER), MA27)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma27.a
-	DEF_SOLVER = SOLVER_MA27
-else
-	LIB_SOLVER =
-	DEF_SOLVER = SOLVER_NONE
-endif
-
-################################################################################
-# do not touch this
-
-CPP = g++
-CC  = gcc
-AR  = ar
-RM  = rm
-F77 = gfortran
-ECHO = echo
-CD = cd
-CP = cp
-
-# file extensions
-OBJEXT = o
-LIBEXT = a
-DLLEXT = so
-EXE = .exe
-MEXOCTEXT = mex
-DEF_TARGET = -o $@
-SHARED = -shared
-
-# 32 or 64 depending on target platform
-BITS = $(shell getconf LONG_BIT)
-
-# decide on MEX interface extension
-ifeq ($(BITS), 32)
-	MEXEXT = mexw32
-else
-	MEXEXT = mexw64
-endif
-
-CPPFLAGS = -Wall -pedantic -Wshadow -Wfloat-equal -O3 -Wconversion -Wsign-conversion -finline-functions -DWIN32 -D${DEF_SOLVER} -D__NO_COPYRIGHT__ 
-#          -g -D__DEBUG__ -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__ -D__USE_SINGLE_PRECISION__
-
-# libraries to link against when building qpOASES .so files
-LINK_LIBRARIES = ${LIB_LAPACK} ${LIB_BLAS} -lm ${LIB_SOLVER}
-LINK_LIBRARIES_WRAPPER = -lm ${LIB_SOLVER} -lstdc++
-
-# how to link against the qpOASES shared library
-QPOASES_LINK = -L${BINDIR} -Wl,-rpath=${BINDIR} -lqpOASES
-QPOASES_LINK_WRAPPER = -L${BINDIR} -Wl,-rpath=${BINDIR} -lqpOASES_wrapper
-
-# link dependencies when creating executables
-LINK_DEPENDS = ${LIB_LAPACK} ${LIB_BLAS} ${BINDIR}/libqpOASES.${LIBEXT} ${BINDIR}/libqpOASES.${DLLEXT}
-LINK_DEPENDS_WRAPPER = ${BINDIR}/libqpOASES_wrapper.${LIBEXT} ${BINDIR}/libqpOASES_wrapper.${DLLEXT}
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/make_linux.mk b/extlibs/qpOASES-3.2.0/make_linux.mk
deleted file mode 100644
index 0670f11..0000000
--- a/extlibs/qpOASES-3.2.0/make_linux.mk
+++ /dev/null
@@ -1,122 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  make_linux.mk
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-################################################################################
-# user configuration
-
-# include directories, relative
-IDIR =   ${TOP}/include
-SRCDIR = ${TOP}/src
-BINDIR = ${TOP}/bin
-
-# Matlab include directory (ADAPT TO YOUR LOCAL SETTINGS!)
-#MATLAB_IDIR   = ${HOME}/Programs/matlab/extern/include/
-MATLAB_IDIR   = /usr/local/matlab/extern/include/
-MATLAB_LIBDIR = /usr/local/matlab/bin/glnxa64/
-
-# system or replacement BLAS/LAPACK
-REPLACE_LINALG = 1
-
-ifeq ($(REPLACE_LINALG), 1)
-	LIB_BLAS =   ${SRCDIR}/BLASReplacement.o
-	LIB_LAPACK = ${SRCDIR}/LAPACKReplacement.o
-else
-	LIB_BLAS =   /usr/lib/libblas.so
-	LIB_LAPACK = /usr/lib/liblapack.so
-endif
-
-# choice of sparse solver: NONE, MA27, or MA57
-# If choice is not 'NONE', BLAS and LAPACK replacements must not be used
-USE_SOLVER = NONE
-
-ifeq ($(USE_SOLVER), MA57)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma57.a /usr/local/lib/libfakemetis.a
-	DEF_SOLVER = SOLVER_MA57
-else ifeq ($(USE_SOLVER), MA27)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma27.a
-	DEF_SOLVER = SOLVER_MA27
-else
-	LIB_SOLVER =
-	DEF_SOLVER = SOLVER_NONE
-endif
-
-################################################################################
-# do not touch this
-
-CPP = g++
-CC  = gcc
-AR  = ar
-RM  = rm
-F77 = gfortran
-ECHO = echo
-CD = cd
-CP = cp
-
-# file extensions
-OBJEXT = o
-LIBEXT = a
-DLLEXT = so
-EXE =
-MEXOCTEXT = mex
-DEF_TARGET = -o $@
-SHARED = -shared
-
-# 32 or 64 depending on target platform
-BITS = $(shell getconf LONG_BIT)
-
-# decide on MEX interface extension
-ifeq ($(BITS), 32)
-	MEXEXT = mexglx
-else
-	MEXEXT = mexa64
-endif
-
-
-
-CPPFLAGS = -Wall -pedantic -Wshadow -Wfloat-equal -O3 -Wconversion -Wsign-conversion -finline-functions -fPIC -DLINUX -D${DEF_SOLVER} -D__NO_COPYRIGHT__
-#          -g -D__DEBUG__ -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__ -D__USE_SINGLE_PRECISION__
-
-# libraries to link against when building qpOASES .so files
-LINK_LIBRARIES = ${LIB_LAPACK} ${LIB_BLAS} -lm ${LIB_SOLVER}
-LINK_LIBRARIES_WRAPPER = -lm ${LIB_SOLVER} -lstdc++
-
-# how to link against the qpOASES shared library
-QPOASES_LINK = -L${BINDIR} -Wl,-rpath=${BINDIR} -lqpOASES
-QPOASES_LINK_WRAPPER = -L${BINDIR} -Wl,-rpath=${BINDIR} -lqpOASES_wrapper
-
-# link dependencies when creating executables
-LINK_DEPENDS = ${LIB_LAPACK} ${LIB_BLAS} ${BINDIR}/libqpOASES.${LIBEXT} ${BINDIR}/libqpOASES.${DLLEXT}
-LINK_DEPENDS_WRAPPER = ${BINDIR}/libqpOASES_wrapper.${LIBEXT} ${BINDIR}/libqpOASES_wrapper.${DLLEXT}
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/make_osx.mk b/extlibs/qpOASES-3.2.0/make_osx.mk
deleted file mode 100644
index 4f77386..0000000
--- a/extlibs/qpOASES-3.2.0/make_osx.mk
+++ /dev/null
@@ -1,124 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  make_osx.mk
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-################################################################################
-# user configuration
-
-# include directories, relative
-IDIR =   ${TOP}/include
-SRCDIR = ${TOP}/src
-BINDIR = ${TOP}/bin
-
-# MacOSX SDK
-SYSROOT = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.8.sdk
-SDK = -isysroot ${SYSROOT} -stdlib=libc++ -I/usr/include -L/usr/lib/
-
-# Matlab include directory (ADAPT TO YOUR LOCAL SETTINGS!)
-MATLAB_IDIR   = /Applications/MATLAB_R2013a.app/extern/include/
-MATLAB_LIBDIR =
-
-# system or replacement BLAS/LAPACK
-REPLACE_LINALG = 1
-
-ifeq ($(REPLACE_LINALG), 1)
-	LIB_BLAS =   ${SRCDIR}/BLASReplacement.o
-	LIB_LAPACK = ${SRCDIR}/LAPACKReplacement.o
-	LA_DEPENDS = ${LIB_LAPACK} ${LIB_BLAS}
-else
-	LIB_BLAS =   -framework Accelerate
-	LIB_LAPACK =
-	LA_DEPENDS =
-endif
-
-# choice of sparse solver: NONE, MA27, or MA57
-# If choice is not 'NONE', BLAS and LAPACK replacements must not be used
-USE_SOLVER = NONE
-
-ifeq ($(USE_SOLVER), MA57)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma57.a /usr/local/lib/libfakemetis.a
-	DEF_SOLVER = SOLVER_MA57
-else ifeq ($(USE_SOLVER), MA27)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma27.a
-	DEF_SOLVER = SOLVER_MA27
-else
-	LIB_SOLVER =
-	DEF_SOLVER = SOLVER_NONE
-endif
-
-################################################################################
-# do not touch this
-
-CPP = clang++
-CC  = clang
-AR  = ar
-RM  = rm
-F77 = gfortran
-ECHO = echo
-CD = cd
-
-# file extensions
-OBJEXT = o
-LIBEXT = a
-DLLEXT = dylib
-EXE =
-MEXOCTEXT = mex
-DEF_TARGET = -o $@
-SHARED = -dynamiclib ${SDK} -lgcc_s.10.5 -ldylib1.o
-
-# 32 or 64 depending on target platform
-BITS = $(shell getconf LONG_BIT)
-
-# decide on MEX interface extension
-ifeq ($(BITS), 32)
-	MEXEXT = mexglx
-else
-	MEXEXT = mexa64
-endif
-
-CPPFLAGS = ${SDK} -Wall -pedantic -Wshadow -Wfloat-equal -Wconversion -Wsign-conversion -O3 -finline-functions -fPIC -DLINUX
-#          -g -D__DEBUG__ -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__ -D__USE_SINGLE_PRECISION__
-
-# libraries to link against when building qpOASES .so files
-LINK_LIBRARIES = ${LIB_LAPACK} ${LIB_BLAS} -lm ${LIB_SOLVER}
-LINK_LIBRARIES_WRAPPER = -lm ${LIB_SOLVER}
-
-# how to link against the qpOASES shared library
-QPOASES_LINK = -L${BINDIR}  -lqpOASES -L${SYSROOT}/usr/lib/System -lgcc_s.10.5 -lcrt1.o
-QPOASES_LINK_WRAPPER = -L${BINDIR} -lqpOASES_wrapper
-
-# link dependencies when creating executables
-LINK_DEPENDS = ${LA_DEPENDS} ${BINDIR}/libqpOASES.${LIBEXT} ${BINDIR}/libqpOASES.${DLLEXT}
-LINK_DEPENDS_WRAPPER = ${BINDIR}/libqpOASES_wrapper.${LIBEXT} ${BINDIR}/libqpOASES_wrapper.${DLLEXT}
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/make_windows.mk b/extlibs/qpOASES-3.2.0/make_windows.mk
deleted file mode 100644
index 8debc8c..0000000
--- a/extlibs/qpOASES-3.2.0/make_windows.mk
+++ /dev/null
@@ -1,126 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  make_windows.mk
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-
-##
-##	definitions for compiling with Visual Studio under Windows
-##
-
-
-################################################################################
-# user configuration
-
-# include directories, relative
-IDIR =   ${TOP}/include
-SRCDIR = ${TOP}/src
-BINDIR = ${TOP}/bin
-
-# Matlab include directory (ADAPT TO YOUR LOCAL SETTINGS!)
-#MATLAB_IDIR   = ${HOME}/Programs/matlab/extern/include/
-MATLAB_IDIR = /usr/local/matlab/extern/include/
-MATLAB_LIBDIR = /usr/local/matlab/bin/glnxa64/
-
-# system or replacement BLAS/LAPACK
-REPLACE_LINALG = 1
-
-ifeq ($(REPLACE_LINALG), 1)
-	LIB_BLAS =   ${SRCDIR}/BLASReplacement.o
-	LIB_LAPACK = ${SRCDIR}/LAPACKReplacement.o
-else
-	LIB_BLAS =   /usr/lib/libblas.so
-	LIB_LAPACK = /usr/lib/liblapack.so
-endif
-
-# choice of sparse solver: NONE, MA27, or MA57
-# If choice is not 'NONE', BLAS and LAPACK replacements must not be used
-USE_SOLVER = NONE
-
-ifeq ($(USE_SOLVER), MA57)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma57.a /usr/local/lib/libfakemetis.a
-	DEF_SOLVER = SOLVER_MA57
-else ifeq ($(USE_SOLVER), MA27)
-	LIB_SOLVER = /usr/local/lib/libhsl_ma27.a
-	DEF_SOLVER = SOLVER_MA27
-else
-	LIB_SOLVER =
-	DEF_SOLVER = SOLVER_NONE
-endif
-
-################################################################################
-# do not touch this
-
-CPP = cl
-CC  = cl
-AR  = ar
-RM  = rm
-F77 = gfortran
-ECHO = echo
-CD = cd
-CP = copy
-
-# file extensions
-OBJEXT = obj
-LIBEXT = lib
-DLLEXT = so
-EXE = .exe
-MEXOCTEXT = mex
-DEF_TARGET =
-SHARED = /LD
-
-# 32 or 64 depending on target platform
-BITS = $(shell getconf LONG_BIT)
-
-# decide on MEX interface extension
-ifeq ($(BITS), 32)
-	MEXEXT = mexglx
-else
-	MEXEXT = mexa64
-endif
-
-CPPFLAGS = -nologo -EHsc -DWIN32 -Dsnprintf=_snprintf
-#-g -D__DEBUG__ -D__NO_COPYRIGHT__ -D__SUPPRESSANYOUTPUT__
-
-# libraries to link against when building qpOASES .so files
-LINK_LIBRARIES = ${LIB_LAPACK} ${LIB_BLAS} -lm ${LIB_SOLVER}
-LINK_LIBRARIES_WRAPPER = -lm ${LIB_SOLVER}
-
-# how to link against the qpOASES shared library
-QPOASES_LINK = /I${BINDIR} /WL /link ${BINDIR}/libqpOASES.lib
-QPOASES_LINK_WRAPPER = /I${BINDIR} /WL /link ${BINDIR}/libqpOASES_wrapper.lib
-
-# link dependencies when creating executables
-LINK_DEPENDS = ${LIB_LAPACK} ${LIB_BLAS} ${BINDIR}/libqpOASES.${LIBEXT} ${BINDIR}/libqpOASES.${DLLEXT}
-LINK_DEPENDS_WRAPPER = ${BINDIR}/libqpOASES_wrapper.${LIBEXT} ${BINDIR}/libqpOASES_wrapper.${DLLEXT}
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/src/BLASReplacement.cpp b/extlibs/qpOASES-3.2.0/src/BLASReplacement.cpp
deleted file mode 100644
index 745fd55..0000000
--- a/extlibs/qpOASES-3.2.0/src/BLASReplacement.cpp
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/BLASReplacement.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	BLAS Level 3 replacement routines.
- */
-
-
-#include <qpOASES/Utils.hpp>
-
-
-extern "C" void dgemm_(	const char *TRANSA, const char *TRANSB,
-						const unsigned long *M, const unsigned long *N, const unsigned long *K,
-						const double *ALPHA, const double *A, const unsigned long *LDA, const double *B, const unsigned long *LDB,
-						const double *BETA, double *C, const unsigned long *LDC
-						)
-{
-	unsigned long i, j, k;
-
-	if ( REFER_NAMESPACE_QPOASES isZero(*BETA) == REFER_NAMESPACE_QPOASES BT_TRUE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] = 0.0;
-	else if ( REFER_NAMESPACE_QPOASES isEqual(*BETA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] = -C[j+(*LDC)*k];
-	else if ( REFER_NAMESPACE_QPOASES isEqual(*BETA,1.0) == REFER_NAMESPACE_QPOASES BT_FALSE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] *= *BETA;
-
-	if (TRANSA[0] == 'N')
-		if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += A[j+(*LDA)*i] * B[i+(*LDB)*k];
-		else if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] -= A[j+(*LDA)*i] * B[i+(*LDB)*k];
-		else
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += *ALPHA * A[j+(*LDA)*i] * B[i+(*LDB)*k];
-	else
-		if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += A[i+(*LDA)*j] * B[i+(*LDB)*k];
-		else if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] -= A[i+(*LDA)*j] * B[i+(*LDB)*k];
-		else
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += *ALPHA * A[i+(*LDA)*j] * B[i+(*LDB)*k];
-}
-
-extern "C" void sgemm_(	const char *TRANSA, const char *TRANSB,
-						const unsigned long *M, const unsigned long *N, const unsigned long *K,
-						const float *ALPHA, const float *A, const unsigned long *LDA, const float *B, const unsigned long *LDB,
-						const float *BETA, float *C, const unsigned long *LDC
-						)
-{
-	unsigned long i, j, k;
-
-	if ( REFER_NAMESPACE_QPOASES isZero(*BETA) == REFER_NAMESPACE_QPOASES BT_TRUE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] = 0.0;
-	else if ( REFER_NAMESPACE_QPOASES isEqual(*BETA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] = -C[j+(*LDC)*k];
-	else if ( REFER_NAMESPACE_QPOASES isEqual(*BETA,1.0) == REFER_NAMESPACE_QPOASES BT_FALSE )
-		for (k = 0; k < *N; k++)
-			for (j = 0; j < *M; j++)
-				C[j+(*LDC)*k] *= *BETA;
-
-	if (TRANSA[0] == 'N')
-		if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += A[j+(*LDA)*i] * B[i+(*LDB)*k];
-		else if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] -= A[j+(*LDA)*i] * B[i+(*LDB)*k];
-		else
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += *ALPHA * A[j+(*LDA)*i] * B[i+(*LDB)*k];
-	else
-		if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += A[i+(*LDA)*j] * B[i+(*LDB)*k];
-		else if ( REFER_NAMESPACE_QPOASES isEqual(*ALPHA,-1.0) == REFER_NAMESPACE_QPOASES BT_TRUE )
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] -= A[i+(*LDA)*j] * B[i+(*LDB)*k];
-		else
-			for (k = 0; k < *N; k++)
-				for (j = 0; j < *M; j++)
-					for (i = 0; i < *K; i++)
-						C[j+(*LDC)*k] += *ALPHA * A[i+(*LDA)*j] * B[i+(*LDB)*k];
-}
diff --git a/extlibs/qpOASES-3.2.0/src/Bounds.cpp b/extlibs/qpOASES-3.2.0/src/Bounds.cpp
deleted file mode 100644
index 64081a1..0000000
--- a/extlibs/qpOASES-3.2.0/src/Bounds.cpp
+++ /dev/null
@@ -1,514 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Bounds.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the Bounds class designed to manage working sets of
- *	bounds within a QProblem.
- */
-
-
-#include <qpOASES/Bounds.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	B o u n d s
- */
-Bounds::Bounds( ) : SubjectTo( )
-{
-}
-
-
-/*
- *	B o u n d s
- */
-Bounds::Bounds( int_t _n ) : SubjectTo( _n )
-{
-	init( _n );
-}
-
-
-/*
- *	B o u n d s
- */
-Bounds::Bounds( const Bounds& rhs ) : SubjectTo( rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ B o u n d s
- */
-Bounds::~Bounds( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Bounds& Bounds::operator=( const Bounds& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		SubjectTo::operator=( rhs );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-
-/*
- *	i n i t
- */
-returnValue Bounds::init(	int_t _n
-							)
-{
-	if ( _n < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	clear( );
-
-	if ( _n >= 0 )
-	{
-		freee.init( _n );
-		fixed.init( _n );
-	}
-
-	return SubjectTo::init( _n );
-}
-
-
-
-/*
- *	s e t u p B o u n d
- */
-returnValue Bounds::setupBound(	int_t number, SubjectToStatus _status
-								)
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Add bound index to respective index list. */
-	switch ( _status )
-	{
-		case ST_INACTIVE:
-			if ( this->addIndex( this->getFree( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-			break;
-
-		case ST_LOWER:
-			if ( this->addIndex( this->getFixed( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-			break;
-
-		case ST_UPPER:
-			if ( this->addIndex( this->getFixed( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-			break;
-
-		default:
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A l l F r e e
- */
-returnValue Bounds::setupAllFree( )
-{
-	return setupAll( ST_INACTIVE );
-}
-
-
-/*
- *	s e t u p A l l L o w e r
- */
-returnValue Bounds::setupAllLower( )
-{
-	return setupAll( ST_LOWER );
-}
-
-
-/*
- *	s e t u p A l l U p p e r
- */
-returnValue Bounds::setupAllUpper( )
-{
-	return setupAll( ST_UPPER );
-}
-
-
-/*
- *	m o v e F i x e d T o F r e e
- */
-returnValue Bounds::moveFixedToFree( int_t number )
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Move index from indexlist of fixed variables to that of free ones. */
-	if ( this->removeIndex( this->getFixed( ),number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	if ( this->addIndex( this->getFree( ),number,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	m o v e F r e e T o F i x e d
- */
-returnValue Bounds::moveFreeToFixed(	int_t number, SubjectToStatus _status
-										)
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Move index from indexlist of free variables to that of fixed ones. */
-	if ( this->removeIndex( this->getFree( ),number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	if ( this->addIndex( this->getFixed( ),number,_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	f l i p F i x e d
- */
-returnValue Bounds::flipFixed( int_t number )
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	if ( status != 0 )
-		switch (status[number])
-		{
-			case ST_LOWER: status[number] = ST_UPPER; break;
-			case ST_UPPER: status[number] = ST_LOWER; break;
-			default: return THROWERROR( RET_MOVING_BOUND_FAILED );
-		}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s w a p F r e e
- */
-returnValue Bounds::swapFree(	int_t number1, int_t number2
-								)
-{
-	/* consistency check */
-	if ( ( number1 < 0 ) || ( number1 >= n ) || ( number2 < 0 ) || ( number2 >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Swap index within indexlist of free variables. */
-	return this->swapIndex( this->getFree( ),number1,number2 );
-}
-
-
-/*
- *	s h i f t
- */
-returnValue Bounds::shift(	int_t offset )
-{
-	int_t i;
-
-	/* consistency check */
-	if ( ( offset == 0 ) || ( n <= 1 ) )
-		return SUCCESSFUL_RETURN;
-
-	if ( ( offset < 0 ) || ( offset > n/2 ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	if ( ( n % offset ) != 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Shift types and status. */
-	for( i=0; i<n-offset; ++i )
-	{
-		setType( i,getType( i+offset ) );
-		setStatus( i,getStatus( i+offset ) );
-	}
-
-	/* 2) Construct shifted index lists of free and fixed variables. */
-	Indexlist shiftedFreee( n );
-	Indexlist shiftedFixed( n );
-
-	for( i=0; i<n; ++i )
-	{
-		switch ( getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( shiftedFreee.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			case ST_LOWER:
-				if ( shiftedFixed.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			case ST_UPPER:
-				if ( shiftedFixed.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			default:
-				return THROWERROR( RET_SHIFTING_FAILED );
-		}
-	}
-
-	/* 3) Assign shifted index list. */
-	freee = shiftedFreee;
-	fixed = shiftedFixed;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r o t a t e
- */
-returnValue Bounds::rotate( int_t offset )
-{
-	int_t i;
-
-	/* consistency check */
-	if ( ( offset == 0 ) || ( offset == n ) || ( n <= 1 ) )
-		return SUCCESSFUL_RETURN;
-
-	if ( ( offset < 0 ) || ( offset > n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-
-	/* 1) Rotate types and status. */
-	SubjectToType*   typeTmp   = new SubjectToType[offset];
-	SubjectToStatus* statusTmp = new SubjectToStatus[offset];
-
-	for( i=0; i<offset; ++i )
-	{
-		typeTmp[i] = getType( i );
-		statusTmp[i] = getStatus( i );
-	}
-
-	for( i=0; i<n-offset; ++i )
-	{
-		setType( i,getType( i+offset ) );
-		setStatus( i,getStatus( i+offset ) );
-	}
-
-	for( i=n-offset; i<n; ++i )
-	{
-		setType( i,typeTmp[i-n+offset] );
-		setStatus( i,statusTmp[i-n+offset] );
-	}
-
-	delete[] statusTmp; delete[] typeTmp;
-
-	/* 2) Construct shifted index lists of free and fixed variables. */
-	Indexlist rotatedFreee( n );
-	Indexlist rotatedFixed( n );
-
-	for( i=0; i<n; ++i )
-	{
-		switch ( getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( rotatedFreee.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			case ST_LOWER:
-				if ( rotatedFixed.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			case ST_UPPER:
-				if ( rotatedFixed.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			default:
-				return THROWERROR( RET_ROTATING_FAILED );
-		}
-	}
-
-	/* 3) Assign shifted index list. */
-	freee = rotatedFreee;
-	fixed = rotatedFixed;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue Bounds::print( )
-{
-	if ( n == 0 )
-		return SUCCESSFUL_RETURN;
-
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-
-	int_t* FR_idx;
-	getFree( )->getNumberArray( &FR_idx );
-
-	int_t* FX_idx;
-	getFixed( )->getNumberArray( &FX_idx );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"Bounds object comprising %d variables (%d free, %d fixed):\n",(int)n,(int)nFR,(int)nFX );
-	myPrintf( myPrintfString );
-
-	REFER_NAMESPACE_QPOASES print( FR_idx,nFR,"free " );
-	REFER_NAMESPACE_QPOASES print( FX_idx,nFX,"fixed" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Bounds::clear( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Bounds::copy(	const Bounds& rhs
-							)
-{
-	freee = rhs.freee;
-	fixed = rhs.fixed;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p A l l
- */
-returnValue Bounds::setupAll( SubjectToStatus _status )
-{
-	int_t i;
-
-	/* 1) Place unbounded variables at the beginning of the index list of free variables. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_UNBOUNDED )
-		{
-			if ( setupBound( i,_status ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_BOUND_FAILED );
-		}
-	}
-
-	/* 2) Add remaining (i.e. bounded but possibly free) variables to the index list of free variables. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_BOUNDED )
-		{
-			if ( setupBound( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-		}
-	}
-
-	/* 3) Place implicitly fixed variables at the end of the index list of free variables. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_EQUALITY )
-		{
-			if ( setupBound( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-		}
-	}
-
-	/* 4) Moreover, add all bounds of unknown type. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_UNKNOWN || getType( i ) == ST_DISABLED )
-		{
-			if ( setupBound( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_BOUND_FAILED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/Constraints.cpp b/extlibs/qpOASES-3.2.0/src/Constraints.cpp
deleted file mode 100644
index 9b024aa..0000000
--- a/extlibs/qpOASES-3.2.0/src/Constraints.cpp
+++ /dev/null
@@ -1,499 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Constraints.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the Constraints class designed to manage working sets of
- *	constraints within a QProblem.
- */
-
-
-#include <qpOASES/Constraints.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	C o n s t r a i n t s
- */
-Constraints::Constraints( ) : SubjectTo( )
-{
-}
-
-
-/*
- *	C o n s t r a i n t s
- */
-Constraints::Constraints( int_t _n ) : SubjectTo( _n )
-{
-	init( _n );
-}
-
-
-/*
- *	C o n s t r a i n t s
- */
-Constraints::Constraints( const Constraints& rhs ) : SubjectTo( rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ C o n s t r a i n t s
- */
-Constraints::~Constraints( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Constraints& Constraints::operator=( const Constraints& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		SubjectTo::operator=( rhs );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-/*
- *	i n i t
- */
-returnValue Constraints::init(	int_t _n
-								)
-{
-	if ( _n < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	clear( );
-
-	if ( _n >= 0 )
-	{
-		active.init(   _n );
-		inactive.init( _n );
-	}
-
-	return SubjectTo::init( _n );
-}
-
-
-
-/*
- *	s e t u p C o n s t r a i n t
- */
-returnValue Constraints::setupConstraint(	int_t number, SubjectToStatus _status
-											)
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Add constraint index to respective index list. */
-	switch ( _status )
-	{
-		case ST_INACTIVE:
-			if ( this->addIndex( this->getInactive( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-			break;
-
-		case ST_LOWER:
-			if ( this->addIndex( this->getActive( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-			break;
-
-		case ST_UPPER:
-			if ( this->addIndex( this->getActive( ),number,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-			break;
-
-		default:
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A l l I n a c t i v e
- */
-returnValue Constraints::setupAllInactive( )
-{
-	return setupAll( ST_INACTIVE );
-}
-
-
-/*
- *	s e t u p A l l L o w e r
- */
-returnValue Constraints::setupAllLower( )
-{
-	return setupAll( ST_LOWER );
-}
-
-
-/*
- *	s e t u p A l l U p p e r
- */
-returnValue Constraints::setupAllUpper( )
-{
-	return setupAll( ST_UPPER );
-}
-
-
-/*
- *	m o v e A c t i v e T o I n a c t i v e
- */
-returnValue Constraints::moveActiveToInactive( int_t number )
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Move index from indexlist of active constraints to that of inactive ones. */
-	if ( this->removeIndex( this->getActive( ),number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	if ( this->addIndex( this->getInactive( ),number,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	m o v e I n a c t i v e T o A c t i v e
- */
-returnValue Constraints::moveInactiveToActive(	int_t number, SubjectToStatus _status
-												)
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	/* Move index from indexlist of inactive constraints to that of active ones. */
-	if ( this->removeIndex( this->getInactive( ),number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	if ( this->addIndex( this->getActive( ),number,_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_MOVING_BOUND_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	f l i p F i x e d
- */
-returnValue Constraints::flipFixed( int_t number )
-{
-	/* consistency check */
-	if ( ( number < 0 ) || ( number >= n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	if ( status != 0 )
-		switch (status[number])
-		{
-			case ST_LOWER: status[number] = ST_UPPER; break;
-			case ST_UPPER: status[number] = ST_LOWER; break;
-			default: return THROWERROR( RET_MOVING_CONSTRAINT_FAILED );
-		}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s h i f t
- */
-returnValue Constraints::shift( int_t offset )
-{
-	int_t i;
-
-	/* consistency check */
-	if ( ( offset == 0 ) || ( n <= 1 ) )
-		return SUCCESSFUL_RETURN;
-
-	if ( ( offset < 0 ) || ( offset > n/2 ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-	if ( ( n % offset ) != 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Shift types and status. */
-	for( i=0; i<n-offset; ++i )
-	{
-		setType( i,getType( i+offset ) );
-		setStatus( i,getStatus( i+offset ) );
-	}
-
-	/* 2) Construct shifted index lists of free and fixed variables. */
-	Indexlist shiftedActive( n );
-	Indexlist shiftedInactive( n );
-
-	for( i=0; i<n; ++i )
-	{
-		switch ( getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( shiftedInactive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			case ST_LOWER:
-				if ( shiftedActive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			case ST_UPPER:
-				if ( shiftedActive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SHIFTING_FAILED );
-				break;
-
-			default:
-				return THROWERROR( RET_SHIFTING_FAILED );
-		}
-	}
-
-	/* 3) Assign shifted index list. */
-	active = shiftedActive;
-	inactive = shiftedInactive;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r o t a t e
- */
-returnValue Constraints::rotate( int_t offset )
-{
-	int_t i;
-
-	/* consistency check */
-	if ( ( offset == 0 ) || ( offset == n ) || ( n <= 1 ) )
-		return SUCCESSFUL_RETURN;
-
-	if ( ( offset < 0 ) || ( offset > n ) )
-		return THROWERROR( RET_INDEX_OUT_OF_BOUNDS );
-
-
-	/* 1) Rotate types and status. */
-	SubjectToType*   typeTmp   = new SubjectToType[offset];
-	SubjectToStatus* statusTmp = new SubjectToStatus[offset];
-
-	for( i=0; i<offset; ++i )
-	{
-		typeTmp[i] = getType( i );
-		statusTmp[i] = getStatus( i );
-	}
-
-	for( i=0; i<n-offset; ++i )
-	{
-		setType( i,getType( i+offset ) );
-		setStatus( i,getStatus( i+offset ) );
-	}
-
-	for( i=n-offset; i<n; ++i )
-	{
-		setType( i,typeTmp[i-n+offset] );
-		setStatus( i,statusTmp[i-n+offset] );
-	}
-
-	delete[] statusTmp; delete[] typeTmp;
-
-	/* 2) Construct shifted index lists of free and fixed variables. */
-	Indexlist rotatedActive( n );
-	Indexlist rotatedInactive( n );
-
-	for( i=0; i<n; ++i )
-	{
-		switch ( getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( rotatedInactive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			case ST_LOWER:
-				if ( rotatedActive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			case ST_UPPER:
-				if ( rotatedActive.addNumber( i ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ROTATING_FAILED );
-				break;
-
-			default:
-				return THROWERROR( RET_ROTATING_FAILED );
-		}
-	}
-
-	/* 3) Assign shifted index list. */
-	active = rotatedActive;
-	inactive = rotatedInactive;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue Constraints::print( )
-{
-	if ( n == 0 )
-		return SUCCESSFUL_RETURN;
-
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	int_t nIAC = getNIAC( );
-	int_t nAC  = getNAC( );
-
-	int_t* IAC_idx;
-	getInactive( )->getNumberArray( &IAC_idx );
-
-	int_t* AC_idx;
-	getActive( )->getNumberArray( &AC_idx );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"Constraints object comprising %d constraints (%d inactive, %d active):\n",(int)n,(int)nIAC,(int)nAC );
-	myPrintf( myPrintfString );
-
-	REFER_NAMESPACE_QPOASES print( IAC_idx,nIAC,"inactive" );
-	REFER_NAMESPACE_QPOASES print( AC_idx, nAC, "active  " );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Constraints::clear( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Constraints::copy(	const Constraints& rhs
-								)
-{
-	active   = rhs.active;
-	inactive = rhs.inactive;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p A l l
- */
-returnValue Constraints::setupAll( SubjectToStatus _status )
-{
-	int_t i;
-
-	/* 1) Place unbounded constraints at the beginning of the index list of inactive constraints. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_UNBOUNDED )
-		{
-			if ( setupConstraint( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-		}
-	}
-
-	/* 2) Add remaining (i.e. "real" inequality) constraints to the index list of inactive constraints. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_BOUNDED )
-		{
-			if ( setupConstraint( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-		}
-	}
-
-	/* 3) Place implicit equality constraints at the end of the index list of inactive constraints. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_EQUALITY )
-		{
-			if ( setupConstraint( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-		}
-	}
-
-	/* 4) Moreover, add all constraints of unknown type. */
-	for( i=0; i<n; ++i )
-	{
-		if ( getType( i ) == ST_UNKNOWN || getType( i ) == ST_DISABLED )
-		{
-			if ( setupConstraint( i,_status ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_CONSTRAINT_FAILED );
-		}
-	}
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/Flipper.cpp b/extlibs/qpOASES-3.2.0/src/Flipper.cpp
deleted file mode 100644
index 14ca0bd..0000000
--- a/extlibs/qpOASES-3.2.0/src/Flipper.cpp
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Flipper.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the Flipper class designed to manage working sets of
- *	constraints and bounds within a QProblem.
- */
-
-
-#include <qpOASES/Flipper.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	F l i p p e r
- */
-Flipper::Flipper( )
-{
-	R = 0;
-	Q = 0;
-	T = 0;
-	
-	init( );
-}
-
-
-/*
- *	F l i p p e r
- */
-Flipper::Flipper(	uint_t _nV,
-					uint_t _nC
-					)
-{
-	R = 0;
-	Q = 0;
-	T = 0;
-	
-	init( _nV,_nC );
-}
-
-
-/*
- *	F l i p p e r
- */
-Flipper::Flipper( const Flipper& rhs )
-{
-	R = 0;
-	Q = 0;
-	T = 0;
-
-	copy( rhs );
-}
-
-
-/*
- *	~ F l i p p e r
- */
-Flipper::~Flipper( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Flipper& Flipper::operator=( const Flipper& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-
-/*
- *	i n i t
- */
-returnValue Flipper::init(	uint_t _nV,
-							uint_t _nC
-							)
-{
-	clear( );
-
-	nV = _nV;
-	nC = _nC;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	g e t
- */
-returnValue Flipper::get(	Bounds* const _bounds,
-							real_t* const _R,
-							Constraints* const _constraints,
-							real_t* const _Q,
-							real_t* const _T 
-							) const
-{
-	if ( _bounds != 0 )
-		*_bounds = bounds;
-
-	if ( _constraints != 0 )
-		*_constraints = constraints;
-
-	if ( ( _R != 0 ) && ( R != 0 ) )
-		memcpy( _R,R, nV*nV*sizeof(real_t) );
-
-	if ( ( _Q != 0 ) && ( Q != 0 ) )
-		memcpy( _Q,Q, nV*nV*sizeof(real_t) );
-
-	if ( ( _T != 0 ) && ( T != 0 ) )
-		memcpy( _T,T, getDimT()*sizeof(real_t) );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t
- */
-returnValue Flipper::set(	const Bounds* const _bounds,
-							const real_t* const _R,
-							const Constraints* const _constraints,
-							const real_t* const _Q,
-							const real_t* const _T
-							)
-{
-	if ( _bounds != 0 )
-		bounds = *_bounds;
-
-	if ( _constraints != 0 )
-		constraints = *_constraints;
-
-	if ( _R != 0 )
-	{
-		if ( R == 0 )
-			R = new real_t[nV*nV];
-
-		memcpy( R,_R, nV*nV*sizeof(real_t) );
-	}
-
-	if ( _Q != 0 )
-	{
-		if ( Q == 0 )
-			Q = new real_t[nV*nV];
-
-		memcpy( Q,_Q, nV*nV*sizeof(real_t) );
-	}
-
-	if ( _T != 0 )
-	{
-		if ( T == 0 )
-			T = new real_t[getDimT()];
-
-		memcpy( T,_T, getDimT()*sizeof(real_t) );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Flipper::clear( )
-{
-	if ( R != 0 )
-	{
-		delete[] R;
-		R = 0;
-	}
-	
-	if ( Q != 0 )
-	{
-		delete[] Q;
-		Q = 0;
-	}
-	
-	if ( T != 0 )
-	{
-		delete[] T;
-		T = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Flipper::copy(	const Flipper& rhs
-							)
-{
-	return set( &(rhs.bounds),rhs.R, &(rhs.constraints),rhs.Q,rhs.T );
-}
-
-
-uint_t Flipper::getDimT( ) const
-{
-	if ( nV > nC )
-		return nC*nC;
-	else
-		return nV*nV;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/Indexlist.cpp b/extlibs/qpOASES-3.2.0/src/Indexlist.cpp
deleted file mode 100644
index 53dec11..0000000
--- a/extlibs/qpOASES-3.2.0/src/Indexlist.cpp
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Indexlist.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the Indexlist class designed to manage index lists of
- *	constraints and bounds within a QProblem_SubjectTo.
- */
-
-
-#include <qpOASES/Indexlist.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	I n d e x l i s t
- */
-Indexlist::Indexlist( )
-{
-	number = 0;
-	iSort  = 0;
-
-	init( );
-}
-
-
-/*
- *	I n d e x l i s t
- */
-Indexlist::Indexlist( int_t n )
-{
-	number = 0;
-	iSort  = 0;
-
-	init( n );
-}
-
-
-/*
- *	I n d e x l i s t
- */
-Indexlist::Indexlist( const Indexlist& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ I n d e x l i s t
- */
-Indexlist::~Indexlist( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Indexlist& Indexlist::operator=( const Indexlist& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-
-/*
- *	i n i t
- */
-returnValue Indexlist::init(	int_t n
-								)
-{
-	if ( n < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	clear( );
-
-	length = 0;
-	physicallength = n;
-
-	if ( n > 0 )
-	{
-		number = new int_t[n];
-		iSort  = new int_t[n];
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t N u m b e r A r r a y
- */
-returnValue Indexlist::getNumberArray( int_t** const numberarray ) const
-{
-	if (numberarray == 0)
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	*numberarray = number;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t I S o r t A r r a y
- */
-returnValue Indexlist::getISortArray( int_t** const iSortArray ) const
-{
-	*iSortArray = iSort;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t I n d e x
- */
-int_t Indexlist::getIndex( int_t givennumber ) const
-{
-	int_t index = findInsert(givennumber);
-	return number[iSort[index]] == givennumber ? iSort[index] : -1;
-}
-
-
-/*
- *	a d d N u m b e r
- */
-returnValue Indexlist::addNumber( int_t addnumber )
-{
-	if ( length >= physicallength )
-		return THROWERROR( RET_INDEXLIST_EXCEEDS_MAX_LENGTH );
-
-	int_t i, j;
-	number[length] = addnumber;
-	j = findInsert(addnumber);
-	for (i = length; i > j+1; i--)
-		iSort[i] = iSort[i-1];
-	iSort[j+1] = length;
-	++length;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e N u m b e r
- */
-returnValue Indexlist::removeNumber( int_t removenumber )
-{
-	int_t i;
-	int_t idx = findInsert( removenumber );
-	int_t iSidx = iSort[idx];
-
-	/* nothing to be done if number is not contained in index set */
-	if ( number[iSidx] != removenumber )
-		return SUCCESSFUL_RETURN;
-
-	/* update sorted indices iSort first */
-	for (i = 0; i < length; i++)
-		if (iSort[i] > iSidx) iSort[i]--;
-	for (i = idx+1; i < length; i++)
-		iSort[i-1] = iSort[i];
-
-	/* remove from numbers list */
-	for( i=iSidx; i<length-1; ++i )
-		number[i] = number[i+1];
-	number[length-1] = -1;
-
-	--length;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s w a p N u m b e r s
- */
-returnValue Indexlist::swapNumbers( int_t number1, int_t number2 )
-{
-	int_t index1 = findInsert( number1 );
-	int_t index2 = findInsert( number2 );
-
-	/* consistency check */
-	if ( ( number[iSort[index1]] != number1 ) || ( number[iSort[index2]] != number2 ) )
-		return THROWERROR( RET_INDEXLIST_CORRUPTED );
-
-	int_t tmp;
-	/* swap numbers */
-	tmp = number[iSort[index1]];
-	number[iSort[index1]] = number[iSort[index2]];
-	number[iSort[index2]] = tmp;
-	/* swap sorting indices */
-	tmp = iSort[index1];
-	iSort[index1] = iSort[index2];
-	iSort[index2] = tmp;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Indexlist::clear( )
-{
-	if ( iSort != 0 )
-	{
-		delete[] iSort;
-		iSort = 0;
-	}
-
-	if ( number != 0 )
-	{
-		delete[] number;
-		number = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Indexlist::copy(	const Indexlist& rhs
-								)
-{
-	int_t i;
-
-	length = rhs.length;
-	physicallength = rhs.physicallength;
-
-	if ( rhs.number != 0 )
-	{
-		number = new int_t[physicallength];
-		for( i=0; i<physicallength; ++i )
-			number[i] = rhs.number[i];
-		iSort = new int_t[physicallength];
-		for( i=0; i<physicallength; ++i )
-			iSort[i] = rhs.iSort[i];
-	}
-	else
-	{
-		number = 0;
-		iSort = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-int_t Indexlist::findInsert(int_t i) const
-{
-	/* quick check if index can be appended */
-	if (length == 0 || i < number[iSort[0]]) return -1;
-	if (i >= number[iSort[length-1]]) return length-1;
-
-	/* otherwise, perform bisection search */
-	int_t fst = 0, lst = length-1, mid;
-
-	while (fst < lst - 1)
-	{
-		mid = (fst + lst) / 2;
-		if (i >= number[iSort[mid]]) fst = mid;
-		else lst = mid;
-	}
-
-	return fst;
-}
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/LAPACKReplacement.cpp b/extlibs/qpOASES-3.2.0/src/LAPACKReplacement.cpp
deleted file mode 100644
index 61a4a98..0000000
--- a/extlibs/qpOASES-3.2.0/src/LAPACKReplacement.cpp
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/LAPACKReplacement.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *  LAPACK replacement routines.
- */
-
-
-#include <qpOASES/Utils.hpp>
-
-
-extern "C" void dpotrf_(	const char *uplo, const unsigned long *_n, double *a,
-							const unsigned long *_lda, long *info
-							)
-{
-	double sum;
-	long i, j, k;
-	long n = (long)(*_n);
-	long lda = (long)(*_lda);
-
-	for( i=0; i<n; ++i )
-	{
-		/* j == i */
-		sum = a[i + lda*i];
-
-		for( k=(i-1); k>=0; --k )
-			sum -= a[k+lda*i] * a[k+lda*i];
-
-		if ( sum > 0.0 )
-			a[i+lda*i] = REFER_NAMESPACE_QPOASES getSqrt( sum );
-		else
-		{
-			a[0] = sum; /* tunnel negative diagonal element to caller */
-			if (info != 0)
-				*info = (long)i+1;
-			return;
-		}
-
-		for( j=(i+1); j<n; ++j )
-		{
-			sum = a[j*lda + i];
-
-			for( k=(i-1); k>=0; --k )
-				sum -= a[k+lda*i] * a[k+lda*j];
-
-			a[i+lda*j] = sum / a[i+lda*i];
-		}
-	}
-	if (info != 0)
-		*info = 0;
-}
-
-
-extern "C" void spotrf_(	const char *uplo, const unsigned long *_n, float *a,
-							const unsigned long *_lda, long *info
-							)
-{
-	float sum;
-	long i, j, k;
-	long n = (long)(*_n);
-	long lda = (long)(*_lda);
-
-	for( i=0; i<n; ++i )
-	{
-		/* j == i */
-		sum = a[i + lda*i];
-
-		for( k=(i-1); k>=0; --k )
-			sum -= a[k+lda*i] * a[k+lda*i];
-
-		if ( sum > 0.0 )
-			a[i+lda*i] = (float)(REFER_NAMESPACE_QPOASES getSqrt( sum ));
-		else
-		{
-			a[0] = sum; /* tunnel negative diagonal element to caller */
-			if (info != 0)
-				*info = (long)i+1;
-			return;
-		}
-
-		for( j=(i+1); j<n; ++j )
-		{
-			sum = a[j*lda + i];
-
-			for( k=(i-1); k>=0; --k )
-				sum -= a[k+lda*i] * a[k+lda*j];
-
-			a[i+lda*j] = sum / a[i+lda*i];
-		}
-	}
-	if (info != 0)
-		*info = 0;
-}
-
-extern "C" void dtrtrs_(	const char *UPLO, const char *TRANS, const char *DIAG,
-							const unsigned long *N, const unsigned long *NRHS,
-							double *A, const unsigned long *LDA, double *B, const unsigned long *LDB, long *INFO
-							)
-{
-	; /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
-}
-
-extern "C" void strtrs_(	const char *UPLO, const char *TRANS, const char *DIAG,
-							const unsigned long *N, const unsigned long *NRHS,
-							float *A, const unsigned long *LDA, float *B, const unsigned long *LDB, long *INFO
-							)
-{
-	; /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
-}
-
-extern "C" void dtrcon_(	const char *NORM, const char *UPLO, const char *DIAG,
-							const unsigned long *N, double *A, const unsigned long *LDA,
-							double *RCOND, double *WORK, const unsigned long *IWORK, long *INFO
-							)
-{
-	; /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
-}
-
-extern "C" void strcon_(	const char *NORM, const char *UPLO, const char *DIAG,
-							const unsigned long *N, float *A, const unsigned long *LDA,
-							float *RCOND, float *WORK, const unsigned long *IWORK, long *INFO
-							)
-{
-	; /* Dummy. If SQProblemSchur is to be used, system LAPACK must be used */
-}
diff --git a/extlibs/qpOASES-3.2.0/src/Makefile b/extlibs/qpOASES-3.2.0/src/Makefile
deleted file mode 100644
index bcad734..0000000
--- a/extlibs/qpOASES-3.2.0/src/Makefile
+++ /dev/null
@@ -1,110 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  src/Makefile
-##	Author:    Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-include ../make.mk
-
-##
-##	flags
-##
-
-IFLAGS      =  -I. \
-               -I${IDIR}
-
-QPOASES_OBJECTS = \
-	SQProblem.${OBJEXT} \
-	QProblem.${OBJEXT} \
-	QProblemB.${OBJEXT} \
-	SQProblemSchur.${OBJEXT} \
-	Bounds.${OBJEXT} \
-	Constraints.${OBJEXT} \
-	SubjectTo.${OBJEXT} \
-	Indexlist.${OBJEXT} \
-	Flipper.${OBJEXT} \
-	Utils.${OBJEXT} \
-	Options.${OBJEXT} \
-	Matrices.${OBJEXT} \
-	MessageHandling.${OBJEXT} \
-	SparseSolver.${OBJEXT}
-
-
-QPOASES_EXTRAS_OBJECTS = \
-	SolutionAnalysis.${OBJEXT} \
-	OQPinterface.${OBJEXT}
-
-QPOASES_DEPENDS = \
-	${IDIR}/qpOASES.hpp \
-	${IDIR}/qpOASES/SQProblem.hpp \
-	${IDIR}/qpOASES/QProblem.hpp \
-	${IDIR}/qpOASES/Flipper.hpp \
-	${IDIR}/qpOASES/QProblemB.hpp \
-	${IDIR}/qpOASES/Bounds.hpp \
-	${IDIR}/qpOASES/Constraints.hpp \
-	${IDIR}/qpOASES/SubjectTo.hpp \
-	${IDIR}/qpOASES/Indexlist.hpp \
-	${IDIR}/qpOASES/Utils.hpp \
-	${IDIR}/qpOASES/Constants.hpp \
-	${IDIR}/qpOASES/Types.hpp \
-	${IDIR}/qpOASES/Options.hpp \
-	${IDIR}/qpOASES/Matrices.hpp \
-	${IDIR}/qpOASES/MessageHandling.hpp \
-	${IDIR}/qpOASES/UnitTesting.hpp
-
-
-##
-##	targets
-##
-
-all: ${LINK_DEPENDS}
-
-
-${BINDIR}/libqpOASES.${LIBEXT}: ${QPOASES_OBJECTS} ${QPOASES_EXTRAS_OBJECTS}
-	@${ECHO} "Creating static lib" $@
-	@${AR} r $@ $^
-
-${BINDIR}/libqpOASES.${DLLEXT}: ${QPOASES_OBJECTS} ${QPOASES_EXTRAS_OBJECTS}
-	@${ECHO} "Creating shared lib" $@
-	@${CPP} ${DEF_TARGET} ${SHARED} $^ ${LINK_LIBRARIES}
-
-clean:
-	@${ECHO} "Cleaning up (src)"
-	@${RM} -f *.${OBJEXT} *.${LIBEXT} *.${DLLEXT}
-
-clobber: clean
-
-
-%.${OBJEXT}: %.cpp ${QPOASES_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/src/Matrices.cpp b/extlibs/qpOASES-3.2.0/src/Matrices.cpp
deleted file mode 100644
index 1249a7b..0000000
--- a/extlibs/qpOASES-3.2.0/src/Matrices.cpp
+++ /dev/null
@@ -1,2141 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Matrices.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the matrix classes.
- */
-
-
-#include <qpOASES/Matrices.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-returnValue Matrix::getSparseSubmatrix(
-				const Indexlist* const irows,
-				const Indexlist* const icols,
-				int_t rowoffset,
-				int_t coloffset,
-				int_t& numNonzeros,
-				int_t* irn,
-				int_t* jcn,
-				real_t* avals,
-				BooleanType only_lower_triangular) const
-{
-	int_t* rowsNumbers;
-	irows->getNumberArray( &rowsNumbers );
-	int_t* colsNumbers;
-	icols->getNumberArray( &colsNumbers );
-
-	return getSparseSubmatrix(irows->getLength(), rowsNumbers, icols->getLength(), colsNumbers, rowoffset, coloffset, numNonzeros, irn, jcn, avals, only_lower_triangular);
-}
-
-returnValue Matrix::getSparseSubmatrix(
-				const Indexlist* const irows,
-				int_t idx_icol,
-				int_t rowoffset,
-				int_t coloffset,
-				int_t& numNonzeros,
-				int_t* irn,
-				int_t* jcn,
-				real_t* avals,
-				BooleanType only_lower_triangular) const
-{
-	int_t* rowsNumbers;
-	irows->getNumberArray( &rowsNumbers );
-
-	return getSparseSubmatrix(irows->getLength(), rowsNumbers, 1, &idx_icol, rowoffset, coloffset, numNonzeros, irn, jcn, avals, only_lower_triangular);
-}
-
-returnValue Matrix::getSparseSubmatrix(
-				int_t idx_row,
-				const Indexlist* const icols,
-				int_t rowoffset,
-				int_t coloffset,
-				int_t& numNonzeros,
-				int_t* irn,
-				int_t* jcn,
-				real_t* avals,
-				BooleanType only_lower_triangular) const
-{
-	int_t* colsNumbers;
-	icols->getNumberArray( &colsNumbers );
-
-	return getSparseSubmatrix(1, &idx_row, icols->getLength(), colsNumbers, rowoffset, coloffset, numNonzeros, irn, jcn, avals, only_lower_triangular);
-}
-
-
-DenseMatrix::~DenseMatrix()
-{
-	if ( needToFreeMemory( ) == BT_TRUE )
-		free( );
-}
-
-void DenseMatrix::free( )
-{
-	if (val != 0)
-		delete[] val;
-	val = 0;
-}
-
-Matrix *DenseMatrix::duplicate( ) const
-{
-	DenseMatrix *dupl = 0;
-
-	if ( needToFreeMemory( ) == BT_TRUE )
-	{
-		real_t* val_new = new real_t[nRows*nCols];
-		memcpy( val_new,val, ((uint_t)(nRows*nCols))*sizeof(real_t) );
-		dupl = new DenseMatrix(nRows, nCols, nCols, val_new);
-		dupl->doFreeMemory( );
-	}
-	else
-	{
-		dupl = new DenseMatrix(nRows, nCols, nCols, val);
-	}
-
-	return dupl;
-}
-
-real_t DenseMatrix::diag(	int_t i
-							) const
-{
-	return val[i*(leaDim+1)];
-}
-
-BooleanType DenseMatrix::isDiag( ) const
-{
-	int_t i, j;
-
-	if (nRows != nCols)
-		return BT_FALSE;
-
-	for ( i=0; i<nRows; ++i )
-		for ( j=0; j<i; ++j )
-			if ( ( getAbs( val[i*leaDim+j] ) > EPS ) || ( getAbs( val[j*leaDim+i] ) > EPS ) )
-				return BT_FALSE;
-
-	return BT_TRUE;
-}
-
-
-real_t DenseMatrix::getNorm(	int_t type
-								) const
-{
-	return REFER_NAMESPACE_QPOASES getNorm( val,nCols*nRows,type );
-}
-
-
-real_t DenseMatrix::getRowNorm( int_t rNum, int_t type ) const
-{
-	return REFER_NAMESPACE_QPOASES getNorm( &(val[rNum*leaDim]),nCols,type );
-}
-
-returnValue DenseMatrix::getRow(int_t rNum, const Indexlist* const icols, real_t alpha, real_t *row) const
-{
-	int_t i;
-    if (icols != 0)
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (i = 0; i < icols->length; i++)
-			    row[i] = val[rNum*leaDim+icols->number[i]];
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (i = 0; i < icols->length; i++)
-			    row[i] = -val[rNum*leaDim+icols->number[i]];
-	    else
-		    for (i = 0; i < icols->length; i++)
-			    row[i] = alpha*val[rNum*leaDim+icols->number[i]];
-    }
-    else
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (i = 0; i < nCols; i++)
-			    row[i] = val[rNum*leaDim+i];
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (i = 0; i < nCols; i++)
-			    row[i] = -val[rNum*leaDim+i];
-	    else
-		    for (i = 0; i < nCols; i++)
-			    row[i] = alpha*val[rNum*leaDim+i];
-    }
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue DenseMatrix::getCol(int_t cNum, const Indexlist* const irows, real_t alpha, real_t *col) const
-{
-	int_t i;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (i = 0; i < irows->length; i++)
-			col[i] = val[irows->number[i]*leaDim+cNum];
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (i = 0; i < irows->length; i++)
-			col[i] = -val[irows->number[i]*leaDim+cNum];
-	else
-		for (i = 0; i < irows->length; i++)
-			col[i] = alpha*val[irows->number[i]*leaDim+cNum];
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue DenseMatrix::getSparseSubmatrix (int_t irowsLength, const int_t* const irowsNumber,
-											 int_t icolsLength, const int_t* const icolsNumber,
-											 int_t rowoffset, int_t coloffset, int_t& numNonzeros,	int_t* irn,
-											 int_t* jcn, real_t* avals,
-											 BooleanType only_lower_triangular /*= BT_FALSE */) const
-{
-	int_t i, j, irA;
-	real_t v;
-	numNonzeros = 0;
-	if ( only_lower_triangular == BT_FALSE )
-	{
-		if (irn == 0)
-		{
-			if (jcn != 0 || avals != 0)
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			for (j = 0; j<irowsLength; j++)
-			{
-				irA = irowsNumber[j] * leaDim;
-				for (i = 0; i<icolsLength; i++)
-					if (isZero( val[irA+icolsNumber[i]] ) == BT_FALSE)
-						numNonzeros++;
-			}
-		}
-		else
-		{
-			for (j = 0; j<irowsLength; j++)
-			{
-				irA = irowsNumber[j] * leaDim;
-				for (i = 0; i<icolsLength; i++)
-				{
-					v = val[irA+icolsNumber[i]];
-					if (isZero( v ) == BT_FALSE)
-					{
-						irn[numNonzeros] = j+rowoffset;
-						jcn[numNonzeros] = i+coloffset;
-						avals[numNonzeros] = v;
-						numNonzeros++;
-					}
-				}
-			}
-		}
-	}
-	else
-	{
-		if (irn == 0)
-		{
-			if (jcn != 0 || avals != 0)
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			for (j = 0; j<irowsLength; j++)
-			{
-				irA = irowsNumber[j] * leaDim;
-				for (i = 0; i<=j; i++)
-					if (isZero( val[irA+irowsNumber[i]] ) == BT_FALSE)
-						numNonzeros++;
-			}
-		}
-		else
-		{
-			for (j = 0; j<irowsLength; j++)
-			{
-				irA = irowsNumber[j] * leaDim;
-				for (i = 0; i<=j; i++)
-				{
-					v = val[irA+irowsNumber[i]];
-					if (isZero( v ) == BT_FALSE)
-					{
-						irn[numNonzeros] = j+rowoffset;
-						jcn[numNonzeros] = i+coloffset;
-						avals[numNonzeros] = v;
-						numNonzeros++;
-					}
-				}
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue DenseMatrix::times(	int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD) const
-{
-	unsigned long _xN     = (unsigned long)xN;
-	unsigned long _nRows  = (unsigned long)nRows;
-	unsigned long _nCols  = (unsigned long)nCols;
-	unsigned long _leaDim = (unsigned long)getMax(1,nCols);
-	unsigned long _xLD    = (unsigned long)getMax(1,xLD);
-	unsigned long _yLD    = (unsigned long)getMax(1,yLD);
-
-	/* Call BLAS. Mind row major format! */
-	GEMM("TRANS", "NOTRANS", &_nRows, &_xN, &_nCols, &alpha, val, &_leaDim, x, &_xLD, &beta, y, &_yLD);
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue DenseMatrix::transTimes( int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD) const
-{
-	unsigned long _xN     = (unsigned long)xN;
-	unsigned long _nRows  = (unsigned long)nRows;
-	unsigned long _nCols  = (unsigned long)nCols;
-	unsigned long _leaDim = (unsigned long)getMax(1,nCols);
-	unsigned long _xLD    = (unsigned long)getMax(1,xLD);
-	unsigned long _yLD    = (unsigned long)getMax(1,yLD);
-
-	/* Call BLAS. Mind row major format! */
-	GEMM("NOTRANS", "NOTRANS", &_nCols, &_xN, &_nRows, &alpha, val, &_leaDim, x, &_xLD, &beta, y, &_yLD);
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue DenseMatrix::times(	const Indexlist* const irows, const Indexlist* const icols,
-								int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD,
-								BooleanType yCompr) const
-{
-	int_t i, j, k, row, col, iy, irA;
-
-	if (yCompr == BT_TRUE)
-	{
-		if ( isZero(beta) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = 0.0;
-		else if ( isEqual(beta,-1.0) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = -y[j+k*yLD];
-		else if ( isEqual(beta,1.0) == BT_FALSE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] *= beta;
-
-		if (icols == 0)
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] += val[irA+i] * x[k*xLD+i];
-					}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] -= val[irA+i] * x[k*xLD+i];
-					}
-			else
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] += alpha * val[irA+i] * x[k*xLD+i];
-					}
-		else /* icols != 0 */
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] += val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] -= val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-			else
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->iSort[j];
-						iy = row + k * yLD;
-						irA = irows->number[row] * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] += alpha * val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-	}
-	else /* y not compressed */
-	{
-		if ( isZero(beta) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = 0.0;
-		else if ( isEqual(beta,-1.0) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = -y[j+k*yLD];
-		else if ( isEqual(beta,1.0) == BT_FALSE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] *= beta;
-
-		if (icols == 0)
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] += val[irA+i] * x[k*xLD+i];
-					}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] -= val[irA+i] * x[k*xLD+i];
-					}
-			else
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < nCols; i++)
-							y[iy] += alpha * val[irA+i] * x[k*xLD+i];
-					}
-		else /* icols != 0 */
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] += val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] -= val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-			else
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-					{
-						row = irows->number[irows->iSort[j]];
-						iy = row + k * yLD;
-						irA = row * leaDim;
-						for (i = 0; i < icols->length; i++)
-						{
-							col = icols->iSort[i];
-							y[iy] += alpha * val[irA+icols->number[col]] * x[k*xLD+col];
-						}
-					}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue DenseMatrix::transTimes(	const Indexlist* const irows, const Indexlist* const icols,
-										int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD) const
-{
-	int_t i, j, k, row, col;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < irows->length; j++)
-			{
-				row = irows->iSort[j];
-				for (i = 0; i < icols->length; i++)
-				{
-					col = icols->iSort[i];
-					y[col+k*yLD] += val[irows->number[row]*leaDim+icols->number[col]] * x[row+k*xLD];
-				}
-			}
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < irows->length; j++)
-			{
-				row = irows->iSort[j];
-				for (i = 0; i < icols->length; i++)
-				{
-					col = icols->iSort[i];
-					y[col+k*yLD] -= val[irows->number[row]*leaDim+icols->number[col]] * x[row+k*xLD];
-				}
-			}
-	else
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < irows->length; j++)
-			{
-				row = irows->iSort[j];
-				for (i = 0; i < icols->length; i++)
-				{
-					col = icols->iSort[i];
-					y[col+k*yLD] += alpha * val[irows->number[row]*leaDim+icols->number[col]] * x[row+k*xLD];
-				}
-			}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue DenseMatrix::addToDiag( real_t alpha )
-{
-	int_t i;
-	for (i = 0; i < nRows && i < nCols; i++)
-		val[i*(leaDim+1)] += alpha;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue DenseMatrix::writeToFile( FILE* output_file, const char* prefix ) const
-{
-	return THROWERROR( RET_NOT_YET_IMPLEMENTED );
-}
-
-
-real_t* DenseMatrix::full() const
-{
-	real_t* v = new real_t[nRows*nCols];
-	memcpy( v,val, ((uint_t)(nRows*nCols))*sizeof(real_t) );
-	return v;
-}
-
-
-returnValue DenseMatrix::print( const char* name ) const
-{
-	return REFER_NAMESPACE_QPOASES print( val,nRows,nCols,name );
-}
-
-
-
-Matrix *SymDenseMat::duplicate( ) const
-{
-	return duplicateSym();
-}
-
-
-SymmetricMatrix *SymDenseMat::duplicateSym( ) const
-{
-	/* "same" as duplicate() in DenseMatrix */
-	SymDenseMat *dupl = 0;
-
-	if ( needToFreeMemory( ) == BT_TRUE )
-	{
-		real_t* val_new = new real_t[nRows*nCols];
-		memcpy( val_new,val, ((uint_t)(nRows*nCols))*sizeof(real_t) );
-		dupl = new SymDenseMat(nRows, nCols, nCols, val_new);
-		dupl->doFreeMemory( );
-	}
-	else
-	{
-		dupl = new SymDenseMat(nRows, nCols, nCols, val);
-	}
-
-	return dupl;
-}
-
-
-returnValue SymDenseMat::bilinear(	const Indexlist* const icols,
-									int_t xN, const real_t *x, int_t xLD, real_t *y, int_t yLD) const
-{
-	int_t ii, jj, kk, col;
-	int_t i,j,k,irA;
-
-	for (ii = 0; ii < xN; ii++)
-		for (jj = 0; jj < xN; jj++)
-			y[ii*yLD+jj] = 0.0;
-
-	real_t *Ax = new real_t[icols->length * xN];
-
-	for (i=0;i<icols->length * xN;++i)
-		Ax[i]=0.0;
-
-	/* exploit symmetry of A ! */
-	for (j = 0; j < icols->length; j++) {
-		irA = icols->number[j] * leaDim;
-		for (i = 0; i < icols->length; i++)
-		{
-			real_t h = val[irA+icols->number[i]];
-			for (k = 0; k < xN; k++)
-				Ax[j + k * icols->length] += h * x[k*xLD+icols->number[i]];
-		}
-	}
-
-	for (ii = 0; ii < icols->length; ++ii) {
-		col = icols->number[ii];
-		for (jj = 0; jj < xN; ++jj) {
-			for (kk = 0; kk < xN; ++kk) {
-				y[kk + jj*yLD] += x[col + jj*xLD] * Ax[ii + kk*icols->length];
-			}
-		}
-	}
-	delete[] Ax;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-SparseMatrix::SparseMatrix() : nRows(0), nCols(0), ir(0), jc(0), jd(0), val(0) {}
-
-SparseMatrix::SparseMatrix(	int_t nr, int_t nc, sparse_int_t *r, sparse_int_t *c, real_t *v)
-								: nRows(nr), nCols(nc), ir(r), jc(c), jd(0), val(v) { doNotFreeMemory(); }
-
-SparseMatrix::SparseMatrix(	int_t nr, int_t nc, int_t ld, const real_t * const v)
-								: nRows(nr), nCols(nc), jd(0)
-{
-	int_t i, j, nnz;
-
-	jc = new sparse_int_t[nc+1];
-	ir = new sparse_int_t[nr*nc];
-	val = new real_t[nr*nc];
-
-	nnz = 0;
-	for (j = 0; j < nCols; j++)
-	{
-		jc[j] = nnz;
-		for (i = 0; i < nRows; i++)
-			if ( ( isZero( v[i*ld+j],0.0 ) == BT_FALSE ) || ( i == j ) ) /* also include zero diagonal elemets! */
-			{
-				ir[nnz] = i;
-				val[nnz++] = v[i*ld+j];
-			}
-	}
-	jc[nCols] = nnz;
-
-	doFreeMemory( );
-}
-
-
-SparseMatrix::~SparseMatrix()
-{
-	if (jd != 0)
-	{
-		delete[] jd;
-		jd = 0;
-	}
-
-	if ( needToFreeMemory() == BT_TRUE )
-		free( );
-}
-
-
-void SparseMatrix::free( )
-{
-	if (ir != 0) delete[] ir;
-	ir = 0;
-	if (jc != 0) delete[] jc;
-	jc = 0;
-	if (val != 0) delete[] val;
-	val = 0;
-
-	doNotFreeMemory( );
-}
-
-Matrix *SparseMatrix::duplicate() const
-{
-	long i, length = jc[nCols];
-	SparseMatrix *dupl = new SparseMatrix;
-
-	dupl->nRows = nRows;
-	dupl->nCols = nCols;
-	dupl->ir = new sparse_int_t[length];
-	dupl->jc = new sparse_int_t[nCols+1];
-	dupl->val = new real_t[length];
-
-	for (i = 0; i < length; i++) dupl->ir[i] = ir[i];
-	for (i = 0; i <= nCols; i++) dupl->jc[i] = jc[i];
-	for (i = 0; i < length; i++) dupl->val[i] = val[i];
-
-	if ( jd != 0 )
-	{
-		dupl->jd = new sparse_int_t[nCols];
-		for (i = 0; i < nCols; i++) dupl->jd[i] = jd[i];
-	}
-	else
-		dupl->jd = 0;
-
-	dupl->doFreeMemory( );
-
-	return dupl;
-}
-
-
-
-real_t SparseMatrix::diag(int_t i) const
-{
-	if ( jd == 0 )
-	{
-		THROWERROR( RET_DIAGONAL_NOT_INITIALISED );
-		return INFTY;
-	}
-
-	int_t entry = jd[i];
-	return (entry < jc[i+1] && ir[entry] == i) ? val[entry] : 0.0;
-}
-
-
-BooleanType SparseMatrix::isDiag() const
-{
-	int_t j;
-
-	if ( nCols != nRows )
-		return BT_FALSE;
-
-	for (j = 0; j < nCols; ++j)
-	{
-		if ( jc[j+1] > jc[j]+1 )
-			return BT_FALSE;
-
-		if ( ( jc[j+1] == jc[j]+1 ) && ( ir[jc[j]] != j ) )
-			return BT_FALSE;
-	}
-
-	return BT_TRUE;
-}
-
-
-
-real_t SparseMatrix::getNorm(	int_t type
-								) const
-{
-	int_t length = jc[nCols];
-	return REFER_NAMESPACE_QPOASES getNorm( val,length,type );
-}
-
-
-real_t SparseMatrix::getRowNorm( int_t rNum, int_t type ) const
-{
-    int_t i,j;
-    real_t norm = 0.0;
-
-	switch( type )
-	{
-		case 2:
-			for ( j=0; j < nCols; ++j ) {
-				for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++) {};
-				norm += (i < jc[j+1] && ir[i] == rNum) ? val[i]*val[i] : 0.0;
-			}
-			return getSqrt(norm);
-
-		case 1:
-			for ( j=0; j < nCols; ++j ) {
-				for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++) {};
-				norm += (i < jc[j+1] && ir[i] == rNum) ? REFER_NAMESPACE_QPOASES getAbs( val[i] ) : 0.0;
-			}
-			return norm;
-
-		default:
-			THROWERROR( RET_INVALID_ARGUMENTS );
-			return -INFTY;
-	}
-}
-
-
-returnValue SparseMatrix::getRow(int_t rNum, const Indexlist* const icols, real_t alpha, real_t *row) const
-{
-	long i, j, k;
-
-    if (icols != 0)
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (k = 0; k < icols->length; k++)
-		    {
-			    j = icols->number[icols->iSort[k]];
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[icols->iSort[k]] = (i < jc[j+1] && ir[i] == rNum) ? val[i] : 0.0;
-		    }
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (k = 0; k < icols->length; k++)
-		    {
-			    j = icols->number[icols->iSort[k]];
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[icols->iSort[k]] = (i < jc[j+1] && ir[i] == rNum) ? -val[i] : 0.0;
-		    }
-	    else
-		    for (k = 0; k < icols->length; k++)
-		    {
-			    j = icols->number[icols->iSort[k]];
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[icols->iSort[k]] = (i < jc[j+1] && ir[i] == rNum) ? alpha*val[i] : 0.0;
-		    }
-    }
-    else
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (j = 0; j < nCols; j++)
-		    {
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[j] = (i < jc[j+1] && ir[i] == rNum) ? val[i] : 0.0;
-		    }
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (j = 0; j < icols->length; j++)
-		    {
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[j] = (i < jc[j+1] && ir[i] == rNum) ? -val[i] : 0.0;
-		    }
-	    else
-		    for (j = 0; j < icols->length; j++)
-		    {
-			    for (i = jc[j]; i < jc[j+1] && ir[i] < rNum; i++);
-			    row[j] = (i < jc[j+1] && ir[i] == rNum) ? alpha*val[i] : 0.0;
-		    }
-    }
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrix::getCol(int_t cNum, const Indexlist* const irows, real_t alpha, real_t *col) const
-{
-	long i, j;
-
-	i = jc[cNum];
-	j = 0;
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		while (i < jc[cNum+1] && j < irows->length)
-			if (ir[i] == irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = val[i++];
-			else if (ir[i] > irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = 0.0;
-			else
-				i++;
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		while (i < jc[cNum+1] && j < irows->length)
-			if (ir[i] == irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = -val[i++];
-			else if (ir[i] > irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = 0.0;
-			else
-				i++;
-	else
-		while (i < jc[cNum+1] && j < irows->length)
-			if (ir[i] == irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = alpha * val[i++];
-			else if (ir[i] > irows->number[irows->iSort[j]])
-				col[irows->iSort[j++]] = 0.0;
-			else
-				i++;
-
-	/* fill in remaining zeros */
-	while (j < irows->length)
-		col[irows->iSort[j++]] = 0.0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SparseMatrix::getSparseSubmatrix (int_t irowsLength, const int_t* const irowsNumber,
-											  int_t icolsLength, const int_t* const icolsNumber,
-											  int_t rowoffset, int_t coloffset, int_t& numNonzeros,	int_t* irn,
-											  int_t* jcn, real_t* avals,
-											  BooleanType only_lower_triangular /*= BT_FALSE */) const
-{
-	int_t i, j, k, l;
-
-	// Compute the "inverse" of the irows->number array
-	// TODO: Ideally this should be a part of Indexlist
-	int_t* rowNumberInv = new int_t[nRows];
-	for (i=0; i<nRows; i++)
-		rowNumberInv[i] = -1;
-	for (i=0; i<irowsLength; i++)
-		rowNumberInv[irowsNumber[i]] = i;
-
-	numNonzeros = 0;
-	if ( only_lower_triangular == BT_FALSE )
-	{
-		if (irn == 0)
-		{
-			if (jcn != 0 || avals != 0)
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			for (k = 0; k < icolsLength; k++)
-			{
-				j = icolsNumber[k];
-				for (i = jc[j]; i < jc[j+1]; i++)
-				{
-					l = rowNumberInv[ir[i]];
-					if (l >= 0)
-						numNonzeros++;
-				}
-			}
-		}
-		else
-		{
-			for (k = 0; k < icolsLength; k++)
-			{
-				j = icolsNumber[k];
-				for (i = jc[j]; i < jc[j+1]; i++)
-				{
-					l = rowNumberInv[ir[i]];
-					if (l >= 0)
-					{
-						irn[numNonzeros] = l+rowoffset;
-						jcn[numNonzeros] = k+coloffset;
-						avals[numNonzeros] = val[i];
-						numNonzeros++;
-					}
-				}
-			}
-		}
-	}
-	else
-	{
-		if (irn == 0)
-		{
-			if (jcn != 0 || avals != 0)
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			for (k = 0; k < icolsLength; k++)
-			{
-				j = icolsNumber[k];
-				for (i = jc[j]; i < jc[j+1]; i++)
-				{
-					l = rowNumberInv[ir[i]];
-					if (l >= k)
-						numNonzeros++;
-				}
-			}
-		}
-		else
-		{
-			for (k = 0; k < icolsLength; k++)
-			{
-				j = icolsNumber[k];
-				for (i = jc[j]; i < jc[j+1]; i++)
-				{
-					l = rowNumberInv[ir[i]];
-					if (l >= k)
-					{
-						irn[numNonzeros] = l+rowoffset;
-						jcn[numNonzeros] = k+coloffset;
-						avals[numNonzeros] = val[i];
-						numNonzeros++;
-					}
-				}
-			}
-		}
-	}
-	delete [] rowNumberInv;
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SparseMatrix::times(int_t xN, real_t alpha, const real_t *x, int_t xLD,
-		real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[ir[i]+k*yLD] += val[i] * x[j+k*xLD];
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[ir[i]+k*yLD] -= val[i] * x[j+k*xLD];
-	else
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[ir[i]+k*yLD] += alpha * val[i] * x[j+k*xLD];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrix::transTimes(int_t xN, real_t alpha, const real_t *x, int_t xLD,
-		real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[j+k*yLD] += val[i] * x[ir[i]+k*xLD];
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[j+k*yLD] -= val[i] * x[ir[i]+k*xLD];
-	else
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				for (i = jc[j]; i < jc[j+1]; i++)
-					y[j+k*yLD] += alpha * val[i] * x[ir[i]+k*xLD];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrix::times(const Indexlist* const irows, const Indexlist* const icols,
-		int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD,
-		BooleanType yCompr) const
-{
-	long i, j, k, l, col;
-	real_t xcol;
-
-	if ( isEqual(alpha,0.0) == BT_TRUE )
-	{
-		if (yCompr == BT_TRUE)
-		{
-			if ( isZero(beta) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[j+k*yLD] = 0.0;
-			else if ( isEqual(beta,-1.0) == BT_TRUE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[j+k*yLD] = -y[j+k*yLD];
-			else if ( isEqual(beta,1.0) == BT_FALSE )
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[j+k*yLD] *= beta;
-		}
-		else
-		{
-			if (isZero( beta ) == BT_TRUE)
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[irows->number[j]+k*yLD] = 0.0;
-			else if (isEqual( beta, -1.0 ) == BT_TRUE)
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[irows->number[j]+k*yLD] = -y[irows->number[j]+k*yLD];
-			else if (isEqual( beta, 1.0 ) == BT_FALSE)
-				for (k = 0; k < xN; k++)
-					for (j = 0; j < irows->length; j++)
-						y[irows->number[j]+k*yLD] *= beta;
-		}
-		return SUCCESSFUL_RETURN;
-	}
-
-	// First, work with full, unordered copy of y and store matrix times x in there
-	const int_t yfullLength = nRows;
-	real_t* ytmp = new real_t[xN*yfullLength];
-	for (k = 0; k < xN*yfullLength; k++)
-		ytmp[k] = 0.0;
-
-	if (icols!=0)
-	{
-		if (xN==1)
-		{
-			for (l = 0; l < icols->length; l++)
-			{
-				col = icols->iSort[l];
-				xcol = x[col];
-				if (isZero( xcol ) == BT_FALSE)
-				{
-					j = icols->number[col];
-					for (i = jc[j]; i < jc[j+1]; i++)
-						ytmp[ir[i]] += val[i] * xcol;
-				}
-			}
-		}
-		else
-		{
-			// AW: I didn't test the case xN>1, but I hope it is working
-			real_t* xcols = new real_t[xN];
-			for (l = 0; l < icols->length; l++)
-			{
-				col = icols->iSort[l];
-				real_t xmax = 0.0;
-				for (k=0; k<xN; k++)
-				{
-					xcols[k] = x[k*xLD+col];
-					xmax = getMax(xmax,getAbs(xcols[k]));
-				}
-				if (isZero( xmax ) == BT_FALSE)
-				{
-					j = icols->number[col];
-					for (i = jc[j]; i < jc[j+1]; i++)
-						for (k=0; k<xN; k++)
-						  // AW: Maybe it makes more sense to order ytmp by vectors, not vector entries, for better cache peformance?
-							ytmp[k*yfullLength+ir[i]] += val[i] * xcols[k];
-				}
-			}
-			delete [] xcols;
-		}
-	}
-	else /* icols == 0 */
-	{
-		if (xN==1)
-		{
-			for (col = 0; col < nCols; col++)
-			{
-				xcol = x[col];
-				if (isZero( xcol ) == BT_FALSE)
-					for (i = jc[col]; i < jc[col+1]; i++)
-						ytmp[ir[i]] += val[i] * xcol;
-			}
-		}
-		else
-		{
-			// AW: I didn't test the case xN>1, but I hope it is working
-			real_t* xcols = new real_t[xN];
-			for (col = 0; col < nCols; col++)
-			{
-				real_t xmax = 0.0;
-				for (k=0; k<xN; k++)
-				{
-					xcols[k] = x[k*xLD+col];
-					xmax = getMax(xmax,getAbs(xcols[k]));
-				}
-				if (isZero( xmax ) == BT_FALSE)
-					for (i = jc[col]; i < jc[col+1]; i++)
-						for (k=0; k<xN; k++)
-							ytmp[k*yfullLength+ir[i]] += val[i] * xcols[k];
-				delete [] xcols;
-			}
-		}
-	}
-
-	if (yCompr == BT_TRUE)
-	{
-		if ( isZero(beta) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength];
-		else if (isEqual( beta, 1.0 ) == BT_TRUE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] += alpha*ytmp[irows->number[j]+k*yfullLength];
-		else if (isEqual( beta, -1.0 ) == BT_TRUE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength]-y[j+k*yLD];
-		else if (isEqual( beta, 1.0 ) == BT_FALSE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength]+beta*y[j+k*yLD];
-	}
-	else
-	{
-		if (isZero( beta ) == BT_TRUE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength];
-		else if (isEqual( beta, 1.0 ) == BT_TRUE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength]+y[j+k*yLD];
-		else if (isEqual( beta, -1.0 ) == BT_TRUE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength]-y[j+k*yLD];
-		else if (isEqual( beta, 1.0 ) == BT_FALSE)
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = alpha*ytmp[irows->number[j]+k*yfullLength]+beta*y[j+k*yLD];
-	}
-
-	delete [] ytmp;
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrix::transTimes(const Indexlist* const irows, const Indexlist* const icols,
-		int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k, l, col;
-	real_t yadd;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] *= beta;
-	if ( isEqual(alpha,0.0) == BT_TRUE )
-		return SUCCESSFUL_RETURN;
-
-	// work with full, unordered copy of x
-	const int_t xfullLength = nRows;
-	real_t* xtmp = new real_t[xfullLength];
-	for (k = 0; k < xN; k++)
-	{
-		for (i = 0; i < xfullLength; i++)
-			xtmp[i] = 0.0;
-		for (i = 0; i < irows->length; i++)
-			xtmp[irows->number[i]] = x[k*xLD+i];
-		for (l = 0; l < icols->length; l++)
-		{
-			col = icols->iSort[l];
-			yadd = 0.0;
-			j = icols->number[col];
-			for (i = jc[j]; i < jc[j+1]; i++)
-				yadd += val[i] * xtmp[ir[i]];
-			y[col] += alpha*yadd;
-		}
-		y += yLD; // move on to next RHS
-	}
-
-	delete [] xtmp;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-returnValue SparseMatrix::addToDiag(real_t alpha)
-{
-	long i;
-
-	if ( jd == 0 )
-		return THROWERROR( RET_DIAGONAL_NOT_INITIALISED );
-
-	if ( isZero( alpha ) == BT_FALSE )
-	{
-		for (i = 0; i < nRows && i < nCols; i++)
-		{
-			if (ir[jd[i]] == i)
-				val[jd[i]] += alpha;
-			else
-				return RET_NO_DIAGONAL_AVAILABLE;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-sparse_int_t *SparseMatrix::createDiagInfo()
-{
-	sparse_int_t i, j;
-
-	if (jd == 0) {
-		jd = new sparse_int_t[nCols];
-
-		for (j = 0; j < nCols; j++)
-		{
-			for (i = jc[j]; i < jc[j+1] && ir[i] < j; i++);
-			jd[j] = i;
-		}
-	}
-
-	return jd;
-}
-
-
-
-real_t *SparseMatrix::full() const
-{
-	sparse_int_t i, j;
-	real_t *v = new real_t[nRows*nCols];
-
-	for (i = 0; i < nCols*nRows; i++)
-		v[i] = 0.0;
-
-	for (j = 0; j < nCols; j++)
-		for (i = jc[j]; i < jc[j+1]; i++)
-			v[ir[i] * nCols + j] = val[i];
-
-	return v;
-}
-
-
-returnValue SparseMatrix::print( const char* name ) const
-{
-	real_t* tmp = this->full();
-	returnValue retVal = REFER_NAMESPACE_QPOASES print( tmp,nRows,nCols,name );
-	delete[] tmp;
-
-	return retVal;
-}
-
-returnValue SparseMatrix::writeToFile( FILE* output_file, const char* prefix ) const
-{
-	for (int_t i=0; i<=nCols; i++) {
-		fprintf( output_file,"%sjc[%d] = %d\n",prefix,(int)i,(int)(jc[i]) );
-	}
-	for (int_t i=0; i<jc[nCols]; i++) {
-		fprintf( output_file,"%sir[%d] = %d\n",prefix,(int)i,(int)(ir[i]) );
-	}
-	for (int_t i=0; i<jc[nCols]; i++) {
-		fprintf( output_file,"%sval[%d] = %23.16e\n",prefix,(int)i,val[i] );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-SparseMatrixRow::SparseMatrixRow() : nRows(0), nCols(0), jr(0), ic(0), jd(0), val(0) {}
-
-SparseMatrixRow::SparseMatrixRow(int_t nr, int_t nc, sparse_int_t *r, sparse_int_t *c, real_t *v)
-	: nRows(nr), nCols(nc), jr(r), ic(c), jd(0), val(v) { doNotFreeMemory(); }
-
-SparseMatrixRow::SparseMatrixRow(int_t nr, int_t nc, int_t ld, const real_t * const v) : nRows(nr), nCols(nc), jd(0)
-{
-	int_t i, j, nnz;
-
-	jr = new sparse_int_t[nr+1];
-	ic = new sparse_int_t[nr*nc];
-	val = new real_t[nr*nc];
-
-	nnz = 0;
-	for (j = 0; j < nRows; j++)
-	{
-		jr[j] = nnz;
-		for (i = 0; i < nCols; i++)
-			if ( ( isZero( v[j*ld+i],0.0 ) == BT_FALSE ) || ( j == i ) )
-			{
-				ic[nnz] = i;
-				val[nnz++] = v[j*ld+i];
-			}
-	}
-	jr[nRows] = nnz;
-
-	doFreeMemory( );
-}
-
-
-SparseMatrixRow::~SparseMatrixRow()
-{
-	if (jd != 0)
-	{
-		delete[] jd;
-		jd = 0;
-	}
-
-	if ( needToFreeMemory() == BT_TRUE )
-		free( );
-}
-
-
-void SparseMatrixRow::free( )
-{
-	if (jr != 0) delete[] jr;
-	jr = 0;
-	if (ic != 0) delete[] ic;
-	ic = 0;
-	if (val != 0) delete[] val;
-	val = 0;
-
-	doNotFreeMemory( );
-}
-
-
-Matrix *SparseMatrixRow::duplicate() const
-{
-	long i, length = jr[nRows];
-	SparseMatrixRow *dupl = new SparseMatrixRow;
-
-	dupl->nRows = nRows;
-	dupl->nCols = nCols;
-	dupl->jr = new sparse_int_t[nRows+1];
-	dupl->ic = new sparse_int_t[length];
-	dupl->val = new real_t[length];
-
-	for (i = 0; i < length; i++) dupl->jr[i] = jr[i];
-	for (i = 0; i <= nCols; i++) dupl->ic[i] = ic[i];
-	for (i = 0; i < length; i++) dupl->val[i] = val[i];
-
-	if ( jd != 0 )
-	{
-		dupl->jd = new sparse_int_t[nRows];
-		for (i = 0; i < nCols; i++) dupl->jd[i] = jd[i];
-	}
-	else
-		dupl->jd = 0;
-
-	dupl->doFreeMemory( );
-
-	return dupl;
-}
-
-
-
-real_t SparseMatrixRow::diag(int_t i) const
-{
-	if ( jd == 0 )
-	{
-		THROWERROR( RET_DIAGONAL_NOT_INITIALISED );
-		return INFTY;
-	}
-
-	int_t entry = jd[i];
-	return (entry < jr[i+1] && ic[entry] == i) ? val[entry] : 0.0;
-}
-
-
-BooleanType SparseMatrixRow::isDiag() const
-{
-	int_t i;
-
-	if ( nCols != nRows )
-		return BT_FALSE;
-
-	for (i = 0; i < nRows; ++i)
-	{
-		if ( jr[i+1] > jr[i]+1 )
-			return BT_FALSE;
-
-		if ( ( jr[i+1] == jr[i]+1 ) && ( ic[jr[i]] != i ) )
-			return BT_FALSE;
-	}
-
-	return BT_TRUE;
-}
-
-
-
-real_t SparseMatrixRow::getNorm(	int_t type
-									) const
-{
-	int_t length = jr[nRows];
-	return REFER_NAMESPACE_QPOASES getNorm( val,length,type );
-
-}
-
-
-real_t SparseMatrixRow::getRowNorm( int_t rNum, int_t type ) const
-{
-	int_t length = jr[rNum+1] - jr[rNum];
-	return REFER_NAMESPACE_QPOASES getNorm( &(val[jr[rNum]]),length,type );
-}
-
-
-
-returnValue SparseMatrixRow::getRow(int_t rNum, const Indexlist* const icols, real_t alpha, real_t *row) const
-{
-	long i, j;
-
-	if (icols != 0)
-	{
-		j = jr[rNum];
-		i = 0;
-		if ( isEqual(alpha,1.0) == BT_TRUE )
-			while (j < jr[rNum+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = val[j++];
-				else if (ic[j] > icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = 0.0;
-				else
-					j++;
-		else if ( isEqual(alpha,-1.0) == BT_TRUE )
-			while (j < jr[rNum+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = -val[j++];
-				else if (ic[j] > icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = 0.0;
-				else
-					j++;
-		else
-			while (j < jr[rNum+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = alpha * val[j++];
-				else if (ic[j] > icols->number[icols->iSort[i]])
-					row[icols->iSort[i++]] = 0.0;
-				else
-					j++;
-
-		/* fill in remaining zeros */
-		while (i < icols->length)
-			row[icols->iSort[i++]] = 0.0;
-	}
-	else
-	{
-		for (i = 0; i < nCols; i++)
-			row[i] = 0;
-
-		if ( isEqual(alpha,1.0) == BT_TRUE )
-			for (j = jr[rNum]; j < jr[rNum+1]; j++)
-				row[ic[j]] = val[j];
-		else if ( isEqual(alpha,-1.0) == BT_TRUE )
-			for (j = jr[rNum]; j < jr[rNum+1]; j++)
-				row[ic[j]] = -val[j];
-		else
-			for (j = jr[rNum]; j < jr[rNum+1]; j++)
-				row[ic[j]] = alpha * val[j];
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrixRow::getCol(int_t cNum, const Indexlist* const irows, real_t alpha, real_t *col) const
-{
-	long i, j, k, srt;
-
-    if (irows != 0)
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (k = 0; k < irows->length; k++)
-		    {
-				srt = irows->iSort[k];
-			    j = irows->number[srt];
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[srt] = (i < jr[j+1] && ic[i] == cNum) ? val[i] : 0.0;
-		    }
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (k = 0; k < irows->length; k++)
-		    {
-				srt = irows->iSort[k];
-			    j = irows->number[srt];
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[srt] = (i < jr[j+1] && ic[i] == cNum) ? -val[i] : 0.0;
-		    }
-	    else
-		    for (k = 0; k < irows->length; k++)
-		    {
-				srt = irows->iSort[k];
-			    j = irows->number[srt];
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[srt] = (i < jr[j+1] && ic[i] == cNum) ? alpha*val[i] : 0.0;
-		    }
-    }
-    else
-    {
-	    if ( isEqual(alpha,1.0) == BT_TRUE )
-		    for (j = 0; j < nCols; j++)
-		    {
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[j] = (i < jr[j+1] && ic[i] == cNum) ? val[i] : 0.0;
-		    }
-	    else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		    for (j = 0; j < irows->length; j++)
-		    {
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[j] = (i < jr[j+1] && ic[i] == cNum) ? -val[i] : 0.0;
-		    }
-	    else
-		    for (j = 0; j < irows->length; j++)
-		    {
-			    for (i = jr[j]; i < jr[j+1] && ic[i] < cNum; i++);
-			    col[j] = (i < jr[j+1] && ic[i] == cNum) ? alpha*val[i] : 0.0;
-		    }
-    }
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SparseMatrixRow::getSparseSubmatrix (
-				int_t irowsLength, const int_t* const irowsNumber,
-				int_t icolsLength, const int_t* const icolsNumber,
-				int_t rowoffset, int_t coloffset, int_t& numNonzeros,	int_t* irn,
-				int_t* jcn, real_t* avals, BooleanType only_lower_triangular /*= BT_FALSE */) const
-{
-	fprintf(stderr, "SparseMatrixRow::getSparseSubmatrix not implemented!\n");
-
-	return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-}
-
-returnValue SparseMatrixRow::times(int_t xN, real_t alpha, const real_t *x, int_t xLD,
-		real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				for (i = jr[j]; i < jr[j+1]; i++)
-					y[j+k*yLD] += val[i] * x[ic[i]+k*xLD];
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				for (i = jr[j]; i < jr[j+1]; i++)
-					y[j+k*yLD] -= val[i] * x[ic[i]+k*xLD];
-	else
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nRows; j++)
-				for (i = jr[j]; i < jr[j+1]; i++)
-					y[j+k*yLD] += alpha * val[i] * x[ic[i]+k*xLD];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrixRow::transTimes(int_t xN, real_t alpha, const real_t *x, int_t xLD,
-		real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < nCols; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (i = 0; i < nRows; i++)
-				for (j = jr[i]; j < jr[i+1]; j++)
-					y[ic[j]+k*yLD] += val[j] * x[i+k*xLD];
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (i = 0; i < nRows; i++)
-				for (j = jr[i]; j < jr[i+1]; j++)
-					y[ic[j]+k*yLD] -= val[j] * x[i+k*xLD];
-	else
-		for (k = 0; k < xN; k++)
-			for (i = 0; i < nRows; i++)
-				for (j = jr[i]; j < jr[i+1]; j++)
-					y[ic[j]+k*yLD] += alpha * val[j] * x[i+k*xLD];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrixRow::times(const Indexlist* const irows, const Indexlist* const icols,
-		int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD,
-		BooleanType yCompr) const
-{
-	long i, j, k, l, srt, row;
-
-	if (yCompr == BT_TRUE)
-	{
-		if ( isZero(beta) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = 0.0;
-		else if ( isEqual(beta,-1.0) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] = -y[j+k*yLD];
-		else if ( isEqual(beta,1.0) == BT_FALSE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[j+k*yLD] *= beta;
-
-		if (icols == 0)
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+srt] += val[j] * x[k*xLD+ic[j]];
-				}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+srt] -= val[j] * x[k*xLD+ic[j]];
-				}
-			else
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+srt] += alpha * val[j] * x[k*xLD+ic[j]];
-				}
-		else /* icols != 0 */
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					j = jr[row];
-					i = 0;
-					while (j < jr[row+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+srt] += val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					j = jr[row];
-					i = 0;
-					while (j < jr[row+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+srt] -= val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-			else
-				for (l = 0; l < irows->length; l++)
-				{
-					srt = irows->iSort[l];
-					row = irows->number[srt];
-					j = jr[row];
-					i = 0;
-					while (j < jr[row+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+srt] += alpha * val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-	}
-	else /* y not compressed */
-	{
-		if ( isZero(beta) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = 0.0;
-		else if ( isEqual(beta,-1.0) == BT_TRUE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] = -y[j+k*yLD];
-		else if ( isEqual(beta,1.0) == BT_FALSE )
-			for (k = 0; k < xN; k++)
-				for (j = 0; j < irows->length; j++)
-					y[irows->number[j]+k*yLD] *= beta;
-
-		if (icols == 0)
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->number[irows->iSort[l]];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+row] += val[j] * x[k*xLD+ic[j]];
-				}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->number[irows->iSort[l]];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+row] -= val[j] * x[k*xLD+ic[j]];
-				}
-			else
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->number[irows->iSort[l]];
-					for (j = jr[row]; j < jr[row+1]; j++)
-						for (k = 0; k < xN; k++)
-							y[k*yLD+row] += alpha * val[j] * x[k*xLD+ic[j]];
-				}
-		else /* icols != 0 */
-			if ( isEqual(alpha,1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->iSort[l];
-					j = jr[irows->number[row]];
-					i = 0;
-					while (j < jr[irows->number[row]+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+row] += val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-			else if ( isEqual(alpha,-1.0) == BT_TRUE )
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->iSort[l];
-					j = jr[irows->number[row]];
-					i = 0;
-					while (j < jr[irows->number[row]+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+row] -= val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-			else
-				for (l = 0; l < irows->length; l++)
-				{
-					row = irows->iSort[l];
-					j = jr[irows->number[row]];
-					i = 0;
-					while (j < jr[irows->number[row]+1] && i < icols->length)
-						if (ic[j] == icols->number[icols->iSort[i]])
-						{
-							for (k = 0; k < xN; k++)
-								y[k*yLD+row] += alpha * val[j] * x[k*xLD+icols->iSort[i]];
-							j++, i++;
-						}
-						else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-						else j++;
-				}
-	}
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SparseMatrixRow::transTimes(const Indexlist* const irows, const Indexlist* const icols,
-		int_t xN, real_t alpha, const real_t *x, int_t xLD, real_t beta, real_t *y, int_t yLD) const
-{
-	long i, j, k, l, row, srt;
-
-	if ( isZero(beta) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = 0.0;
-	else if ( isEqual(beta,-1.0) == BT_TRUE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] = -y[j+k*yLD];
-	else if ( isEqual(beta,1.0) == BT_FALSE )
-		for (k = 0; k < xN; k++)
-			for (j = 0; j < icols->length; j++)
-				y[j+k*yLD] *= beta;
-
-	if ( isEqual(alpha,1.0) == BT_TRUE )
-		for (l = 0; l < irows->length; l++)
-		{
-			srt = irows->iSort[l];
-			row = irows->number[srt];
-			j = jr[row];
-			i = 0;
-			while (j < jr[row+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-				{
-					for (k = 0; k < xN; k++)
-						y[k*yLD+icols->iSort[i]] += val[j] * x[k*xLD+srt];
-					j++, i++;
-				}
-				else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-				else j++;
-		}
-	else if ( isEqual(alpha,-1.0) == BT_TRUE )
-		for (l = 0; l < irows->length; l++)
-		{
-			srt = irows->iSort[l];
-			row = irows->number[srt];
-			j = jr[row];
-			i = 0;
-			while (j < jr[row+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-				{
-					for (k = 0; k < xN; k++)
-						y[k*yLD+icols->iSort[i]] -= val[j] * x[k*xLD+srt];
-					j++, i++;
-				}
-				else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-				else j++;
-		}
-	else
-		for (l = 0; l < irows->length; l++)
-		{
-			srt = irows->iSort[l];
-			row = irows->number[srt];
-			j = jr[row];
-			i = 0;
-			while (j < jr[row+1] && i < icols->length)
-				if (ic[j] == icols->number[icols->iSort[i]])
-				{
-					for (k = 0; k < xN; k++)
-						y[k*yLD+icols->iSort[i]] += alpha * val[j] * x[k*xLD+srt];
-					j++, i++;
-				}
-				else if (ic[j] > icols->number[icols->iSort[i]]) i++;
-				else j++;
-		}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-returnValue SparseMatrixRow::addToDiag(real_t alpha)
-{
-	long i;
-
-	if ( jd == 0 )
-		return THROWERROR( RET_DIAGONAL_NOT_INITIALISED );
-
-	if ( isZero(alpha) == BT_FALSE )
-	{
-		for (i = 0; i < nRows && i < nCols; i++)
-		{
-			if (ic[jd[i]] == i)
-				val[jd[i]] += alpha;
-			else
-				return RET_NO_DIAGONAL_AVAILABLE;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-sparse_int_t *SparseMatrixRow::createDiagInfo()
-{
-	sparse_int_t i, j;
-
-	if (jd == 0) {
-		jd = new sparse_int_t[nRows];
-
-		for (i = 0; i < nRows; i++)
-		{
-			for (j = jr[i]; j < jr[i+1] && ic[j] < i; j++);
-			jd[i] = j;
-		}
-	}
-
-	return jd;
-}
-
-
-real_t *SparseMatrixRow::full() const
-{
-	sparse_int_t i, j;
-	real_t *v = new real_t[nRows*nCols];
-
-	for (i = 0; i < nCols*nRows; i++)
-		v[i] = 0.0;
-
-	for (i = 0; i < nRows; i++)
-		for (j = jr[i]; j < jr[i+1]; j++)
-			v[ic[j] + i * nCols] = val[j];
-
-	return v;
-}
-
-
-returnValue SparseMatrixRow::print( const char* name ) const
-{
-	real_t* tmp = this->full();
-	returnValue retVal = REFER_NAMESPACE_QPOASES print( tmp,nRows,nCols,name );
-	delete[] tmp;
-
-	return retVal;
-}
-
-returnValue SparseMatrixRow::writeToFile( FILE* output_file, const char* prefix ) const
-{
-	return THROWERROR( RET_NOT_YET_IMPLEMENTED );
-}
-
-Matrix *SymSparseMat::duplicate() const
-{
-	return duplicateSym();
-}
-
-
-SymmetricMatrix *SymSparseMat::duplicateSym() const
-{
-	/* "same" as duplicate() in SparseMatrix */
-	long i, length = jc[nCols];
-	SymSparseMat *dupl = new SymSparseMat;
-
-	dupl->nRows = nRows;
-	dupl->nCols = nCols;
-	dupl->ir = new sparse_int_t[length];
-	dupl->jc = new sparse_int_t[nCols+1];
-	dupl->val = new real_t[length];
-
-	for (i = 0; i < length; i++) dupl->ir[i] = ir[i];
-	for (i = 0; i <= nCols; i++) dupl->jc[i] = jc[i];
-	for (i = 0; i < length; i++) dupl->val[i] = val[i];
-
-	if ( jd != 0 )
-	{
-		dupl->jd = new sparse_int_t[nCols];
-		for (i = 0; i < nCols; i++) dupl->jd[i] = jd[i];
-	}
-	else
-		dupl->jd = 0;
-
-	dupl->doFreeMemory( );
-
-	return dupl;
-}
-
-
-returnValue SymSparseMat::bilinear(const Indexlist* const icols,
-		int_t xN, const real_t *x, int_t xLD, real_t *y, int_t yLD) const
-{
-	int_t i, j, k, l, idx, row, col;
-
-	if ( jd == 0 )
-		return THROWERROR( RET_DIAGONAL_NOT_INITIALISED );
-
-	/* clear output */
-	for (i = 0; i < xN*xN; i++)
-		y[i] = 0.0;
-
-	/* compute lower triangle */
-	for (l = 0; l < icols->length; l++)
-	{
-		col = icols->number[icols->iSort[l]];
-		idx = jd[col];
-		k = 0;
-		while (idx < jc[col+1] && k < icols->length)
-		{
-			row = icols->number[icols->iSort[k]];
-			if (ir[idx] == row)
-			{
-				/* TODO: It is possible to formulate this as DSYR and DSYR2
-				 * operations. */
-				if (row == col) /* diagonal element */
-					for (i = 0; i < xN; i++)
-						for (j = i; j < xN; j++)
-							y[i*yLD+j] += val[idx] * x[i*xLD+col] * x[j*xLD+col];
-				else /* subdiagonal elements */
-					for (i = 0; i < xN; i++)
-						for (j = i; j < xN; j++)
-							y[i*yLD+j] += val[idx] * (x[i*xLD+col] * x[j*xLD+row] + x[i*xLD+row] * x[j*xLD+col]);
-				idx++, k++;
-			}
-			else if (ir[idx] > row) k++;
-			else idx++;
-		}
-	}
-
-	/* fill upper triangle */
-	for (i = 0; i < xN; i++)
-		for (j = i; j < xN; j++)
-			y[j*yLD+i] = y[i*yLD+j];
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/MessageHandling.cpp b/extlibs/qpOASES-3.2.0/src/MessageHandling.cpp
deleted file mode 100644
index 00a3985..0000000
--- a/extlibs/qpOASES-3.2.0/src/MessageHandling.cpp
+++ /dev/null
@@ -1,632 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/MessageHandling.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the MessageHandling class including global return values.
- *
- */
-
-
-#include <stdio.h>
-
-#ifdef __MATLAB__
-  #include "mex.h"
-#endif
-
-#include <qpOASES/MessageHandling.hpp>
-#include <qpOASES/Utils.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-/** Default file to display messages. */
-FILE* stdFile = stdout;
-
-
-
-#ifndef __SUPPRESSANYOUTPUT__
-
-/** Defines pairs of global return values and messages. */
-MessageHandling::ReturnValueList returnValueList[] =
-{
-/* miscellaneous */
-{ SUCCESSFUL_RETURN, "Successful return", VS_VISIBLE },
-{ RET_DIV_BY_ZERO, "Division by zero", VS_VISIBLE },
-{ RET_INDEX_OUT_OF_BOUNDS, "Index out of bounds", VS_VISIBLE },
-{ RET_INVALID_ARGUMENTS, "At least one of the arguments is invalid", VS_VISIBLE },
-{ RET_ERROR_UNDEFINED, "Error number undefined", VS_VISIBLE },
-{ RET_WARNING_UNDEFINED, "Warning number undefined", VS_VISIBLE },
-{ RET_INFO_UNDEFINED, "Info number undefined", VS_VISIBLE },
-{ RET_EWI_UNDEFINED, "Error/warning/info number undefined", VS_VISIBLE },
-{ RET_AVAILABLE_WITH_LINUX_ONLY, "This function is available under Linux only", VS_HIDDEN },
-{ RET_UNKNOWN_BUG, "The error occurred is not yet known", VS_VISIBLE },
-{ RET_PRINTLEVEL_CHANGED, "Print level changed", VS_VISIBLE },
-{ RET_NOT_YET_IMPLEMENTED, "Requested function is not yet implemented.", VS_VISIBLE },
-/* Indexlist */
-{ RET_INDEXLIST_MUST_BE_REORDERD, "Index list has to be reordered", VS_VISIBLE },
-{ RET_INDEXLIST_EXCEEDS_MAX_LENGTH, "Index list exceeds its maximal physical length", VS_VISIBLE },
-{ RET_INDEXLIST_CORRUPTED, "Index list corrupted", VS_VISIBLE },
-{ RET_INDEXLIST_OUTOFBOUNDS, "Physical index is out of bounds", VS_VISIBLE },
-{ RET_INDEXLIST_ADD_FAILED, "Adding indices from another index set failed", VS_VISIBLE },
-{ RET_INDEXLIST_INTERSECT_FAILED, "Intersection with another index set failed", VS_VISIBLE },
-/* SubjectTo / Bounds / Constraints */
-{ RET_INDEX_ALREADY_OF_DESIRED_STATUS, "Index is already of desired status", VS_VISIBLE },
-{ RET_ADDINDEX_FAILED, "Adding index to index set failed", VS_VISIBLE },
-{ RET_REMOVEINDEX_FAILED, "Removing index from index set failed", VS_VISIBLE },
-{ RET_SWAPINDEX_FAILED, "Cannot swap between different indexsets", VS_VISIBLE },
-{ RET_NOTHING_TO_DO, "Nothing to do", VS_VISIBLE },
-{ RET_SETUP_BOUND_FAILED, "Setting up bound index failed", VS_VISIBLE },
-{ RET_SETUP_CONSTRAINT_FAILED, "Setting up constraint index failed", VS_VISIBLE },
-{ RET_MOVING_BOUND_FAILED, "Moving bound between index sets failed", VS_VISIBLE },
-{ RET_MOVING_CONSTRAINT_FAILED, "Moving constraint between index sets failed", VS_VISIBLE },
-{ RET_SHIFTING_FAILED, "Shifting of bounds/constraints failed", VS_VISIBLE },
-{ RET_ROTATING_FAILED, "Rotating of bounds/constraints failed", VS_VISIBLE },
-/* QProblem */
-{ RET_QPOBJECT_NOT_SETUP, "The QP object has not been setup correctly, use another constructor", VS_VISIBLE },
-{ RET_QP_ALREADY_INITIALISED, "QProblem has already been initialised", VS_VISIBLE },
-{ RET_NO_INIT_WITH_STANDARD_SOLVER, "Initialisation via extern QP solver is not yet implemented", VS_VISIBLE },
-{ RET_RESET_FAILED, "Reset failed", VS_VISIBLE },
-{ RET_INIT_FAILED, "Initialisation failed", VS_VISIBLE },
-{ RET_INIT_FAILED_TQ, "Initialisation failed due to TQ factorisation", VS_VISIBLE },
-{ RET_INIT_FAILED_CHOLESKY, "Initialisation failed due to Cholesky decomposition", VS_VISIBLE },
-{ RET_INIT_FAILED_HOTSTART, "Initialisation failed! QP could not be solved!", VS_VISIBLE },
-{ RET_INIT_FAILED_INFEASIBILITY, "Initial QP could not be solved due to infeasibility!", VS_VISIBLE },
-{ RET_INIT_FAILED_UNBOUNDEDNESS, "Initial QP could not be solved due to unboundedness!", VS_VISIBLE },
-{ RET_INIT_FAILED_REGULARISATION, "Initialisation failed as Hessian matrix could not be regularised", VS_VISIBLE },
-{ RET_INIT_SUCCESSFUL, "Initialisation done", VS_VISIBLE },
-{ RET_OBTAINING_WORKINGSET_FAILED, "Failed to obtain working set for auxiliary QP", VS_VISIBLE },
-{ RET_SETUP_WORKINGSET_FAILED, "Failed to setup working set for auxiliary QP", VS_VISIBLE },
-{ RET_SETUP_AUXILIARYQP_FAILED, "Failed to setup auxiliary QP for initialised homotopy", VS_VISIBLE },
-{ RET_NO_CHOLESKY_WITH_INITIAL_GUESS, "Externally computed Cholesky factor cannot be combined with an initial guess", VS_VISIBLE },
-{ RET_NO_EXTERN_SOLVER, "No extern QP solver available", VS_VISIBLE },
-{ RET_QP_UNBOUNDED, "QP is unbounded", VS_VISIBLE },
-{ RET_QP_INFEASIBLE, "QP is infeasible", VS_VISIBLE },
-{ RET_QP_NOT_SOLVED, "Problems occurred while solving QP with standard solver", VS_VISIBLE },
-{ RET_QP_SOLVED, "QP successfully solved", VS_VISIBLE },
-{ RET_UNABLE_TO_SOLVE_QP, "Problems occurred while solving QP", VS_VISIBLE },
-{ RET_INITIALISATION_STARTED, "Starting problem initialisation...", VS_VISIBLE },
-{ RET_HOTSTART_FAILED, "Unable to perform homotopy due to internal error", VS_VISIBLE },
-{ RET_HOTSTART_FAILED_TO_INIT, "Unable to initialise problem", VS_VISIBLE },
-{ RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED, "Unable to perform homotopy as previous QP is not solved", VS_VISIBLE },
-{ RET_ITERATION_STARTED, "Iteration", VS_VISIBLE },
-{ RET_SHIFT_DETERMINATION_FAILED, "Determination of shift of the QP data failed", VS_VISIBLE },
-{ RET_STEPDIRECTION_DETERMINATION_FAILED, "Determination of step direction failed", VS_VISIBLE },
-{ RET_STEPLENGTH_DETERMINATION_FAILED, "Determination of step direction failed", VS_VISIBLE },
-{ RET_OPTIMAL_SOLUTION_FOUND, "Optimal solution of neighbouring QP found", VS_VISIBLE },
-{ RET_HOMOTOPY_STEP_FAILED, "Unable to perform homotopy step", VS_VISIBLE },
-{ RET_HOTSTART_STOPPED_INFEASIBILITY, "Premature homotopy termination because QP is infeasible", VS_VISIBLE },
-{ RET_HOTSTART_STOPPED_UNBOUNDEDNESS, "Premature homotopy termination because QP is unbounded", VS_VISIBLE },
-{ RET_WORKINGSET_UPDATE_FAILED, "Unable to update working sets according to initial guesses", VS_VISIBLE },
-{ RET_MAX_NWSR_REACHED, "Maximum number of working set recalculations performed", VS_VISIBLE },
-{ RET_CONSTRAINTS_NOT_SPECIFIED, "Problem does comprise constraints! You have to specify new constraints' bounds", VS_VISIBLE },
-{ RET_INVALID_FACTORISATION_FLAG, "Invalid factorisation flag", VS_VISIBLE },
-{ RET_UNABLE_TO_SAVE_QPDATA, "Unable to save QP data", VS_VISIBLE },
-{ RET_STEPDIRECTION_FAILED_TQ, "Abnormal termination due to TQ factorisation", VS_VISIBLE },
-{ RET_STEPDIRECTION_FAILED_CHOLESKY, "Abnormal termination due to Cholesky factorisation", VS_VISIBLE },
-{ RET_CYCLING_DETECTED, "Cycling detected", VS_VISIBLE },
-{ RET_CYCLING_NOT_RESOLVED, "Cycling cannot be resolved, QP is probably infeasible", VS_VISIBLE },
-{ RET_CYCLING_RESOLVED, "Cycling probably resolved", VS_VISIBLE },
-{ RET_STEPSIZE, "", VS_VISIBLE },
-{ RET_STEPSIZE_NONPOSITIVE, "", VS_VISIBLE },
-{ RET_SETUPSUBJECTTOTYPE_FAILED, "Setup of SubjectToTypes failed", VS_VISIBLE },
-{ RET_ADDCONSTRAINT_FAILED, "Addition of constraint to working set failed", VS_VISIBLE },
-{ RET_ADDCONSTRAINT_FAILED_INFEASIBILITY, "Addition of constraint to working set failed", VS_VISIBLE },
-{ RET_ADDBOUND_FAILED, "Addition of bound to working set failed", VS_VISIBLE },
-{ RET_ADDBOUND_FAILED_INFEASIBILITY, "Addition of bound to working set failed", VS_VISIBLE },
-{ RET_REMOVECONSTRAINT_FAILED, "Removal of constraint from working set failed", VS_VISIBLE },
-{ RET_REMOVEBOUND_FAILED, "Removal of bound from working set failed", VS_VISIBLE },
-{ RET_REMOVE_FROM_ACTIVESET, "Removing from active set:", VS_VISIBLE },
-{ RET_ADD_TO_ACTIVESET, "Adding to active set:", VS_VISIBLE },
-{ RET_REMOVE_FROM_ACTIVESET_FAILED, "Removing from active set failed", VS_VISIBLE },
-{ RET_ADD_TO_ACTIVESET_FAILED, "Adding to active set failed", VS_VISIBLE },
-{ RET_CONSTRAINT_ALREADY_ACTIVE, "Constraint is already active", VS_VISIBLE },
-{ RET_ALL_CONSTRAINTS_ACTIVE, "All constraints are active, no further constraint can be added", VS_VISIBLE },
-{ RET_LINEARLY_DEPENDENT, "New bound/constraint is linearly dependent", VS_VISIBLE },
-{ RET_LINEARLY_INDEPENDENT, "New bound/constraint is linearly independent", VS_VISIBLE },
-{ RET_LI_RESOLVED, "Linear independence of active constraint matrix successfully resolved", VS_VISIBLE },
-{ RET_ENSURELI_FAILED, "Failed to ensure linear independence of active constraint matrix", VS_VISIBLE },
-{ RET_ENSURELI_FAILED_TQ, "Abnormal termination due to TQ factorisation", VS_VISIBLE },
-{ RET_ENSURELI_FAILED_NOINDEX, "QP is infeasible", VS_VISIBLE },
-{ RET_ENSURELI_FAILED_CYCLING, "QP is infeasible", VS_VISIBLE },
-{ RET_BOUND_ALREADY_ACTIVE, "Bound is already active", VS_VISIBLE },
-{ RET_ALL_BOUNDS_ACTIVE, "All bounds are active, no further bound can be added", VS_VISIBLE },
-{ RET_CONSTRAINT_NOT_ACTIVE, "Constraint is not active", VS_VISIBLE },
-{ RET_BOUND_NOT_ACTIVE, "Bound is not active", VS_VISIBLE },
-{ RET_HESSIAN_NOT_SPD, "Projected Hessian matrix not positive definite", VS_VISIBLE },
-{ RET_HESSIAN_INDEFINITE, "Hessian matrix is indefinite", VS_VISIBLE },
-{ RET_MATRIX_SHIFT_FAILED, "Unable to update matrices or to transform vectors", VS_VISIBLE },
-{ RET_MATRIX_FACTORISATION_FAILED, "Unable to calculate new matrix factorisations", VS_VISIBLE },
-{ RET_PRINT_ITERATION_FAILED, "Unable to print information on current iteration", VS_VISIBLE },
-{ RET_NO_GLOBAL_MESSAGE_OUTPUTFILE, "No global message output file initialised", VS_VISIBLE },
-{ RET_DISABLECONSTRAINTS_FAILED, "Unable to disable constraints", VS_VISIBLE },
-{ RET_ENABLECONSTRAINTS_FAILED, "Unable to enable constraints", VS_VISIBLE },
-{ RET_ALREADY_ENABLED, "Bound or constraint is already enabled", VS_VISIBLE },
-{ RET_ALREADY_DISABLED, "Bound or constraint is already disabled", VS_VISIBLE },
-{ RET_NO_HESSIAN_SPECIFIED, "No Hessian matrix has been specified", VS_VISIBLE },
-{ RET_USING_REGULARISATION, "Using regularisation as Hessian matrix is not positive definite", VS_VISIBLE },
-{ RET_EPS_MUST_BE_POSITVE, "Eps for regularisation must be sufficiently positive", VS_VISIBLE },
-{ RET_REGSTEPS_MUST_BE_POSITVE, "Maximum number of regularisation steps must be non-negative", VS_VISIBLE },
-{ RET_HESSIAN_ALREADY_REGULARISED, "Hessian has been already regularised", VS_VISIBLE },
-{ RET_CANNOT_REGULARISE_IDENTITY, "Identity Hessian matrix cannot be regularised", VS_VISIBLE },
-{ RET_CANNOT_REGULARISE_SPARSE, "Sparse matrix cannot be regularised as diagonal entry is missing", VS_VISIBLE },
-{ RET_NO_REGSTEP_NWSR, "No additional regularisation step could be performed due to limits", VS_VISIBLE },
-{ RET_FEWER_REGSTEPS_NWSR, "Fewer additional regularisation steps have been performed due to limits", VS_VISIBLE },
-{ RET_CHOLESKY_OF_ZERO_HESSIAN, "Cholesky decomposition of (unregularised) zero Hessian matrix", VS_VISIBLE },
-{ RET_ZERO_HESSIAN_ASSUMED, "Zero Hessian matrix assumed as null pointer passed without specifying hessianType", VS_VISIBLE },
-{ RET_CONSTRAINTS_ARE_NOT_SCALED, "(should not be thrown, no longer in use)", VS_VISIBLE },
-{ RET_INITIAL_BOUNDS_STATUS_NYI, "(should not be thrown, no longer in use)", VS_VISIBLE },
-{ RET_ERROR_IN_CONSTRAINTPRODUCT, "Error in user-defined constraint product function", VS_VISIBLE },
-{ RET_FIX_BOUNDS_FOR_LP, "All initial bounds must be fixed when solving an (unregularised) LP", VS_VISIBLE },
-{ RET_USE_REGULARISATION_FOR_LP, "Set options.enableRegularisation=BT_TRUE for solving LPs", VS_VISIBLE },
-/* SQProblem */
-{ RET_UPDATEMATRICES_FAILED, "Unable to update QP matrices", VS_VISIBLE },
-{ RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED, "Unable to update matrices as previous QP is not solved", VS_VISIBLE },
-/* Utils */
-{ RET_UNABLE_TO_OPEN_FILE, "Unable to open file", VS_VISIBLE },
-{ RET_UNABLE_TO_WRITE_FILE, "Unable to write into file", VS_VISIBLE },
-{ RET_UNABLE_TO_READ_FILE, "Unable to read from file", VS_VISIBLE },
-{ RET_FILEDATA_INCONSISTENT, "File contains inconsistent data", VS_VISIBLE },
-/* Options */
-{ RET_OPTIONS_ADJUSTED,	"Options needed to be adjusted for consistency reasons", VS_VISIBLE },
-/* SolutionAnalysis */
-{ RET_UNABLE_TO_ANALYSE_QPROBLEM, "Unable to analyse (S)QProblem(B) object", VS_VISIBLE },
-/* Benchmark */
-{ RET_NWSR_SET_TO_ONE, "Maximum number of working set changes was set to 1", VS_VISIBLE },
-{ RET_UNABLE_TO_READ_BENCHMARK, "Unable to read benchmark data", VS_VISIBLE },
-{ RET_BENCHMARK_ABORTED, "Benchmark aborted", VS_VISIBLE },
-{ RET_INITIAL_QP_SOLVED, "Initial QP solved", VS_VISIBLE },
-{ RET_QP_SOLUTION_STARTED, "Solving QP no.", VS_VISIBLE },
-{ RET_BENCHMARK_SUCCESSFUL, "Benchmark terminated successfully", VS_VISIBLE },
-/* Sparse matrices */
-{ RET_NO_DIAGONAL_AVAILABLE, "Sparse matrix does not have entries on full diagonal", VS_VISIBLE },
-{ RET_DIAGONAL_NOT_INITIALISED, "Diagonal data of sparse matrix has not been initialised", VS_VISIBLE },
-/* Dropping of infeasible constraints */
-{ RET_ENSURELI_DROPPED, "Linear independence resolved by dropping blocking constraint", VS_VISIBLE },
-/* Schur complement computations */
-{ RET_KKT_MATRIX_SINGULAR, "KKT matrix is singular", VS_VISIBLE },
-{ RET_QR_FACTORISATION_FAILED, "QR factorization of Schur complement failed", VS_VISIBLE },
-{ RET_INERTIA_CORRECTION_FAILED, "Inertia correction of KKT matrix failed", VS_VISIBLE },
-{ RET_NO_SPARSE_SOLVER, "No Sparse Solver installed", VS_VISIBLE },
-/* Simple exitflags */
-{ RET_SIMPLE_STATUS_P1, "QP problem could not be solved within given number of iterations", VS_VISIBLE },
-{ RET_SIMPLE_STATUS_P0, "QP problem solved", VS_VISIBLE },
-{ RET_SIMPLE_STATUS_M1, "QP problem could not be solved due to an internal error", VS_VISIBLE },
-{ RET_SIMPLE_STATUS_M2, "QP problem is infeasible (and thus could not be solved)", VS_VISIBLE },
-{ RET_SIMPLE_STATUS_M3, "QP problem is unbounded (and thus could not be solved)", VS_VISIBLE },
-/* IMPORTANT: Terminal list element! */
-{ TERMINAL_LIST_ELEMENT, "", VS_HIDDEN }
-};
-
-#else /* __SUPPRESSANYOUTPUT__ */
-
-MessageHandling::ReturnValueList returnValueList[1]; /* Do not use messages for embedded platforms! */
-
-#endif /* __SUPPRESSANYOUTPUT__ */
-
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-/*
- *	M e s s a g e H a n d l i n g
- */
-MessageHandling::MessageHandling( )
-{
-	errorVisibility   = VS_VISIBLE;
-	warningVisibility = VS_VISIBLE;
-	infoVisibility    = VS_VISIBLE;
-
-	outputFile = stdFile;
-	errorCount = 0;
-}
-
-/*
- *	M e s s a g e H a n d l i n g
- */
-MessageHandling::MessageHandling( FILE* _outputFile )
-{
-	errorVisibility   = VS_VISIBLE;
-	warningVisibility = VS_HIDDEN;
-	infoVisibility    = VS_HIDDEN;
-
-	outputFile = _outputFile;
-	errorCount = 0;
-}
-
-/*
- *	M e s s a g e H a n d l i n g
- */
-MessageHandling::MessageHandling(	VisibilityStatus _errorVisibility,
-									VisibilityStatus _warningVisibility,
-		 							VisibilityStatus _infoVisibility
-									)
-{
-	errorVisibility   = _errorVisibility;
-	warningVisibility = _warningVisibility;
-	infoVisibility    = _infoVisibility;
-
-	outputFile = stdFile;
-	errorCount = 0;
-}
-
-/*
- *	M e s s a g e H a n d l i n g
- */
-MessageHandling::MessageHandling( 	FILE* _outputFile,
-									VisibilityStatus _errorVisibility,
-									VisibilityStatus _warningVisibility,
-		 							VisibilityStatus _infoVisibility
-									)
-{
-	errorVisibility   = _errorVisibility;
-	warningVisibility = _warningVisibility;
-	infoVisibility    = _infoVisibility;
-
-	outputFile = _outputFile;
-	errorCount = 0;
-}
-
-
-
-/*
- *	M e s s a g e H a n d l i n g
- */
-MessageHandling::MessageHandling( const MessageHandling& rhs )
-{
-	errorVisibility   = rhs.errorVisibility;
-	warningVisibility = rhs.warningVisibility;
-	infoVisibility    = rhs.infoVisibility;
-
-	outputFile = rhs.outputFile;
-	errorCount = rhs.errorCount;
-}
-
-
-/*
- *	~ M e s s a g e H a n d l i n g
- */
-MessageHandling::~MessageHandling( )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	if ( ( outputFile != 0 ) && ( outputFile != stdout ) && ( outputFile != stderr ) )
-		fclose( outputFile );
- 	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	o p e r a t o r =
- */
-MessageHandling& MessageHandling::operator=( const MessageHandling& rhs )
-{
-	if ( this != &rhs )
-	{
-		errorVisibility   = rhs.errorVisibility;
-		warningVisibility = rhs.warningVisibility;
-		infoVisibility    = rhs.infoVisibility;
-
-		outputFile = rhs.outputFile;
-		errorCount = rhs.errorCount;
-	}
-
-	return *this;
-}
-
-
-/*
- *	t h r o w E r r o r
- */
-returnValue MessageHandling::throwError(	returnValue Enumber,
-											const char* additionaltext,
-											const char* functionname,
-											const char* filename,
-											const unsigned long linenumber,
-											VisibilityStatus localVisibilityStatus
-											)
-{
-	/* consistency check */
-	if ( Enumber <= SUCCESSFUL_RETURN )
-		return throwError( RET_ERROR_UNDEFINED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-
-	/* Call to common throwMessage function if error shall be displayed. */
-	if ( errorVisibility == VS_VISIBLE )
-		return throwMessage( Enumber,additionaltext,functionname,filename,linenumber,localVisibilityStatus,"ERROR" );
-	else
-		return Enumber;
-}
-
-
-/*
- *	t h r o w W a r n i n g
- */
-returnValue MessageHandling::throwWarning(	returnValue Wnumber,
-											const char* additionaltext,
-											const char* functionname,
-											const char* filename,
-											const unsigned long linenumber,
-											VisibilityStatus localVisibilityStatus
-											)
-{
-	/* consistency check */
-  	if ( Wnumber <= SUCCESSFUL_RETURN )
-		return throwError( RET_WARNING_UNDEFINED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-
-	/* Call to common throwMessage function if warning shall be displayed. */
-	if ( warningVisibility == VS_VISIBLE )
-		return throwMessage( Wnumber,additionaltext,functionname,filename,linenumber,localVisibilityStatus,"WARNING" );
-  	else
-  		return Wnumber;
-}
-
-
-/*
- *	t h r o w I n f o
- */
-returnValue MessageHandling::throwInfo(	returnValue Inumber,
-										const char* additionaltext,
-										const char* functionname,
-										const char* filename,
-										const unsigned long linenumber,
-										VisibilityStatus localVisibilityStatus
-										)
-{
-	/* consistency check */
-	if ( Inumber < SUCCESSFUL_RETURN )
-		return throwError( RET_INFO_UNDEFINED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-
-	/* Call to common throwMessage function if info shall be displayed. */
-	if ( infoVisibility == VS_VISIBLE )
-		return throwMessage( Inumber,additionaltext,functionname,filename,linenumber,localVisibilityStatus,"INFO" );
-	else
-		return Inumber;
-}
-
-
-/*
- *	r e s e t
- */
-returnValue MessageHandling::reset( )
-{
-	setErrorVisibilityStatus(   VS_VISIBLE );
-	setWarningVisibilityStatus( VS_HIDDEN );
-	setInfoVisibilityStatus(    VS_HIDDEN );
-
-	setOutputFile( stdFile );
-	setErrorCount( 0 );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	l i s t A l l M e s s a g e s
- */
-returnValue MessageHandling::listAllMessages( )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	int_t keypos = 0;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Run through whole returnValueList and print each item. */
-	while ( returnValueList[keypos].key != TERMINAL_LIST_ELEMENT )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH," %d - %s \n",(int)keypos,returnValueList[keypos].data );
-		myPrintf( myPrintfString );
-
-		++keypos;
-	}
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-
-/*
- *	t h r o w M e s s a g e
- */
-returnValue MessageHandling::throwMessage(	returnValue RETnumber,
-											const char* additionaltext,
-											const char* functionname,
-											const char* filename,
-											const unsigned long linenumber,
-											VisibilityStatus localVisibilityStatus,
-											const char* RETstring
-											)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t keypos = 0;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* 1) Determine number of whitespace for output. */
-	char whitespaces[MAX_STRING_LENGTH];
-	int_t numberOfWhitespaces = (errorCount-1)*2;
-
-	if ( numberOfWhitespaces < 0 )
-		numberOfWhitespaces = 0;
-
-	if ( numberOfWhitespaces > 40 )
-		numberOfWhitespaces = 40;
-
-	if ( numberOfWhitespaces >= (int_t)MAX_STRING_LENGTH )
-		numberOfWhitespaces = (int_t)MAX_STRING_LENGTH-1;
-
-	memset( whitespaces, ' ', (size_t) numberOfWhitespaces );
-	whitespaces[numberOfWhitespaces] = '\0';
-
-	/* 2) Find error/warning/info in list. */
-	while ( returnValueList[keypos].key != TERMINAL_LIST_ELEMENT )
-	{
-		if ( returnValueList[keypos].key == RETnumber )
-			break;
-		else
-			++keypos;
-	}
-
-	if ( returnValueList[keypos].key == TERMINAL_LIST_ELEMENT )
-	{
-		throwError( RET_EWI_UNDEFINED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		return RETnumber;
-	}
-
-	/* 3) Print error/warning/info. */
-	if ( ( returnValueList[keypos].globalVisibilityStatus == VS_VISIBLE ) && ( localVisibilityStatus == VS_VISIBLE ) )
-	{
-		if ( errorCount < 0 )
-		{
-			myPrintf( "\n" );
-			errorCount = 0;
-		}
-
-		if ( errorCount > 0 )
-		{
-			snprintf( myPrintfString,MAX_STRING_LENGTH,"%s->", whitespaces );
-			myPrintf( myPrintfString );
-		}
-
-		if ( additionaltext == 0 )
-		{
-			#ifdef __DEBUG__
-			snprintf(	myPrintfString,MAX_STRING_LENGTH,"%s (%s, %s:%d): \t%s\n",
-						RETstring,functionname,filename,(int_t)linenumber,returnValueList[keypos].data
-						);
-			#else
-			snprintf(	myPrintfString,MAX_STRING_LENGTH,"%s:  %s\n",
-						RETstring,returnValueList[keypos].data
-						);
-			#endif
-			myPrintf( myPrintfString );
-		}
-		else
-		{
-			#ifdef __DEBUG__
-			snprintf(	myPrintfString,MAX_STRING_LENGTH,"%s (%s, %s:%d): \t%s %s\n",
-						RETstring,functionname,filename,(int_t)linenumber,returnValueList[keypos].data,additionaltext
-						);
-			#else
-			snprintf(	myPrintfString,MAX_STRING_LENGTH,"%s:  %s %s\n",
-						RETstring,returnValueList[keypos].data,additionaltext
-						);
-			#endif
-			myPrintf( myPrintfString );
-		}
-
-		/* take care of proper indention for subsequent error messages */
-		if ( RETstring[0] == 'E' )
-		{
-			++errorCount;
-		}
-		else
-		{
-			if ( errorCount > 0 )
-				myPrintf( "\n" );
-			errorCount = 0;
-		}
-	}
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return RETnumber;
-}
-
-/****************************************************************************/
-/* S T A T I C  P U B L I C */
-/****************************************************************************/
-
-const char* MessageHandling::getErrorCodeMessage(	const returnValue _returnValue
-													)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t keypos = 0;
-	
-	/* 2) Find error/warning/info in list. */
-	while ( returnValueList[keypos].key != TERMINAL_LIST_ELEMENT )
-	{
-		if ( returnValueList[keypos].key == _returnValue )
-			break;
-		else
-			++keypos;
-	}
-
-	if ( returnValueList[keypos].key == TERMINAL_LIST_ELEMENT )
-	{
-		return "Unknown error code";
-	}
-
-	return (returnValueList[keypos].data != 0) ? returnValueList[keypos].data : "No message for this error code";
-    
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return "No message for this error code";
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*****************************************************************************
- *  G L O B A L  M E S S A G E  H A N D L E R                                *
- *****************************************************************************/
-
-
-/** Global message handler for all qpOASES modules.*/
-#if defined(__DSPACE__) || defined(__XPCTARGET__)
-static MessageHandling globalMessageHandler( stdFile,VS_VISIBLE,VS_HIDDEN,VS_HIDDEN );
-#endif
-
-
-/*
- *	g e t G l o b a l M e s s a g e H a n d l e r
- */
-MessageHandling* getGlobalMessageHandler( )
-{
-	#ifndef __DSPACE__
-    #ifndef __XPCTARGET__
-	static MessageHandling globalMessageHandler( stdFile,VS_VISIBLE,VS_VISIBLE,VS_VISIBLE );
-	#endif /* __DSPACE__ */
-    #endif /* __XPCTARGET__ */
-
-	return &globalMessageHandler;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/OQPinterface.cpp b/extlibs/qpOASES-3.2.0/src/OQPinterface.cpp
deleted file mode 100644
index 861b59c..0000000
--- a/extlibs/qpOASES-3.2.0/src/OQPinterface.cpp
+++ /dev/null
@@ -1,683 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/OQPinterface.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Implementation of an interface comprising several utility functions
- *	for solving test problems from the Online QP Benchmark Collection
- *	(This collection is no longer maintained, see 
- *	http://www.qpOASES.org/onlineQP for a backup).
- *
- */
-
-
-#include <qpOASES/extras/OQPinterface.hpp>
-#include <qpOASES/QProblem.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*
- *	r e a d O q p D i m e n s i o n s
- */
-returnValue readOqpDimensions(	const char* path,
-								int_t& nQP, int_t& nV, int_t& nC, int_t& nEC
-								)
-{
-	/* 1) Setup file name where dimensions are stored. */
-	char filename[MAX_STRING_LENGTH];
-	snprintf( filename,MAX_STRING_LENGTH,"%sdims.oqp",path );
-
-	/* 2) Load dimensions from file. */
-	int_t dims[4];
-	if ( readFromFile( dims,4,filename ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-
-	nQP = dims[0];
-	nV  = dims[1];
-	nC  = dims[2];
-	nEC = dims[3];
-
-
-	/* consistency check */
-	if ( ( nQP <= 0 ) || ( nV <= 0 ) || ( nC < 0 ) || ( nEC < 0 ) )
-		return THROWERROR( RET_FILEDATA_INCONSISTENT );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e a d O q p D a t a
- */
-returnValue readOqpData(	const char* path,
-							int_t& nQP, int_t& nV, int_t& nC, int_t& nEC,
-							real_t** H, real_t** g, real_t** A, real_t** lb, real_t** ub, real_t** lbA, real_t** ubA,
-							real_t** xOpt, real_t** yOpt, real_t** objOpt
-							)
-{
-	char filename[MAX_STRING_LENGTH];
-
-	/* consistency check */
-	if ( ( H == 0 ) || ( g == 0 ) || ( lb == 0 ) || ( ub == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Obtain OQP dimensions. */
-	if ( readOqpDimensions( path, nQP,nV,nC,nEC ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-
-
-	/* another consistency check */
-	if ( ( nC > 0 ) && ( ( A == 0 ) || ( lbA == 0 ) || ( ubA == 0 ) ) )
-		return THROWERROR( RET_FILEDATA_INCONSISTENT );
-
-
-	/* 2) Allocate memory and load OQP data: */
-	/* Hessian matrix */
-	*H  = new real_t[nV*nV];
-	snprintf( filename,MAX_STRING_LENGTH,"%sH.oqp",path );
-	if ( readFromFile( *H,nV,nV,filename ) != SUCCESSFUL_RETURN )
-	{
-		delete[] *H;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	/* gradient vector sequence */
-	*g  = new real_t[nQP*nV];
-	snprintf( filename,MAX_STRING_LENGTH,"%sg.oqp",path );
-	if ( readFromFile( *g,nQP,nV,filename ) != SUCCESSFUL_RETURN )
-	{
-		delete[] *g; delete[] *H;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	/* lower bound vector sequence */
-	*lb  = new real_t[nQP*nV];
-	snprintf( filename,MAX_STRING_LENGTH,"%slb.oqp",path );
-	if ( readFromFile( *lb,nQP,nV,filename ) != SUCCESSFUL_RETURN )
-	{
-		delete[] *lb; delete[] *g; delete[] *H;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	/* upper bound vector sequence */
-	*ub  = new real_t[nQP*nV];
-	snprintf( filename,MAX_STRING_LENGTH,"%sub.oqp",path );
-	if ( readFromFile( *ub,nQP,nV,filename ) != SUCCESSFUL_RETURN )
-	{
-		delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	if ( nC > 0 )
-	{
-		/* Constraint matrix */
-		*A   = new real_t[nC*nV];
-		snprintf( filename,MAX_STRING_LENGTH,"%sA.oqp",path );
-		if ( readFromFile( *A,nC,nV,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] *A;
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-
-		/* lower constraints' bound vector sequence */
-		*lbA = new real_t[nQP*nC];
-		snprintf( filename,MAX_STRING_LENGTH,"%slbA.oqp",path );
-		if ( readFromFile( *lbA,nQP,nC,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] *lbA; delete[] *A;
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-
-		/* upper constraints' bound vector sequence */
-		*ubA = new real_t[nQP*nC];
-		snprintf( filename,MAX_STRING_LENGTH,"%subA.oqp",path );
-		if ( readFromFile( *ubA,nQP,nC,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] *ubA; delete[] *lbA; delete[] *A;
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-	}
-	else
-	{
-		*A = 0;
-		*lbA = 0;
-		*ubA = 0;
-	}
-
-	if ( xOpt != 0 )
-	{
-		/* primal solution vector sequence */
-		*xOpt = new real_t[nQP*nV];
-		snprintf( filename,MAX_STRING_LENGTH,"%sx_opt.oqp",path );
-		if ( readFromFile( *xOpt,nQP,nV,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] xOpt;
-			if ( nC > 0 ) { delete[] *ubA; delete[] *lbA; delete[] *A; };
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-	}
-
-	if ( yOpt != 0 )
-	{
-		/* dual solution vector sequence */
-		*yOpt = new real_t[nQP*(nV+nC)];
-		snprintf( filename,MAX_STRING_LENGTH,"%sy_opt.oqp",path );
-		if ( readFromFile( *yOpt,nQP,nV+nC,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] yOpt;
-			if ( xOpt != 0 ) { delete[] xOpt; };
-			if ( nC > 0 ) { delete[] *ubA; delete[] *lbA; delete[] *A; };
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-	}
-
-	if ( objOpt != 0 )
-	{
-		/* dual solution vector sequence */
-		*objOpt = new real_t[nQP];
-		snprintf( filename,MAX_STRING_LENGTH,"%sobj_opt.oqp",path );
-		if ( readFromFile( *objOpt,nQP,1,filename ) != SUCCESSFUL_RETURN )
-		{
-			delete[] objOpt;
-			if ( yOpt != 0 ) { delete[] yOpt; };
-			if ( xOpt != 0 ) { delete[] xOpt; };
-			if ( nC > 0 ) { delete[] *ubA; delete[] *lbA; delete[] *A; };
-			delete[] *ub; delete[] *lb; delete[] *g; delete[] *H;
-			return THROWERROR( RET_UNABLE_TO_READ_FILE );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s o l v e O q p B e n c h m a r k
- */
-returnValue solveOqpBenchmark(	int_t nQP, int_t nV, int_t nC, int_t nEC,
-								const real_t* const _H, const real_t* const g, const real_t* const _A,
-								const real_t* const lb, const real_t* const ub,
-								const real_t* const lbA, const real_t* const ubA,
-								BooleanType isSparse, 
-								const Options& options, int_t& nWSR, real_t& maxCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	real_t maxNWSR = 0.0;
-	real_t avgNWSR = 0.0;
-	real_t avgCPUtime = 0.0;
-
-	returnValue returnvalue = solveOqpBenchmark(	nQP,nV,nC,nEC,
-													_H,g,_A,lb,ub,lbA,ubA,
-													isSparse,BT_TRUE,
-													options,nWSR,
-													maxNWSR,avgNWSR,maxCPUtime,avgCPUtime, 
-													maxStationarity,maxFeasibility,maxComplementarity
-													);
-	nWSR = (int_t)maxNWSR;
-
-	return returnvalue;
-}
-
-
-
-/*
- *	s o l v e O q p B e n c h m a r k
- */
-returnValue solveOqpBenchmark(	int_t nQP, int_t nV, int_t nC, int_t nEC,
-								const real_t* const _H, const real_t* const g, const real_t* const _A,
-								const real_t* const lb, const real_t* const ub,
-								const real_t* const lbA, const real_t* const ubA,
-								BooleanType isSparse, BooleanType useHotstarts, 
-								const Options& options, int_t maxAllowedNWSR,
-								real_t& maxNWSR, real_t& avgNWSR, real_t& maxCPUtime, real_t& avgCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	int_t k;
-
-	/* I) SETUP AUXILIARY VARIABLES: */
-	/* 1) Keep nWSR and store current and maximum number of
-	 *    working set recalculations in temporary variables */
-	int_t nWSRcur;
-
-	real_t CPUtimeLimit = maxCPUtime;
-	real_t CPUtimeCur = CPUtimeLimit;
-	maxNWSR = 0.0;
-	avgNWSR = 0.0;
-	maxCPUtime = 0.0;
-	avgCPUtime = 0.0;
-	maxStationarity    = 0.0;
-	maxFeasibility     = 0.0;
-	maxComplementarity = 0.0;
-	real_t stat, feas, cmpl;
-
-	/* 2) Pointers to data of current QP ... */
-	const real_t* gCur;
-	const real_t* lbCur;
-	const real_t* ubCur;
-	const real_t* lbACur;
-	const real_t* ubACur;
-
-	/* 3) Vectors for solution obtained by qpOASES. */
-	real_t* x = new real_t[nV];
-	real_t* y = new real_t[nV+nC];
-	//real_t obj;
-
-	/* 4) Prepare matrix objects */
-	SymmetricMatrix *H; 
-	Matrix *A;
-
-	real_t* H_cpy = new real_t[nV*nV];
-	memcpy( H_cpy,_H, ((uint_t)(nV*nV))*sizeof(real_t) );
-	real_t* A_cpy = new real_t[nC*nV];
-	memcpy( A_cpy,_A, ((uint_t)(nC*nV))*sizeof(real_t) );
-
-	if ( isSparse == BT_TRUE )
-	{
-		SymSparseMat *Hs;
-		H = Hs = new SymSparseMat(nV, nV, nV, H_cpy);
-		A = new SparseMatrixRow(nC, nV, nV, A_cpy);
-		Hs->createDiagInfo();
-		delete[] A_cpy; delete[] H_cpy;
-	}
-	else
-	{
-		H = new SymDenseMat(nV, nV, nV, const_cast<real_t *>(H_cpy));
-		A = new DenseMatrix(nC, nV, nV, const_cast<real_t *>(A_cpy));
-	}
-
-	H->doFreeMemory( );
-	A->doFreeMemory( );
-
-	/* II) SETUP QPROBLEM OBJECT */
-	QProblem qp( nV,nC );
-	qp.setOptions( options );
-	//qp.setPrintLevel( PL_LOW );
-
-	//qp.printOptions();
-
-	/* III) RUN BENCHMARK SEQUENCE: */
-	returnValue returnvalue;
-
-	for( k=0; k<nQP; ++k )
-	{
-		//if ( k%50 == 0 )
-		//	printf( "%d\n",k );
-
-		/* 1) Update pointers to current QP data. */
-		gCur   = &( g[k*nV] );
-		lbCur  = &( lb[k*nV] );
-		ubCur  = &( ub[k*nV] );
-		lbACur = &( lbA[k*nC] );
-		ubACur = &( ubA[k*nC] );
-
-		/* 2) Set nWSR and maximum CPU time. */
-		nWSRcur = maxAllowedNWSR;
-		CPUtimeCur = CPUtimeLimit;
-
-		/* 3) Solve current QP. */
-		if ( ( k == 0 ) || ( useHotstarts == BT_FALSE ) )
-		{
-			/* initialise */
-			returnvalue = qp.init( H,gCur,A,lbCur,ubCur,lbACur,ubACur, nWSRcur,&CPUtimeCur );
-			if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-			{
-				delete A; delete H; delete[] y; delete[] x;
-				return THROWERROR( returnvalue );
-			}
-		}
-		else
-		{
-			/* hotstart */
-			returnvalue = qp.hotstart( gCur,lbCur,ubCur,lbACur,ubACur, nWSRcur,&CPUtimeCur );
-			if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-			{
-				delete A; delete H; delete[] y; delete[] x;
-				return THROWERROR( returnvalue );
-			}
-		}
-
-		/* 4) Obtain solution vectors and objective function value */
-		qp.getPrimalSolution( x );
-		qp.getDualSolution( y );
-		//obj = qp.getObjVal( );
-
-		/* 5) Compute KKT residuals */
-		getKktViolation( nV,nC, _H,gCur,_A,lbCur,ubCur,lbACur,ubACur, x,y, stat,feas,cmpl );
-		
-		/* 6) Update maximum and average values. */
-		if ( ((double)nWSRcur) > maxNWSR )
-			maxNWSR = ((double)nWSRcur);
-		if (stat > maxStationarity) maxStationarity = stat;
-		if (feas > maxFeasibility) maxFeasibility = feas;
-		if (cmpl > maxComplementarity) maxComplementarity = cmpl;
-
-		if ( CPUtimeCur > maxCPUtime )
-			maxCPUtime = CPUtimeCur;
-
-		avgNWSR += ((double)nWSRcur);
-		avgCPUtime += CPUtimeCur;
-	}
-	avgNWSR /= ((double)nQP);
-	avgCPUtime /= ((double)nQP);
-
-	delete A; delete H; delete[] y; delete[] x;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s o l v e O q p B e n c h m a r k
- */
-returnValue solveOqpBenchmark(	int_t nQP, int_t nV,
-								const real_t* const _H, const real_t* const g,
-								const real_t* const lb, const real_t* const ub,
-								BooleanType isSparse, 
-								const Options& options, int_t& nWSR, real_t& maxCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	real_t maxNWSR = 0.0;
-	real_t avgNWSR = 0.0;
-	real_t avgCPUtime = 0.0;
-
-	returnValue returnvalue = solveOqpBenchmark(	nQP,nV,
-													_H,g,lb,ub,
-													isSparse,BT_TRUE,
-													options,nWSR,
-													maxNWSR,avgNWSR,maxCPUtime,avgCPUtime, 
-													maxStationarity,maxFeasibility,maxComplementarity
-													);
-	nWSR = (int_t)maxNWSR;
-
-	return returnvalue;
-}
-
-
-/*
- *	s o l v e O q p B e n c h m a r k
- */
-returnValue solveOqpBenchmark(	int_t nQP, int_t nV,
-								const real_t* const _H, const real_t* const g,
-								const real_t* const lb, const real_t* const ub,
-								BooleanType isSparse, BooleanType useHotstarts, 
-								const Options& options, int_t maxAllowedNWSR,
-								real_t& maxNWSR, real_t& avgNWSR, real_t& maxCPUtime, real_t& avgCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	int_t k;
-
-	/* I) SETUP AUXILIARY VARIABLES: */
-	/* 1) Keep nWSR and store current and maximum number of
-	 *    working set recalculations in temporary variables */
-	int_t nWSRcur;
-
-	real_t CPUtimeLimit = maxCPUtime;
-	real_t CPUtimeCur = CPUtimeLimit;
-	real_t stat, feas, cmpl;
-	maxNWSR = 0;
-	avgNWSR = 0;
-	maxCPUtime = 0.0;
-	avgCPUtime = 0.0;
-	maxStationarity = 0.0;
-	maxFeasibility = 0.0;
-	maxComplementarity = 0.0;
-
-	/* 2) Pointers to data of current QP ... */
-	const real_t* gCur;
-	const real_t* lbCur;
-	const real_t* ubCur;
-
-	/* 3) Vectors for solution obtained by qpOASES. */
-	real_t* x = new real_t[nV];
-	real_t* y = new real_t[nV];
-	//real_t  obj;
-
-	/* 4) Prepare matrix objects */
-	SymmetricMatrix *H; 
-	real_t* H_cpy = new real_t[nV*nV];
-	memcpy( H_cpy,_H, ((uint_t)(nV*nV))*sizeof(real_t) );
-
-	if ( isSparse == BT_TRUE )
-	{
-		SymSparseMat *Hs;
-		H = Hs = new SymSparseMat(nV, nV, nV, H_cpy);
-		Hs->createDiagInfo();
-		delete[] H_cpy;
-	}
-	else
-	{
-		H = new SymDenseMat(nV, nV, nV, const_cast<real_t *>(H_cpy));
-	}
-	
-	H->doFreeMemory( );
-
-	/* II) SETUP QPROBLEM OBJECT */
-	QProblemB qp( nV );
-	qp.setOptions( options );
-	//qp.setPrintLevel( PL_LOW );
-
-
-	/* III) RUN BENCHMARK SEQUENCE: */
-	returnValue returnvalue;
-
-	for( k=0; k<nQP; ++k )
-	{
-		//if ( k%50 == 0 )
-		//	printf( "%d\n",k );
-
-		/* 1) Update pointers to current QP data. */
-		gCur   = &( g[k*nV] );
-		lbCur  = &( lb[k*nV] );
-		ubCur  = &( ub[k*nV] );
-
-		/* 2) Set nWSR and maximum CPU time. */
-		nWSRcur = maxAllowedNWSR;
-		CPUtimeCur = CPUtimeLimit;
-
-		/* 3) Solve current QP. */
-		if ( ( k == 0 ) || ( useHotstarts == BT_FALSE ) )
-		{
-			/* initialise */
-			returnvalue = qp.init( H,gCur,lbCur,ubCur, nWSRcur,&CPUtimeCur );
-			if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-			{
-				delete H; delete[] y; delete[] x;
-				return THROWERROR( returnvalue );
-			}
-		}
-		else
-		{
-			/* hotstart */
-			returnvalue = qp.hotstart( gCur,lbCur,ubCur, nWSRcur,&CPUtimeCur );
-			if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-			{
-				delete H; delete[] y; delete[] x;
-				return THROWERROR( returnvalue );
-			}
-		}
-
-		/* 4) Obtain solution vectors and objective function value ... */
-		qp.getPrimalSolution( x );
-		qp.getDualSolution( y );
-		//obj = qp.getObjVal( );
-
-		/* 5) Compute KKT residuals */
-		getKktViolation( nV, _H,gCur,lbCur,ubCur, x,y, stat,feas,cmpl );
-
-		/* 6) update maximum values. */
-		if ( nWSRcur > maxNWSR )
-			maxNWSR = nWSRcur;
-		if (stat > maxStationarity) maxStationarity = stat;
-		if (feas > maxFeasibility) maxFeasibility = feas;
-		if (cmpl > maxComplementarity) maxComplementarity = cmpl;
-
-		if ( CPUtimeCur > maxCPUtime )
-			maxCPUtime = CPUtimeCur;
-
-		avgNWSR += nWSRcur;
-		avgCPUtime += CPUtimeCur;
-	}
-	avgNWSR /= nQP;
-	avgCPUtime /= ((double)nQP);
-
-	delete H; delete[] y; delete[] x;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r u n O q p B e n c h m a r k
- */
-returnValue runOqpBenchmark(	const char* path, BooleanType isSparse, const Options& options,
-								int_t& nWSR, real_t& maxCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	real_t maxNWSR = 0.0;
-	real_t avgNWSR = 0.0;
-	real_t avgCPUtime = 0.0;
-
-	returnValue returnvalue = runOqpBenchmark(	path,isSparse,BT_TRUE,
-												options,nWSR,
-												maxNWSR,avgNWSR,maxCPUtime,avgCPUtime, 
-												maxStationarity,maxFeasibility,maxComplementarity
-												);
-	nWSR = (int_t)maxNWSR;
-
-	return returnvalue;
-}
-
-
-/*
- *	r u n O q p B e n c h m a r k
- */
-returnValue runOqpBenchmark(	const char* path, BooleanType isSparse, BooleanType useHotstarts, 
-								const Options& options, int_t maxAllowedNWSR,
-								real_t& maxNWSR, real_t& avgNWSR, real_t& maxCPUtime, real_t& avgCPUtime,
-								real_t& maxStationarity, real_t& maxFeasibility, real_t& maxComplementarity
-								)
-{
-	int_t nQP=0, nV=0, nC=0, nEC=0;
-
-	real_t *H=0, *g=0, *A=0, *lb=0, *ub=0, *lbA=0, *ubA=0;
-
-
-	returnValue returnvalue;
-
-	/* I) SETUP BENCHMARK: */
-	/* 1) Obtain QP sequence dimensions. */
-	if ( readOqpDimensions( path, nQP,nV,nC,nEC ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_BENCHMARK_ABORTED );
-
-	/* 2) Read OQP benchmark data. */
-	if ( readOqpData(	path,
-						nQP,nV,nC,nEC,
-						&H,&g,&A,&lb,&ub,&lbA,&ubA,
-						0,0,0
-						) != SUCCESSFUL_RETURN )
-	{
-		return THROWERROR( RET_UNABLE_TO_READ_BENCHMARK );
-	}
-
-	// normaliseConstraints( nV,nC,A,lbA,ubA ); //only works when nP==1
-
-	/* II) SOLVE BENCHMARK */
-	if ( nC > 0 )
-	{
-		returnvalue = solveOqpBenchmark(	nQP,nV,nC,nEC,
-											H,g,A,lb,ub,lbA,ubA,
-											isSparse,useHotstarts,
-											options,maxAllowedNWSR,
-											maxNWSR,avgNWSR,maxCPUtime,avgCPUtime,
-											maxStationarity,maxFeasibility,maxComplementarity
-											);
-
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			if ( H != 0 )   delete[] H;
-			if ( g != 0 )   delete[] g;
-			if ( A != 0 )   delete[] A;
-			if ( lb != 0 )  delete[] lb;
-			if ( ub != 0 )  delete[] ub;
-			if ( lbA != 0 ) delete[] lbA;
-			if ( ubA != 0 ) delete[] ubA;
-			return THROWERROR( returnvalue );
-		}
-	}
-	else
-	{
-		returnvalue = solveOqpBenchmark(	nQP,nV,
-											H,g,lb,ub,
-											isSparse,useHotstarts,
-											options,maxAllowedNWSR,
-											maxNWSR,avgNWSR,maxCPUtime,avgCPUtime,
-											maxStationarity,maxFeasibility,maxComplementarity
-											);
-
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			if ( H != 0 )   delete[] H;
-			if ( g != 0 )   delete[] g;
-			if ( A != 0 )   delete[] A;
-			if ( lb != 0 )  delete[] lb;
-			if ( ub != 0 )  delete[] ub;
-			return THROWERROR( returnvalue );
-		}
-	}
-
-	if ( H != 0 )   delete[] H;
-	if ( g != 0 )   delete[] g;
-	if ( A != 0 )   delete[] A;
-	if ( lb != 0 )  delete[] lb;
-	if ( ub != 0 )  delete[] ub;
-	if ( lbA != 0 ) delete[] lbA;
-	if ( ubA != 0 ) delete[] ubA;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/Options.cpp b/extlibs/qpOASES-3.2.0/src/Options.cpp
deleted file mode 100644
index cde9f37..0000000
--- a/extlibs/qpOASES-3.2.0/src/Options.cpp
+++ /dev/null
@@ -1,563 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Options.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the Options class designed to manage working sets of
- *	constraints and bounds within a QProblem.
- */
-
-
-#include <qpOASES/Options.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	O p t i o n s
- */
-Options::Options( )
-{
-	setToDefault( );
-}
-
-
-/*
- *	O p t i o n s
- */
-Options::Options( const Options& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ O p t i o n s
- */
-Options::~Options( )
-{
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Options& Options::operator=( const Options& rhs )
-{
-	if ( this != &rhs )
-	{
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-
-/*
- *	s e t T o D e f a u l t
- */
-returnValue Options::setToDefault( )
-{
-	printLevel = PL_MEDIUM;
-	#ifdef __DEBUG__
-	printLevel = PL_HIGH;
-	#endif
-	#ifdef __SUPPRESSANYOUTPUT__
-	printLevel = PL_NONE;
-	#endif
-
-	enableRamping                 =  BT_TRUE;
-	enableFarBounds               =  BT_TRUE;
-	enableFlippingBounds          =  BT_TRUE;
-	enableRegularisation          =  BT_FALSE;
-	enableFullLITests             =  BT_FALSE;
-	enableNZCTests                =  BT_TRUE;
-	enableDriftCorrection         =  1;
-	enableCholeskyRefactorisation =  0;
-	enableEqualities              =  BT_FALSE;
-
-	#ifdef __USE_SINGLE_PRECISION__
-	terminationTolerance          =  1.0e2 * EPS;
-	boundTolerance                =  1.0e2 * EPS;
-	#else
-	terminationTolerance          =  5.0e6 * EPS;
-	boundTolerance                =  1.0e6 * EPS;
-	#endif
-	boundRelaxation               =  1.0e4;
-	#ifdef __USE_SINGLE_PRECISION__
-	epsNum                        = -1.0e2 * EPS;
-	epsDen                        =  1.0e2 * EPS;
-	#else
-	epsNum                        = -1.0e3 * EPS;
-	epsDen                        =  1.0e3 * EPS;
-	#endif
-	maxPrimalJump                 =  1.0e8;
-	maxDualJump                   =  1.0e8;
-
-	initialRamping                =  0.5;
-	finalRamping                  =  1.0;
-	initialFarBounds              =  1.0e6;
-	growFarBounds                 =  1.0e3;
- 	initialStatusBounds           =  ST_LOWER;
-	#ifdef __USE_SINGLE_PRECISION__
-	epsFlipping                   =  5.0e1 * EPS;
-	#else
-	epsFlipping                   =  1.0e3 * EPS;
-	#endif
-	numRegularisationSteps        =  0;
-	#ifdef __USE_SINGLE_PRECISION__
-	epsRegularisation             =  2.0e1 * EPS;
-	numRefinementSteps            =  2;
-	#else
-	epsRegularisation             =  1.0e3 * EPS;
-	numRefinementSteps            =  1;
-	#endif
-	epsIterRef                    =  1.0e2 * EPS;
-	#ifdef __USE_SINGLE_PRECISION__
-	epsLITests                    =  5.0e1 * EPS;
-	epsNZCTests                   =  1.0e2 * EPS;
-	#else
-	epsLITests                    =  1.0e5 * EPS;
-	epsNZCTests                   =  3.0e3 * EPS;
-	#endif
-
-	enableDropInfeasibles         =  BT_FALSE;
-    dropBoundPriority             =  1;
-    dropEqConPriority             =  1;
-    dropIneqConPriority           =  1;
-
-    enableInertiaCorrection       =  BT_TRUE;
-    rcondSMin                     =  1.0e-14;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t T o R e l i a b l e
- */
-returnValue Options::setToReliable( )
-{
-	setToDefault( );
-
-	enableFullLITests             =  BT_TRUE;
-	enableCholeskyRefactorisation =  1;
-
-	#ifdef __USE_SINGLE_PRECISION__
-	numRefinementSteps            =  3;
-	#else
-	numRefinementSteps            =  2;
-	#endif
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t T o M P C
- */
-returnValue Options::setToMPC( )
-{
-	setToDefault( );
-
-	enableRamping                 =  BT_FALSE;
-	enableFarBounds               =  BT_TRUE;
-	enableFlippingBounds          =  BT_FALSE;
-	enableRegularisation          =  BT_TRUE;
-	enableNZCTests                =  BT_FALSE;
-	enableDriftCorrection         =  0;
-	enableEqualities              =  BT_TRUE;
-
-	#ifdef __USE_SINGLE_PRECISION__
-	terminationTolerance          =  1.0e3 * EPS;
-	#else
-	terminationTolerance          =  1.0e9 * EPS;
-	#endif
-
-	initialStatusBounds           =  ST_INACTIVE;
-	numRegularisationSteps        =  1;
-	#ifdef __USE_SINGLE_PRECISION__
-	numRefinementSteps            =  2;
-	#else
-	numRefinementSteps            =  0;
-	#endif
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t T o F a s t
- */
-returnValue Options::setToFast( )
-{
-	return setToMPC( );
-}
-
-
-
-/*
- *	e n s u r e C o n s i s t e n c y
- */
-returnValue Options::ensureConsistency( )
-{
-	BooleanType needToAdjust = BT_FALSE;
-
-	/* flipping bounds require far bounds */
-    /* (ckirches) Removed this as per filter's trust region
-	if( enableFlippingBounds == BT_TRUE )
-		enableFarBounds = BT_TRUE;
-    */
-
-	if( enableDriftCorrection < 0 )
-	{
-		enableDriftCorrection = 0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if( enableCholeskyRefactorisation < 0 )
-	{
-		enableCholeskyRefactorisation = 0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( terminationTolerance <= 0.0 )
-	{
-		terminationTolerance = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsIterRef <= 0.0 )
-	{
-		epsIterRef = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsRegularisation <= 0.0 )
-	{
-		epsRegularisation = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( boundTolerance <= 0.0 )
-	{
-		boundTolerance = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( boundRelaxation <= 0.0 )
-	{
-		boundRelaxation = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( maxPrimalJump <= 0.0 )
-	{
-		maxPrimalJump = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( maxDualJump <= 0.0 )
-	{
-		maxDualJump = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-
-	if ( initialRamping < 0.0 )
-	{
-		initialRamping = 0.0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( finalRamping < 0.0 )
-	{
-		finalRamping = 0.0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( initialFarBounds <= boundRelaxation )
-	{
-		initialFarBounds = boundRelaxation+EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( growFarBounds < 1.1 )
-	{
-		growFarBounds = 1.1;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsFlipping <= 0.0 )
-	{
-		epsFlipping = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( numRegularisationSteps < 0 )
-	{
-		numRegularisationSteps = 0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsRegularisation < 0.0 )
-	{
-		epsRegularisation = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( numRefinementSteps < 0 )
-	{
-		numRefinementSteps = 0;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsIterRef < 0.0 )
-	{
-		epsIterRef = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsLITests < 0.0 )
-	{
-		epsLITests = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( epsNZCTests < 0.0 )
-	{
-		epsNZCTests = EPS;
-		needToAdjust = BT_TRUE;
-	}
-
-	if ( needToAdjust == BT_TRUE)
-		return THROWWARNING( RET_OPTIONS_ADJUSTED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue Options::print( ) const
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	char myPrintfString[MAX_STRING_LENGTH];
-	char info[MAX_STRING_LENGTH];
-
-	myPrintf( "\n###################   qpOASES  --  QP OPTIONS   ##################\n" );
-	myPrintf( "\n" );
-
-	convertPrintLevelToString( printLevel,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"printLevel                     =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	myPrintf( "\n" );
-
-	convertBooleanTypeToString( enableRamping,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableRamping                  =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableFarBounds,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableFarBounds                =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableFlippingBounds,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableFlippingBounds           =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableRegularisation,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableRegularisation           =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableFullLITests,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableFullLITests              =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableNZCTests,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableNZCTests                 =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableDriftCorrection          =  %d\n",(int)enableDriftCorrection );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableCholeskyRefactorisation  =  %d\n",(int)enableCholeskyRefactorisation );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableEqualities,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableEqualities               =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	convertBooleanTypeToString( enableInertiaCorrection,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"enableInertiaCorrection        =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"rcondSMin                      =  %e\n",rcondSMin );
-	myPrintf( myPrintfString );
-
-	myPrintf( "\n" );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"terminationTolerance           =  %e\n",terminationTolerance );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"boundTolerance                 =  %e\n",boundTolerance );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"boundRelaxation                =  %e\n",boundRelaxation );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsNum                         =  %e\n",epsNum );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsDen                         =  %e\n",epsDen );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"maxPrimalJump                  =  %e\n",maxPrimalJump );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"maxDualJump                    =  %e\n",maxDualJump );
-	myPrintf( myPrintfString );
-
-	myPrintf( "\n" );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"initialRamping                 =  %e\n",initialRamping );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"finalRamping                   =  %e\n",finalRamping );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"initialFarBounds               =  %e\n",initialFarBounds );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"growFarBounds                  =  %e\n",growFarBounds );
-	myPrintf( myPrintfString );
-
-	convertSubjectToStatusToString( initialStatusBounds,info );
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"initialStatusBounds            =  %s\n",info );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsFlipping                    =  %e\n",epsFlipping );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"numRegularisationSteps         =  %d\n",(int)numRegularisationSteps );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsRegularisation              =  %e\n",epsRegularisation );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"numRefinementSteps             =  %d\n",(int)numRefinementSteps );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsIterRef                     =  %e\n",epsIterRef );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsLITests                     =  %e\n",epsLITests );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,"epsNZCTests                    =  %e\n",epsNZCTests );
-	myPrintf( myPrintfString );
-
-	myPrintf( "\n\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c o p y
- */
-returnValue Options::copy(	const Options& rhs
-							)
-{
-	printLevel             = rhs.printLevel;
-
-	enableRamping                 =  rhs.enableRamping;
-	enableFarBounds               =  rhs.enableFarBounds;
-	enableFlippingBounds          =  rhs.enableFlippingBounds;
-	enableRegularisation          =  rhs.enableRegularisation;
-	enableFullLITests             =  rhs.enableFullLITests;
-	enableNZCTests                =  rhs.enableNZCTests;
-	enableDriftCorrection         =  rhs.enableDriftCorrection;
-	enableCholeskyRefactorisation =  rhs.enableCholeskyRefactorisation;
-	enableEqualities              =  rhs.enableEqualities;
-
-	terminationTolerance          =  rhs.terminationTolerance;
-	boundTolerance                =  rhs.boundTolerance;
-	boundRelaxation               =  rhs.boundRelaxation;
-	epsNum                        =  rhs.epsNum;
-	epsDen                        =  rhs.epsDen;
-	maxPrimalJump                 =  rhs.maxPrimalJump;
-	maxDualJump                   =  rhs.maxDualJump;
-
-	initialRamping                =  rhs.initialRamping;
-	finalRamping                  =  rhs.finalRamping;
-	initialFarBounds              =  rhs.initialFarBounds;
-	growFarBounds                 =  rhs.growFarBounds;
- 	initialStatusBounds           =  rhs.initialStatusBounds;
-	epsFlipping                   =  rhs.epsFlipping;
-	numRegularisationSteps        =  rhs.numRegularisationSteps;
-	epsRegularisation             =  rhs.epsRegularisation;
-	numRefinementSteps            =  rhs.numRefinementSteps;
-	epsIterRef                    =  rhs.epsIterRef;
-	epsLITests                    =  rhs.epsLITests;
-	epsNZCTests                   =  rhs.epsNZCTests;
-
-	enableInertiaCorrection       =  rhs.enableInertiaCorrection;
-	rcondSMin                     =  rhs.rcondSMin;
-
-	enableDropInfeasibles         =  rhs.enableDropInfeasibles;
-    dropBoundPriority             =  rhs.dropBoundPriority;
-    dropEqConPriority             =  rhs.dropEqConPriority;
-    dropIneqConPriority           =  rhs.dropIneqConPriority;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/QProblem.cpp b/extlibs/qpOASES-3.2.0/src/QProblem.cpp
deleted file mode 100644
index a8f199a..0000000
--- a/extlibs/qpOASES-3.2.0/src/QProblem.cpp
+++ /dev/null
@@ -1,6433 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/QProblem.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the QProblem class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming.
- */
-
-
-#include <qpOASES/QProblem.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	Q P r o b l e m
- */
-QProblem::QProblem( ) : QProblemB( )
-{
-	freeConstraintMatrix = BT_FALSE;
-	A = 0;
-
-	lbA = 0;
-	ubA = 0;
-
-	sizeT = 0;
-	T = 0;
-	Q = 0;
-
-	Ax = 0;
-	Ax_l = 0;
-	Ax_u = 0;
-
-	constraintProduct = 0;
-
-	tempA = 0;
-	ZFR_delta_xFRz = 0;
-	delta_xFRy = 0;
-	delta_xFRz = 0;
-	tempB = 0;
-	delta_yAC_TMP = 0;
-}
-
-
-/*
- *	Q P r o b l e m
- */
-QProblem::QProblem( int_t _nV, int_t _nC, HessianType _hessianType ) : QProblemB( _nV,_hessianType )
-{
-	int_t i;
-
-	/* consistency checks */
-	if ( _nV <= 0 )
-	{
-		_nV = 1;
-		THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( _nC < 0 )
-	{
-		_nC = 0;
-		THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( _nC > 0 )
-	{
-		freeConstraintMatrix = BT_FALSE;
-		A = 0;
-
-		lbA = new real_t[_nC];
-		for( i=0; i<_nC; ++i ) lbA[i] = 0.0;
-
-		ubA = new real_t[_nC];
-		for( i=0; i<_nC; ++i ) ubA[i] = 0.0;
-	}
-	else
-	{
-		/* prevent segmentation faults in case nC == 0
-		 * (avoiding checks for A!=0 around all calls to A->... */
-		freeConstraintMatrix = BT_TRUE;
-		A = new DenseMatrix( );
-
-		lbA = 0;
-		ubA = 0;
-	}
-
-	constraints.init( _nC );
-
-	delete[] y; /* y of no constraints version too short! */
-	y = new real_t[_nV+_nC];
-	for( i=0; i<_nV+_nC; ++i ) y[i] = 0.0;
-
-	sizeT = getMin( _nV,_nC );
-	T = new real_t[sizeT*sizeT];
-	Q = new real_t[_nV*_nV];
-
-	if ( _nC > 0 )
-	{
-		Ax = new real_t[_nC];
-		Ax_l = new real_t[_nC];
-		Ax_u = new real_t[_nC];
-	}
-	else
-	{
-		Ax = 0;
-		Ax_l = 0;
-		Ax_u = 0;
-	}
-
-	constraintProduct = 0;
-
-	tempA = new real_t[_nV];			/* nFR */
-	ZFR_delta_xFRz = new real_t[_nV];	/* nFR */
-	delta_xFRz = new real_t[_nV];		/* nZ */
-
-	if ( _nC > 0 )
-	{
-		tempB = new real_t[_nC];			/* nAC */
-		delta_xFRy = new real_t[_nC];		/* nAC */
-		delta_yAC_TMP = new real_t[_nC];   /* nAC */
-	}
-	else
-	{
-		tempB = 0;
-		delta_xFRy = 0;
-		delta_yAC_TMP = 0;
-	}
-
-	flipper.init( (uint_t)_nV,(uint_t)_nC );
-}
-
-
-/*
- *	Q P r o b l e m
- */
-QProblem::QProblem( const QProblem& rhs ) : QProblemB( rhs )
-{
-	freeConstraintMatrix = BT_FALSE;
-	A = 0;
-
-	copy( rhs );
-}
-
-
-/*
- *	~ Q P r o b l e m
- */
-QProblem::~QProblem( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-QProblem& QProblem::operator=( const QProblem& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		QProblemB::operator=( rhs );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-/*
- *	r e s e t
- */
-returnValue QProblem::reset( )
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-
-	/* 1) Reset bounds, Cholesky decomposition and status flags. */
-	if ( QProblemB::reset( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_RESET_FAILED );
-
-	/* 2) Reset constraints. */
-	constraints.init( nC );
-
-	/* 3) Reset TQ factorisation. */
-	if ( T!=0 )
-		for( i=0; i<sizeT*sizeT; ++i )
-			T[i] = 0.0;
-
-	if ( Q!=0 )
-		for( i=0; i<nV*nV; ++i )
-			Q[i] = 0.0;
-
-	/* 4) Reset constraint product pointer. */
-	constraintProduct = 0;
-
-	/* 5) Reset flipper object */
-	flipper.init( (uint_t)nV,(uint_t)nC );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblem::init(	SymmetricMatrix *_H, const real_t* const _g, Matrix *_A,
-							const real_t* const _lb, const real_t* const _ub,
-							const real_t* const _lbA, const real_t* const _ubA,
-							int_t& nWSR, real_t* const cputime,
-							const real_t* const xOpt, const real_t* const yOpt,
-							const Bounds* const guessedBounds, const Constraints* const guessedConstraints,
-							const real_t* const _R
-							)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	if ( guessedConstraints != 0 )
-	{
-		for( i=0; i<nC; ++i )
-			if ( guessedConstraints->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* exclude these possibilities in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( _R != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data. */
-	if ( setupQPdata( _H,_g,_A,_lb,_ub,_lbA,_ubA ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* 3) Call to main initialisation routine. */
-	return solveInitialQP( xOpt,yOpt,guessedBounds,guessedConstraints,_R, nWSR,cputime );
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblem::init(	const real_t* const _H, const real_t* const _g, const real_t* const _A,
-							const real_t* const _lb, const real_t* const _ub,
-							const real_t* const _lbA, const real_t* const _ubA,
-							int_t& nWSR, real_t* const cputime,
-							const real_t* const xOpt, const real_t* const yOpt,
-							const Bounds* const guessedBounds, const Constraints* const guessedConstraints,
-							const real_t* const _R
-							)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	if ( guessedConstraints != 0 )
-	{
-		for( i=0; i<nC; ++i )
-			if ( guessedConstraints->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* exclude these possibilities in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( _R != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data. */
-	if ( setupQPdata( _H,_g,_A,_lb,_ub,_lbA,_ubA ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 3) Call to main initialisation routine. */
-	return solveInitialQP( xOpt,yOpt,guessedBounds,guessedConstraints,_R, nWSR,cputime );
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblem::init(	const char* const H_file, const char* const g_file, const char* const A_file,
-							const char* const lb_file, const char* const ub_file,
-							const char* const lbA_file, const char* const ubA_file,
-							int_t& nWSR, real_t* const cputime,
-							const real_t* const xOpt, const real_t* const yOpt,
-							const Bounds* const guessedBounds, const Constraints* const guessedConstraints,
-							const char* const R_file
-							)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	if ( guessedConstraints != 0 )
-	{
-		for( i=0; i<nC; ++i )
-			if ( guessedConstraints->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* exclude these possibilities in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( R_file != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data from files. */
-	if ( setupQPdataFromFile( H_file,g_file,A_file,lb_file,ub_file,lbA_file,ubA_file ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-
-	if ( R_file == 0 )
-	{
-		/* 3) Call to main initialisation routine. */
-		return solveInitialQP( xOpt,yOpt,guessedBounds,guessedConstraints,0, nWSR,cputime );
-	}
-	else
-	{
-		/* Also read Cholesky factor from file and store it directly into R [thus... */
-		returnValue returnvalue = readFromFile( R, nV,nV, R_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-			return THROWWARNING( returnvalue );
-
-		/* 3) Call to main initialisation routine. ...passing R here!] */
-		return solveInitialQP( xOpt,yOpt,guessedBounds,guessedConstraints,R, nWSR,cputime );
-	}
-}
-
-
-
-/*
- *	h o t s t a r t
- */
-returnValue QProblem::hotstart(	const real_t* const g_new,
-								const real_t* const lb_new, const real_t* const ub_new,
-								const real_t* const lbA_new, const real_t* const ubA_new,
-								int_t& nWSR, real_t* const cputime,
-								const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-								)
-{
-	int_t i, nActiveFar;
-	int_t nV = getNV ();
-	int_t nC = getNC ();
-	real_t starttime = 0.0;
-	real_t auxTime = 0.0;
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-
-	/* Possibly update working sets according to guesses for working sets of bounds and constraints. */
-	if ( ( guessedBounds != 0 ) || ( guessedConstraints != 0 ) )
-	{
-		if ( cputime != 0 )
-			starttime = getCPUtime( );
-
-		const Bounds*      actualGuessedBounds      = ( guessedBounds != 0 )      ? guessedBounds      : &bounds;
-		const Constraints* actualGuessedConstraints = ( guessedConstraints != 0 ) ? guessedConstraints : &constraints;
-
-		if ( setupAuxiliaryQP( actualGuessedBounds,actualGuessedConstraints ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		status = QPS_AUXILIARYQPSOLVED;
-
-		/* Allow only remaining CPU time for usual hotstart. */
-		if ( cputime != 0 )
-		{
-			auxTime = getCPUtime( ) - starttime;
-			*cputime -= auxTime;
-		}
-	}
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	/* Simple check for consistency of bounds and constraints. */
-	if ( areBoundsConsistent(lb_new, ub_new, lbA_new, ubA_new) != SUCCESSFUL_RETURN )
-		return setInfeasibilityFlag(returnvalue,BT_TRUE);
-
-	++count;
-
-	int_t nWSR_max = nWSR;
-	int_t nWSR_performed = 0;
-
-	real_t cputime_remaining = INFTY, *pcputime_rem;
-	real_t cputime_needed = 0.0;
-
-	real_t farbound = options.initialFarBounds;
-
-	/* writeQpDataIntoMatFile( "qpData.mat" ); */
-	/* writeQpWorkspaceIntoMatFile( "qpWorkspace.mat" ); */
-
-	if ( haveCholesky == BT_FALSE )
-	{
-		returnvalue = setupInitialCholesky( );
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return THROWERROR(returnvalue);
-	}
-
-	BooleanType isFirstCall = BT_TRUE;
-
-	if ( options.enableFarBounds == BT_FALSE )
-	{
-		/* Automatically call standard solveQP if regularisation is not active. */
-		returnvalue = solveRegularisedQP(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-											nWSR,cputime,0,
-											isFirstCall
-											);
-	}
-	else
-	{
-		real_t *ub_new_far = new real_t[nV];
-		real_t *lb_new_far = new real_t[nV];
-		real_t *ubA_new_far = new real_t[nC];
-		real_t *lbA_new_far = new real_t[nC];
-
-		/* possibly extend initial far bounds to largest bound/constraint data */
-		if (ub_new)
-			for (i = 0; i < nV; i++)
-				if ((ub_new[i] < INFTY) && (ub_new[i] > farbound)) farbound = ub_new[i];
-		if (lb_new)
-			for (i = 0; i < nV; i++)
-				if ((lb_new[i] > -INFTY) && (lb_new[i] < -farbound)) farbound = -lb_new[i];
-		if (ubA_new)
-			for (i = 0; i < nC; i++)
-				if ((ubA_new[i] < INFTY) && (ubA_new[i] > farbound)) farbound = ubA_new[i];
-		if (lbA_new)
-			for (i = 0; i < nC; i++)
-				if ((lbA_new[i] > -INFTY) && (lbA_new[i] < -farbound)) farbound = -lbA_new[i];
-
-		updateFarBounds(	farbound,nV+nC,
-							lb_new,lb_new_far, ub_new,ub_new_far,
-							lbA_new,lbA_new_far, ubA_new,ubA_new_far
-							);
-
-		for ( ;; )
-		{
-			nWSR = nWSR_max;
-			if ( cputime != 0 )
-			{
-				cputime_remaining = *cputime - cputime_needed;
-				pcputime_rem = &cputime_remaining;
-			}
-			else
-				pcputime_rem = 0;
-
-			/* Automatically call standard solveQP if regularisation is not active. */
-			returnvalue = solveRegularisedQP(	g_new,lb_new_far,ub_new_far,lbA_new_far,ubA_new_far,
-												nWSR,pcputime_rem,nWSR_performed,
-												isFirstCall
-												);
-
-			nWSR_performed  = nWSR;
-			cputime_needed += cputime_remaining;
-			isFirstCall     = BT_FALSE;
-
-			/* Check for active far-bounds and move them away */
-			nActiveFar = 0;
-			farbound *= options.growFarBounds;
-
-			if ( infeasible == BT_TRUE )
-			{
-				if ( farbound >= INFTY )
-				{
-					returnvalue = RET_HOTSTART_STOPPED_INFEASIBILITY;
-					break; // goto farewell;
-				}
-
-				updateFarBounds(	farbound,nV+nC,
-									lb_new,lb_new_far, ub_new,ub_new_far,
-									lbA_new,lbA_new_far, ubA_new,ubA_new_far
-									);
-			}
-			else if ( status == QPS_SOLVED )
-			{
-				real_t tol = farbound/options.growFarBounds * options.boundTolerance;
-
-				for ( i=0; i<nV; ++i )
-				{
-					if ( ( ( lb_new == 0 ) || ( lb_new_far[i] > lb_new[i] ) ) && ( getAbs ( lb_new_far[i] - x[i] ) < tol ) )
-						++nActiveFar;
-					if ( ( ( ub_new == 0 ) || ( ub_new_far[i] < ub_new[i] ) ) && ( getAbs ( ub_new_far[i] - x[i] ) < tol ) )
-						++nActiveFar;
-				}
-				for ( i=0; i<nC; ++i )
-				{
-					if ( ( ( lbA_new == 0 ) || ( lbA_new_far[i] > lbA_new[i] ) ) && ( getAbs ( lbA_new_far[i] - Ax[i] ) < tol ) )
-						++nActiveFar;
-					if ( ( ( ubA_new == 0 ) || ( ubA_new_far[i] < ubA_new[i] ) ) && ( getAbs ( ubA_new_far[i] - Ax[i] ) < tol ) )
-						++nActiveFar;
-				}
-
-				if ( nActiveFar == 0 )
-					break;
-
-				status = QPS_HOMOTOPYQPSOLVED;
-
-				if ( farbound >= INFTY )
-				{
-					unbounded = BT_TRUE;
-					returnvalue = RET_HOTSTART_STOPPED_UNBOUNDEDNESS;
-					goto farewell;
-				}
-
-				updateFarBounds(	farbound,nV+nC,
-									lb_new,lb_new_far, ub_new,ub_new_far,
-									lbA_new,lbA_new_far, ubA_new,ubA_new_far
-									);
-			}
-			else
-			{
-				/* some other error when solving QP */
-				break;
-			}
-
-			/* advance ramp offset to avoid Ramping cycles */
-			rampOffset++;
-		}
-
-		farewell:
-			/* add time to setup auxiliary QP */
-			if ( cputime != 0 )
-				*cputime = cputime_needed + auxTime;
-			delete[] lbA_new_far; delete[] ubA_new_far;
-			delete[] lb_new_far; delete[] ub_new_far;
-	}
-
-	return ( returnvalue != SUCCESSFUL_RETURN ) ? THROWERROR( returnvalue ) : returnvalue;
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue QProblem::hotstart(	const char* const g_file,
-								const char* const lb_file, const char* const ub_file,
-								const char* const lbA_file, const char* const ubA_file,
-								int_t& nWSR, real_t* const cputime,
-								const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-								)
-{
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* consistency check */
-	if ( g_file == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Allocate memory (if bounds exist). */
-	real_t* g_new   = new real_t[nV];
-	real_t* lb_new  = ( lb_file != 0 )  ? new real_t[nV] : 0;
-	real_t* ub_new  = ( ub_file != 0 )  ? new real_t[nV] : 0;
-	real_t* lbA_new = ( lbA_file != 0 ) ? new real_t[nC] : 0;
-	real_t* ubA_new = ( ubA_file != 0 ) ? new real_t[nC] : 0;
-
-
-	/* 2) Load new QP vectors from file. */
-	returnValue returnvalue;
-	returnvalue = loadQPvectorsFromFile(	g_file,lb_file,ub_file,lbA_file,ubA_file,
-											g_new,lb_new,ub_new,lbA_new,ubA_new
-											);
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		if ( ubA_file != 0 )
-			delete[] ubA_new;
-		if ( lbA_file != 0 )
-			delete[] lbA_new;
-		if ( ub_file != 0 )
-			delete[] ub_new;
-		if ( lb_file != 0 )
-			delete[] lb_new;
-		delete[] g_new;
-
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-
-	/* 3) Actually perform hotstart. */
-	returnvalue = hotstart(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-							nWSR,cputime,
-							guessedBounds,guessedConstraints
-							);
-
-
-	/* 4) Free memory. */
-	if ( ubA_file != 0 )
-		delete[] ubA_new;
-	if ( lbA_file != 0 )
-		delete[] lbA_new;
-	if ( ub_file != 0 )
-		delete[] ub_new;
-	if ( lb_file != 0 )
-		delete[] lb_new;
-	delete[] g_new;
-
-	return returnvalue;
-}
-
-
-/*
- * s o l v e C u r r e n t E Q P
- */
-returnValue QProblem::solveCurrentEQP(	const int_t n_rhs,
-										const real_t* g_in,
-										const real_t* lb_in,
-										const real_t* ub_in,
-										const real_t* lbA_in,
-										const real_t* ubA_in,
-										real_t* x_out,
-										real_t* y_out
-										)
-{
-	if ( ( x_out == 0 ) || ( y_out == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-	int_t ii, jj;
-	int_t nV  = getNV( );
-	int_t nC  = getNC( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-
-	real_t *delta_xFX = new real_t[nFX];
-	real_t *delta_xFR = new real_t[nFR];
-	real_t *delta_yAC = new real_t[nAC];
-	real_t *delta_yFX = new real_t[nFX];
-
-	/* 1) Determine index arrays. */
-	int_t* FR_idx;
-	int_t* FX_idx;
-	int_t* AC_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	for ( ii = 0 ; ii < (nV+nC)*n_rhs; ++ii )
-		y_out[ii] = 0.0;
-
-	for ( ii = 0 ; ii < n_rhs; ++ii )
-	{
-		returnvalue = determineStepDirection(
-			g_in, lbA_in, ubA_in, lb_in, ub_in, BT_FALSE, BT_FALSE,
-			delta_xFX, delta_xFR, delta_yAC, delta_yFX );
-
-		for ( jj = 0; jj < nFX; ++jj )
-			x_out[FX_idx[jj]] = delta_xFX[jj];
-		for ( jj = 0; jj < nFR; ++jj )
-			x_out[FR_idx[jj]] = delta_xFR[jj];
-		for ( jj = 0; jj < nFX; ++jj )
-			y_out[FX_idx[jj]] = delta_yFX[jj];
-		for ( jj = 0; jj < nAC; ++jj )
-			y_out[nV+AC_idx[jj]] = delta_yAC[jj];
-
-		g_in += nV;
-		lb_in += nV;
-		ub_in += nV;
-		lbA_in += nC;
-		ubA_in += nC;
-		x_out += nV;
-		y_out += nV+nC;
-	}
-
-
-	delete[] delta_yFX;
-	delete[] delta_yAC;
-	delete[] delta_xFR;
-	delete[] delta_xFX;
-
-	return returnvalue;
-}
-
-
-
-/*
- *	g e t W o r k i n g S e t
- */
-returnValue QProblem::getWorkingSet( real_t* workingSet )
-{
-	int_t nV = this->getNV();
-
-	if ( workingSet == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* At which limit are the bounds active? */
-	getWorkingSetBounds( workingSet );
-
-	/* At which limit are the contraints active? */
-	getWorkingSetConstraints( &(workingSet[nV]) );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t W o r k i n g S e t B o u n d s
- */
-returnValue QProblem::getWorkingSetBounds( real_t* workingSetB )
-{
-	return QProblemB::getWorkingSetBounds( workingSetB );
-}
-
-
-/*
- *	g e t W o r k i n g S e t C o n s t r a i n t s
- */
-returnValue QProblem::getWorkingSetConstraints( real_t* workingSetC )
-{
-	int_t i;
-	int_t nC = this->getNC();
-
-	if ( workingSetC == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	for ( i=0; i<nC; ++i )
-	{
-		switch ( constraints.getStatus(i) )
-		{
-			case ST_LOWER: workingSetC[i] = -1.0; break;
-			case ST_UPPER: workingSetC[i] = +1.0; break;
-			default:       workingSetC[i] =  0.0; break;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	g e t N Z
- */
-int_t QProblem::getNZ( ) const
-{
-	/* nZ = nFR - nAC */
-	return getNFR( ) - getNAC( );
-}
-
-
-/*
- *	g e t D u a l S o l u t i o n
- */
-returnValue QProblem::getDualSolution( real_t* const yOpt ) const
-{
-	int_t i;
-
-	for( i=0; i<getNV( )+getNC( ); ++i )
-		yOpt[i] = y[i];
-
-	/* return optimal dual solution vector
-	 * only if current QP has been solved */
-	if ( ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED ) )
-	{
-		return SUCCESSFUL_RETURN;
-	}
-	else
-	{
-		return RET_QP_NOT_SOLVED;
-	}
-}
-
-
-
-/*
- *	s e t C o n s t r a i n t P r o d u c t
- */
-returnValue QProblem::setConstraintProduct( ConstraintProduct* const _constraintProduct )
-{
-	constraintProduct = _constraintProduct;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t P r o p e r t i e s
- */
-returnValue QProblem::printProperties( )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	/* Do not print properties if print level is set to none! */
-	if ( options.printLevel == PL_NONE )
-		return SUCCESSFUL_RETURN;
-
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	myPrintf( "\n#################   qpOASES  --  QP PROPERTIES   #################\n" );
-	myPrintf( "\n" );
-
-	/* 1) Variables properties. */
-	snprintf( myPrintfString,MAX_STRING_LENGTH,  "Number of Variables: %4.1d\n",(int)getNV( ) );
-	myPrintf( myPrintfString );
-
-	if ( bounds.hasNoLower( ) == BT_TRUE )
-			myPrintf( "Variables are not bounded from below.\n" );
-		else
-			myPrintf( "Variables are bounded from below.\n" );
-
-	if ( bounds.hasNoUpper( ) == BT_TRUE )
-			myPrintf( "Variables are not bounded from above.\n" );
-		else
-			myPrintf( "Variables are bounded from above.\n" );
-
-	myPrintf( "\n" );
-
-
-	/* 2) Constraints properties. */
-	snprintf( myPrintfString,MAX_STRING_LENGTH,  "Total number of Constraints:      %4.1d\n",(int)getNC( ) );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,  "Number of Equality Constraints:   %4.1d\n",(int)getNEC( ) );
-	myPrintf( myPrintfString );
-
-	snprintf( myPrintfString,MAX_STRING_LENGTH,  "Number of Inequality Constraints: %4.1d\n",(int)(getNC( )-getNEC( )) );
-	myPrintf( myPrintfString );
-
-	if ( getNC( ) > 0 )
-	{
-		if ( constraints.hasNoLower( ) == BT_TRUE )
-				myPrintf( "Constraints are not bounded from below.\n" );
-			else
-				myPrintf( "Constraints are bounded from below.\n" );
-
-		if ( constraints.hasNoUpper( ) == BT_TRUE )
-				myPrintf( "Constraints are not bounded from above.\n" );
-			else
-				myPrintf( "Constraints are bounded from above.\n" );
-	}
-
-	myPrintf( "\n" );
-
-
-	/* 3) Further properties. */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			myPrintf( "Hessian is zero matrix (i.e. actually an LP is solved).\n" );
-			break;
-
-		case HST_IDENTITY:
-			myPrintf( "Hessian is identity matrix.\n" );
-			break;
-
-		case HST_POSDEF:
-			myPrintf( "Hessian matrix is (strictly) positive definite.\n" );
-			break;
-
-		case HST_POSDEF_NULLSPACE:
-			myPrintf( "Hessian matrix is positive definite on null space of active constraints.\n" );
-			break;
-
-		case HST_SEMIDEF:
-			myPrintf( "Hessian matrix is positive semi-definite.\n" );
-			break;
-
-		case HST_INDEF:
-			myPrintf( "Hessian matrix is indefinite.\n" );
-			break;
-
-		default:
-			myPrintf( "Hessian matrix has unknown type.\n" );
-			break;
-	}
-
-	if ( infeasible == BT_TRUE )
-		myPrintf( "QP was found to be infeasible.\n" );
-	else
-		myPrintf( "QP seems to be feasible.\n" );
-
-	if ( unbounded == BT_TRUE )
-		myPrintf( "QP was found to be unbounded from below.\n" );
-	else
-		myPrintf( "QP seems to be bounded from below.\n" );
-
-	myPrintf( "\n" );
-
-
-	/* 4) QP object properties. */
-	switch ( status )
-	{
-		case QPS_NOTINITIALISED:
-			myPrintf( "Status of QP object: freshly instantiated or reset.\n" );
-			break;
-
-		case QPS_PREPARINGAUXILIARYQP:
-			myPrintf( "Status of QP object: an auxiliary QP is currently setup.\n" );
-			break;
-
-		case QPS_AUXILIARYQPSOLVED:
-			myPrintf( "Status of QP object: an auxilary QP was solved.\n" );
-			break;
-
-		case QPS_PERFORMINGHOMOTOPY:
-			myPrintf( "Status of QP object: a homotopy step is performed.\n" );
-			break;
-
-		case QPS_HOMOTOPYQPSOLVED:
-			myPrintf( "Status of QP object: an intermediate QP along the homotopy path was solved.\n" );
-			break;
-
-		case QPS_SOLVED:
-			myPrintf( "Status of QP object: solution of the actual QP was found.\n" );
-			break;
-	}
-
-	switch ( options.printLevel )
-	{
-		case PL_DEBUG_ITER:
-			myPrintf( "Print level of QP object is set to display a tabular output for debugging.\n" );
-			break;
-
-		case PL_TABULAR:
-			myPrintf( "Print level of QP object is set to display a tabular output.\n" );
-			break;
-
-		case PL_LOW:
-			myPrintf( "Print level of QP object is low, i.e. only error are printed.\n" );
-			break;
-
-		case PL_MEDIUM:
-			myPrintf( "Print level of QP object is medium, i.e. error and warnings are printed.\n" );
-			break;
-
-		case PL_HIGH:
-			myPrintf( "Print level of QP object is high, i.e. all available output is printed.\n" );
-			break;
-
-		default:
-			break;
-	}
-
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue QProblem::getFreeVariablesFlags( BooleanType* varIsFree )
-{
-	int_t nV  = getNV( );
-	for ( int_t i=0; i<nV; i++ )
-		varIsFree[i] = BT_FALSE;
-
-	int_t nFR  = getNFR( );
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	for ( int_t i=0; i<nFR; i++ )
-		varIsFree[FR_idx[i]] = BT_TRUE;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue QProblem::clear( )
-{
-	if ( ( freeConstraintMatrix == BT_TRUE ) && ( A != 0 ) )
-	{
-		delete A;
-		A = 0;
-	}
-
-	if ( lbA != 0 )
-	{
-		delete[] lbA;
-		lbA = 0;
-	}
-
-	if ( ubA != 0 )
-	{
-		delete[] ubA;
-		ubA = 0;
-	}
-
-	if ( T != 0 )
-	{
-		delete[] T;
-		T = 0;
-	}
-
-	if ( Q != 0 )
-	{
-		delete[] Q;
-		Q = 0;
-	}
-
-	if ( Ax != 0 )
-	{
-		delete[] Ax;
-		Ax = 0;
-	}
-
-	if ( Ax_l != 0 )
-	{
-		delete[] Ax_l;
-		Ax_l = 0;
-	}
-
-	if ( Ax_u != 0 )
-	{
-		delete[] Ax_u;
-		Ax_u = 0;
-	}
-
-	if ( tempA != 0 )
-	{
-		delete[] tempA;
-		tempA = 0;
-	}
-
-	if ( ZFR_delta_xFRz != 0 )
-	{
-		delete[] ZFR_delta_xFRz;
-		ZFR_delta_xFRz = 0;
-	}
-
-	if ( delta_xFRy != 0 )
-	{
-		delete[] delta_xFRy;
-		delta_xFRy = 0;
-	}
-
-	if ( delta_xFRz != 0 )
-	{
-		delete[] delta_xFRz;
-		delta_xFRz = 0;
-	}
-
-	if ( tempB != 0 )
-	{
-		delete[] tempB;
-		tempB = 0;
-	}
-
-	if ( delta_yAC_TMP != 0 )
-	{
-		delete[] delta_yAC_TMP;
-		delta_yAC_TMP = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue QProblem::copy(	const QProblem& rhs
-							)
-{
-	uint_t _nV = (uint_t)rhs.getNV( );
-	uint_t _nC = (uint_t)rhs.getNC( );
-
-	constraints = rhs.constraints;
-
-	if ( ( freeConstraintMatrix == BT_TRUE ) && ( A != 0 ) )
-	{
-		delete A;
-		A = 0;
-	}
-
-	freeConstraintMatrix = rhs.freeConstraintMatrix;
-
-	if ( freeConstraintMatrix == BT_TRUE )
-		A = rhs.A->duplicate();
-	else
-		A = rhs.A;
-
-	if ( rhs.lbA != 0 )
-	{
-		lbA = new real_t[_nC];
-		setLBA( rhs.lbA );
-	}
-	else
-		lbA = 0;
-
-	if ( rhs.ubA != 0 )
-	{
-		ubA = new real_t[_nC];
-		setUBA( rhs.ubA );
-	}
-	else
-		ubA = 0;
-
-	if ( rhs.y != 0 )
-	{
-		delete[] y; /* y of no constraints version too short! */
-		y = new real_t[_nV+_nC];
-		memcpy( y,rhs.y,(_nV+_nC)*sizeof(real_t) );
-	}
-	else
-		y = 0;
-
-	sizeT = rhs.sizeT;
-
-	if ( rhs.T != 0 )
-	{
-		T = new real_t[sizeT*sizeT];
-		memcpy( T,rhs.T,((uint_t)(sizeT*sizeT))*sizeof(real_t) );
-	}
-	else
-		T = 0;
-
-	if ( rhs.Q != 0 )
-	{
-		Q = new real_t[_nV*_nV];
-		memcpy( Q,rhs.Q,_nV*_nV*sizeof(real_t) );
-	}
-	else
-		Q = 0;
-
-	if ( rhs.Ax != 0 )
-	{
-		Ax = new real_t[_nC];
-		memcpy( Ax,rhs.Ax,_nC*sizeof(real_t) );
-	}
-	else
-		Ax = 0;
-
-	if ( rhs.Ax_l != 0 )
-	{
-		Ax_l = new real_t[_nC];
-		memcpy( Ax_l,rhs.Ax_l,_nC*sizeof(real_t) );
-	}
-	else
-		Ax_l = 0;
-
-	if ( rhs.Ax_u != 0 )
-	{
-		Ax_u = new real_t[_nC];
-		memcpy( Ax_u,rhs.Ax_u,_nC*sizeof(real_t) );
-	}
-	else
-		Ax_u = 0;
-
-	if ( rhs.constraintProduct != 0 )
-		constraintProduct = rhs.constraintProduct;
-	else
-		constraintProduct = 0;
-
-	tempA = new real_t[_nV];			/* nFR */
-	ZFR_delta_xFRz = new real_t[_nV];	/* nFR */
-	delta_xFRz = new real_t[_nV];		/* nZ */
-
-	if ( _nC > 0 )
-	{
-		delta_xFRy = new real_t[_nC];		/* nAC */
-		tempB = new real_t[_nC];			/* nAC */
-		delta_yAC_TMP = new real_t[_nC];   /* nAC */
-	}
-	else
-	{
-		delta_xFRy = 0;
-		tempB = 0;
-		delta_yAC_TMP = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s o l v e I n i t i a l Q P
- */
-returnValue QProblem::solveInitialQP(	const real_t* const xOpt, const real_t* const yOpt,
-										const Bounds* const guessedBounds, const Constraints* const guessedConstraints,
-										const real_t* const _R,
-										int_t& nWSR, real_t* const cputime
-										)
-{
-	int_t i,j;
-
-	/* some definitions */
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	//writeQpDataIntoMatFile( "qpData.mat" );
-
-	/* start runtime measurement */
-	real_t starttime = 0.0;
-	if ( cputime != 0 )
-		starttime = getCPUtime( );
-
-	status = QPS_NOTINITIALISED;
-
-	/* I) ANALYSE QP DATA: */
-	/* 1) Check if Hessian happens to be the identity matrix. */
-	if ( determineHessianType( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 2) Setup type of bounds and constraints (i.e. unbounded, implicitly fixed etc.). */
-	if ( setupSubjectToType( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* II) SETUP AUXILIARY QP WITH GIVEN OPTIMAL SOLUTION: */
-	/* 1) Setup bounds and constraints data structure. */
-	if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	if ( constraints.setupAllInactive( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 2) Setup optimal primal/dual solution for auxiliary QP. */
-	if ( setupAuxiliaryQPsolution( xOpt,yOpt ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 3) Obtain linear independent working set for auxiliary QP. */
-	Bounds auxiliaryBounds( nV );
-	Constraints auxiliaryConstraints( nC );
-
-	if ( obtainAuxiliaryWorkingSet(	xOpt,yOpt,guessedBounds,guessedConstraints,
-									&auxiliaryBounds,&auxiliaryConstraints ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 4) Setup working set of auxiliary QP and setup matrix factorisations. */
-	/* a) Regularise Hessian if necessary. */
-	if ( ( hessianType == HST_ZERO ) || ( hessianType == HST_SEMIDEF ) )
-	{
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_INIT_FAILED_REGULARISATION );
-	}
-
-	/* b) TQ factorisation. */
-	if ( setupTQfactorisation( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED_TQ );
-
-	/* c) Working set of auxiliary QP. */
-	if ( setupAuxiliaryWorkingSet( &auxiliaryBounds,&auxiliaryConstraints,BT_TRUE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* d) Copy external Cholesky factor if provided */
-	haveCholesky = BT_FALSE;
-
-	if ( _R != 0 )
-	{
-		if ( options.initialStatusBounds != ST_INACTIVE )
-		{
-			THROWWARNING( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-		}
-		else
-		{
-			if ( _R == R )
-			{
-				/* Cholesky factor read from file and already loaded into R. */
-				haveCholesky = BT_TRUE;
-			}
-			else if ( ( xOpt == 0 ) && ( yOpt == 0 ) && ( guessedBounds == 0 ) && ( guessedConstraints == 0 ) )
-			{
-				for( i=0; i<nV; ++i )
-					for( j=i; j<nV; ++j )
-						RR(i,j) = _R[i*nV+j];
-				haveCholesky = BT_TRUE;
-			}
-			else
-			{
-				THROWWARNING( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-			}
-		}
-	}
-
-	/* 5) Store original QP formulation... */
-	real_t* g_original = new real_t[nV];
-	real_t* lb_original = new real_t[nV];
-	real_t* ub_original = new real_t[nV];
-	real_t* lbA_original = new real_t[nC];
-	real_t* ubA_original = new real_t[nC];
-
-	for( i=0; i<nV; ++i )
-	{
-		g_original[i] = g[i];
-		lb_original[i] = lb[i];
-		ub_original[i] = ub[i];
-	}
-
-	for( i=0; i<nC; ++i )
-	{
-		lbA_original[i] = lbA[i];
-		ubA_original[i] = ubA[i];
-	}
-
-	/* ... and setup QP data of an auxiliary QP having an optimal solution
-	 * as specified by the user (or xOpt = yOpt = 0, by default). */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-	{
-		delete[] ubA_original; delete[] lbA_original; delete[] ub_original; delete[] lb_original; delete[] g_original;
-		return THROWERROR( RET_INIT_FAILED );
-	}
-
-	if ( setupAuxiliaryQPbounds( &auxiliaryBounds,&auxiliaryConstraints,BT_TRUE ) != SUCCESSFUL_RETURN )
-	{
-		delete[] ubA_original; delete[] lbA_original; delete[] ub_original; delete[] lb_original; delete[] g_original;
-		return THROWERROR( RET_INIT_FAILED );
-	}
-
-	status = QPS_AUXILIARYQPSOLVED;
-
-
-	if ( options.enableRamping == BT_TRUE )
-		performRamping( );
-
-
-	/* III) SOLVE ACTUAL INITIAL QP: */
-	/* Allow only remaining CPU time for usual hotstart. */
-	if ( cputime != 0 )
-		*cputime -= getCPUtime( ) - starttime;
-
-	/* Use hotstart method to find the solution of the original initial QP,... */
-	returnValue returnvalue = hotstart( g_original,lb_original,ub_original,lbA_original,ubA_original, nWSR,cputime );
-
-	/* ... deallocate memory,... */
-	delete[] ubA_original; delete[] lbA_original; delete[] ub_original; delete[] lb_original; delete[] g_original;
-
-	/* ... check for infeasibility and unboundedness... */
-	if ( isInfeasible( ) == BT_TRUE )
-		return THROWERROR( RET_INIT_FAILED_INFEASIBILITY );
-
-	if ( isUnbounded( ) == BT_TRUE )
-		return THROWERROR( RET_INIT_FAILED_UNBOUNDEDNESS );
-
-	/* ... and internal errors. */
-	if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-		return THROWERROR( RET_INIT_FAILED_HOTSTART );
-
-
-	/* stop runtime measurement */
-	if ( cputime != 0 )
-		*cputime = getCPUtime( ) - starttime;
-
-	THROWINFO( RET_INIT_SUCCESSFUL );
-
-	return returnvalue;
-}
-
-
-/*
- *	s o l v e Q P
- */
-returnValue QProblem::solveQP(	const real_t* const g_new,
-								const real_t* const lb_new, const real_t* const ub_new,
-								const real_t* const lbA_new, const real_t* const ubA_new,
-								int_t& nWSR, real_t* const cputime, int_t nWSRperformed,
-								BooleanType isFirstCall
-								)
-{
-	int_t iter;
-	int_t nV  = getNV( );
-	int_t nC  = getNC( );
-
-	returnValue returnvalue;
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED );
-	}
-
-	/* start runtime measurement */
-	real_t starttime = 0.0;
-	if ( cputime != 0 )
-		starttime = getCPUtime( );
-
-	/* AW: Remove bounds if they were active before but are now infinity */
-	status = QPS_PERFORMINGHOMOTOPY; // AW TODO: Not sure if this is too early, but otherwise removeBounds will complain
-	returnvalue = updateActivitiesForHotstart( lb_new, ub_new, lbA_new, ubA_new );
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		THROWERROR( RET_HOTSTART_FAILED );
-		return returnvalue;
-	}
-
-	/* I) PREPARATIONS */
-	/* 1) Allocate delta vectors of gradient and (constraints') bounds,
-	 *    index arrays and step direction arrays. */
-	real_t* delta_xFR = new real_t[nV];
-	real_t* delta_xFX = new real_t[nV];
-	real_t* delta_yAC = new real_t[nC];
-	real_t* delta_yFX = new real_t[nV];
-
-	real_t* delta_g   = new real_t[nV];
-	real_t* delta_lb  = new real_t[nV];
-	real_t* delta_ub  = new real_t[nV];
-	real_t* delta_lbA = new real_t[nC];
-	real_t* delta_ubA = new real_t[nC];
-
-	BooleanType Delta_bC_isZero, Delta_bB_isZero;
-
-	int_t BC_idx;
-	SubjectToStatus BC_status;
-	BooleanType BC_isBound;
-
-	real_t homotopyLength;
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-
-	/* 2) Update type of bounds and constraints, e.g.
-	 *    a former equality constraint might have become a normal one etc. */
-
-  // (ckirches) disabled this, as inactive but tight bounds may become inactive equalities
-    //            which would then never become active again!
-/*
-	if ( setupSubjectToType( lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_HOTSTART_FAILED );
-*/
-
-	/* 3) Reset status flags. */
-	infeasible = BT_FALSE;
-	unbounded  = BT_FALSE;
-
-
-	/* II) MAIN HOMOTOPY LOOP */
-	for( iter=nWSRperformed; iter<nWSR; ++iter )
-	{
-		tabularOutput.idxAddB = tabularOutput.idxRemB = tabularOutput.idxAddC = tabularOutput.idxRemC = -1;
-		tabularOutput.excAddB = tabularOutput.excRemB = tabularOutput.excAddC = tabularOutput.excRemC = 0;
-
-		if ( isCPUtimeLimitExceeded( cputime,starttime,iter-nWSRperformed ) == BT_TRUE )
-		{
-			/* If CPU time limit is exceeded, stop homotopy loop immediately!
-			* Assign number of working set recalculations (runtime measurement is stopped later). */
-			nWSR = iter;
-			break;
-		}
-
-		status = QPS_PERFORMINGHOMOTOPY;
-
-		#ifndef __SUPPRESSANYOUTPUT__
-		if ( isFirstCall == BT_TRUE )
-			snprintf( messageString,MAX_STRING_LENGTH,"%d ...",(int)iter );
-		else
-			snprintf( messageString,MAX_STRING_LENGTH,"%d* ...",(int)iter );
-		getGlobalMessageHandler( )->throwInfo( RET_ITERATION_STARTED,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#endif
-
-		/* 2) Determination of shift direction of the gradient and the (constraints') bounds. */
-		returnvalue = determineDataShift(	g_new,lbA_new,ubA_new,lb_new,ub_new,
-											delta_g,delta_lbA,delta_ubA,delta_lb,delta_ub,
-											Delta_bC_isZero, Delta_bB_isZero
-											);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_SHIFT_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-		/* 3) Determination of step direction of X and Y. */
-		returnvalue = determineStepDirection(	delta_g,delta_lbA,delta_ubA,delta_lb,delta_ub,
-												Delta_bC_isZero, Delta_bB_isZero,
-												delta_xFX,delta_xFR,delta_yAC,delta_yFX
-												);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_STEPDIRECTION_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-		/* 4) Determination of step length TAU.
-		 *    This step along the homotopy path is also taken (without changing working set). */
-		returnvalue = performStep(	delta_g, delta_lbA,delta_ubA,delta_lb,delta_ub,
-									delta_xFX,delta_xFR,delta_yAC,delta_yFX,
-									BC_idx,BC_status,BC_isBound
-									);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_STEPLENGTH_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-		/* 5) Termination criterion. */
-		nV = getNV( );
-		nC = getNC( );
-
-		homotopyLength = getRelativeHomotopyLength( g_new,lb_new,ub_new,lbA_new,ubA_new );
-		if ( homotopyLength <= options.terminationTolerance )
-		{
-			status = QPS_SOLVED;
-
-			THROWINFO( RET_OPTIMAL_SOLUTION_FOUND );
-
-			if ( printIteration( iter,BC_idx,BC_status,BC_isBound,homotopyLength,isFirstCall ) != SUCCESSFUL_RETURN )
-				THROWERROR( RET_PRINT_ITERATION_FAILED ); /* do not pass this as return value! */
-
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-			return SUCCESSFUL_RETURN;
-		}
-
-		/* 6) Change active set. */
-		returnvalue = changeActiveSet( BC_idx,BC_status,BC_isBound );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			/* Checks for infeasibility... */
-			if ( isInfeasible( ) == BT_TRUE )
-			{
-				status = QPS_HOMOTOPYQPSOLVED;
-				return setInfeasibilityFlag( RET_HOTSTART_STOPPED_INFEASIBILITY );
-			}
-
-			/* ...unboundedness... */
-			if ( unbounded == BT_TRUE ) /* not necessary since objective function convex! */
-				return THROWERROR( RET_HOTSTART_STOPPED_UNBOUNDEDNESS );
-
-			/* ... and throw unspecific error otherwise */
-			THROWERROR( RET_HOMOTOPY_STEP_FAILED );
-			return returnvalue;
-		}
-
-		/* 6a) Possibly refactorise projected Hessian from scratch. */
-		if ( ( options.enableCholeskyRefactorisation > 0 ) && ( (iter % options.enableCholeskyRefactorisation) == 0 ) )
-		{
-			returnvalue = computeProjectedCholesky( );
-			if (returnvalue != SUCCESSFUL_RETURN)
-			{
-				delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-				delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-				return returnvalue;
-			}
-		}
-
-		/* 7) Output information of successful QP iteration. */
-		status = QPS_HOMOTOPYQPSOLVED;
-
-		if ( printIteration( iter,BC_idx,BC_status,BC_isBound,homotopyLength,isFirstCall ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_PRINT_ITERATION_FAILED ); /* do not pass this as return value! */
-
-		/* 8) Perform Ramping Strategy on zero homotopy step or drift correction (if desired). */
-		if (BC_status != ST_UNDEFINED)
-		{
-			if ( ( tau <= EPS ) && ( options.enableRamping == BT_TRUE ) )
-				performRamping( );
-			else
-			if ( (options.enableDriftCorrection > 0)
-			  && ((iter+1) % options.enableDriftCorrection == 0) )
-				performDriftCorrection( );  /* always returns SUCCESSFUL_RETURN */
-		}
-		else // AW: Added this.  Otherwise, I observed that the gradient might become incorrect
-		{
-			if ( (options.enableDriftCorrection > 0)
-			  && ((iter+1) % options.enableDriftCorrection == 0) )
-				performDriftCorrection( );  /* always returns SUCCESSFUL_RETURN */
-		}
-	}
-
-	delete[] delta_yAC; delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-	delete[] delta_ub; delete[] delta_lb; delete[] delta_ubA; delete[] delta_lbA; delete[] delta_g;
-
-	/* stop runtime measurement */
-	if ( cputime != 0 )
-		*cputime = getCPUtime( ) - starttime;
-
-
-	/* if program gets to here, output information that QP could not be solved
-	 * within the given maximum numbers of working set changes */
-	if ( options.printLevel == PL_HIGH )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		snprintf( messageString,MAX_STRING_LENGTH,"(nWSR = %d)",(int)iter );
-		return getGlobalMessageHandler( )->throwWarning( RET_MAX_NWSR_REACHED,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#else
-		return RET_MAX_NWSR_REACHED;
-		#endif
-	}
-	else
-	{
-		return RET_MAX_NWSR_REACHED;
-	}
-}
-
-
-/*
- *	s o l v e R e g u l a r i s e d Q P
- */
-returnValue QProblem::solveRegularisedQP(	const real_t* const g_new,
-											const real_t* const lb_new, const real_t* const ub_new,
-											const real_t* const lbA_new, const real_t* const ubA_new,
-											int_t& nWSR, real_t* const cputime, int_t nWSRperformed,
-											BooleanType isFirstCall
-											)
-{
-	int_t i, step;
-	int_t nV = getNV( );
-
-
-	/* Perform normal QP solution if QP has not been regularised. */
-	if ( usingRegularisation( ) == BT_FALSE )
-		return solveQP( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,cputime,nWSRperformed,isFirstCall );
-
-
-	/* I) SOLVE USUAL REGULARISED QP */
-	returnValue returnvalue;
-
-	int_t nWSR_max   = nWSR;
-	int_t nWSR_total = nWSRperformed;
-
-	real_t cputime_total = 0.0;
-	real_t cputime_cur   = 0.0;
-
-	if ( cputime == 0 )
-	{
-		returnvalue = solveQP( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0,nWSRperformed,isFirstCall );
-	}
-	else
-	{
-		cputime_cur = *cputime;
-		returnvalue = solveQP( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,&cputime_cur,nWSRperformed,isFirstCall );
-	}
-	nWSR_total     = nWSR;
-	cputime_total += cputime_cur;
-	isFirstCall    = BT_FALSE;
-
-	/* Only continue if QP solution has been successful. */
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		if ( cputime != 0 )
-			*cputime = cputime_total;
-
-		if ( returnvalue == RET_MAX_NWSR_REACHED )
-			THROWWARNING( RET_NO_REGSTEP_NWSR );
-
-		return returnvalue;
-	}
-
-
-	/* II) PERFORM SUCCESSIVE REGULARISATION STEPS */
-	real_t* gMod = new real_t[nV];
-
-	for( step=0; step<options.numRegularisationSteps; ++step )
-	{
-		/* 1) Modify gradient: gMod = g - eps*xOpt
-		 *    (assuming regularisation matrix to be regVal*Id). */
-		for( i=0; i<nV; ++i )
-			gMod[i] = g_new[i] - regVal*x[i];
-
-		/* 2) Solve regularised QP with modified gradient allowing
-		 *    only as many working set recalculations and CPU time
-		 *    as have been left from previous QP solutions. */
-		nWSR = nWSR_max;
-
-		if ( cputime == 0 )
-		{
-			returnvalue = solveQP( gMod,lb_new,ub_new,lbA_new,ubA_new, nWSR,0,nWSR_total,isFirstCall );
-		}
-		else
-		{
-			cputime_cur = *cputime - cputime_total;
-			returnvalue = solveQP( gMod,lb_new,ub_new,lbA_new,ubA_new, nWSR,&cputime_cur,nWSR_total,isFirstCall );
-		}
-
-		nWSR_total     = nWSR;
-		cputime_total += cputime_cur;
-
-		/* Only continue if QP solution has been successful. */
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] gMod;
-
-			if ( cputime != 0 )
-				*cputime = cputime_total;
-
-			if ( returnvalue == RET_MAX_NWSR_REACHED )
-				THROWWARNING( RET_FEWER_REGSTEPS_NWSR );
-
-			return returnvalue;
-		}
-	}
-
-	for( i=0; i<nV; ++i )
-		g[i] = g_new[i];
-
-	delete[] gMod;
-
-	if ( cputime != 0 )
-		*cputime = cputime_total;
-
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	s e t u p S u b j e c t T o T y p e
- */
-returnValue QProblem::updateActivitiesForHotstart( const real_t* const lb_new, const real_t* const ub_new,
-												   const real_t* const lbA_new, const real_t* const ubA_new
-												   )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	returnValue returnvalue;
-
-	if ( QProblemB::setupSubjectToType( lb_new,ub_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUPSUBJECTTOTYPE_FAILED );
-
-	for ( i=0; i<nV; i++ )
-	{
-		if ( lb_new[i] <= -INFTY && bounds.getStatus(i) == ST_LOWER )
-		{
-			returnvalue = removeBound( i, BT_TRUE, BT_FALSE, options.enableNZCTests );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return returnvalue;
-			g[i] -= y[i];
-			y[i] = 0.0;
-		}
-		if ( ub_new[i] >= INFTY && bounds.getStatus(i) == ST_UPPER )
-		{
-			returnvalue = removeBound( i, BT_TRUE, BT_FALSE, options.enableNZCTests );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return returnvalue;
-			g[i] -= y[i];
-			y[i] = 0.0;
-		}
-		if ( lb_new[i] > -INFTY && lb[i] <= -INFTY )
-		{
-			/* Now a lower bound has become finite.  To avoid numerical issues, adjust lb */
-			lb[i] = x[i] - options.boundRelaxation;
-		}
-		if ( ub_new[i] < INFTY && ub[i] >= INFTY )
-		{
-			/* Now a lower bound has become finite.  To avoid numerical issues, adjust lb */
-			ub[i] = x[i] + options.boundRelaxation;
-		}
-	}
-
-	for ( i=0; i<nV; i++ )
-	{
-	  if ( bounds.getType(i) == ST_EQUALITY ) // ?? && lb[i] != ub[i]
-		{
-			/* AW: Are the following two lines OK? */
-			lb[i] = x[i];
-			ub[i] = x[i];
-			if (  bounds.getStatus(i) == ST_INACTIVE )
-			{
-				returnvalue = addBound_checkLI(i);
-				if ( returnvalue == RET_LINEARLY_INDEPENDENT )
-				{
-					returnvalue = addBound( i,ST_LOWER, BT_TRUE );
-					if ( returnvalue != SUCCESSFUL_RETURN )
-						return returnvalue;
-				}
-				/* AW: Check: This allows to have variables that are
-				   equalities to be in the set of free variables. */
-			}
-		}
-	}
-
-
-	// AW TODO: We could also implement something here for the constraints
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p S u b j e c t T o T y p e
- */
-returnValue QProblem::setupSubjectToType( )
-{
-	return setupSubjectToType( lb,ub,lbA,ubA );
-}
-
-
-/*
- *	s e t u p S u b j e c t T o T y p e
- */
-returnValue QProblem::setupSubjectToType(	const real_t* const lb_new, const real_t* const ub_new,
-											const real_t* const lbA_new, const real_t* const ubA_new
-											)
-{
-	int_t i;
-	int_t nC = getNC( );
-
-
-	/* I) SETUP SUBJECTTOTYPE FOR BOUNDS */
-	if ( QProblemB::setupSubjectToType( lb_new,ub_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUPSUBJECTTOTYPE_FAILED );
-
-
-	/* II) SETUP SUBJECTTOTYPE FOR CONSTRAINTS */
-	/* 1) Check if lower constraints' bounds are present. */
-	constraints.setNoLower( BT_TRUE );
-	if ( lbA_new != 0 )
-	{
-		for( i=0; i<nC; ++i )
-		{
-			if ( lbA_new[i] > -INFTY )
-			{
-				constraints.setNoLower( BT_FALSE );
-				break;
-			}
-		}
-	}
-
-	/* 2) Check if upper constraints' bounds are present. */
-	constraints.setNoUpper( BT_TRUE );
-	if ( ubA_new != 0 )
-	{
-		for( i=0; i<nC; ++i )
-		{
-			if ( ubA_new[i] < INFTY )
-			{
-				constraints.setNoUpper( BT_FALSE );
-				break;
-			}
-		}
-	}
-
-	/* 3) Determine implicit equality constraints and unbounded constraints. */
-	if ( ( lbA_new != 0 ) && ( ubA_new != 0 ) )
-	{
-		for( i=0; i<nC; ++i )
-		{
-			if (constraints.getType (i) == ST_DISABLED)
-				continue;
-
-			if ( ( lbA_new[i] < -INFTY+options.boundTolerance ) && ( ubA_new[i] > INFTY-options.boundTolerance )
-					&& (options.enableFarBounds == BT_FALSE))
-			{
-				constraints.setType( i,ST_UNBOUNDED );
-			}
-			else
-			{
-				if ( options.enableEqualities && lbA[i] > ubA[i] - options.boundTolerance
-				                              && lbA_new[i] > ubA_new[i] - options.boundTolerance)
-					constraints.setType( i,ST_EQUALITY );
-				else
-					constraints.setType( i,ST_BOUNDED );
-			}
-		}
-	}
-	else
-	{
-		if ( ( lbA_new == 0 ) && ( ubA_new == 0 ) )
-		{
-			for( i=0; i<nC; ++i )
-				constraints.setType( i,ST_UNBOUNDED );
-		}
-		else
-		{
-			for( i=0; i<nC; ++i )
-				constraints.setType( i,ST_BOUNDED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o m p u t e P r o j e c t e d C h o l e s k y
- */
-returnValue QProblem::computeProjectedCholesky( )
-{
-	int_t i, j;
-	int_t nV  = getNV( );
-	int_t nZ  = getNZ( );
-
-	SymSparseMat* Id;
-
-	/* Revert to unprotected Cholesky decomposition */
-	if ( getNFX() + getNAC() == 0 )
-		return QProblemB::computeCholesky( );
-
-	/* 1) Initialises R with all zeros. */
-	for( i=0; i<nV*nV; ++i )
-		R[i] = 0.0;
-
-	/* Do not do anything for empty null spaces (important for LP case, HST_ZERO !)*/
-	if ( nZ == 0 ) // nZ == nV - getNFX() - getNAC()
-		return SUCCESSFUL_RETURN;
-
-	/* 2) Calculate Cholesky decomposition of projected Hessian Z'*H*Z. */
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	/* calculate Z'*H*Z */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			if ( usingRegularisation() == BT_TRUE )
-			{
-				Id = createDiagSparseMat( nV, regVal );
-				Id->bilinear(bounds.getFree(), nZ, Q, nV, R, nV);
-				delete Id;
-			}
-			else
-			{
-				/* Code should not get here, as  nZ == 0  always holds for an LP (without regularisation)! */
-				if ( nZ > 0 )
-					return THROWERROR( RET_UNKNOWN_BUG );
-			}
-			break;
-
-		case HST_IDENTITY:
-			Id = createDiagSparseMat( nV, 1.0 );
-			Id->bilinear(bounds.getFree(), nZ, Q, nV, R, nV);
-			delete Id;
-			break;
-
-		default:
-			if ( getNAC() == 0 ) {
-				/* make Z trivial */
-				for ( j=0; j < nZ; ++j ) {
-					for ( i=0; i < nV; ++i )
-						QQ(i,j) = 0.0;
-					QQ(FR_idx[j],j) = 1.0;
-				}
-				/* now Z is trivial, and so is Z'HZ */
-				int_t nFR = getNFR ();
-				for ( j=0; j < nFR; ++j )
-					H->getCol (FR_idx[j], bounds.getFree (), 1.0, &R[j*nV]);
-			} else {
-				/* this is expensive if Z is large! */
-				H->bilinear(bounds.getFree(), nZ, Q, nV, R, nV);
-			}
-	}
-
-	/* R'*R = Z'*H*Z */
-	long info = 0;
-	unsigned long _nZ = (unsigned long)nZ, _nV = (unsigned long)nV;
-
-	POTRF( "U", &_nZ, R, &_nV, &info );
-
-	/* <0 = invalid call, =0 ok, >0 not spd */
-	if (info > 0) {
-		if ( R[0] < 0.0 )
-		{
-			/* Cholesky decomposition has tunneled a negative
-			 * diagonal element. */
-			options.epsRegularisation = getMin( -R[0]+options.epsRegularisation,getSqrt(getAbs(options.epsRegularisation)) );
-		}
-
-		hessianType = HST_SEMIDEF;
-		return RET_HESSIAN_NOT_SPD;
-	}
-
-	/* zero first subdiagonal to make givens updates work */
-	for (i=0;i<nZ-1;++i)
-		RR(i+1,i) = 0.0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p I n i t i a l C h o l e s k y
- */
-returnValue QProblem::setupInitialCholesky( )
-{
-	returnValue returnvalueCholesky;
-
-	/* If regularisation shall be used, always regularise at beginning
-	 * if initial working set is not empty. */
-	if ( ( getNV() != getNFR()-getNFV() ) && ( options.enableRegularisation == BT_TRUE ) )
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return RET_INIT_FAILED_REGULARISATION;
-
-	/* Factorise projected Hessian
-	 * now handles all special cases (no active bounds/constraints, no nullspace) */
-	returnvalueCholesky = computeProjectedCholesky( );
-
-	/* If Hessian is not positive definite, regularise and try again. */
-	if ( returnvalueCholesky == RET_HESSIAN_NOT_SPD )
-	{
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return RET_INIT_FAILED_REGULARISATION;
-
-		returnvalueCholesky = computeProjectedCholesky( );
-	}
-
-	if ( returnvalueCholesky != SUCCESSFUL_RETURN )
-		return RET_INIT_FAILED_CHOLESKY;
-
-	haveCholesky = BT_TRUE;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p T Q f a c t o r i s a t i o n
- */
-returnValue QProblem::setupTQfactorisation( )
-{
-	int_t i, ii;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	/* 1) Set Q to unity matrix. */
-	for( i=0; i<nV*nV; ++i )
-		Q[i] = 0.0;
-
-	for( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		QQ(ii,i) = 1.0;
-	}
-
- 	/* 2) Set T to zero matrix. */
-	for( i=0; i<sizeT*sizeT; ++i )
-		T[i] = 0.0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	o b t a i n A u x i l i a r y W o r k i n g S e t
- */
-returnValue QProblem::obtainAuxiliaryWorkingSet(	const real_t* const xOpt, const real_t* const yOpt,
-													const Bounds* const guessedBounds, const Constraints* const guessedConstraints,
-													Bounds* auxiliaryBounds, Constraints* auxiliaryConstraints
-													) const
-{
-	int_t i = 0;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-
-	/* 1) Ensure that desiredBounds is allocated (and different from guessedBounds). */
-	if ( ( auxiliaryBounds == 0 ) || ( auxiliaryBounds == guessedBounds ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( auxiliaryConstraints == 0 ) || ( auxiliaryConstraints == guessedConstraints ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	SubjectToStatus guessedStatus;
-
-	/* 2) Setup working set of bounds for auxiliary initial QP. */
-	if ( QProblemB::obtainAuxiliaryWorkingSet( xOpt,yOpt,guessedBounds, auxiliaryBounds ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-
-	/* 3) Setup working set of constraints for auxiliary initial QP. */
-	if ( guessedConstraints != 0 )
-	{
-		/* If an initial working set is specific, use it!
-		 * Moreover, add all equality constraints if specified. */
-		for( i=0; i<nC; ++i )
-		{
-			/* Add constraint only if it is not (going to be) disabled! */
-			guessedStatus = guessedConstraints->getStatus( i );
-
-			#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-			if ( constraints.getType( i ) == ST_EQUALITY )
-			{
-				if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-			}
-			else
-			#endif
-			{
-				if ( auxiliaryConstraints->setupConstraint( i,guessedStatus ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-			}
-		}
-	}
-	else	/* No initial working set specified. */
-	{
-		/* Obtain initial working set by "clipping". */
-		if ( ( xOpt != 0 ) && ( yOpt == 0 ) )
-		{
-			for( i=0; i<nC; ++i )
-			{
-				if ( Ax[i] - lbA[i] <= options.boundTolerance )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				if ( ubA[i] - Ax_u[i] <= options.boundTolerance )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_UPPER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				/* Moreover, add all equality constraints if specified. */
-				#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-				if ( constraints.getType( i ) == ST_EQUALITY )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-				else
-				#endif
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-			}
-		}
-
-		/* Obtain initial working set in accordance to sign of dual solution vector. */
-		if ( ( xOpt == 0 ) && ( yOpt != 0 ) )
-		{
-			for( i=0; i<nC; ++i )
-			{
-				if ( yOpt[nV+i] > EPS )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				if ( yOpt[nV+i] < -EPS )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_UPPER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				/* Moreover, add all equality constraints if specified. */
-				#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-				if ( constraints.getType( i ) == ST_EQUALITY )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-				else
-				#endif
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-			}
-		}
-
-		/* If xOpt and yOpt are null pointer and no initial working is specified,
-		 * start with empty working set (or implicitly fixed bounds and equality constraints only)
-		 * for auxiliary QP. */
-		if ( ( xOpt == 0 ) && ( yOpt == 0 ) )
-		{
-			for( i=0; i<nC; ++i )
-			{
-				/* Only add all equality constraints if specified. */
-				#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-				if ( constraints.getType( i ) == ST_EQUALITY )
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-				else
-				#endif
-				{
-					if ( auxiliaryConstraints->setupConstraint( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p A u x i l i a r y W o r k i n g S e t
- */
-returnValue QProblem::setupAuxiliaryWorkingSet(	const Bounds* const auxiliaryBounds,
-												const Constraints* const auxiliaryConstraints,
-												BooleanType setupAfresh
-												)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-	BooleanType WSisTrivial = BT_TRUE;
-
-	/* consistency checks */
-	if ( auxiliaryBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-			if ( ( bounds.getStatus( i ) == ST_UNDEFINED ) || ( auxiliaryBounds->getStatus( i ) == ST_UNDEFINED ) )
-				return THROWERROR( RET_UNKNOWN_BUG );
-	}
-	else
-	{
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( auxiliaryConstraints != 0 )
-	{
-		for( i=0; i<nC; ++i )
-			if ( ( constraints.getStatus( i ) == ST_UNDEFINED ) || ( auxiliaryConstraints->getStatus( i ) == ST_UNDEFINED ) )
-				return THROWERROR( RET_UNKNOWN_BUG );
-	}
-	else
-	{
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* Check for trivial working set (all and only bounds active) */
-	for (i = 0; i < nV; i++)
-		if (auxiliaryBounds->getStatus(i) == ST_INACTIVE)
-		{
-			WSisTrivial = BT_FALSE;
-			break;
-		}
-	for (i = 0; i < nC; i++)
-		// (ckirches) here we chose to ignore an invalid ST_INACTIVE on
-		//            constraints that are ST_EQUALITies or may just have become equalities
-		if ( (constraints.getType(i) == ST_EQUALITY) // NOT auxiliaryConstraints here
-			|| (auxiliaryConstraints->getStatus(i) != ST_INACTIVE) )
-		{
-			WSisTrivial = BT_FALSE;
-			break;
-		}
-
-	if (WSisTrivial == BT_TRUE)
-	{
-		for (i = 0; i < nV; i++)
-			if (bounds.getStatus(i) == ST_INACTIVE)
-				bounds.moveFreeToFixed(i, auxiliaryBounds->getStatus(i));
-
-		return SUCCESSFUL_RETURN;
-	}
-
-
-	/* I) SETUP CHOLESKY FLAG:
-	 *    Cholesky decomposition shall only be updated if working set
-	 *    shall be updated (i.e. NOT setup afresh!) */
-	BooleanType updateCholesky;
-	if ( setupAfresh == BT_TRUE )
-		updateCholesky = BT_FALSE;
-	else
-		updateCholesky = BT_TRUE;
-
-
-	BooleanType was_fulli = options.enableFullLITests;
-	real_t backupEpsLITests = options.epsLITests;
-
-	options.enableFullLITests = BT_FALSE;
-	/* options.epsLITests = 1e-1; */
-
-	/* II) REMOVE FORMERLY ACTIVE (CONSTRAINTS') BOUNDS (IF NECESSARY): */
-	if ( setupAfresh == BT_FALSE )
-	{
-		/* 1) Remove all active constraints that shall be inactive or disabled AND
-		*    all active constraints that are active at the wrong bound. */
-		for( i=0; i<nC; ++i )
-		{
-			if ( ( constraints.getStatus( i ) == ST_LOWER ) && ( auxiliaryConstraints->getStatus( i ) != ST_LOWER ) )
-				if ( removeConstraint( i,updateCholesky,BT_FALSE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-			if ( ( constraints.getStatus( i ) == ST_UPPER ) && ( auxiliaryConstraints->getStatus( i ) != ST_UPPER ) )
-				if ( removeConstraint( i,updateCholesky,BT_FALSE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-		}
-
-		/* 2) Remove all active bounds that shall be inactive AND
-		*    all active bounds that are active at the wrong bound. */
-		for( i=0; i<nV; ++i )
-		{
-			if ( ( bounds.getStatus( i ) == ST_LOWER ) && ( auxiliaryBounds->getStatus( i ) != ST_LOWER ) )
-				if ( removeBound( i,updateCholesky,BT_FALSE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-			if ( ( bounds.getStatus( i ) == ST_UPPER ) && ( auxiliaryBounds->getStatus( i ) != ST_UPPER ) )
-				if ( removeBound( i,updateCholesky,BT_FALSE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-		}
-	}
-
-
-	/* III) ADD NEWLY ACTIVE (CONSTRAINTS') BOUNDS: */
-
-	/* 1) Add all equality bounds. */
-	for( i=0; i<nV; ++i )
-	{
-		//if ( ( bounds.getType( i ) == ST_EQUALITY ) && ( ( bounds.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryBounds->getStatus( i ) != ST_INACTIVE ) ) )
-
-		// (ckirches) force equalities active
-
-		if ( ( bounds.getType( i ) == ST_EQUALITY ) && ( bounds.getStatus( i ) == ST_INACTIVE ) )
-		{
-            // assert ( auxiliaryBounds->getStatus( i ) != ST_INACTIVE );
-			/* No check for linear independence necessary. */
-			if ( addBound( i,ST_LOWER,updateCholesky ) != SUCCESSFUL_RETURN ) // was auxiliaryBounds->getStatus( i )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-		}
-	}
-
-	/* 2) Add all equality constraints. */
-	for( i=0; i<nC; ++i )
-	{
-        //if ( ( constraints.getType( i ) == ST_EQUALITY ) && ( ( constraints.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryConstraints->getStatus( i ) != ST_INACTIVE ) ) )
-
-		// (ckirches) force equalities active
-
-		if ( ( constraints.getType( i ) == ST_EQUALITY ) && ( constraints.getStatus( i ) == ST_INACTIVE ) )
-		{
-            // assert ( auxiliaryConstraints->getStatus( i ) != ST_INACTIVE );
-			/* Add constraint only if it is linearly independent from the current working set. */
-			if ( addConstraint_checkLI( i ) == RET_LINEARLY_INDEPENDENT )
-			{
-				if ( addConstraint( i,ST_LOWER,updateCholesky ) != SUCCESSFUL_RETURN )  // was auxiliaryConstraints->getStatus( i )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-			}
-			else
-			{
-				/* Equalities are not linearly independent! */
-				constraints.setType(i, ST_BOUNDED);
-			}
-		}
-	}
-
-
-	/* 3) Add all inactive bounds that shall be active AND
-	 *    all formerly active bounds that have been active at the wrong bound. */
-	for( i=0; i<nV; ++i )
-	{
-		if ( ( bounds.getType( i ) != ST_EQUALITY ) && ( ( bounds.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryBounds->getStatus( i ) != ST_INACTIVE ) ) )
-		{
-			/* Add bound only if it is linearly independent from the current working set. */
-			if ( addBound_checkLI( i ) == RET_LINEARLY_INDEPENDENT )
-			{
-				if ( addBound( i,auxiliaryBounds->getStatus( i ),updateCholesky ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-			}
-		}
-	}
-
-	/* 4) Add all inactive constraints that shall be active AND
-	 *    all formerly active constraints that have been active at the wrong bound. */
-	for( i=0; i<nC; ++i )
-	{
-		if ( ( constraints.getType( i ) != ST_EQUALITY ) && ( auxiliaryConstraints->getStatus( i ) != ST_INACTIVE ) )
-		{
-			/* formerly inactive */
-			if ( constraints.getStatus( i ) == ST_INACTIVE )
-			{
-				/* Add constraint only if it is linearly independent from the current working set. */
-				if ( addConstraint_checkLI( i ) == RET_LINEARLY_INDEPENDENT )
-				{
-					if ( addConstraint( i,auxiliaryConstraints->getStatus( i ),updateCholesky ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-				}
-			}
-		}
-	}
-
-	options.enableFullLITests = was_fulli;
-	options.epsLITests = backupEpsLITests;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P s o l u t i o n
- */
-returnValue QProblem::setupAuxiliaryQPsolution(	const real_t* const xOpt, const real_t* const yOpt
-												)
-{
-	int_t i, j;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-
-	/* Setup primal/dual solution vector for auxiliary initial QP:
-	 * if a null pointer is passed, a zero vector is assigned;
-	 *  old solution vector is kept if pointer to internal solution vector is passed. */
-	if ( xOpt != 0 )
-	{
-		if ( xOpt != x )
-			for( i=0; i<nV; ++i )
-				x[i] = xOpt[i];
-
-		A->times(1, 1.0, x, nV, 0.0, Ax, nC);
-
-		for ( j=0; j<nC; ++j )
-		{
-			Ax_l[j] = Ax[j];
-			Ax_u[j] = Ax[j];
-		}
-	}
-	else
-	{
-		for( i=0; i<nV; ++i )
-			x[i] = 0.0;
-
-		for ( j=0; j<nC; ++j )
-		{
-			Ax[j] = 0.0;
-			Ax_l[j] = 0.0;
-			Ax_u[j] = 0.0;
-		}
-	}
-
-	if ( yOpt != 0 )
-	{
-		if ( yOpt != y )
-			for( i=0; i<nV+nC; ++i )
-				y[i] = yOpt[i];
-	}
-	else
-	{
-		for( i=0; i<nV+nC; ++i )
-			y[i] = 0.0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P g r a d i e n t
- */
-returnValue QProblem::setupAuxiliaryQPgradient( )
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-
-	/* Setup gradient vector: g = -H*x + [Id A]'*[yB yC]
-	 *                          = yB - H*x + A'*yC. */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			if ( usingRegularisation( ) == BT_FALSE )
-				for ( i=0; i<nV; ++i )
-					g[i] = y[i];
-			else
-				for ( i=0; i<nV; ++i )
-					g[i] = y[i] - regVal*x[i];
-			break;
-
-		case HST_IDENTITY:
-			for ( i=0; i<nV; ++i )
-				g[i] = y[i] - x[i];
-			break;
-
-		default:
-			/* y'*Id */
-			for ( i=0; i<nV; ++i )
-				g[i] = y[i];
-
-			/* - H*x */
-			H->times(1, -1.0, x, nV, 1.0, g, nV);
-			break;
-	}
-
-	/* + A'*yC */
-	A->transTimes(1, 1.0, y + nV, nC, 1.0, g, nV);
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a r e B o u n d s C o n s i s t e n t
- */
-returnValue QProblem::areBoundsConsistent(	const real_t* const lb_new, const real_t* const ub_new,
-											const real_t* const lbA_new, const real_t* const ubA_new) const
-{
-	if (QProblemB::areBoundsConsistent(lb_new, ub_new) == RET_QP_INFEASIBLE)
-		return RET_QP_INFEASIBLE;
-
-	if (lbA_new && ubA_new) {
-		for (int_t i = 0; i < getNC(); ++i) {
-			if (lbA_new[i] > ubA_new[i]+EPS) {
-				return RET_QP_INFEASIBLE;
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P b o u n d s
- */
-returnValue QProblem::setupAuxiliaryQPbounds(	const Bounds* const auxiliaryBounds,
-												const Constraints* const auxiliaryConstraints,
-												BooleanType useRelaxation
-												)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-
-	/* 1) Setup bound vectors. */
-	for ( i=0; i<nV; ++i )
-	{
-		switch ( bounds.getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( useRelaxation == BT_TRUE )
-				{
-					if ( bounds.getType( i ) == ST_EQUALITY )
-					{
-						lb[i] = x[i];
-						ub[i] = x[i];
-					}
-					else
-					{
-						/* If a bound is inactive although it was supposed to be
-						* active by the auxiliaryBounds, it could not be added
-						* due to linear dependence. Thus set it "strongly inactive". */
-						if ( auxiliaryBounds->getStatus( i ) == ST_LOWER )
-							lb[i] = x[i];
-						else
-							lb[i] = x[i] - options.boundRelaxation;
-
-						if ( auxiliaryBounds->getStatus( i ) == ST_UPPER )
-							ub[i] = x[i];
-						else
-							ub[i] = x[i] + options.boundRelaxation;
-					}
-				}
-				break;
-
-			case ST_LOWER:
-				lb[i] = x[i];
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					ub[i] = x[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						ub[i] = x[i] + options.boundRelaxation;
-				}
-				break;
-
-			case ST_UPPER:
-				ub[i] = x[i];
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					lb[i] = x[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						lb[i] = x[i] - options.boundRelaxation;
-				}
-				break;
-
-            case ST_DISABLED:
-                break;
-
-			default:
-				return THROWERROR( RET_UNKNOWN_BUG );
-		}
-	}
-
-	/* 2) Setup constraints vectors. */
-	for ( i=0; i<nC; ++i )
-	{
-		switch ( constraints.getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( useRelaxation == BT_TRUE )
-				{
-					if ( constraints.getType( i ) == ST_EQUALITY )
-					{
-						lbA[i] = Ax_l[i];
-						ubA[i] = Ax_u[i];
-					}
-					else
-					{
-						/* If a constraint is inactive although it was supposed to be
-						* active by the auxiliaryConstraints, it could not be added
-						* due to linear dependence. Thus set it "strongly inactive". */
-						if ( auxiliaryConstraints->getStatus( i ) == ST_LOWER )
-							lbA[i] = Ax_l[i];
-						else
-							lbA[i] = Ax_l[i] - options.boundRelaxation;
-
-						if ( auxiliaryConstraints->getStatus( i ) == ST_UPPER )
-							ubA[i] = Ax_u[i];
-						else
-							ubA[i] = Ax_u[i] + options.boundRelaxation;
-					}
-				}
-				break;
-
-			case ST_LOWER:
-				lbA[i] = Ax_l[i];
-				if ( constraints.getType( i ) == ST_EQUALITY )
-				{
-					ubA[i] = Ax_l[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						ubA[i] = Ax_l[i] + options.boundRelaxation;
-				}
-				break;
-
-			case ST_UPPER:
-				ubA[i] = Ax_u[i];
-				if ( constraints.getType( i ) == ST_EQUALITY )
-				{
-					lbA[i] = Ax_u[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						lbA[i] = Ax_u[i] - options.boundRelaxation;
-				}
-				break;
-
-            case ST_DISABLED:
-                break;
-
-			default:
-				return THROWERROR( RET_UNKNOWN_BUG );
-		}
-		Ax_l[i] = Ax_l[i] - lbA[i];
-		Ax_u[i] = ubA[i] - Ax_u[i];
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a d d C o n s t r a i n t
- */
-returnValue QProblem::addConstraint(	int_t number, SubjectToStatus C_status,
-										BooleanType updateCholesky,
-										BooleanType ensureLI
-										)
-{
-	int_t i, j, ii;
-
-	/* consistency checks */
-	if ( constraints.getStatus( number ) != ST_INACTIVE )
-		return THROWERROR( RET_CONSTRAINT_ALREADY_ACTIVE );
-
-	if ( ( constraints.getNC( ) - getNAC( ) ) == constraints.getNUC( ) )
-		return THROWERROR( RET_ALL_CONSTRAINTS_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-
-	/* I) ENSURE LINEAR INDEPENDENCE OF THE WORKING SET,
-	 *    i.e. remove a constraint or bound if linear dependence occurs. */
-	/* check for LI only if Cholesky decomposition shall be updated! */
-	if ( updateCholesky == BT_TRUE && ensureLI == BT_TRUE )
-	{
-		returnValue ensureLIreturnvalue = addConstraint_ensureLI( number,C_status );
-
-		switch ( ensureLIreturnvalue )
-		{
-			case SUCCESSFUL_RETURN:
-				break;
-
-			case RET_LI_RESOLVED:
-				break;
-
-			case RET_ENSURELI_FAILED_NOINDEX:
-				return RET_ADDCONSTRAINT_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_FAILED_CYCLING:
-				return RET_ADDCONSTRAINT_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_DROPPED:
-				return SUCCESSFUL_RETURN;
-
-			default:
-				return THROWERROR( RET_ENSURELI_FAILED );
-		}
-	}
-
-	/* some definitions */
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-	int_t tcol = sizeT - nAC;
-
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	real_t* aFR = new real_t[nFR];
-	real_t* wZ = new real_t[nZ];
-	for( i=0; i<nZ; ++i )
-		wZ[i] = 0.0;
-
-
-	/* II) ADD NEW ACTIVE CONSTRAINT TO MATRIX T: */
-	/* 1) Add row [wZ wY] = aFR'*[Z Y] to the end of T: assign aFR. */
-	A->getRow(number, bounds.getFree(), 1.0, aFR);
-
-	/* calculate wZ */
-	for( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		for( j=0; j<nZ; ++j )
-			wZ[j] += aFR[i] * QQ(ii,j);
-	}
-
-	/* 2) Calculate wY and store it directly into T. */
-	if ( nAC > 0 )
-	{
-		for( j=0; j<nAC; ++j )
-			TT(nAC,tcol+j) = 0.0;
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			for( j=0; j<nAC; ++j )
-				TT(nAC,tcol+j) += aFR[i] * QQ(ii,nZ+j);
-		}
-	}
-
-	delete[] aFR;
-
-
-	real_t c, s, nu;
-
-	if ( nZ > 0 )
-	{
-		/* II) RESTORE TRIANGULAR FORM OF T: */
-		/*     Use column-wise Givens rotations to restore reverse triangular form
-		*      of T, simultanenous change of Q (i.e. Z) and R. */
-		for( j=0; j<nZ-1; ++j )
-		{
-			computeGivens( wZ[j+1],wZ[j], wZ[j+1],wZ[j],c,s );
-			nu = s/(1.0+c);
-
-			for( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				applyGivens( c,s,nu,QQ(ii,1+j),QQ(ii,j), QQ(ii,1+j),QQ(ii,j) );
-			}
-
-			if ( ( updateCholesky == BT_TRUE ) &&
-				 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-			{
-				for( i=0; i<=j+1; ++i )
-					applyGivens( c,s,nu,RR(i,1+j),RR(i,j), RR(i,1+j),RR(i,j) );
-			}
-		}
-
-		TT(nAC,tcol-1) = wZ[nZ-1];
-
-
-		if ( ( updateCholesky == BT_TRUE ) &&
-			 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-		{
-			/* III) RESTORE TRIANGULAR FORM OF R:
-			 *      Use row-wise Givens rotations to restore upper triangular form of R. */
-			for( i=0; i<nZ-1; ++i )
-			{
-				computeGivens( RR(i,i),RR(1+i,i), RR(i,i),RR(1+i,i),c,s );
-				nu = s/(1.0+c);
-
-				for( j=(1+i); j<(nZ-1); ++j ) /* last column of R is thrown away */
-					applyGivens( c,s,nu,RR(i,j),RR(1+i,j), RR(i,j),RR(1+i,j) );
-			}
-			/* last column of R is thrown away */
-			for( i=0; i<nZ; ++i )
-				RR(i,nZ-1) = 0.0;
-		}
-	}
-
-	delete[] wZ;
-
-
-	/* IV) UPDATE INDICES */
-	tabularOutput.idxAddC = number;
-	if ( constraints.moveInactiveToActive( number,C_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	a d d C o n s t r a i n t _ c h e c k L I
- */
-returnValue QProblem::addConstraint_checkLI( int_t number )
-{
-	returnValue returnvalue = RET_LINEARLY_DEPENDENT;
-
-	int_t i, j, ii;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nZ  = getNZ( );
-	int_t nC  = getNC( );
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	int_t *FR_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-
-	if (options.enableFullLITests)
-	{
-		/*
-		 * expensive LI test. Backsolve with refinement using special right
-		 * hand side. This gives an estimate for what should be considered
-		 * "zero". We then check linear independence relative to this estimate.
-		 */
-
-		int_t *FX_idx, *AC_idx, *IAC_idx;
-
-		real_t *delta_g   = new real_t[nV];
-		real_t *delta_xFX = new real_t[nFX];
-		real_t *delta_xFR = new real_t[nFR];
-		real_t *delta_yAC = new real_t[nAC];
-		real_t *delta_yFX = new real_t[nFX];
-
-		bounds.getFixed( )->getNumberArray( &FX_idx );
-		constraints.getActive( )->getNumberArray( &AC_idx );
-		constraints.getInactive( )->getNumberArray( &IAC_idx );
-
-		int_t dim = (nC>nV)?nC:nV;
-		real_t *nul = new real_t[dim];
-		for (ii = 0; ii < dim; ++ii)
-			nul[ii]=0.0;
-
-		A->getRow (number, 0, 1.0, delta_g);
-
-		// AW: I think original line overwrote correct return value
-		// original: returnvalue = determineStepDirection ( delta_g,
-		returnValue dsdreturnvalue = determineStepDirection ( delta_g,
-											  nul, nul, nul, nul,
-											  BT_FALSE, BT_FALSE,
-											  delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		if (dsdreturnvalue!=SUCCESSFUL_RETURN)
-			returnvalue = dsdreturnvalue;
-
-		delete[] nul;
-
-		/* compute the weight in inf-norm */
-		real_t weight = 0.0;
-		for (ii = 0; ii < nAC; ++ii)
-		{
-			real_t a = getAbs (delta_yAC[ii]);
-			if (weight < a) weight = a;
-		}
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_yFX[ii]);
-			if (weight < a) weight = a;
-		}
-
-		/* look at the "zero" in a relative inf-norm */
-		real_t zero = 0.0;
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_xFX[ii]);
-			if (zero < a) zero = a;
-		}
-		for (ii = 0; ii < nFR; ++ii)
-		{
-			real_t a = getAbs (delta_xFR[ii]);
-			if (zero < a) zero = a;
-		}
-
-		/* relative test against zero in inf-norm */
-		if (zero > options.epsLITests * weight)
-			returnvalue = RET_LINEARLY_INDEPENDENT;
-
-		delete[] delta_yFX;
-		delete[] delta_yAC;
-		delete[] delta_xFR;
-		delete[] delta_xFX;
-		delete[] delta_g;
-
-	}
-	else
-	{
-		/*
-		 * cheap LI test for constraint. Check if constraint <number> is
-		 * linearly independent from the the active ones (<=> is element of null
-		 * space of Afr).
-		 */
-
-		real_t *Arow = new real_t[nFR];
-		A->getRow(number, bounds.getFree(), 1.0, Arow);
-
-		real_t sum, l2;
-
-		l2  = 0.0;
-		for (i = 0; i < nFR; i++)
-			l2  += Arow[i]*Arow[i];
-
-		for( j=0; j<nZ; ++j )
-		{
-			sum = 0.0;
-			for( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				sum += Arow[i] * QQ(ii,j);
-			}
-
-			if ( getAbs( sum ) > options.epsLITests*l2 )
-			{
-				/*fprintf(stdFile, "LI test: |sum| = %9.2e, l2 = %9.2e, var = %d\n", getAbs(sum), l2, jj+1); */
-				returnvalue = RET_LINEARLY_INDEPENDENT;
-				break;
-			}
-		}
-
-		delete[] Arow;
-	}
-
-	return THROWINFO( returnvalue );
-}
-
-
-/*
- *	a d d C o n s t r a i n t _ e n s u r e L I
- */
-returnValue QProblem::addConstraint_ensureLI( int_t number, SubjectToStatus C_status )
-{
-	int_t i, j, ii, jj;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addConstraint_checkLI( number );
-
-	if ( returnvalueCheckLI == RET_INDEXLIST_CORRUPTED )
-		return THROWERROR( RET_ENSURELI_FAILED );
-
-	if ( returnvalueCheckLI == RET_LINEARLY_INDEPENDENT )
-		return SUCCESSFUL_RETURN;
-
-
- 	/* II) NEW CONSTRAINT IS LINEARLY DEPENDENT: */
-	/* 1) Determine coefficients of linear combination,
-	 *    cf. M.J. Best. Applied Mathematics and Parallel Computing, chapter:
-	 *    An Algorithm for the Solution of the Parametric Quadratic Programming
-	 *    Problem, pages 57-76. Physica-Verlag, Heidelberg, 1996. */
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	real_t* xiC = new real_t[nAC];
-	real_t* xiC_TMP = new real_t[nAC];
-	real_t* xiB = new real_t[nFX];
-	real_t* Arow = new real_t[nFR];
-	real_t* num = new real_t[nV];
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	real_t y_min = options.maxDualJump;
-	int_t y_min_number = -1;
-	int_t y_min_number_bound = -1;
-	BooleanType y_min_isBound = BT_FALSE;
-
-	A->getRow(number, bounds.getFree(), C_status == ST_LOWER ? 1.0 : -1.0, Arow);
-
-	/* 2) Calculate xiC */
-	if ( nAC > 0 )
-	{
-		for( i=0; i<nAC; ++i )
-		{
-			xiC_TMP[i] = 0.0;
-			for( j=0; j<nFR; ++j )
-			{
-				jj = FR_idx[j];
-				xiC_TMP[i] += QQ(jj,nZ+i) * Arow[j];
-			}
-		}
-
-		if ( backsolveT( xiC_TMP, BT_TRUE, xiC ) != SUCCESSFUL_RETURN )
-		{
-			returnvalue = RET_ENSURELI_FAILED_TQ;
-			goto farewell;
-		}
-	}
-
-	/* 3) Calculate xiB. */
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	A->getRow(number, bounds.getFixed(), C_status == ST_LOWER ? 1.0 : -1.0, xiB);
-	A->transTimes(constraints.getActive(), bounds.getFixed(), 1, -1.0, xiC, nAC, 1.0, xiB, nFX);
-
-	/* III) DETERMINE CONSTRAINT/BOUND TO BE REMOVED. */
-
-	/* 1) Constraints. */
-	for( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-		num[i] = y[nV+ii];
-	}
-
-	performRatioTest (nAC, AC_idx, &constraints, num, xiC, options.epsNum, options.epsDen, y_min, y_min_number);
-
-	/* 2) Bounds. */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-	}
-
-	performRatioTest (nFX, FX_idx, &bounds, num, xiB, options.epsNum, options.epsDen, y_min, y_min_number_bound);
-
-	if ( y_min_number_bound >= 0 )
-	{
-		y_min_number = y_min_number_bound;
-		y_min_isBound = BT_TRUE;
-	}
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	/* setup output preferences */
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-	/* IV) REMOVE CONSTRAINT/BOUND FOR RESOLVING LINEAR DEPENDENCE: */
-	if ( y_min_number >= 0 )
-	{
-		/* Update Lagrange multiplier... */
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			y[nV+ii] -= y_min * xiC[i];
-		}
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			y[ii] -= y_min * xiB[i];
-		}
-
-		/* ... also for newly active constraint... */
-		if ( C_status == ST_LOWER )
-			y[nV+number] = y_min;
-		else
-			y[nV+number] = -y_min;
-
-		/* ... and for constraint to be removed. */
-		if ( y_min_isBound == BT_TRUE )
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			snprintf( messageString,MAX_STRING_LENGTH,"bound no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeBound( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemB = 1;
-
-			y[y_min_number] = 0.0;
-		}
-		else
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			snprintf( messageString,MAX_STRING_LENGTH,"constraint no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeConstraint( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemC = 1;
-
-			y[nV+y_min_number] = 0.0;
-		}
-	}
-	else
-	{
-		if (options.enableDropInfeasibles == BT_TRUE) {
-			/* dropping of infeasible constraints according to drop priorities */
-			returnvalue = dropInfeasibles (number, C_status, BT_FALSE, xiB, xiC);
-		}
-		else
-		{
-			/* no constraint/bound can be removed => QP is infeasible! */
-			returnvalue = RET_ENSURELI_FAILED_NOINDEX;
-			setInfeasibilityFlag( returnvalue );
-		}
-	}
-
-farewell:
-	delete[] num;
-	delete[] Arow;
-	delete[] xiB;
-	delete[] xiC_TMP;
-	delete[] xiC;
-
-	getGlobalMessageHandler( )->throwInfo( RET_LI_RESOLVED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-
-	return ( (returnvalue != SUCCESSFUL_RETURN) && (returnvalue != RET_ENSURELI_FAILED_NOINDEX ) ) ? THROWERROR (returnvalue) : returnvalue;
-}
-
-
-
-/*
- *	a d d B o u n d
- */
-returnValue QProblem::addBound(	int_t number, SubjectToStatus B_status,
-								BooleanType updateCholesky,
-								BooleanType ensureLI
-								)
-{
-	int_t i, j, ii;
-
-	/* consistency checks */
-	if ( bounds.getStatus( number ) != ST_INACTIVE )
-		return THROWERROR( RET_BOUND_ALREADY_ACTIVE );
-
-	if ( getNFR( ) == bounds.getNUV( ) )
-		return THROWERROR( RET_ALL_BOUNDS_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-
-	/* I) ENSURE LINEAR INDEPENDENCE OF THE WORKING SET,
-	 *    i.e. remove a constraint or bound if linear dependence occurs. */
-	/* check for LI only if Cholesky decomposition shall be updated! */
-	if ( ( updateCholesky == BT_TRUE ) && ( ensureLI == BT_TRUE ) )
-	{
-		returnValue ensureLIreturnvalue = addBound_ensureLI( number,B_status );
-
-		switch ( ensureLIreturnvalue )
-		{
-			case SUCCESSFUL_RETURN:
-				break;
-
-			case RET_LI_RESOLVED:
-				break;
-
-			case RET_ENSURELI_FAILED_NOINDEX:
-				return RET_ADDBOUND_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_FAILED_CYCLING:
-				return RET_ADDBOUND_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_DROPPED:
-				return SUCCESSFUL_RETURN;
-
-			default:
-				return THROWERROR( RET_ENSURELI_FAILED );
-		}
-	}
-
-
-	/* some definitions */
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-	int_t tcol = sizeT - nAC;
-
-
-	/* II) SWAP INDEXLIST OF FREE VARIABLES:
-	 *     move the variable to be fixed to the end of the list of free variables. */
-	int_t lastfreenumber = bounds.getFree( )->getLastNumber( );
-	if ( lastfreenumber != number )
-		if ( bounds.swapFree( number,lastfreenumber ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_ADDBOUND_FAILED );
-
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	real_t* w = new real_t[nFR];
-
-
-	/* III) ADD NEW ACTIVE BOUND TO TOP OF MATRIX T: */
-	/* 1) add row [wZ wY] = [Z Y](number) at the top of T: assign w */
-	for( i=0; i<nFR; ++i )
-		w[i] = QQ(FR_idx[nFR-1],i);
-
-
-	/* 2) Use column-wise Givens rotations to restore reverse triangular form
-	 *    of the first row of T, simultanenous change of Q (i.e. Z) and R. */
-	real_t c, s, nu;
-
-	for( j=0; j<nZ-1; ++j )
-	{
-		computeGivens( w[j+1],w[j], w[j+1],w[j],c,s );
-		nu = s/(1.0+c);
-
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			applyGivens( c,s,nu,QQ(ii,1+j),QQ(ii,j), QQ(ii,1+j),QQ(ii,j) );
-		}
-
-		if ( ( updateCholesky == BT_TRUE ) &&
-			 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-		{
-			for( i=0; i<=j+1; ++i )
-				applyGivens( c,s,nu,RR(i,1+j),RR(i,j), RR(i,1+j),RR(i,j) );
-		}
-	}
-
-
-	if ( nAC > 0 )	  /* ( nAC == 0 ) <=> ( nZ == nFR ) <=> Y and T are empty => nothing to do */
-	{
-		/* store new column a in a temporary vector instead of shifting T one column to the left */
-		real_t* tmp = new real_t[nAC];
-		for( i=0; i<nAC; ++i )
-			tmp[i] = 0.0;
-
-		{
-			j = nZ-1;
-
-			computeGivens( w[j+1],w[j], w[j+1],w[j],c,s );
-			nu = s/(1.0+c);
-
-			for( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				applyGivens( c,s,nu,QQ(ii,1+j),QQ(ii,j), QQ(ii,1+j),QQ(ii,j) );
-			}
-
-			applyGivens( c,s,nu,TT(nAC-1,tcol),tmp[nAC-1], tmp[nAC-1],TT(nAC-1,tcol) );
-		}
-
-		for( j=nZ; j<nFR-1; ++j )
-		{
-			computeGivens( w[j+1],w[j], w[j+1],w[j],c,s );
-			nu = s/(1.0+c);
-
-			for( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				applyGivens( c,s,nu,QQ(ii,1+j),QQ(ii,j), QQ(ii,1+j),QQ(ii,j) );
-			}
-
-			for( i=(nFR-2-j); i<nAC; ++i )
-				applyGivens( c,s,nu,TT(i,1+tcol-nZ+j),tmp[i], tmp[i],TT(i,1+tcol-nZ+j) );
-		}
-
-		delete[] tmp;
-	}
-
-	delete[] w;
-
-
-	if ( ( updateCholesky == BT_TRUE ) &&
-		 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-	{
-		/* IV) RESTORE TRIANGULAR FORM OF R:
-		 *     use row-wise Givens rotations to restore upper triangular form of R */
-		for( i=0; i<nZ-1; ++i )
-		{
-			computeGivens( RR(i,i),RR(1+i,i), RR(i,i),RR(1+i,i),c,s );
-			nu = s/(1.0+c);
-
-			for( j=(1+i); j<nZ-1; ++j ) /* last column of R is thrown away */
-				applyGivens( c,s,nu,RR(i,j),RR(1+i,j), RR(i,j),RR(1+i,j) );
-		}
-		/* last column of R is thrown away */
-		for( i=0; i<nZ; ++i )
-			RR(i,nZ-1) = 0.0;
-	}
-
-
-	/* V) UPDATE INDICES */
-	tabularOutput.idxAddB = number;
-	if ( bounds.moveFreeToFixed( number,B_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_ADDBOUND_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a d d B o u n d _ c h e c k L I
- */
-returnValue QProblem::addBound_checkLI( int_t number )
-{
-	int_t i, ii;
-	int_t nV  = getNV( );  /* for QQ() macro */
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	int_t nC  = getNC( );
-	returnValue returnvalue = RET_LINEARLY_DEPENDENT;
-
-	if (options.enableFullLITests)
-	{
-		/*
-		 * expensive LI test. Backsolve with refinement using special right
-		 * hand side. This gives an estimate for what should be considered
-		 * "zero". We then check linear independence relative to this estimate.
-		 */
-
-		/*
-		 * expensive LI test. Backsolve with refinement using special right
-		 * hand side. This gives an estimate for what should be considered
-		 * "zero". We then check linear independence relative to this estimate.
-		 */
-
-		real_t *delta_g   = new real_t[nV];
-		real_t *delta_xFX = new real_t[nFX];
-		real_t *delta_xFR = new real_t[nFR];
-		real_t *delta_yAC = new real_t[nAC];
-		real_t *delta_yFX = new real_t[nFX];
-
-		for (ii = 0; ii < nV; ++ii)
-			delta_g[ii] = 0.0;
-		delta_g[number] = 1.0;	/* sign doesn't matter here */
-
-		int_t dim = (nC>nV)?nC:nV;
-		real_t *nul = new real_t[dim];
-		for (ii = 0; ii < dim; ++ii)
-			nul[ii]=0.0;
-
-		returnValue dsdReturnValue = determineStepDirection (
-				delta_g, nul, nul, nul, nul, BT_FALSE, BT_FALSE,
-				delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		if (dsdReturnValue != SUCCESSFUL_RETURN)
-			returnvalue = dsdReturnValue;
-
-		/* compute the weight in inf-norm */
-		real_t weight = 0.0;
-		for (ii = 0; ii < nAC; ++ii)
-		{
-			real_t a = getAbs (delta_yAC[ii]);
-			if (weight < a) weight = a;
-		}
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_yFX[ii]);
-			if (weight < a) weight = a;
-		}
-
-		/* look at the "zero" in a relative inf-norm */
-		real_t zero = 0.0;
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_xFX[ii]);
-			if (zero < a) zero = a;
-		}
-		for (ii = 0; ii < nFR; ++ii)
-		{
-			real_t a = getAbs (delta_xFR[ii]);
-			if (zero < a) zero = a;
-		}
-
-		/* relative test against zero in inf-norm */
-		if (zero > options.epsLITests * weight)
-			returnvalue = RET_LINEARLY_INDEPENDENT;
-
-		delete[] nul;
-		delete[] delta_yFX;
-		delete[] delta_yAC;
-		delete[] delta_xFR;
-		delete[] delta_xFX;
-		delete[] delta_g;
-
-	}
-	else
-	{
-		/*
-		 * cheap LI test for simple bound. Check if constraint <number> is
-		 * linearly independent from the the active ones (<=> is element of null
-		 * space of Afr).
-		 */
-
-		/* some definitions */
-		int_t nZ  = getNZ( );
-
-		for( i=0; i<nZ; ++i )
-			if ( getAbs( QQ(number,i) ) > options.epsLITests )
-			{
-				returnvalue = RET_LINEARLY_INDEPENDENT;
-				break;
-			}
-	}
-
-	return THROWINFO( returnvalue );
-}
-
-
-/*
- *	a d d B o u n d _ e n s u r e L I
- */
-returnValue QProblem::addBound_ensureLI( int_t number, SubjectToStatus B_status )
-{
-	int_t i, ii;
-	int_t nV  = getNV( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addBound_checkLI( number );
-
-	if ( returnvalueCheckLI == RET_INDEXLIST_CORRUPTED )
-		return THROWERROR( RET_ENSURELI_FAILED );
-
-	if ( returnvalueCheckLI == RET_LINEARLY_INDEPENDENT )
-		return SUCCESSFUL_RETURN;
-
-
- 	/* II) NEW BOUND IS LINEARLY DEPENDENT: */
-	/* 1) Determine coefficients of linear combination,
-	 *    cf. M.J. Best. Applied Mathematics and Parallel Computing, chapter:
-	 *    An Algorithm for the Solution of the Parametric Quadratic Programming
-	 *    Problem, pages 57-76. Physica-Verlag, Heidelberg, 1996. */
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	real_t* xiC = new real_t[nAC];
-	real_t* xiC_TMP = new real_t[nAC];
-	real_t* xiB = new real_t[nFX];
-	real_t* num = new real_t[nV];
-
-	real_t y_min = options.maxDualJump;
-	int_t y_min_number = -1;
-	int_t y_min_number_bound = -1;
-	BooleanType y_min_isBound = BT_FALSE;
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-
-	/* 2) Calculate xiC. */
-	if ( nAC > 0 )
-	{
-		if ( B_status == ST_LOWER )
-		{
-			for( i=0; i<nAC; ++i )
-				xiC_TMP[i] = QQ(number,nZ+i);
-		}
-		else
-		{
-			for( i=0; i<nAC; ++i )
-				xiC_TMP[i] = -QQ(number,nZ+i);
-		}
-
-		if ( backsolveT( xiC_TMP, BT_TRUE, xiC ) != SUCCESSFUL_RETURN )
-		{
-			returnvalue = RET_ENSURELI_FAILED_TQ;
-			goto farewell;
-		}
-	}
-
-	/* 3) Calculate xiB. */
-	A->transTimes(constraints.getActive(), bounds.getFixed(), 1, -1.0, xiC, nAC, 0.0, xiB, nFX);
-
-
-	/* III) DETERMINE CONSTRAINT/BOUND TO BE REMOVED. */
-
-	/* 1) Constraints. */
-	for( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-		num[i] = y[nV+ii];
-	}
-
-	performRatioTest( nAC,AC_idx,&constraints, num,xiC, options.epsNum,options.epsDen, y_min,y_min_number );
-
-	/* 2) Bounds. */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-	}
-
-	performRatioTest( nFX,FX_idx,&bounds, num,xiB, options.epsNum,options.epsDen, y_min,y_min_number_bound );
-
-	if ( y_min_number_bound >= 0 )
-	{
-		y_min_number = y_min_number_bound;
-		y_min_isBound = BT_TRUE;
-	}
-
-	/* IV) REMOVE CONSTRAINT/BOUND FOR RESOLVING LINEAR DEPENDENCE: */
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-	if ( y_min_number >= 0 )
-	{
-		/* Update Lagrange multiplier... */
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			y[nV+ii] -= y_min * xiC[i];
-		}
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			y[ii] -= y_min * xiB[i];
-		}
-
-		/* ... also for newly active bound ... */
-		if ( B_status == ST_LOWER )
-			y[number] = y_min;
-		else
-			y[number] = -y_min;
-
-		/* ... and for bound to be removed. */
-		if ( y_min_isBound == BT_TRUE )
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			snprintf( messageString,MAX_STRING_LENGTH,"bound no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeBound( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemB = 1;
-
-			y[y_min_number] = 0.0;
-		}
-		else
-		{
-			#ifndef __SUPPRESSANYOUTPUT__
-			snprintf( messageString,MAX_STRING_LENGTH,"constraint no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeConstraint( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemC = 1;
-
-			y[nV+y_min_number] = 0.0;
-		}
-	}
-	else
-	{
-		if (options.enableDropInfeasibles == BT_TRUE) {
-			/* dropping of infeasible constraints according to drop priorities */
-			returnvalue = dropInfeasibles (number, B_status, BT_TRUE, xiB, xiC);
-		}
-		else
-		{
-			/* no constraint/bound can be removed => QP is infeasible! */
-			returnvalue = RET_ENSURELI_FAILED_NOINDEX;
-			setInfeasibilityFlag( returnvalue );
-		}
-	}
-
-farewell:
-	delete[] num;
-	delete[] xiB;
-	delete[] xiC_TMP;
-	delete[] xiC;
-
-	getGlobalMessageHandler( )->throwInfo( RET_LI_RESOLVED,0,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-
-	return ( (returnvalue != SUCCESSFUL_RETURN) && (returnvalue != RET_ENSURELI_FAILED_NOINDEX ) ) ? THROWERROR (returnvalue) : returnvalue;
-}
-
-
-
-/*
- *	r e m o v e C o n s t r a i n t
- */
-returnValue QProblem::removeConstraint(	int_t number,
-										BooleanType updateCholesky,
-										BooleanType allowFlipping,
-										BooleanType ensureNZC
-										)
-{
-	int_t i, j, ii, jj;
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-	BooleanType hasFlipped = BT_FALSE;
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* some definitions */
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-	int_t tcol = sizeT - nAC;
-	int_t number_idx = constraints.getActive( )->getIndex( number );
-
-	int_t addIdx;
-	BooleanType addBoundNotConstraint;
-	SubjectToStatus addStatus;
-	BooleanType exchangeHappened = BT_FALSE;
-
-
-	/* consistency checks */
-	if ( constraints.getStatus( number ) == ST_INACTIVE )
-		return THROWERROR( RET_CONSTRAINT_NOT_ACTIVE );
-
-	if ( ( number_idx < 0 ) || ( number_idx >= nAC ) )
-		return THROWERROR( RET_CONSTRAINT_NOT_ACTIVE );
-
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	/* N) PERFORM ZERO CURVATURE TEST. */
-	if (ensureNZC == BT_TRUE)
-	{
-		returnvalue = ensureNonzeroCurvature(BT_FALSE, number, exchangeHappened, addBoundNotConstraint, addIdx, addStatus);
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return returnvalue;
-	}
-
-	/* save index sets and decompositions for flipping bounds strategy */
-	if ( ( exchangeHappened == BT_FALSE ) && ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) )
-		flipper.set( &bounds,R,&constraints,Q,T );
-
-	/* I) REMOVE <number>th ROW FROM T,
-	 *    i.e. shift rows number+1 through nAC  upwards (instead of the actual
-	 *    constraint number its corresponding index within matrix A is used). */
-	if ( number_idx < nAC-1 )
-	{
-		for( i=(number_idx+1); i<nAC; ++i )
-			for( j=(nAC-i-1); j<nAC; ++j )
-				TT(i-1,tcol+j) = TT(i,tcol+j);
-		/* gimmick: write zeros into the last row of T */
-		for( j=0; j<nAC; ++j )
-			TT(nAC-1,tcol+j) = 0.0;
-
-
-		/* II) RESTORE TRIANGULAR FORM OF T,
-		 *     use column-wise Givens rotations to restore reverse triangular form
-		 *     of T simultanenous change of Q (i.e. Y). */
-		real_t c, s, nu;
-
-		for( j=(nAC-2-number_idx); j>=0; --j )
-		{
-			computeGivens( TT(nAC-2-j,tcol+1+j),TT(nAC-2-j,tcol+j), TT(nAC-2-j,tcol+1+j),TT(nAC-2-j,tcol+j),c,s );
-			nu = s/(1.0+c);
-
-			for( i=(nAC-j-1); i<(nAC-1); ++i )
-				applyGivens( c,s,nu,TT(i,tcol+1+j),TT(i,tcol+j), TT(i,tcol+1+j),TT(i,tcol+j) );
-
-			for( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				applyGivens( c,s,nu,QQ(ii,nZ+1+j),QQ(ii,nZ+j), QQ(ii,nZ+1+j),QQ(ii,nZ+j) );
-			}
-		}
-	}
-	else
-	{
-		/* gimmick: write zeros into the last row of T */
-		for( j=0; j<nAC; ++j )
-			TT(nAC-1,tcol+j) = 0.0;
-	}
-
-
-	if ( ( updateCholesky == BT_TRUE ) &&
-		 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-	{
-		/* III) UPDATE CHOLESKY DECOMPOSITION,
-		 *      calculate new additional column (i.e. [r sqrt(rho2)]')
-		 *      of the Cholesky factor R. */
-		real_t* Hz = new real_t[nFR];
-		real_t* z = new real_t[nFR];
-		real_t rho2 = 0.0;
-
-		/* 1) Calculate Hz = H*z, where z is the new rightmost column of Z
-		 *    (i.e. the old leftmost column of Y).  */
-		for( j=0; j<nFR; ++j )
-			z[j] = QQ(FR_idx[j],nZ);
-		H->times(bounds.getFree(), bounds.getFree(), 1, 1.0, z, nFR, 0.0, Hz, nFR);
-		delete[] z;
-
-		if ( nZ > 0 )
-		{
-			real_t* ZHz = new real_t[nZ];
-			for ( i=0; i<nZ; ++i )
-				ZHz[i] = 0.0;
-			real_t* r = new real_t[nZ];
-
-			/* 2) Calculate ZHz = Z'*Hz (old Z). */
-			for( j=0; j<nFR; ++j )
-			{
-				jj = FR_idx[j];
-
-				for( i=0; i<nZ; ++i )
-					ZHz[i] += QQ(jj,i) * Hz[j];
-			}
-
-			/* 3) Calculate r = R^-T * ZHz. */
-			if ( backsolveR( ZHz,BT_TRUE,r ) != SUCCESSFUL_RETURN )
-			{
-				delete[] Hz; delete[] r; delete[] ZHz;
-				return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-			}
-
-			/* 4) Calculate rho2 = rho^2 = z'*Hz - r'*r
-			 *    and store r into R. */
-			for( i=0; i<nZ; ++i )
-			{
-				rho2 -= r[i]*r[i];
-				RR(i,nZ) = r[i];
-			}
-
-			delete[] r; delete[] ZHz;
-		}
-
-		/* 5) Store rho into R. */
-		for( j=0; j<nFR; ++j )
-			rho2 += QQ(FR_idx[j],nZ) * Hz[j];
-
-		delete[] Hz;
-
-		if ( ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) && ( exchangeHappened == BT_FALSE ) )
-		{
-			if ( rho2 > options.epsFlipping )
-				RR(nZ,nZ) = getSqrt( rho2 );
-			else
-			{
-				hessianType = HST_SEMIDEF;
-
-				flipper.get( &bounds,R,&constraints,Q,T );
-				constraints.flipFixed(number);
-				tabularOutput.idxAddC = number;
-				tabularOutput.excAddC = 2;
-
-				switch (constraints.getStatus(number))
-				{
-					case ST_LOWER:
-						lbA[number] = ubA[number]; Ax_l[number] = -Ax_u[number]; break;
-					case ST_UPPER:
-						ubA[number] = lbA[number]; Ax_u[number] = -Ax_l[number]; break;
-					default:
-						return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-
-				hasFlipped = BT_TRUE;
-			}
-		}
-		else if ( exchangeHappened == BT_FALSE )
-		{
-			if ( rho2 > ZERO )
-				RR(nZ,nZ) = getSqrt( rho2 );
-			else
-			{
-				if ( allowFlipping == BT_FALSE )
-				{
-					RR(nZ,nZ) = 100.0*EPS;
-				}
-				else
-				{
-					hessianType = HST_SEMIDEF;
-					return THROWERROR( RET_HESSIAN_NOT_SPD );
-				}
-			}
-		}
-	}
-
-
-	/* IV) UPDATE INDICES */
-	tabularOutput.idxRemC = number;
-	if ( hasFlipped == BT_FALSE )
-	{
-		if ( constraints.moveActiveToInactive( number ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-	}
-
-	if (exchangeHappened == BT_TRUE)
-	{
-		/* add bound or constraint */
-
-		/* hessianType = HST_SEMIDEF; */
-		RR(nZ,nZ) = 0.0;
-
-		if ( addBoundNotConstraint )
-		{
-			addBound(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddB = 1;
-		}
-		else
-		{
-			addConstraint(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddC = 1;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e B o u n d
- */
-returnValue QProblem::removeBound(	int_t number,
-									BooleanType updateCholesky,
-									BooleanType allowFlipping,
-									BooleanType ensureNZC
-									)
-{
-	int_t i, j, ii, jj;
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-	int_t addIdx;
-	BooleanType addBoundNotConstraint;
-	SubjectToStatus addStatus;
-	BooleanType exchangeHappened = BT_FALSE;
-
-
-	/* consistency checks */
-	if ( bounds.getStatus( number ) == ST_INACTIVE )
-		return THROWERROR( RET_BOUND_NOT_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* some definitions */
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-	int_t tcol = sizeT - nAC;
-
-	/* 0) PERFORM ZERO CURVATURE TEST. */
-	if (ensureNZC == BT_TRUE)
-	{
-		returnvalue = ensureNonzeroCurvature(BT_TRUE, number, exchangeHappened, addBoundNotConstraint, addIdx, addStatus);
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return returnvalue;
-	}
-
-	/* save index sets and decompositions for flipping bounds strategy */
-	if ( ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) && ( exchangeHappened == BT_FALSE ) )
-		flipper.set( &bounds,R,&constraints,Q,T );
-
-	/* I) UPDATE INDICES */
-	tabularOutput.idxRemB = number;
-	if ( bounds.moveFixedToFree( number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	/* I) APPEND <nFR+1>th UNITY VECTOR TO Q. */
-	int_t nnFRp1 = FR_idx[nFR];
-	for( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		QQ(ii,nFR) = 0.0;
-		QQ(nnFRp1,i) = 0.0;
-	}
-	QQ(nnFRp1,nFR) = 1.0;
-
-	if ( nAC > 0 )
-	{
-		/* store new column a in a temporary vector instead of shifting T one column to the left and appending a */
-		int_t* AC_idx;
-		constraints.getActive( )->getNumberArray( &AC_idx );
-
-		real_t* tmp = new real_t[nAC];
-		A->getCol(number, constraints.getActive(), 1.0, tmp);
-
-
-		/* II) RESTORE TRIANGULAR FORM OF T,
-		 *     use column-wise Givens rotations to restore reverse triangular form
-		 *     of T = [T A(:,number)], simultanenous change of Q (i.e. Y and Z). */
-		real_t c, s, nu;
-
-		for( j=(nAC-1); j>=0; --j )
-		{
-			computeGivens( tmp[nAC-1-j],TT(nAC-1-j,tcol+j),TT(nAC-1-j,tcol+j),tmp[nAC-1-j],c,s );
-			nu = s/(1.0+c);
-
-			for( i=(nAC-j); i<nAC; ++i )
-				applyGivens( c,s,nu,tmp[i],TT(i,tcol+j),TT(i,tcol+j),tmp[i] );
-
-			for( i=0; i<=nFR; ++i )
-			{
-				ii = FR_idx[i];
-				/* nZ+1+nAC = nFR+1  /  nZ+(1) = nZ+1 */
-				applyGivens( c,s,nu,QQ(ii,nZ+1+j),QQ(ii,nZ+j),QQ(ii,nZ+1+j),QQ(ii,nZ+j) );
-			}
-		}
-
-		delete[] tmp;
-	}
-
-
-	if ( ( updateCholesky == BT_TRUE ) &&
-	     ( hessianType != HST_ZERO ) && ( hessianType != HST_IDENTITY ) )
-	{
-		/* III) UPDATE CHOLESKY DECOMPOSITION,
-		 *      calculate new additional column (i.e. [r sqrt(rho2)]')
-		 *      of the Cholesky factor R: */
-		real_t z2 = QQ(nnFRp1,nZ);
-		real_t rho2 = H->diag(nnFRp1) * z2*z2;
-
-		if ( nFR > 0 )
-		{
-			/* Attention: Index list of free variables has already grown by one! */
-			real_t* Hz = new real_t[nFR+1];
-			real_t* z = new real_t[nFR+1];
-			/* 1) Calculate R'*r = Zfr'*Hfr*z1 + z2*Zfr'*h1 =: Zfr'*Hz + z2*Zfr'*h1 =: rhs and
-			 *    rho2 = z1'*Hfr*z1 + 2*z2*h1'*z1 + h2*z2^2 - r'*r =: z1'*Hz + 2*z2*h1'*z1 + h2*z2^2 - r'r */
-			for( j=0; j<nFR; ++j )
-				z[j] = QQ(FR_idx[j],nZ);
-			z[nFR] = 0.0;
-
-			H->times(bounds.getFree(), bounds.getFree(), 1, 1.0, z, nFR+1, 0.0, Hz, nFR+1);
-			H->getCol(nnFRp1, bounds.getFree(), 1.0, z);
-
-			if ( nZ > 0 )
-			{
-				real_t* r = new real_t[nZ];
-				real_t* rhs = new real_t[nZ];
-				for( i=0; i<nZ; ++i )
-					rhs[i] = 0.0;
-
-				/* 2) Calculate rhs. */
-				for( j=0; j<nFR; ++j )
-				{
-					jj = FR_idx[j];
-					for( i=0; i<nZ; ++i )
-										/* Zfr' * ( Hz + z2*h1 ) */
-						rhs[i] += QQ(jj,i) * ( Hz[j] + z2 * z[j] );
-				}
-
-				/* 3) Calculate r = R^-T * rhs. */
-				if ( backsolveR( rhs,BT_TRUE,BT_TRUE,r ) != SUCCESSFUL_RETURN )
-				{
-					delete[] z;
-					delete[] Hz; delete[] r; delete[] rhs;
-					return THROWERROR( RET_REMOVEBOUND_FAILED );
-				}
-
-
-				/* 4) Calculate rho2 = rho^2 = z'*Hz - r'*r
-				 *    and store r into R. */
-				for( i=0; i<nZ; ++i )
-				{
-					rho2 -= r[i]*r[i];
-					RR(i,nZ) = r[i];
-				}
-
-				delete[] rhs; delete[] r;
-			}
-
-			for( j=0; j<nFR; ++j )
-			{
-				jj = FR_idx[j];
-							/* z1' * ( Hz + 2*z2*h1 ) */
-				rho2 += QQ(jj,nZ) * ( Hz[j] + 2.0*z2*z[j] );
-			}
-
-			delete[] z;
-			delete[] Hz;
-		}
-
-		/* 5) Store rho into R. */
-		if ( ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) && ( exchangeHappened == BT_FALSE ) )
-		{
-			if ( rho2 > options.epsFlipping )
-				RR(nZ,nZ) = getSqrt( rho2 );
-			else
-			{
-				if ( hessianType != HST_ZERO )
-					hessianType = HST_SEMIDEF;
-
-				flipper.get( &bounds,R,&constraints,Q,T );
-				bounds.flipFixed(number);
-				tabularOutput.idxAddB = number;
-				tabularOutput.excAddB = 2;
-
-				switch (bounds.getStatus(number))
-				{
-					case ST_LOWER:
-						lb[number] = ub[number];
-						break;
-					case ST_UPPER:
-						ub[number] = lb[number];
-						break;
-					default: return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-
-			}
-		}
-		else if ( exchangeHappened == BT_FALSE )
-		{
-			if ( rho2 > ZERO )
-				RR(nZ,nZ) = getSqrt( rho2 );
-			else
-			{
-				if ( allowFlipping == BT_FALSE )
-					RR(nZ,nZ) = 100.0*EPS;
-				else
-				{
-					hessianType = HST_SEMIDEF;
-					return THROWERROR( RET_HESSIAN_NOT_SPD );
-				}
-			}
-		}
-		else
-		{
-			/* add bound or constraint */
-
-			/* hessianType = HST_SEMIDEF; */
-			RR(nZ,nZ) = 0.0;
-
-			if ( addBoundNotConstraint )
-			{
-				addBound(addIdx, addStatus, BT_TRUE, BT_FALSE);
-				tabularOutput.excAddB = 1;
-			}
-			else
-			{
-				addConstraint(addIdx, addStatus, BT_TRUE, BT_FALSE);
-				tabularOutput.excAddC = 1;
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-returnValue QProblem::performPlainRatioTest(	int_t nIdx,
-												const int_t* const idxList,
-												const real_t* const num,
-												const real_t* const den,
-												real_t epsNum,
-												real_t epsDen,
-												real_t& t,
-												int_t& BC_idx
-												) const
-{
-	int_t i;
-	for (i = 0; i < nIdx; i++)
-		if ( (num[i] > epsNum) && (den[i] > epsDen) && (t * den[i] > num[i]) )
-		{
-			t = num[i] / den[i];
-			BC_idx = idxList[i];
-		}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue QProblem::ensureNonzeroCurvature(	BooleanType removeBoundNotConstraint,
-												int_t remIdx,
-												BooleanType &exchangeHappened,
-												BooleanType &addBoundNotConstraint,
-												int_t &addIdx,
-												SubjectToStatus &addStatus
-												)
-{
-	int_t i, ii;
-	int_t addLBndIdx = -1, addLCnstrIdx = -1, addUBndIdx = -1, addUCnstrIdx = -1; /* exchange indices */
-	int_t *FX_idx, *AC_idx, *IAC_idx;
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-	int_t nC  = getNC( );
-	int_t nFX = getNFX( );
-	int_t nIAC = getNIAC( );
-
-	int_t* FR_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-// 	real_t *delta_g   = new real_t[nV];
-	real_t *delta_xFX = new real_t[nFX];
-	real_t *delta_xFR = new real_t[nFR];
-	real_t *delta_yAC = new real_t[nAC];
-	real_t *delta_yFX = new real_t[nFX];
-
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-	constraints.getInactive( )->getNumberArray( &IAC_idx );
-
-	addBoundNotConstraint = BT_TRUE;
-	addStatus = ST_INACTIVE;
-	exchangeHappened = BT_FALSE;
-
-	if (removeBoundNotConstraint)
-	{
-		int_t dim = nV < nC ? nC : nV;
-		real_t *nul = new real_t[dim];
-		real_t *ek = new real_t[nV]; /* minus e_k (bound k is removed) */
-		for (ii = 0; ii < dim; ++ii)
-			nul[ii]=0.0;
-		for (ii = 0; ii < nV; ++ii)
-			ek[ii]=0.0;
-		ek[remIdx] = bounds.getStatus(remIdx) == ST_LOWER ? 1.0 : -1.0;
-
-		returnvalue = determineStepDirection (nul, nul, nul, ek, ek,
-											  BT_FALSE, BT_FALSE,
-											  delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		delete[] ek;
-		delete[] nul;
-	}
-	else
-	{
-		real_t *nul = new real_t[nV];
-		real_t *ek = new real_t[nC]; /* minus e_k (constraint k is removed) */
-		for (ii = 0; ii < nV; ++ii)
-			nul[ii]=0.0;
-		for (ii = 0; ii < nC; ++ii)
-			ek[ii]=0.0;
-		ek[remIdx] = constraints.getStatus(remIdx) == ST_LOWER ? 1.0 : -1.0;
-
-		returnvalue = determineStepDirection (nul,
-											  ek, ek, nul, nul,
-											  BT_FALSE, BT_TRUE,
-											  delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		delete[] ek;
-		delete[] nul;
-	}
-
-	/* compute the weight in inf-norm */
-	real_t normXi = 0.0;
-	for (ii = 0; ii < nAC; ++ii)
-	{
-		real_t a = getAbs (delta_yAC[ii]);
-		if (normXi < a) normXi = a;
-	}
-	for (ii = 0; ii < nFX; ++ii)
-	{
-		real_t a = getAbs (delta_yFX[ii]);
-		if (normXi < a) normXi = a;
-	}
-
-	/* look at the "zero" in a relative inf-norm */
-	real_t normS = 0.0;
-	for (ii = 0; ii < nFX; ++ii)
-	{
-		real_t a = getAbs (delta_xFX[ii]);
-		if (normS < a) normS = a;
-	}
-	for (ii = 0; ii < nFR; ++ii)
-	{
-		real_t a = getAbs (delta_xFR[ii]);
-		if (normS < a) normS = a;
-	}
-
-	/* relative test against zero in inf-norm */
-	if (normXi < options.epsNZCTests * normS)
-	{
-		/* determine jump in x via ratio tests */
-		real_t sigmaLBnd, sigmaLCnstr, sigmaUBnd, sigmaUCnstr, sigma;
-
-		/* bounds */
-
-		/* compress x-u */
-		real_t *x_W = new real_t[getMax(1,nFR)];
-		for (i = 0; i < nFR; i++)
-		{
-			ii = FR_idx[i];
-			x_W[i] = ub[ii] - x[ii];
-		}
-		/* performRatioTest( nFR,FR_idx,&bounds, x_W,delta_xFR, options.epsNum,options.epsDen, sigmaUBnd,addUBndIdx ); */
-		sigmaUBnd = options.maxPrimalJump;
-		addUBndIdx = -1;
-		performPlainRatioTest(nFR, FR_idx, x_W, delta_xFR, options.epsNum, options.epsDen, sigmaUBnd, addUBndIdx);
-		if (removeBoundNotConstraint == BT_TRUE && bounds.getStatus(remIdx) == ST_LOWER)
-		{
-			/* also consider bound which is to be removed */
-			real_t one = 1.0;
-			x_W[0] = ub[remIdx] - x[remIdx];
-			performPlainRatioTest(1, &remIdx, x_W, &one, options.epsNum, options.epsDen, sigmaUBnd, addUBndIdx);
-		}
-
-		/* compress x-l */
-		for (i = 0; i < nFR; i++)
-		{
-			ii = FR_idx[i];
-			x_W[i] = x[ii] - lb[ii];
-		}
-		for (i = 0; i < nFR; i++)
-			delta_xFR[i] = -delta_xFR[i];
-		/* performRatioTest( nFR,FR_idx,&bounds, x_W,delta_xFR, options.epsNum,options.epsDen, sigmaLBnd,addLBndIdx ); */
-		sigmaLBnd = options.maxPrimalJump;
-		addLBndIdx = -1;
-		performPlainRatioTest(nFR, FR_idx, x_W, delta_xFR, options.epsNum, options.epsDen, sigmaLBnd, addLBndIdx);
-		if (removeBoundNotConstraint == BT_TRUE && bounds.getStatus(remIdx) == ST_UPPER)
-		{
-			/* also consider bound which is to be removed */
-			real_t one = 1.0;
-			x_W[0] = x[remIdx] - lb[remIdx];
-			performPlainRatioTest(1, &remIdx, x_W, &one, options.epsNum, options.epsDen, sigmaLBnd, addLBndIdx);
-		}
-		for (i = 0; i < nFR; i++)
-			delta_xFR[i] = -delta_xFR[i];
-
-		delete[] x_W;
-
-		/* constraints */
-
-		/* compute As (compressed to inactive constraints) */
-		real_t *As = new real_t[nIAC];
-		A->times(constraints.getInactive(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 0.0, As, nIAC);
-		A->times(constraints.getInactive(), bounds.getFree(), 1, 1.0, delta_xFR, nFR, 1.0, As, nIAC);
-
-		/* compress Ax_u */
-		real_t *Ax_W = new real_t[nIAC];
-		for (i = 0; i < nIAC; i++)
-		{
-			ii = IAC_idx[i];
-			Ax_W[i] = Ax_u[ii];
-		}
-		/* performRatioTest( nIAC,IAC_idx,&constraints, Ax_W,As, options.epsNum,options.epsDen, sigmaUCnstr,addUCnstrIdx ); */
-		sigmaUCnstr = options.maxPrimalJump;
-		addUCnstrIdx = -1;
-		performPlainRatioTest(nIAC, IAC_idx, Ax_W, As, options.epsNum, options.epsDen, sigmaUCnstr, addUCnstrIdx);
-		if (removeBoundNotConstraint == BT_FALSE && constraints.getStatus(remIdx) == ST_LOWER)
-		{
-			/* also consider constraint which is to be removed */
-			real_t one = 1.0;
-			performPlainRatioTest(1, &remIdx, &Ax_u[remIdx], &one, options.epsNum, options.epsDen, sigmaUCnstr, addUCnstrIdx);
-		}
-
-		/* compress Ax_l */
-		for (i = 0; i < nIAC; i++)
-		{
-			ii = IAC_idx[i];
-			Ax_W[i] = Ax_l[ii];
-		}
-		for (i = 0; i < nIAC; i++)
-			As[i] = -As[i];
-		/* performRatioTest( nIAC,IAC_idx,&constraints, Ax_W,As, options.epsNum,options.epsDen, sigmaLCnstr,addLCnstrIdx ); */
-		sigmaLCnstr = options.maxPrimalJump;
-		addLCnstrIdx = -1;
-		performPlainRatioTest(nIAC, IAC_idx, Ax_W, As, options.epsNum, options.epsDen, sigmaLCnstr, addLCnstrIdx);
-		if (removeBoundNotConstraint == BT_FALSE && constraints.getStatus(remIdx) == ST_UPPER)
-		{
-			/* also consider constraint which is to be removed */
-			real_t one = 1.0;
-			performPlainRatioTest(1, &remIdx, &Ax_l[remIdx], &one, options.epsNum, options.epsDen, sigmaLCnstr, addLCnstrIdx);
-		}
-
-		/* perform primal jump */
-		sigma = options.maxPrimalJump;
-		if (sigmaUCnstr < sigma) { sigma = sigmaUCnstr; addStatus = ST_UPPER; addBoundNotConstraint = BT_FALSE; addIdx = addUCnstrIdx; }
-		if (sigmaLCnstr < sigma) { sigma = sigmaLCnstr; addStatus = ST_LOWER; addBoundNotConstraint = BT_FALSE; addIdx = addLCnstrIdx; }
-		if (sigmaUBnd < sigma) { sigma = sigmaUBnd; addStatus = ST_UPPER; addBoundNotConstraint = BT_TRUE; addIdx = addUBndIdx; }
-		if (sigmaLBnd < sigma) { sigma = sigmaLBnd; addStatus = ST_LOWER; addBoundNotConstraint = BT_TRUE; addIdx = addLBndIdx; }
-
-		if (sigma >= options.maxPrimalJump)
-		{
-			unbounded = BT_TRUE;
-			returnvalue = RET_HOTSTART_STOPPED_UNBOUNDEDNESS;
-		}
-		else
-		{
-			for (i = 0; i < nFR; i++)
-				x[FR_idx[i]] += sigma * delta_xFR[i];
-
-			for (i = 0; i < nFX; i++)
-				x[FX_idx[i]] += sigma * delta_xFX[i];
-
-			/* update Ax, Ax_u, and Ax_l */
-			A->times(1, 1.0, x, nV, 0.0, Ax, nC);
-			for (i = 0; i < nC; i++) Ax_u[i] = ubA[i] - Ax[i];
-			for (i = 0; i < nC; i++) Ax_l[i] = Ax[i] - lbA[i];
-
-			/* change working set later */
-			exchangeHappened = BT_TRUE;
-		}
-
-		delete[] Ax_W;
-		delete[] As;
-	}
-
-	delete[] delta_yFX;
-	delete[] delta_yAC;
-	delete[] delta_xFR;
-	delete[] delta_xFX;
-// 	delete[] delta_g;
-
-	return returnvalue;
-}
-
-
-
-/*
- *	b a c k s o l v e T
- */
-returnValue QProblem::backsolveT( const real_t* const b, BooleanType transposed, real_t* const a ) const
-{
-	int_t i, j;
-	int_t nT = getNAC( );
-	int_t tcol = sizeT - nT;
-
-	real_t sum;
-
-	/* nothing to do */
-	if ( nT <= 0 )
-		return SUCCESSFUL_RETURN;
-
-
-	/* Solve Ta = b, where T might be transposed. */
-	if ( transposed == BT_FALSE )
-	{
-		/* solve Ta = b */
-		for( i=0; i<nT; ++i )
-		{
-			sum = b[i];
-			for( j=0; j<i; ++j )
-				sum -= TT(i,sizeT-1-j) * a[nT-1-j];
-
-			if ( getAbs( TT(i,sizeT-1-i) ) > EPS )
-				a[nT-1-i] = sum / TT(i,sizeT-1-i);
-			else
-				return THROWERROR( RET_DIV_BY_ZERO );
-		}
-	}
-	else
-	{
-		/* solve T^T*a = b */
-		for( i=0; i<nT; ++i )
-		{
-			sum = b[i];
-			for( j=0; j<i; ++j )
-				sum -= TT(nT-1-j,tcol+i) * a[nT-1-j];
-
-			if ( getAbs( TT(nT-1-i,tcol+i) ) > EPS )
-				a[nT-1-i] = sum / TT(nT-1-i,tcol+i);
-			else
-				return THROWERROR( RET_DIV_BY_ZERO );
-		}
-	}
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	d e t e r m i n e D a t a S h i f t
- */
-returnValue QProblem::determineDataShift(	const real_t* const g_new, const real_t* const lbA_new, const real_t* const ubA_new,
-											const real_t* const lb_new, const real_t* const ub_new,
-											real_t* const delta_g, real_t* const delta_lbA, real_t* const delta_ubA,
-											real_t* const delta_lb, real_t* const delta_ub,
-											BooleanType& Delta_bC_isZero, BooleanType& Delta_bB_isZero
-											)
-{
-	int_t i, ii;
-	int_t nC  = getNC( );
-	int_t nAC = getNAC( );
-
-	int_t* FX_idx;
-	int_t* AC_idx;
-
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-
-
-	/* I) DETERMINE DATA SHIFT FOR BOUNDS */
-	QProblemB::determineDataShift(	g_new,lb_new,ub_new,
-									delta_g,delta_lb,delta_ub,
-									Delta_bB_isZero );
-
-
-	/* II) DETERMINE DATA SHIFT FOR CONSTRAINTS */
-	/* 1) Calculate shift directions. */
-	for( i=0; i<nC; ++i )
-	{
-		/* if lower constraints' bounds are to be disabled or do not exist, shift them to -infinity */
-		if ( lbA_new != 0 )
-			delta_lbA[i] = lbA_new[i] - lbA[i];
-		else
-			delta_lbA[i] = -INFTY - lbA[i];
-	}
-
-	for( i=0; i<nC; ++i )
-	{
-		/* if upper constraints' bounds are to be disabled or do not exist, shift them to infinity */
-		if ( ubA_new != 0 )
-			delta_ubA[i] = ubA_new[i] - ubA[i];
-		else
-			delta_ubA[i] = INFTY - ubA[i];
-	}
-
-	/* 2) Determine if active constraints' bounds are to be shifted. */
-	Delta_bC_isZero = BT_TRUE;
-
-	for ( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-
-		if ( ( getAbs( delta_lbA[ii] ) > EPS ) || ( getAbs( delta_ubA[ii] ) > EPS ) )
-		{
-			Delta_bC_isZero = BT_FALSE;
-			break;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	d e t e r m i n e S t e p D i r e c t i o n
- */
-returnValue QProblem::determineStepDirection(	const real_t* const delta_g, const real_t* const delta_lbA, const real_t* const delta_ubA,
-												const real_t* const delta_lb, const real_t* const delta_ub,
-												BooleanType Delta_bC_isZero, BooleanType Delta_bB_isZero,
-												real_t* const delta_xFX, real_t* const delta_xFR,
-												real_t* const delta_yAC, real_t* const delta_yFX
-												)
-{
-	int_t i, j, ii, jj, r;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-	int_t nZ  = getNZ( );
-
-	int_t* FR_idx;
-	int_t* FX_idx;
-	int_t* AC_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-
-	/* I) DETERMINE delta_xFX (this is exact, does not need refinement) */
-	if ( Delta_bB_isZero == BT_FALSE )
-	{
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-
-			if ( bounds.getStatus( ii ) == ST_LOWER )
-				delta_xFX[i] = delta_lb[ii];
-			else
-				delta_xFX[i] = delta_ub[ii];
-		}
-	}
-	else
-	{
-		for( i=0; i<nFX; ++i )
-			delta_xFX[i] = 0.0;
-	}
-
-
-	/* tempA and tempB hold the residuals in gFR and bA (= lbA or ubA)
-	 * delta_xFR, delta_yAC hold the steps that get refined */
-	for ( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		tempA[i] = delta_g[ii];
-		delta_xFR[i] = 0.0;
-	}
-	for ( i=0; i<nAC; ++i )
-		delta_yAC[i] = 0.0;
-	if ( Delta_bC_isZero == BT_FALSE )
-	{
-		for ( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			if ( constraints.getStatus( ii ) == ST_LOWER )
-				tempB[i] = delta_lbA[ii];
-			else
-				tempB[i] = delta_ubA[ii];
-		}
-	}
-	else
-	{
-		for ( i=0; i<nAC; ++i )
-			tempB[i] = 0.0;
-	}
-
-	/* Iterative refinement loop for delta_xFRz, delta_xFRy, delta_yAC */
-	for ( r=0; r<=options.numRefinementSteps; ++r )
-	{
-		/* II) DETERMINE delta_xFR */
-		if ( nFR > 0 )
-		{
-			for( i=0; i<nFR; ++i )
-				delta_xFR_TMP[i] = 0.0;
-
-			/* 1) Determine delta_xFRy. */
-			if ( nAC > 0 )
-			{
-				if ( ( Delta_bC_isZero == BT_TRUE ) && ( Delta_bB_isZero == BT_TRUE ) )
-				{
-					for( i=0; i<nAC; ++i )
-						delta_xFRy[i] = 0.0;
-				}
-				else
-				{
-					/* compute bA - A * delta_xFX. tempB already holds bA->
-					 * in refinements r>=1, delta_xFX is exactly zero */
-					if ( ( Delta_bB_isZero == BT_FALSE ) && ( r == 0 ) )
-						A->times(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, tempB, nAC);
-
-					if ( backsolveT( tempB, BT_FALSE, delta_xFRy ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_STEPDIRECTION_FAILED_TQ );
-
-					for( i=0; i<nFR; ++i )
-					{
-						ii = FR_idx[i];
-						for( j=0; j<nAC; ++j )
-							delta_xFR_TMP[i] += QQ(ii,nZ+j) * delta_xFRy[j];
-					}
-				}
-			}
-
-
-			/* 2) Determine delta_xFRz. */
-			for( i=0; i<nZ; ++i )
-				delta_xFRz[i] = 0.0;
-
-			if ( ( hessianType == HST_ZERO ) || ( hessianType == HST_IDENTITY ) )
-			{
-				/* compute Z*delta_gFR [/eps] (delta_gFR is stored in tempA) */
-				for( j=0; j<nFR; ++j )
-				{
-					jj = FR_idx[j];
-					for( i=0; i<nZ; ++i )
-						delta_xFRz[i] -= QQ(jj,i) * tempA[j];
-				}
-
-				if ( hessianType == HST_ZERO )
-				{
-					if ( usingRegularisation( ) == BT_TRUE )
-					{
-						for( i=0; i<nZ; ++i )
-							delta_xFRz[i] /= regVal;
-					}
-					else
-					{
-						/* When solving LPs without regularisation, iterates must always be at a vertex. */
-						if ( nZ > 0 )
-							return THROWERROR( RET_UNKNOWN_BUG );
-					}
-				}
-			}
-			else
-			{
-				/* compute HMX*delta_xFX. DESTROY delta_gFR that was in tempA */
-				if ( ( Delta_bB_isZero == BT_FALSE ) && ( r == 0 ) )
-					H->times(bounds.getFree(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, tempA, nFR);
-
-				/* compute HFR*delta_xFRy */
-				if ( ( nAC > 0 ) && ( ( Delta_bC_isZero == BT_FALSE ) || ( Delta_bB_isZero == BT_FALSE ) ) )
-					H->times(bounds.getFree(), bounds.getFree(), 1, 1.0, delta_xFR_TMP, nFR, 1.0, tempA, nFR);
-
-				/* compute ZFR_delta_xFRz = (Z'*HFR*Z) \ Z * (HFR*delta_xFR + HMX*delta_xFX + delta_gFR) */
-				if ( nZ > 0 )
-				{
-					for( j=0; j<nFR; ++j )
-					{
-						jj = FR_idx[j];
-						for( i=0; i<nZ; ++i )
-							delta_xFRz[i] -= QQ(jj,i) * tempA[j];
-					}
-
-					if ( backsolveR( delta_xFRz,BT_TRUE,delta_xFRz ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_STEPDIRECTION_FAILED_CHOLESKY );
-
-					if ( backsolveR( delta_xFRz,BT_FALSE,delta_xFRz ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_STEPDIRECTION_FAILED_CHOLESKY );
-				}
-			}
-
-			/* compute Z * ZFR_delta_xFRz */
-			if ( nZ > 0 )
-			{
-				for( i=0; i<nFR; ++i )
-				{
-					ZFR_delta_xFRz[i] = 0.0;
-
-					ii = FR_idx[i];
-					for( j=0; j<nZ; ++j )
-						ZFR_delta_xFRz[i] += QQ(ii,j) * delta_xFRz[j];
-
-					delta_xFR_TMP[i] += ZFR_delta_xFRz[i];
-				}
-			}
-		}
-
-		/* III) DETERMINE delta_yAC */
-		if ( nAC > 0 ) /* => ( nFR = nZ + nAC > 0 ) */
-		{
-			if ( ( hessianType == HST_ZERO ) || ( hessianType == HST_IDENTITY ) )
-			{
-				/* if zero:     delta_yAC = (T')^-1 * ( Yfr*delta_gFR + eps*delta_xFRy ),
-				 * if identity: delta_yAC = (T')^-1 * ( Yfr*delta_gFR +     delta_xFRy )
-				 *
-				 * DESTROY residual_bA that was stored in tempB
-				 * If we come here, residual_gFR in tempA is STILL VALID
-				 */
-				if ( hessianType == HST_IDENTITY )
-				{
-					for( j=0; j<nAC; ++j )
-						tempB[j] = delta_xFRy[j];
-				}
-				else /* hessianType == HST_ZERO */
-				{
-					if ( usingRegularisation( ) == BT_TRUE )
-					{
-						for( j=0; j<nAC; ++j )
-							tempB[j] = regVal*delta_xFRy[j];
-					}
-					else
-					{
-						for( j=0; j<nAC; ++j )
-							tempB[j] = 0.0;
-					}
-				}
-
-				for( j=0; j<nAC; ++j )
-				{
-					for( i=0; i<nFR; ++i )
-					{
-						ii = FR_idx[i];
-						tempB[j] += QQ(ii,nZ+j) * tempA[i];
-					}
-				}
-			}
-			else
-			{
-				/* Compute HFR * delta_xFR + HMX*delta_xFX
-				 * Here, tempA holds (HFR*delta_xFRy + HMX*delta_xFX) */
-				if ( nZ > 0 )
-					H->times(bounds.getFree(), bounds.getFree(), 1, 1.0, ZFR_delta_xFRz, nFR, 1.0, tempA, nFR);
-
-				for( i=0; i<nAC; ++i)
-				{
-					tempB[i] = 0.0;
-					for( j=0; j<nFR; ++j )
-					{
-						jj = FR_idx[j];
-						tempB[i] += QQ(jj,nZ+i) * tempA[j];
-					}
-				}
-			}
-
-			if ( backsolveT( tempB,BT_TRUE,delta_yAC_TMP ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_STEPDIRECTION_FAILED_TQ );
-		}
-
-		/* refine the solution found so far */
-		for ( i=0; i<nFR; ++i )
-			delta_xFR[i] += delta_xFR_TMP[i];
-		for ( i=0; i<nAC; ++i )
-			delta_yAC[i] += delta_yAC_TMP[i];
-
-		if ( options.numRefinementSteps > 0 )
-		{
-			/* compute residuals in tempA and tempB, and max-norm */
-			for ( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				tempA[i] = delta_g[ii];
-			}
-
-			switch ( hessianType )
-			{
-				case HST_ZERO:
-					if ( usingRegularisation( ) == BT_TRUE )
-						for ( i=0; i<nFR; ++i )
-							tempA[i] += regVal*delta_xFR[i];
-					break;
-
-				case HST_IDENTITY:
-					for ( i=0; i<nFR; ++i )
-						tempA[i] += delta_xFR[i];
-					break;
-
-				default:
-					H->times(bounds.getFree(), bounds.getFree(),  1, 1.0, delta_xFR, nFR, 1.0, tempA, nFR);
-					H->times(bounds.getFree(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, tempA, nFR);
-					break;
-			}
-
-			A->transTimes(constraints.getActive(), bounds.getFree(), 1, -1.0, delta_yAC, nAC, 1.0, tempA, nFR);
-			real_t rnrm = 0.0;
-			for ( i=0; i<nFR; ++i )
-				if (rnrm < getAbs (tempA[i]))
-					rnrm = getAbs (tempA[i]);
-
-			if (!Delta_bC_isZero)
-			{
-				for ( i=0; i<nAC; ++i )
-				{
-					ii = AC_idx[i];
-					if ( constraints.getStatus( ii ) == ST_LOWER )
-						tempB[i] = delta_lbA[ii];
-					else
-						tempB[i] = delta_ubA[ii];
-				}
-			}
-			else
-			{
-				for ( i=0; i<nAC; ++i )
-					tempB[i] = 0.0;
-			}
-			A->times(constraints.getActive(), bounds.getFree(), 1, -1.0, delta_xFR, nFR, 1.0, tempB, nAC);
-			A->times(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, tempB, nAC);
-			for ( i=0; i<nAC; ++i )
-				if (rnrm < getAbs (tempB[i]))
-					rnrm = getAbs (tempB[i]);
-
-			/* early termination of residual norm small enough */
-			if ( rnrm < options.epsIterRef )
-				break;
-		}
-	} /* end of refinement loop for delta_xFRz, delta_xFRy, delta_yAC */
-
-
-	/* IV) DETERMINE delta_yFX */
-	if ( nFX > 0 )
-	{
-		for( i=0; i<nFX; ++i )
-			delta_yFX[i] = delta_g[FX_idx[i]];
-
-		A->transTimes(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_yAC, nAC, 1.0, delta_yFX, nFX);
-
-		switch( hessianType )
-		{
-			case HST_ZERO:
-				if ( usingRegularisation( ) == BT_TRUE )
-					for( i=0; i<nFX; ++i )
-						delta_yFX[i] += regVal*delta_xFX[i];
-				break;
-
-			case HST_IDENTITY:
-				for( i=0; i<nFX; ++i )
-					delta_yFX[i] += 1.0 * delta_xFX[i];
-				break;
-
-			default:
-				H->times(bounds.getFixed(), bounds.getFree(), 1, 1.0, delta_xFR, nFR, 1.0, delta_yFX, nFX);
-				H->times(bounds.getFixed(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, delta_yFX, nFX);
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p e r f o r m S t e p
- */
-returnValue QProblem::performStep(	const real_t* const delta_g,
-									const real_t* const delta_lbA, const real_t* const delta_ubA,
-									const real_t* const delta_lb, const real_t* const delta_ub,
-									const real_t* const delta_xFX, const real_t* const delta_xFR,
-									const real_t* const delta_yAC, const real_t* const delta_yFX,
-									int_t& BC_idx, SubjectToStatus& BC_status, BooleanType& BC_isBound
-									)
-{
-	int_t i, j, ii, jj;
-	int_t nV  = getNV( );
-	int_t nC  = getNC( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-	int_t nIAC = getNIAC( );
-
-	int_t* FR_idx;
-	int_t* FX_idx;
-	int_t* AC_idx;
-	int_t* IAC_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-	constraints.getInactive( )->getNumberArray( &IAC_idx );
-
-	/* initialise maximum steplength array */
-	tau = 1.0;
-	BC_idx = -1;
-	BC_status = ST_UNDEFINED;
-
-	int_t BC_idx_tmp = -1;
-
-	real_t* num = new real_t[ getMax( nV,nC ) ];
-	real_t* den = new real_t[ getMax( nV,nC ) ];
-
-	real_t* delta_Ax_l = new real_t[nC];
-	real_t* delta_Ax_u = new real_t[nC];
-	real_t* delta_Ax   = new real_t[nC];
-
-	real_t* delta_x = new real_t[nV];
-	for( j=0; j<nFR; ++j )
-	{
-		jj = FR_idx[j];
-		delta_x[jj] = delta_xFR[j];
-	}
-	for( j=0; j<nFX; ++j )
-	{
-		jj = FX_idx[j];
-		delta_x[jj] = delta_xFX[j];
-	}
-
-
-	/* I) DETERMINE MAXIMUM DUAL STEPLENGTH: */
-	/* 1) Ensure that active dual constraints' bounds remain valid
-	 *    (ignoring inequality constraints).  */
-	for( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-
-		num[i] = y[nV+ii];
-		den[i] = -delta_yAC[i];
-	}
-
-	performRatioTest( nAC,AC_idx,&constraints, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-	if ( BC_idx_tmp >= 0 )
-	{
-		BC_idx = BC_idx_tmp;
-		BC_status = ST_INACTIVE;
-		BC_isBound = BT_FALSE;
-	}
-
-
-	/* 2) Ensure that active dual bounds remain valid
-	 *    (ignoring implicitly fixed variables). */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-		den[i] = -delta_yFX[i];
-	}
-
-	performRatioTest( nFX,FX_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-	if ( BC_idx_tmp >= 0 )
-	{
-		BC_idx = BC_idx_tmp;
-		BC_status = ST_INACTIVE;
-		BC_isBound = BT_TRUE;
-	}
-
-
- 	/* II) DETERMINE MAXIMUM PRIMAL STEPLENGTH */
-	/* 1) Ensure that inactive constraints' bounds remain valid
-	 *    (ignoring unbounded constraints). */
-
-	/* calculate product A*x */
-	if ( constraintProduct == 0 )
-	{
-		A->times(constraints.getInactive(), 0, 1, 1.0, delta_x, nV, 0.0, delta_Ax, nC, BT_FALSE);
-	}
-	else
-	{
-		for( i=0; i<nIAC; ++i )
-		{
-			ii = IAC_idx[i];
-
-			if ( constraints.getType( ii ) != ST_UNBOUNDED )
-			{
-				if ( (*constraintProduct)( ii,delta_x, &(delta_Ax[ii]) ) != 0 )
-				{
-					delete[] den; delete[] num;
-					delete[] delta_Ax; delete[] delta_Ax_u; delete[] delta_Ax_l; delete[] delta_x;
-					return THROWERROR( RET_ERROR_IN_CONSTRAINTPRODUCT );
-				}
-			}
-		}
-	}
-
-	if ( constraints.hasNoLower( ) == BT_FALSE )
-	{
-		for( i=0; i<nIAC; ++i )
-		{
-			ii = IAC_idx[i];
-			num[i] = getMax( Ax_l[ii],0.0 );
-			den[i] = delta_lbA[ii] - delta_Ax[ii];
-		}
-
-		performRatioTest( nIAC,IAC_idx,&constraints, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_LOWER;
-			BC_isBound = BT_FALSE;
-		}
-	}
-
-	if ( constraints.hasNoUpper( ) == BT_FALSE )
-	{
-		for( i=0; i<nIAC; ++i )
-		{
-			ii = IAC_idx[i];
-			num[i] = getMax( Ax_u[ii],0.0 );
-			den[i] = delta_Ax[ii] - delta_ubA[ii];
-		}
-
-		performRatioTest( nIAC,IAC_idx,&constraints, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_UPPER;
-			BC_isBound = BT_FALSE;
-		}
-	}
-
-
-	for( i=0; i<nIAC; ++i )
-	{
-		ii = IAC_idx[i];
-
-		if ( constraints.getType( ii ) != ST_UNBOUNDED )
-		{
-			delta_Ax_l[ii] = delta_Ax[ii] - delta_lbA[ii];
-			delta_Ax_u[ii] = delta_ubA[ii] - delta_Ax[ii];
-		}
-	}
-
-
-	/* 2) Ensure that inactive bounds remain valid
-	 *    (ignoring unbounded variables). */
-	/* inactive lower bounds */
-	if ( bounds.hasNoLower( ) == BT_FALSE )
-	{
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			num[i] = getMax( x[ii] - lb[ii],0.0 );
-			den[i] = delta_lb[ii] - delta_xFR[i];
-		}
-
-		performRatioTest( nFR,FR_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_LOWER;
-			BC_isBound = BT_TRUE;
-		}
-	}
-
-	/* inactive upper bounds */
-	if ( bounds.hasNoUpper( ) == BT_FALSE )
-	{
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			num[i] = getMax( ub[ii] - x[ii],0.0 );
-			den[i] = delta_xFR[i] - delta_ub[ii];
-		}
-
-		performRatioTest( nFR,FR_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_UPPER;
-			BC_isBound = BT_TRUE;
-		}
-	}
-
-	delete[] den;
-	delete[] num;
-	delete[] delta_x;
-
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-
-	if ( BC_status == ST_UNDEFINED )
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e!",tau );
-	else
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e! (idx = %d, isBound = %d, status = %d)",tau,(int)BC_idx,(int)BC_isBound,(int)BC_status );
-
-	getGlobalMessageHandler( )->throwInfo( RET_STEPSIZE_NONPOSITIVE,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-	#endif
-
-
-	/* III) PERFORM STEP ALONG HOMOTOPY PATH */
-	if ( tau > ZERO )
-	{
-		/* 1) Perform step in primal and dual space... */
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			x[ii] += tau*delta_xFR[i];
-		}
-
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			x[ii] += tau*delta_xFX[i];
-			y[ii] += tau*delta_yFX[i];
-		}
-
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			y[nV+ii] += tau*delta_yAC[i];
-		}
-
-		/* 2) Shift QP data. */
-		for( i=0; i<nV; ++i )
-		{
-			g[i]  += tau*delta_g[i];
-			lb[i] += tau*delta_lb[i];
-			ub[i] += tau*delta_ub[i];
-		}
-
-		for( i=0; i<nC; ++i )
-		{
-			lbA[i] += tau*delta_lbA[i];
-			ubA[i] += tau*delta_ubA[i];
-		}
-
-		A->times( constraints.getActive(),0, 1, 1.0, x, nV, 0.0, Ax, nC, BT_FALSE );
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			Ax_u[ii] = ubA[ii] - Ax[ii];
-			Ax_l[ii] = Ax[ii] - lbA[ii];
-		}
-		for( i=0; i<nIAC; ++i )
-		{
-			ii = IAC_idx[i];
-			if ( constraints.getType( ii ) != ST_UNBOUNDED )
-			{
-				Ax[ii]   += tau*delta_Ax[ii];
-				Ax_l[ii] += tau*delta_Ax_l[ii];
-				Ax_u[ii] += tau*delta_Ax_u[ii];
-			}
-		}
-	}
-	else
-	{
-		/* print a stepsize warning if stepsize is zero */
-		#ifndef __SUPPRESSANYOUTPUT__
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e",tau );
-		getGlobalMessageHandler( )->throwWarning( RET_STEPSIZE,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#endif
-	}
-
-	delete[] delta_Ax; delete[] delta_Ax_u; delete[] delta_Ax_l;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c h a n g e A c t i v e S e t
- */
-returnValue QProblem::changeActiveSet( int_t BC_idx, SubjectToStatus BC_status, BooleanType BC_isBound )
-{
-	int_t nV = getNV( );
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-	switch ( BC_status )
-	{
-		/* Optimal solution found as no working set change detected. */
-		case ST_UNDEFINED:
-			return SUCCESSFUL_RETURN;
-
-		/* Remove one variable from active set. */
-		case ST_INACTIVE:
-			if ( BC_isBound == BT_TRUE )
-			{
-				#ifndef __SUPPRESSANYOUTPUT__
-				snprintf( messageString,MAX_STRING_LENGTH,"bound no. %d.",(int)BC_idx );
-				getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-				#endif
-
-				if ( removeBound( BC_idx,BT_TRUE,BT_TRUE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_REMOVE_FROM_ACTIVESET_FAILED );
-
-				y[BC_idx] = 0.0;
-			}
-			else
-			{
-				#ifndef __SUPPRESSANYOUTPUT__
-				snprintf( messageString,MAX_STRING_LENGTH,"constraint no. %d.",(int)BC_idx );
-				getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-				#endif
-
-				if ( removeConstraint( BC_idx,BT_TRUE,BT_TRUE,options.enableNZCTests ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_REMOVE_FROM_ACTIVESET_FAILED );
-
-				y[nV+BC_idx] = 0.0;
-			}
-			break;
-
-
-		/* Add one variable to active set. */
-		default:
-			returnValue returnvalue;
-			if ( BC_isBound == BT_TRUE )
-			{
-				#ifndef __SUPPRESSANYOUTPUT__
-				if ( BC_status == ST_LOWER )
-					snprintf( messageString,MAX_STRING_LENGTH,"lower bound no. %d.",(int)BC_idx );
-				else
-					snprintf( messageString,MAX_STRING_LENGTH,"upper bound no. %d.",(int)BC_idx );
-				getGlobalMessageHandler( )->throwInfo( RET_ADD_TO_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-				#endif
-
-				returnvalue = addBound( BC_idx,BC_status,BT_TRUE );
-				if ( returnvalue == RET_ADDBOUND_FAILED_INFEASIBILITY )
-					return returnvalue;
-				if ( returnvalue != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ADD_TO_ACTIVESET_FAILED );
-			}
-			else
-			{
-				#ifndef __SUPPRESSANYOUTPUT__
-				if ( BC_status == ST_LOWER )
-					snprintf( messageString,MAX_STRING_LENGTH,"lower constraint's bound no. %d.",(int)BC_idx );
-				else
-					snprintf( messageString,MAX_STRING_LENGTH,"upper constraint's bound no. %d.",(int)BC_idx );
-				getGlobalMessageHandler( )->throwInfo( RET_ADD_TO_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-				#endif
-
-				returnvalue = addConstraint( BC_idx,BC_status,BT_TRUE );
-				if ( returnvalue == RET_ADDCONSTRAINT_FAILED_INFEASIBILITY )
-					return returnvalue;
-				if ( returnvalue != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_ADD_TO_ACTIVESET_FAILED );
-			}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- * g e t R e l a t i v e H o m o t o p y L e n g t h
- */
-real_t QProblem::getRelativeHomotopyLength(	const real_t* const g_new, const real_t* const lb_new, const real_t* const ub_new,
-											const real_t* const lbA_new, const real_t* const ubA_new
-											)
-{
-	int_t i;
-	int_t nC = getNC( );
-	real_t len = QProblemB::getRelativeHomotopyLength( g_new,lb_new,ub_new );
-	real_t d, s;
-
-	/*fprintf( stdFile, "len in homotopyLength = %.3e\n",len ); */
-
-	/* lower constraint bounds */
-	if ( lbA_new != 0 )
-	{
-		for (i = 0; i < nC; i++)
-		{
-			s = getAbs(lbA_new[i]);
-			if (s < 1.0) s = 1.0;
-			d = getAbs(lbA_new[i] - lbA[i]) / s;
-			if (d > len) len = d;
-		}
-	}
-	/*fprintf( stdFile, "len in homotopyLength = %.3e\n",len ); */
-
-	/* upper constraint bounds */
-	if ( ubA_new != 0 )
-	{
-		for (i = 0; i < nC; i++)
-		{
-			s = getAbs(ubA_new[i]);
-			if (s < 1.0) s = 1.0;
-			d = getAbs(ubA_new[i] - ubA[i]) / s;
-			if (d > len) len = d;
-		}
-	}
-	/*fprintf( stdFile, "len in homotopyLength = %.3e\n",len ); */
-
-	return len;
-}
-
-
-/*
- * p e r f o r m R a m p i n g
- */
-returnValue QProblem::performRamping( )
-{
-	int_t nV = getNV( ), nC = getNC( ), bstat, cstat, i, nRamp;
-	real_t tP, rampValP, tD, rampValD, sca;
-
-	/* compute number of values in ramp */
-	nRamp = nV + nC + nC + nV;
-
-	/* ramp inactive variable bounds and active dual bound variables */
-	for (i = 0; i < nV; i++)
-	{
-		switch (bounds.getType(i))
-		{
-			case ST_EQUALITY:
-				lb[i] = x[i]; ub[i] = x[i];  /* reestablish exact feasibility */
-				continue;
-
-			case ST_BOUNDED:
-				tP = static_cast<real_t>((i+rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-				rampValP = (1.0-tP) * ramp0 + tP * ramp1;
-				tD = static_cast<real_t>((nV+nC+nC+i+rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-				rampValD = (1.0-tD) * ramp0 + tD * ramp1;
-				bstat = bounds.getStatus(i);
-				if (bstat != ST_LOWER) { sca = getMax(getAbs(x[i]), 1.0); lb[i] = x[i] - sca * rampValP; }
-				if (bstat != ST_UPPER) { sca = getMax(getAbs(x[i]), 1.0); ub[i] = x[i] + sca * rampValP; }
-				if (bstat == ST_LOWER) { lb[i] = x[i]; y[i] = +rampValD; }
-				if (bstat == ST_UPPER) { ub[i] = x[i]; y[i] = -rampValD; }
-				if (bstat == ST_INACTIVE) y[i] = 0.0; /* reestablish exact complementarity */
-				break;
-
-			case ST_UNBOUNDED:
-			case ST_DISABLED:
-			default:
-				 continue;
-		}
-	}
-
-	/* ramp inactive constraints and active dual constraint variables */
-	for (i = 0; i < nC; i++)
-	{
-		switch (constraints.getType(i))
-		{
-			case ST_EQUALITY:
-				lbA[i] = Ax[i]; ubA[i] = Ax[i];  /* reestablish exact feasibility */
-				continue;
-
-			case ST_BOUNDED:
-				tP = static_cast<real_t>((nV+i+rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-				rampValP = (1.0-tP) * ramp0 + tP * ramp1;
-				tD = static_cast<real_t>((nV+nC+i+rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-				rampValD = (1.0-tD) * ramp0 + tD * ramp1;
-				cstat = constraints.getStatus(i);
-				if (cstat != ST_LOWER) { sca = getMax(getAbs(Ax[i]), 1.0); lbA[i] = Ax[i] - sca * rampValP; }
-				if (cstat != ST_UPPER) { sca = getMax(getAbs(Ax[i]), 1.0); ubA[i] = Ax[i] + sca * rampValP; }
-				if (cstat == ST_LOWER) { lbA[i] = Ax[i]; y[nV+i] = +rampValD; }
-				if (cstat == ST_UPPER) { ubA[i] = Ax[i]; y[nV+i] = -rampValD; }
-				if (cstat == ST_INACTIVE) y[nV+i] = 0.0; /* reestablish exact complementarity */
-
-				Ax_l[i] = Ax[i] - lbA[i];
-				Ax_u[i] = ubA[i] - Ax[i];
-				break;
-
-			case ST_UNBOUNDED:
-			case ST_DISABLED:
-			default:
-				continue;
-		}
-	}
-
-	/* reestablish exact stationarity */
-	setupAuxiliaryQPgradient( );
-
-	/* advance ramp offset to avoid Ramping cycles */
-	rampOffset++;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- * u p d a t e F a r B o u n d s
- */
-returnValue QProblem::updateFarBounds(	real_t curFarBound, int_t nRamp,
-										const real_t* const lb_new, real_t* const lb_new_far,
-										const real_t* const ub_new, real_t* const ub_new_far,
-										const real_t* const lbA_new, real_t* const lbA_new_far,
-										const real_t* const ubA_new, real_t* const ubA_new_far
-										) const
-{
-	int_t i;
-	real_t rampVal, t;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-    returnValue returnvalue = QProblemB::updateFarBounds(	curFarBound,nRamp,
-															lb_new,lb_new_far, ub_new,ub_new_far
-															);
-    if ( returnvalue != SUCCESSFUL_RETURN )
-        return returnvalue;
-
-	if ( options.enableRamping == BT_TRUE )
-	{
-		for ( i=0; i<nC; ++i )
-		{
-			t = static_cast<real_t>((nV+i + rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-			rampVal = curFarBound * (1.0 + (1.0-t)*ramp0 + t*ramp1);
-
-			if ( lbA_new == 0 )
-				lbA_new_far[i] = -rampVal;
-			else
-				lbA_new_far[i] = getMax( -rampVal,lbA_new[i] );
-
-			if ( ubA_new == 0 )
-				ubA_new_far[i] = rampVal;
-			else
-				ubA_new_far[i] = getMin( rampVal,ubA_new[i] );
-		}
-	}
-	else
-	{
-		for ( i=0; i<nC; ++i )
-		{
-			if ( lbA_new == 0 )
-				lbA_new_far[i] = -curFarBound;
-			else
-				lbA_new_far[i] = getMax( -curFarBound,lbA_new[i] );
-
-			if ( ubA_new == 0 )
-				ubA_new_far[i] = curFarBound;
-			else
-				ubA_new_far[i] = getMin( curFarBound,ubA_new[i] );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- * p e r f o r m D r i f t C o r r e c t i o n
- */
-returnValue QProblem::performDriftCorrection( )
-{
-	int_t i;
-	int_t nV = getNV ();
-	int_t nC = getNC ();
-
-	for ( i=0; i<nV; ++i )
-	{
-		switch ( bounds.getType ( i ) )
-		{
-			case ST_BOUNDED:
-				switch ( bounds.getStatus ( i ) )
-				{
-					case ST_LOWER:
-						lb[i] = x[i];
-						ub[i] = getMax (ub[i], x[i]);
-						y[i] = getMax (y[i], 0.0);
-						break;
-					case ST_UPPER:
-						lb[i] = getMin (lb[i], x[i]);
-						ub[i] = x[i];
-						y[i] = getMin (y[i], 0.0);
-						break;
-					case ST_INACTIVE:
-						lb[i] = getMin (lb[i], x[i]);
-						ub[i] = getMax (ub[i], x[i]);
-						y[i] = 0.0;
-						break;
-					case ST_UNDEFINED:
-					case ST_INFEASIBLE_LOWER:
-					case ST_INFEASIBLE_UPPER:
-						break;
-				}
-				break;
-			case ST_EQUALITY:
-				lb[i] = x[i];
-				ub[i] = x[i];
-				break;
-			case ST_UNBOUNDED:
-			case ST_UNKNOWN:
-            case ST_DISABLED:
-				break;
-		}
-	}
-
-	for ( i=0; i<nC; ++i )
-	{
-		switch ( constraints.getType ( i ) )
-		{
-			case ST_BOUNDED:
-				switch ( constraints.getStatus ( i ) )
-				{
-					case ST_LOWER:
-						lbA[i] = Ax[i];
-						Ax_l[i] = 0.0;
-						ubA[i] = getMax (ubA[i], Ax[i]);
-						Ax_u[i] = ubA[i] - Ax[i];
-						y[i+nV] = getMax (y[i+nV], 0.0);
-						break;
-					case ST_UPPER:
-						lbA[i] = getMin (lbA[i], Ax[i]);
-						Ax_l[i] = Ax[i] - lbA[i];
-						ubA[i] = Ax[i];
-						Ax_u[i] = 0.0;
-						y[i+nV] = getMin (y[i+nV], 0.0);
-						break;
-					case ST_INACTIVE:
-						lbA[i] = getMin (lbA[i], Ax[i]);
-						Ax_l[i] = Ax[i] - lbA[i];
-						ubA[i] = getMax (ubA[i], Ax[i]);
-						Ax_u[i] = ubA[i] - Ax[i];
-						y[i+nV] = 0.0;
-						break;
-					case ST_UNDEFINED:
-					case ST_INFEASIBLE_LOWER:
-					case ST_INFEASIBLE_UPPER:
-						break;
-				}
-				break;
-			case ST_EQUALITY:
-				lbA[i] = Ax[i];
-				Ax_l[i] = 0.0;
-				ubA[i] = Ax[i];
-				Ax_u[i] = 0.0;
-				break;
-			case ST_UNBOUNDED:
-			case ST_UNKNOWN:
-            case ST_DISABLED:
-				break;
-		}
-	}
-
-	return setupAuxiliaryQPgradient( );
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P
- */
-returnValue QProblem::setupAuxiliaryQP( const Bounds* const guessedBounds, const Constraints* const guessedConstraints )
-{
-	int_t i, j;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	/* consistency check */
-	if ( ( guessedBounds == 0 ) || ( guessedConstraints == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* nothing to do */
-	if ( ( guessedBounds == &bounds ) && ( guessedConstraints == &constraints ) )
-		return SUCCESSFUL_RETURN;
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* I) SETUP WORKING SET ... */
-	if ( shallRefactorise( guessedBounds,guessedConstraints ) == BT_TRUE )
-	{
-		/* ... WITH REFACTORISATION: */
-		/* 1) Reset bounds/constraints ... */
-		bounds.init( nV );
-		constraints.init( nC );
-
-		/*    ... and set them up afresh. */
-		if ( setupSubjectToType( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		if ( constraints.setupAllInactive( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* 2) Setup TQ factorisation. */
-		if ( setupTQfactorisation( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* 3) Setup guessed working sets afresh. */
-		if ( setupAuxiliaryWorkingSet( guessedBounds,guessedConstraints,BT_TRUE ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* 4) Computes Cholesky decomposition of projected Hessian
-		 *    This now handles all special cases (no active bounds/constraints, no nullspace) */
-		if ( computeProjectedCholesky( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-	else
-	{
-		/* ... WITHOUT REFACTORISATION: */
-		if ( setupAuxiliaryWorkingSet( guessedBounds,guessedConstraints,BT_FALSE ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-
-
-	/* II) SETUP AUXILIARY QP DATA: */
-	/* 1) Ensure that dual variable is zero for free bounds and inactive constraints. */
-	for ( i=0; i<nV; ++i )
-		if ( bounds.getStatus( i ) == ST_INACTIVE )
-			y[i] = 0.0;
-
-	for ( i=0; i<nC; ++i )
-		if ( constraints.getStatus( i ) == ST_INACTIVE )
-			y[nV+i] = 0.0;
-
-	/* 2) Setup gradient and (constraints') bound vectors. */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-		THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	A->times(1, 1.0, x, nV, 0.0, Ax, nC);
-	for ( j=0; j<nC; ++j )
-	{
-		Ax_l[j] = Ax[j];
-		Ax_u[j] = Ax[j];
-	}
-
-	/* (also sets Ax_l and Ax_u) */
-	if ( setupAuxiliaryQPbounds( 0,0,BT_FALSE ) != SUCCESSFUL_RETURN )
-		THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s h a l l R e f a c t o r i s e
- */
-
-BooleanType QProblem::shallRefactorise(	const Bounds* const guessedBounds,
-										const Constraints* const guessedConstraints
-										) const
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	/* always refactorise if Hessian is not known to be positive definite */
-	if ( ( hessianType == HST_SEMIDEF ) || ( hessianType == HST_INDEF ) )
-		return BT_TRUE;
-
-	/* 1) Determine number of bounds that have same status
-	 *    in guessed AND current bounds.*/
-	int_t differenceNumberBounds = 0;
-
-	for( i=0; i<nV; ++i )
-		if ( guessedBounds->getStatus( i ) != bounds.getStatus( i ) )
-			++differenceNumberBounds;
-
-	/* 2) Determine number of constraints that have same status
-	 *    in guessed AND current constraints.*/
-	int_t differenceNumberConstraints = 0;
-
-	for( i=0; i<nC; ++i )
-		if ( guessedConstraints->getStatus( i ) != constraints.getStatus( i ) )
-			++differenceNumberConstraints;
-
-	/* 3) Decide wheter to refactorise or not. */
-	if ( 2*(differenceNumberBounds+differenceNumberConstraints) > guessedConstraints->getNAC( )+guessedBounds->getNFX( ) )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *	s e t u p Q P d a t a
- */
-returnValue QProblem::setupQPdata(	SymmetricMatrix *_H, const real_t* const _g, Matrix *_A,
-									const real_t* const _lb, const real_t* const _ub,
-									const real_t* const _lbA, const real_t* const _ubA
-									)
-{
-	int_t nC = getNC( );
-
-#ifdef __WRITE_DATA_FILES__
-	{
-		int_t i;
-		const double Infinity = 1e20;
-		int_t nV = getNV( );
-		GlobalOutputFileCounter++;
-		char buf[256];
-		snprintf(buf,256,"QP%d_setupQPdata.dat",GlobalOutputFileCounter);
-		MyPrintf("+++ Writing output file %s\n", buf);
-
-		FILE* output_file = fopen(buf,"w");
-
-		fprintf(output_file,"nVar = %d\n", nV);
-		fprintf(output_file,"nCon = %d\n", nC);
-
-		_H->writeToFile(output_file,"H_");
-		for (i=0; i<nV; i++) {
-			fprintf(output_file,"g[%d] = %23.16e\n",i,_g[i]);
-		}
-		_A->writeToFile(output_file,"A_");
-		for (i=0; i<nV; i++) {
-			fprintf(output_file,"lb[%d] = %23.16e\n",i,getMax(-Infinity,_lb[i]));
-		}
-		for (i=0; i<nV; i++) {
-			fprintf(output_file,"ub[%d] = %23.16e\n",i,getMin(Infinity,_ub[i]));
-		}
-
-		for (i=0; i<nC; i++) {
-			fprintf(output_file,"lbA[%d] = %23.16e\n",i,getMax(-Infinity,_lbA[i]));
-		}
-		for (i=0; i<nC; i++) {
-			fprintf(output_file,"ubA[%d] = %23.16e\n",i,getMin(Infinity,_ubA[i]));
-		}
-		fclose(output_file);
-  }
-#endif
-
-	/* 1) Load Hessian matrix as well as lower and upper bounds vectors. */
-	if ( QProblemB::setupQPdata( _H,_g,_lb,_ub ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( nC > 0 ) && ( _A == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( nC > 0 )
-	{
-		/* 2) Setup lower/upper constraints' bounds vector. */
-		setLBA( _lbA );
-		setUBA( _ubA );
-
-		/* 3) Only load constraint matrix after setting up vectors! */
-		setA( _A );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p Q P d a t a
- */
-returnValue QProblem::setupQPdata(	const real_t* const _H, const real_t* const _g, const real_t* const _A,
-									const real_t* const _lb, const real_t* const _ub,
-									const real_t* const _lbA, const real_t* const _ubA
-									)
-{
-	int_t nC = getNC( );
-
-	/* 1) Load Hessian matrix as well as lower and upper bounds vectors. */
-	if ( QProblemB::setupQPdata( _H,_g,_lb,_ub ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( nC > 0 ) && ( _A == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( nC > 0 )
-	{
-		/* 2) Setup lower/upper constraints' bounds vector. */
-		setLBA( _lbA );
-		setUBA( _ubA );
-
-		/* 3) Only load constraint matrix after setting up vectors! */
-		setA( _A );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p Q P d a t a F r o m F i l e
- */
-returnValue QProblem::setupQPdataFromFile(	const char* const H_file, const char* const g_file, const char* const A_file,
-											const char* const lb_file, const char* const ub_file,
-											const char* const lbA_file, const char* const ubA_file
-											)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	returnValue returnvalue;
-
-
-	/* 1) Load Hessian matrix as well as lower and upper bounds vectors from files. */
-	returnvalue = QProblemB::setupQPdataFromFile( H_file,g_file,lb_file,ub_file );
-	if ( returnvalue != SUCCESSFUL_RETURN )
-		return THROWERROR( returnvalue );
-
-	if ( ( nC > 0 ) && ( A_file == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( nC > 0 )
-	{
-		/* 2) Load lower constraints' bounds vector from file. */
-		if ( lbA_file != 0 )
-		{
-			returnvalue = readFromFile( lbA, nC, lbA_file );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( returnvalue );
-		}
-		else
-		{
-			/* if no lower constraints' bounds are specified, set them to -infinity */
-			for( i=0; i<nC; ++i )
-				lbA[i] = -INFTY;
-		}
-
-		/* 3) Load upper constraints' bounds vector from file. */
-		if ( ubA_file != 0 )
-		{
-			returnvalue = readFromFile( ubA, nC, ubA_file );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( returnvalue );
-		}
-		else
-		{
-			/* if no upper constraints' bounds are specified, set them to infinity */
-			for( i=0; i<nC; ++i )
-				ubA[i] = INFTY;
-		}
-
-		/* 4) Only load constraint matrix from file after setting up vectors! */
-		real_t* _A = new real_t[nC * nV];
-		returnvalue = readFromFile( _A, nC,nV, A_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] _A;
-			return THROWERROR( returnvalue );
-		}
-		setA( _A );
-		A->doFreeMemory( );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	l o a d Q P v e c t o r s F r o m F i l e
- */
-returnValue QProblem::loadQPvectorsFromFile(	const char* const g_file, const char* const lb_file, const char* const ub_file,
-												const char* const lbA_file, const char* const ubA_file,
-												real_t* const g_new, real_t* const lb_new, real_t* const ub_new,
-												real_t* const lbA_new, real_t* const ubA_new
-												) const
-{
-	int_t nC = getNC( );
-
-	returnValue returnvalue;
-
-
-	/* 1) Load gradient vector as well as lower and upper bounds vectors from files. */
-	returnvalue = QProblemB::loadQPvectorsFromFile( g_file,lb_file,ub_file, g_new,lb_new,ub_new );
-	if ( returnvalue != SUCCESSFUL_RETURN )
-		return THROWERROR( returnvalue );
-
-	if ( nC > 0 )
-	{
-		/* 2) Load lower constraints' bounds vector from file. */
-		if ( lbA_file != 0 )
-		{
-			if ( lbA_new != 0 )
-			{
-				returnvalue = readFromFile( lbA_new, nC, lbA_file );
-				if ( returnvalue != SUCCESSFUL_RETURN )
-					return THROWERROR( returnvalue );
-			}
-			else
-			{
-				/* If filename is given, storage must be provided! */
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			}
-		}
-
-		/* 3) Load upper constraints' bounds vector from file. */
-		if ( ubA_file != 0 )
-		{
-			if ( ubA_new != 0 )
-			{
-				returnvalue = readFromFile( ubA_new, nC, ubA_file );
-				if ( returnvalue != SUCCESSFUL_RETURN )
-					return THROWERROR( returnvalue );
-			}
-			else
-			{
-				/* If filename is given, storage must be provided! */
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t I t e r a t i o n
- */
-returnValue QProblem::printIteration( 	int_t iter,
-										int_t BC_idx,	SubjectToStatus BC_status, BooleanType BC_isBound, real_t homotopyLength,
-										BooleanType isFirstCall
-		  								)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	/* consistency check */
-	if ( iter < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	int_t i;
-	int_t nV = getNV();
-	int_t nC = getNC();
-	int_t nAC = getNAC();
-
-	real_t stat, bfeas, cfeas, bcmpl, ccmpl, Tmaxomin;
-	real_t *grad = 0;
-	real_t *AX = 0;
-	real_t Tmin, Tmax;
-
-	char myPrintfString[MAX_STRING_LENGTH];
-	char info[MAX_STRING_LENGTH];
-	const char excStr[] = " ef";
-
-	switch ( options.printLevel )
-	{
-		case PL_DEBUG_ITER:
-			grad = new real_t[nV];
-			AX = new real_t[nC];
-			stat = bfeas = cfeas = bcmpl = ccmpl = Tmaxomin = 0.0;
-
-			/* stationarity */
-			for (i = 0; i < nV; i++) grad[i] = g[i] - y[i];
-
-			switch ( hessianType )
-			{
-				case HST_ZERO:
-					for( i=0; i<nV; ++i )
-						grad[i] += regVal * x[i];
-					break;
-
-				case HST_IDENTITY:
-					for( i=0; i<nV; ++i )
-						grad[i] += 1.0 * x[i];
-					break;
-
-				default:
-					H->times(1, 1.0, x, nV, 1.0, grad, nV);
-					break;
-			}
-
-			A->transTimes(1, -1.0, y+nV, nC, 1.0, grad, nV);
-			for (i = 0; i < nV; i++) if (getAbs(grad[i]) > stat) stat = getAbs(grad[i]);
-
-			/* feasibility */
-			for (i = 0; i < nV; i++) if (lb[i] - x[i] > bfeas) bfeas = lb[i] - x[i];
-			for (i = 0; i < nV; i++) if (x[i] - ub[i] > bfeas) bfeas = x[i] - ub[i];
-			A->times(1, 1.0, x, nV, 0.0, AX, nC);
-			for (i = 0; i < nC; i++) if (lbA[i] - AX[i] > cfeas) cfeas = lbA[i] - AX[i];
-			for (i = 0; i < nC; i++) if (AX[i] - ubA[i] > cfeas) cfeas = AX[i] - ubA[i];
-
-			/* complementarity */
-			for (i = 0; i < nV; i++) if (y[i] > +EPS && getAbs((lb[i] - x[i])*y[i]) > bcmpl) bcmpl = getAbs((lb[i] - x[i])*y[i]);
-			for (i = 0; i < nV; i++) if (y[i] < -EPS && getAbs((ub[i] - x[i])*y[i]) > bcmpl) bcmpl = getAbs((ub[i] - x[i])*y[i]);
-			for (i = 0; i < nC; i++) if (y[nV+i] > +EPS && getAbs((lbA[i]-AX[i])*y[nV+i]) > ccmpl) ccmpl = getAbs((lbA[i]-AX[i])*y[nV+i]);
-			for (i = 0; i < nC; i++) if (y[nV+i] < -EPS && getAbs((ubA[i]-AX[i])*y[nV+i]) > ccmpl) ccmpl = getAbs((ubA[i]-AX[i])*y[nV+i]);
-
-			Tmin = 1.0e16; Tmax = 0.0;
-			for (i = 0; i < nAC; i++)
-				if (getAbs(TT(i,sizeT-i-1)) < Tmin)
-					Tmin = getAbs(TT(i,sizeT-i-1));
-				else if (getAbs(TT(i,sizeT-i-1)) > Tmax)
-					Tmax = getAbs(TT(i,sizeT-i-1));
-			Tmaxomin = Tmax/Tmin;
-
-			if ( (iter % 10 == 0) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "\n%5s %4s %4s %4s %4s %9s %9s %9s %9s %9s %9s %9s %9s\n",
-						"iter", "addB", "remB", "addC", "remC", "hom len", "tau", "stat",
-						"bfeas", "cfeas", "bcmpl", "ccmpl", "Tmin");
-				myPrintf( myPrintfString );
-			}
-
-			if ( isFirstCall == BT_TRUE )
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d ",(int)iter );
-			else
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d*",(int)iter );
-			myPrintf( myPrintfString );
-
-			if (tabularOutput.idxAddB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxAddB) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			if (tabularOutput.idxRemB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxRemB) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			if (tabularOutput.idxAddC >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxAddC) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			if (tabularOutput.idxRemC >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxRemC) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%9.2e %9.2e %9.2e %9.2e %9.2e %9.2e %9.2e %9.2e\n",
-					homotopyLength, tau, stat, bfeas, cfeas, bcmpl, ccmpl, Tmin);
-			myPrintf( myPrintfString );
-
-			delete[] AX;
-			delete[] grad;
-			break;
-
-		case PL_TABULAR:
-			if ( (iter % 10 == 0) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "\n%5s %6s %6s %6s %6s %9s %9s\n",
-						"iter", "addB", "remB", "addC", "remC", "hom len", "tau" );
-				myPrintf( myPrintfString );
-			}
-			if ( isFirstCall == BT_TRUE )
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d ",(int)iter);
-			else
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d*",(int)iter);
-			myPrintf( myPrintfString );
-
-			if (tabularOutput.idxAddB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxAddB), excStr[tabularOutput.excAddB]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			if (tabularOutput.idxRemB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxRemB), excStr[tabularOutput.excRemB]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			if (tabularOutput.idxAddC >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxAddC), excStr[tabularOutput.excAddC]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			if (tabularOutput.idxRemC >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxRemC), excStr[tabularOutput.excRemC]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%9.2e %9.2e\n", homotopyLength, tau);
-			myPrintf( myPrintfString );
-			break;
-
-		case PL_MEDIUM:
-			/* 1) Print header at first iteration. */
- 			if ( ( iter == 0 ) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH,"\n\n####################   qpOASES  --  QP NO. %3.0d   #####################\n\n",(int)count );
-				myPrintf( myPrintfString );
-
-				myPrintf( "    Iter   |    StepLength    |       Info       |   nFX   |   nAC    \n" );
-				myPrintf( " ----------+------------------+------------------+---------+--------- \n" );
-			}
-
-			/* 2) Print iteration line. */
-			if ( BC_status == ST_UNDEFINED )
-			{
-				if ( hessianType == HST_ZERO )
-					snprintf( info,3,"LP" );
-				else
-					snprintf( info,3,"QP" );
-
-				if ( isFirstCall == BT_TRUE )
-					snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d   |   %1.6e   |    %s SOLVED     |  %4.1d   |  %4.1d   \n", (int)iter,tau,info,(int)getNFX( ),(int)getNAC( ) );
-				else
-					snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d*  |   %1.6e   |    %s SOLVED     |  %4.1d   |  %4.1d   \n", (int)iter,tau,info,(int)getNFX( ),(int)getNAC( ) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				if ( BC_status == ST_INACTIVE )
-					snprintf( info,5,"REM " );
-				else
-					snprintf( info,5,"ADD " );
-
-				if ( BC_isBound == BT_TRUE )
-					snprintf( &(info[4]),4,"BND" );
-				else
-					snprintf( &(info[4]),4,"CON" );
-
-				snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d   |   %1.6e   |   %s %4.1d   |  %4.1d   |  %4.1d   \n", (int)iter,tau,info,(int)BC_idx,(int)getNFX( ),(int)getNAC( ) );
-				myPrintf( myPrintfString );
-			}
-			break;
-
-		default:
-			/* nothing to display */
-			break;
-	}
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-inline real_t abs (real_t x) { return (x>0)?x:-x; }
-
-/*
- * d r o p I n f e a s i b l e s
- */
-returnValue QProblem::dropInfeasibles( int_t BC_number, SubjectToStatus BC_status, BooleanType BC_isBound,
-										real_t *xiB, real_t *xiC )
-{
-	int_t i;
-
-	int_t nAC                   = getNAC ();
-	int_t nFX                   = getNFX ();
-	int_t blockingPriority      = (BC_isBound) ? options.dropBoundPriority : options.dropIneqConPriority;
-	int_t y_min_number          = -1;
-	BooleanType y_min_isBound = BC_isBound;
-	int_t y_min_priority        = blockingPriority;
-
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	if (options.dropEqConPriority <= y_min_priority)
-	{
-		// look for an equality constraint we can drop according to priorities
-		for ( i = 0; i < nAC; ++i )
-			if ( (constraints.getType (i) == ST_EQUALITY)
-				&& (getAbs (xiC[i]) > options.epsDen) )
-			{
-				y_min_number = AC_idx[i];
-				y_min_isBound = BT_FALSE;
-				y_min_priority = options.dropEqConPriority;
-				break;
-			}
-	}
-
-	if (options.dropIneqConPriority <= y_min_priority)
-	{
-		// look for an inequality constraint we can drop according to priorities
-		for ( i = 0; i < nAC; ++i )
-			if ( (constraints.getType (i) == ST_BOUNDED)
-				&& (getAbs (xiC[i]) > options.epsDen) )
-			{
-				y_min_number = AC_idx[i];
-				y_min_isBound = BT_FALSE;
-				y_min_priority = options.dropIneqConPriority;
-				break;
-			}
-	}
-
-	if (options.dropBoundPriority <= y_min_priority)
-	{
-		// look for a simple bound we can drop according to priorities
-		for ( i = 0; i < nFX; ++i )
-			if (getAbs (xiB[i]) > options.epsDen)
-			{
-				y_min_number = FX_idx[i];
-				y_min_isBound = BT_TRUE;
-				y_min_priority = options.dropBoundPriority;
-				break;
-			}
-	}
-
-	if (y_min_number >= 0) {
-
-		// drop active equality or active bound we have found
-		if (y_min_isBound) {
-			SubjectToStatus status_ = bounds.getStatus (y_min_number);
-			removeBound (y_min_number, BT_TRUE, BT_FALSE, BT_FALSE);
-			bounds.setStatus (y_min_number, (status_ == ST_LOWER) ? ST_INFEASIBLE_LOWER : ST_INFEASIBLE_UPPER);
-			// TODO: fix duals y[]
-			/* fprintf (stdFile, "Dropping bounds %d for %s %d\n", y_min_number, BC_isBound?"bound":"constraint", BC_number); */
-		} else {
-			SubjectToStatus status_ = constraints.getStatus (y_min_number);
-			removeConstraint (y_min_number, BT_TRUE, BT_FALSE, BT_FALSE);
-			constraints.setStatus (y_min_number, (status_ == ST_LOWER) ? ST_INFEASIBLE_LOWER : ST_INFEASIBLE_UPPER);
-			// TODO: fix duals y[]
-			/* fprintf (stdFile, "Dropping constraint %d for %s %d\n", y_min_number, BC_isBound?"bound":"constraint", BC_number); */
-		}
-
-		// ... now return, add the blocking constraint, and continue solving QP with dropped bound/constraint
-		return SUCCESSFUL_RETURN;
-
-	} else {
-
-		// nothing found, then drop the blocking (still inactive) constraint
-		if (BC_isBound)
-			bounds.setStatus (BC_number, (BC_status == ST_LOWER) ? ST_INFEASIBLE_LOWER : ST_INFEASIBLE_UPPER);
-		else
-			constraints.setStatus (BC_number, (BC_status == ST_LOWER) ? ST_INFEASIBLE_LOWER : ST_INFEASIBLE_UPPER);
-
-		/* fprintf (stdFile, "Dropping %s %d itself\n", BC_isBound?"bound":"constraint", BC_number); */
-
-		// ... now return, and continue solving QP with dropped bound/constraint
-		return RET_ENSURELI_DROPPED;
-	}
-}
-
-
-
-/*
- *  w r i t e Q p D a t a I n t o M a t F i l e
- */
-returnValue QProblem::writeQpDataIntoMatFile(	const char* const filename
-												) const
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	FILE* matFile;
-	matFile = fopen( filename,"w+" );
-
-	if ( matFile == 0 )
-		return RET_UNABLE_TO_OPEN_FILE;
-
-	int_t nV = getNV();
-	int_t nC = getNC();
-
-	real_t* Hfull = H->full();
-	writeIntoMatFile( matFile, Hfull, nV,nV, "H"   );
-	delete[] Hfull;
-
-	writeIntoMatFile( matFile, g,     nV,1,  "g"   );
-
-	real_t* Afull = A->full();
-	writeIntoMatFile( matFile, Afull, nC,nV, "A"   );
-	delete[] Afull;
-
-	writeIntoMatFile( matFile, lb,    nV,1,  "lb"  );
-	writeIntoMatFile( matFile, ub,    nV,1,  "ub"  );
-	writeIntoMatFile( matFile, lbA,   nC,1,  "lbA" );
-	writeIntoMatFile( matFile, ubA,   nC,1,  "ubA" );
-
-	fclose( matFile );
-
-	return SUCCESSFUL_RETURN;
-    
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *  w r i t e Q p W o r k s p a c e I n t o M a t F i l e
- */
-returnValue QProblem::writeQpWorkspaceIntoMatFile(	const char* const filename
-													)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	FILE* matFile;
-	matFile = fopen( filename,"w+" );
-
-	if ( matFile == 0 )
-		return RET_UNABLE_TO_OPEN_FILE;
-
-	int_t nV = getNV();
-	int_t nC = getNC();
-	int_t nFR  = getNFR();
-	int_t nFX  = getNFX();
-	int_t nAC  = getNAC();
-	int_t nIAC = getNIAC();
-
-
-	writeIntoMatFile( matFile, T, sizeT,sizeT, "T" );
-	writeIntoMatFile( matFile, Q, nV,nV, "Q" );
-
-	writeIntoMatFile( matFile, Ax, nC,1, "Ax" );
-	writeIntoMatFile( matFile, Ax_l, nC,1, "Ax_l" );
-	writeIntoMatFile( matFile, Ax_u, nC,1, "Ax_u" );
-
-
-	int_t *FR_idx, *FX_idx, *AC_idx, *IAC_idx;
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-	constraints.getInactive( )->getNumberArray( &IAC_idx );
-
-	writeIntoMatFile( matFile, FR_idx,  nFR, 1, "FR_idx"  );
-	writeIntoMatFile( matFile, FX_idx,  nFX, 1, "FX_idx"  );
-	writeIntoMatFile( matFile, AC_idx,  nAC, 1, "AC_idx"  );
-	writeIntoMatFile( matFile, IAC_idx, nIAC,1, "IAC_idx" );
-
-	fclose( matFile );
-
-	return SUCCESSFUL_RETURN;
-    
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/QProblemB.cpp b/extlibs/qpOASES-3.2.0/src/QProblemB.cpp
deleted file mode 100644
index b1812c4..0000000
--- a/extlibs/qpOASES-3.2.0/src/QProblemB.cpp
+++ /dev/null
@@ -1,3850 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/QProblemB.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the QProblemB class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming.
- */
-
-
-#include <qpOASES/QProblemB.hpp>
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	Q P r o b l e m B
- */
-QProblemB::QProblemB( )
-{
-	/* print copyright notice */
-	if (options.printLevel != PL_NONE)
-		printCopyrightNotice( );
-
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-
-	freeHessian = BT_FALSE;
-	H = 0;
-
-	g = 0;
-	lb = 0;
-	ub = 0;
-
-	R = 0;
-	haveCholesky = BT_FALSE;
-
-	x = 0;
-	y = 0;
-
-	tau = 0.0;
-
-	hessianType = HST_UNKNOWN;
-	regVal = 0.0;
-
-	infeasible  = BT_FALSE;
-	unbounded   = BT_FALSE;
-
-	status = QPS_NOTINITIALISED;
-
-	count = 0;
-
-	ramp0 = options.initialRamping;
-	ramp1 = options.finalRamping;
-	rampOffset = 0;
-
-	delta_xFR_TMP = 0;
-
-	setPrintLevel( options.printLevel );
-}
-
-
-/*
- *	Q P r o b l e m B
- */
-QProblemB::QProblemB( int_t _nV, HessianType _hessianType )
-{
-	int_t i;
-
-	/* print copyright notice */
-	if (options.printLevel != PL_NONE)
-		printCopyrightNotice( );
-
-	/* consistency check */
-	if ( _nV <= 0 )
-	{
-		_nV = 1;
-		THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-
-	freeHessian = BT_FALSE;
-	H = 0;
-
-	g = new real_t[_nV];
-	for( i=0; i<_nV; ++i ) g[i] = 0.0;
-
-	lb = new real_t[_nV];
-	for( i=0; i<_nV; ++i ) lb[i] = 0.0;
-
-	ub = new real_t[_nV];
-	for( i=0; i<_nV; ++i ) ub[i] = 0.0;
-
-	bounds.init( _nV );
-
-	R = new real_t[_nV*_nV];
-	for( i=0; i<_nV*_nV; ++i ) R[i] = 0.0;
-	haveCholesky = BT_FALSE;
-
-	x = new real_t[_nV];
-	for( i=0; i<_nV; ++i ) x[i] = 0.0;
-
-	y = new real_t[_nV];
-	for( i=0; i<_nV; ++i ) y[i] = 0.0;
-
-	tau = 0.0;
-
-	hessianType = _hessianType;
-	regVal = 0.0;
-
-	infeasible  = BT_FALSE;
-	unbounded   = BT_FALSE;
-
-	status = QPS_NOTINITIALISED;
-
-	count = 0;
-
-	ramp0 = options.initialRamping;
-	ramp1 = options.finalRamping;
-	rampOffset = 0;
-
-	delta_xFR_TMP = new real_t[_nV];
-
-	setPrintLevel( options.printLevel );
-
-	flipper.init( (uint_t)_nV );
-}
-
-
-/*
- *	Q P r o b l e m B
- */
-QProblemB::QProblemB( const QProblemB& rhs )
-{
-	freeHessian = BT_FALSE;
-	H = 0;
-
-	copy( rhs );
-}
-
-
-/*
- *	~ Q P r o b l e m B
- */
-QProblemB::~QProblemB( )
-{
-	clear( );
-
-	/* reset global message handler */
-	getGlobalMessageHandler( )->reset( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-QProblemB& QProblemB::operator=( const QProblemB& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-/*
- *	r e s e t
- */
-returnValue QProblemB::reset( )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Reset bounds. */
-	bounds.init( nV );
-
-	/* 2) Reset Cholesky decomposition. */
-	if ( R!=0 )
-		for( i=0; i<nV*nV; ++i )
-			R[i] = 0.0;
-
-	haveCholesky = BT_FALSE;
-
-	/* 3) Reset steplength and status flags. */
-	tau = 0.0;
-
-	hessianType = HST_UNKNOWN;
-	regVal = 0.0;
-
-	infeasible  = BT_FALSE;
-	unbounded   = BT_FALSE;
-
-	status = QPS_NOTINITIALISED;
-
-	ramp0 = options.initialRamping;
-	ramp1 = options.finalRamping;
-	rampOffset = 0;
-
-	/* 4) Reset flipper object */
-	flipper.init( (uint_t)nV );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblemB::init( 	SymmetricMatrix *_H, const real_t* const _g,
-								const real_t* const _lb, const real_t* const _ub,
-								int_t& nWSR, real_t* const cputime,
-								const real_t* const xOpt, const real_t* const yOpt,
-								const Bounds* const guessedBounds,
-								const real_t* const _R
-								)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	/* exclude this possibility in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( guessedBounds != 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( _R != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data. */
-	if ( setupQPdata( _H,_g,_lb,_ub ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* 3) Call to main initialisation routine. */
-	return solveInitialQP( xOpt,yOpt,guessedBounds,_R, nWSR,cputime );
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblemB::init( 	const real_t* const _H, const real_t* const _g,
-								const real_t* const _lb, const real_t* const _ub,
-								int_t& nWSR, real_t* const cputime,
-								const real_t* const xOpt, const real_t* const yOpt,
-								const Bounds* const guessedBounds,
-								const real_t* const _R
-								)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	/* exclude this possibility in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( guessedBounds != 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( _R != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data. */
-	if ( setupQPdata( _H,_g,_lb,_ub ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	/* 3) Call to main initialisation routine. */
-	return solveInitialQP( xOpt,yOpt,guessedBounds,_R, nWSR,cputime );
-}
-
-
-/*
- *	i n i t
- */
-returnValue QProblemB::init( 	const char* const H_file, const char* const g_file,
-								const char* const lb_file, const char* const ub_file,
-								int_t& nWSR, real_t* const cputime,
-								const real_t* const xOpt, const real_t* const yOpt,
-								const Bounds* const guessedBounds,
-								const char* const R_file
-								)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* 1) Consistency checks. */
-	if ( isInitialised( ) == BT_TRUE )
-	{
-		THROWWARNING( RET_QP_ALREADY_INITIALISED );
-		reset( );
-	}
-
-	if ( guessedBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( guessedBounds->getStatus( i ) == ST_UNDEFINED )
-				return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	/* exclude this possibility in order to avoid inconsistencies */
-	if ( ( xOpt == 0 ) && ( yOpt != 0 ) && ( guessedBounds != 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( R_file != 0 ) && ( ( xOpt != 0 ) || ( yOpt != 0 ) || ( guessedBounds != 0 ) ) )
-		return THROWERROR( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-
-	/* 2) Setup QP data from files. */
-	if ( setupQPdataFromFile( H_file,g_file,lb_file,ub_file ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-
-	if ( R_file == 0 )
-	{
-		/* 3) Call to main initialisation routine. */
-		return solveInitialQP( xOpt,yOpt,guessedBounds,0, nWSR,cputime );
-	}
-	else
-	{
-		/* Also read Cholesky factor from file and store it directly into R [thus... */
-		returnValue returnvalue = readFromFile( R, nV,nV, R_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-			return THROWWARNING( returnvalue );
-
-		/* 3) Call to main initialisation routine. ...passing R here!] */
-		return solveInitialQP( xOpt,yOpt,guessedBounds,R, nWSR,cputime );
-	}
-}
-
-
-
-/*
- *	h o t s t a r t
- */
-returnValue QProblemB::hotstart(	const real_t* const g_new,
-									const real_t* const lb_new, const real_t* const ub_new,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds
-									)
-{
-	int_t i, nActiveFar;
-	int_t nV = getNV ();
-	real_t starttime = 0.0;
-	real_t auxTime = 0.0;
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-
-	/* Possibly update working set according to guess for working set of bounds. */
-	if ( guessedBounds != 0 )
-	{
-		if ( cputime != 0 )
-			starttime = getCPUtime( );
-
-		if ( setupAuxiliaryQP( guessedBounds ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		status = QPS_AUXILIARYQPSOLVED;
-
-		/* Allow only remaining CPU time for usual hotstart. */
-		if ( cputime != 0 )
-		{
-			auxTime = getCPUtime( ) - starttime;
-			*cputime -= auxTime;
-		}
-	}
-
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	/* Simple check for consistency of bounds */
-	if ( areBoundsConsistent( lb_new,ub_new ) != SUCCESSFUL_RETURN )
-		return setInfeasibilityFlag(returnvalue,BT_TRUE);
-
-	++count;
-
-
-	int_t nWSR_max = nWSR;
-	int_t nWSR_performed = 0;
-
-	real_t cputime_remaining = INFTY;
-	real_t cputime_needed = 0.0;
-
-	real_t farbound = options.initialFarBounds;
-
-	if ( haveCholesky == BT_FALSE )
-	{
-		returnvalue = setupInitialCholesky( );
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return THROWERROR(returnvalue);
-	}
-
-	BooleanType isFirstCall = BT_TRUE;
-
-	if ( options.enableFarBounds == BT_FALSE )
-	{
-		/* Automatically call standard solveQP if regularisation is not active. */
-		returnvalue = solveRegularisedQP(	g_new,lb_new,ub_new,
-											nWSR,cputime,0,
-											isFirstCall
-											);
-	}
-	else
-	{
-		real_t *ub_new_far = new real_t[nV];
-		real_t *lb_new_far = new real_t[nV];
-
-		/* possibly extend initial far bounds to largest bound/constraint data */
-		if (ub_new)
-			for (i = 0; i < nV; i++)
-				if ((ub_new[i] < INFTY) && (ub_new[i] > farbound)) farbound = ub_new[i];
-		if (lb_new)
-			for (i = 0; i < nV; i++)
-				if ((lb_new[i] > -INFTY) && (lb_new[i] < -farbound)) farbound = -lb_new[i];
-
-		updateFarBounds(	farbound,nV,
-							lb_new,lb_new_far, ub_new,ub_new_far
-							);
-
-		for ( ;; )
-		{
-			nWSR = nWSR_max;
-			if ( cputime != 0 )
-				cputime_remaining = *cputime - cputime_needed;
-
-			/* Automatically call standard solveQP if regularisation is not active. */
-			returnvalue = solveRegularisedQP(	g_new,lb_new_far,ub_new_far,
-												nWSR,&cputime_remaining,nWSR_performed,
-												isFirstCall
-												);
-
-			nWSR_performed  = nWSR;
-			cputime_needed += cputime_remaining;
-			isFirstCall     = BT_FALSE;
-
-			/* Check for active far-bounds and move them away */
-			nActiveFar = 0;
-			farbound *= options.growFarBounds;
-
-			if ( infeasible == BT_TRUE )
-			{
-				if ( farbound >= INFTY )
-				{
-					returnvalue = RET_HOTSTART_STOPPED_INFEASIBILITY;
-					goto farewell;
-				}
-
-				updateFarBounds(	farbound,nV,
-									lb_new,lb_new_far, ub_new,ub_new_far
-									);
-			}
-			else if ( status == QPS_SOLVED )
-			{
-				real_t tol = farbound/options.growFarBounds * options.boundTolerance;
-				nActiveFar = 0;
-				for ( i=0; i<nV; ++i )
-				{
-					if ( ( ( lb_new == 0 ) || ( lb_new_far[i] > lb_new[i] ) ) && ( getAbs ( lb_new_far[i] - x[i] ) < tol ) )
-						++nActiveFar;
-					if ( ( ( ub_new == 0 ) || ( ub_new_far[i] < ub_new[i] ) ) && ( getAbs ( ub_new_far[i] - x[i] ) < tol ) )
-						++nActiveFar;
-				}
-
-				if ( nActiveFar == 0 )
-					break;
-
-				status = QPS_HOMOTOPYQPSOLVED;
-
-				if ( farbound >= INFTY )
-				{
-					unbounded = BT_TRUE;
-					returnvalue = RET_HOTSTART_STOPPED_UNBOUNDEDNESS;
-					goto farewell;
-				}
-
-				updateFarBounds(	farbound,nV,
-									lb_new,lb_new_far, ub_new,ub_new_far
-									);
-			}
-			else
-			{
-				/* some other error when solving QP */
-				break;
-			}
-
-			/* advance ramp offset to avoid Ramping cycles */
-			rampOffset++;
-		}
-
-		farewell:
-			/* add time to setup auxiliary QP */
-			if ( cputime != 0 )
-				*cputime = cputime_needed + auxTime;
-			delete[] lb_new_far; delete[] ub_new_far;
-	}
-
-	return ( returnvalue != SUCCESSFUL_RETURN ) ? THROWERROR( returnvalue ) : returnvalue;
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue QProblemB::hotstart(	const char* const g_file,
-									const char* const lb_file, const char* const ub_file,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds
-									)
-{
-	int_t nV  = getNV( );
-
-	if ( nV == 0 )
-		return THROWERROR( RET_QPOBJECT_NOT_SETUP );
-
-	/* consistency check */
-	if ( g_file == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Allocate memory (if bounds exist). */
-	real_t* g_new  = new real_t[nV];
-	real_t* lb_new = ( lb_file != 0 ) ? new real_t[nV] : 0;
-	real_t* ub_new = ( ub_file != 0 ) ? new real_t[nV] : 0;
-
-
-	/* 2) Load new QP vectors from file. */
-	returnValue returnvalue;
-	returnvalue = loadQPvectorsFromFile(	g_file,lb_file,ub_file,
-											g_new,lb_new,ub_new
-											);
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		if ( ub_file != 0 )
-			delete[] ub_new;
-		if ( lb_file != 0 )
-			delete[] lb_new;
-		delete[] g_new;
-
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-
-	/* 3) Actually perform hotstart. */
-	returnvalue = hotstart(	g_new,lb_new,ub_new,
-							nWSR,cputime,
-							guessedBounds
-							);
-
-
-	/* 4) Free memory. */
-	if ( ub_file != 0 )
-		delete[] ub_new;
-	if ( lb_file != 0 )
-		delete[] lb_new;
-	delete[] g_new;
-
-	return returnvalue;
-}
-
-
-/*
- *	g e t W o r k i n g S e t
- */
-returnValue QProblemB::getWorkingSet( real_t* workingSet )
-{
-	return getWorkingSetBounds( workingSet );
-}
-
-
-/*
- *	g e t W o r k i n g S e t B o u n d s
- */
-returnValue QProblemB::getWorkingSetBounds( real_t* workingSetB )
-{
-	int_t i;
-	int_t nV = this->getNV();
-
-	if ( workingSetB == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	for ( i=0; i<nV; ++i )
-	{
-		switch ( bounds.getStatus(i) )
-		{
-			case ST_LOWER: workingSetB[i] = -1.0; break;
-			case ST_UPPER: workingSetB[i] = +1.0; break;
-			default:       workingSetB[i] =  0.0; break;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t W o r k i n g S e t C o n s t r a i n t s
- */
-returnValue QProblemB::getWorkingSetConstraints( real_t* workingSetC )
-{
-	if ( workingSetC == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	else
-		return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t N Z
- */
-int_t QProblemB::getNZ( ) const
-{
-	/* if no constraints are present: nZ=nFR */
-	return getNFR( );
-}
-
-
-/*
- *	g e t O b j V a l
- */
-real_t QProblemB::getObjVal( ) const
-{
-	real_t objVal;
-
-	/* calculated optimal objective function value
-	 * only if current QP has been solved */
-	if ( ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED ) )
-	{
-		objVal = getObjVal( x );
-	}
-	else
-	{
-		objVal = INFTY;
-	}
-
-	return objVal;
-}
-
-
-/*
- *	g e t O b j V a l
- */
-real_t QProblemB::getObjVal( const real_t* const _x ) const
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	if ( nV == 0 )
-		return 0.0;
-
-	real_t objVal = 0.0;
-
-	for( i=0; i<nV; ++i )
-		objVal += _x[i]*g[i];
-
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			break;
-
-		case HST_IDENTITY:
-			for( i=0; i<nV; ++i )
-				objVal += 0.5*_x[i]*_x[i];
-			break;
-
-		default:
-			real_t *Hx = new real_t[nV];
-			H->times(1, 1.0, _x, nV, 0.0, Hx, nV);
-			for( i=0; i<nV; ++i )
-				objVal += 0.5*_x[i]*Hx[i];
-			delete[] Hx;
-			break;
-	}
-
-	/* When using regularisation, the objective function value
-	 * needs to be modified as follows:
-	 * objVal = objVal - 0.5*_x*(Hmod-H)*_x - _x'*(gMod-g)
-	 *        = objVal - 0.5*_x*eps*_x * - _x'*(-eps*_x)
-	 *        = objVal + 0.5*_x*eps*_x */
-	if ( usingRegularisation( ) == BT_TRUE )
-	{
-		for( i=0; i<nV; ++i )
-			objVal += 0.5*_x[i]*regVal*_x[i];
-	}
-
-	return objVal;
-}
-
-
-/*
- *	g e t P r i m a l S o l u t i o n
- */
-returnValue QProblemB::getPrimalSolution( real_t* const xOpt ) const
-{
-	int_t i;
-
-	/* return optimal primal solution vector
-	 * only if current QP has been solved */
-	if ( ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED ) )
-	{
-		for( i=0; i<getNV( ); ++i )
-			xOpt[i] = x[i];
-
-		return SUCCESSFUL_RETURN;
-	}
-	else
-	{
-		return RET_QP_NOT_SOLVED;
-	}
-}
-
-
-/*
- *	g e t D u a l S o l u t i o n
- */
-returnValue QProblemB::getDualSolution( real_t* const yOpt ) const
-{
-	int_t i;
-
-	for( i=0; i<getNV( ); ++i )
-		yOpt[i] = y[i];
-
-	/* return optimal dual solution vector
-	 * only if current QP has been solved */
-	if ( ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED ) )
-	{
-		return SUCCESSFUL_RETURN;
-	}
-	else
-	{
-		return RET_QP_NOT_SOLVED;
-	}
-}
-
-
-/*
- *	s e t P r i n t L e v e l
- */
-returnValue QProblemB::setPrintLevel( PrintLevel _printLevel )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-		#ifndef __MATLAB__
-			if ( ( options.printLevel == PL_HIGH ) && ( options.printLevel != _printLevel ) )
-				THROWINFO( RET_PRINTLEVEL_CHANGED );
-		#endif /* __MATLAB__ */
-		options.printLevel = _printLevel;
-	#else
-	options.printLevel = PL_NONE;
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	/* update message handler preferences */
- 	switch ( options.printLevel )
- 	{
- 		case PL_NONE:
- 			getGlobalMessageHandler( )->setErrorVisibilityStatus( VS_HIDDEN );
-			getGlobalMessageHandler( )->setWarningVisibilityStatus( VS_HIDDEN );
-			getGlobalMessageHandler( )->setInfoVisibilityStatus( VS_HIDDEN );
-			break;
-
-		case PL_TABULAR:
-		case PL_LOW:
-			getGlobalMessageHandler( )->setErrorVisibilityStatus( VS_VISIBLE );
-			getGlobalMessageHandler( )->setWarningVisibilityStatus( VS_HIDDEN );
-			getGlobalMessageHandler( )->setInfoVisibilityStatus( VS_HIDDEN );
-			break;
-
-		case PL_DEBUG_ITER:
-		case PL_MEDIUM:
-			getGlobalMessageHandler( )->setErrorVisibilityStatus( VS_VISIBLE );
-			getGlobalMessageHandler( )->setWarningVisibilityStatus( VS_VISIBLE );
-			getGlobalMessageHandler( )->setInfoVisibilityStatus( VS_HIDDEN );
-			break;
-
-		default: /* PL_HIGH */
-			getGlobalMessageHandler( )->setErrorVisibilityStatus( VS_VISIBLE );
-			getGlobalMessageHandler( )->setWarningVisibilityStatus( VS_VISIBLE );
-			getGlobalMessageHandler( )->setInfoVisibilityStatus( VS_VISIBLE );
-			break;
- 	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t P r o p e r t i e s
- */
-returnValue QProblemB::printProperties( )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	/* Do not print properties if print level is set to none! */
-	if ( options.printLevel == PL_NONE )
-		return SUCCESSFUL_RETURN;
-
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	myPrintf( "\n#################   qpOASES  --  QP PROPERTIES   #################\n" );
-	myPrintf( "\n" );
-
-	/* 1) Variables properties. */
-	snprintf( myPrintfString,MAX_STRING_LENGTH,  "Number of Variables: %4.1d\n",(int)getNV( ) );
-	myPrintf( myPrintfString );
-
-	if ( bounds.hasNoLower( ) == BT_TRUE )
-			myPrintf( "Variables are not bounded from below.\n" );
-		else
-			myPrintf( "Variables are bounded from below.\n" );
-
-	if ( bounds.hasNoUpper( ) == BT_TRUE )
-			myPrintf( "Variables are not bounded from above.\n" );
-		else
-			myPrintf( "Variables are bounded from above.\n" );
-
-	myPrintf( "\n" );
-
-
-	/* 2) Further properties. */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			myPrintf( "Hessian is zero matrix (i.e. actually an LP is solved).\n" );
-			break;
-
-		case HST_IDENTITY:
-			myPrintf( "Hessian is identity matrix.\n" );
-			break;
-
-		case HST_POSDEF:
-			myPrintf( "Hessian matrix is (strictly) positive definite.\n" );
-			break;
-
-		case HST_POSDEF_NULLSPACE:
-			myPrintf( "Hessian matrix is positive definite on null space of active constraints.\n" );
-			break;
-
-		case HST_SEMIDEF:
-			myPrintf( "Hessian matrix is positive semi-definite.\n" );
-			break;
-
-		case HST_INDEF:
-			myPrintf( "Hessian matrix is indefinite.\n" );
-			break;
-
-		default:
-			myPrintf( "Hessian matrix has unknown type.\n" );
-			break;
-	}
-
-	if ( infeasible == BT_TRUE )
-		myPrintf( "QP was found to be infeasible.\n" );
-	else
-		myPrintf( "QP seems to be feasible.\n" );
-
-	if ( unbounded == BT_TRUE )
-		myPrintf( "QP was found to be unbounded from below.\n" );
-	else
-		myPrintf( "QP seems to be bounded from below.\n" );
-
-	myPrintf( "\n" );
-
-
-	/* 3) QP object properties. */
-	switch ( status )
-	{
-		case QPS_NOTINITIALISED:
-			myPrintf( "Status of QP object: freshly instantiated or reset.\n" );
-			break;
-
-		case QPS_PREPARINGAUXILIARYQP:
-			myPrintf( "Status of QP object: an auxiliary QP is currently setup.\n" );
-			break;
-
-		case QPS_AUXILIARYQPSOLVED:
-			myPrintf( "Status of QP object: an auxilary QP was solved.\n" );
-			break;
-
-		case QPS_PERFORMINGHOMOTOPY:
-			myPrintf( "Status of QP object: a homotopy step is performed.\n" );
-			break;
-
-		case QPS_HOMOTOPYQPSOLVED:
-			myPrintf( "Status of QP object: an intermediate QP along the homotopy path was solved.\n" );
-			break;
-
-		case QPS_SOLVED:
-			myPrintf( "Status of QP object: solution of the actual QP was found.\n" );
-			break;
-	}
-
-	switch ( options.printLevel )
-	{
-		case PL_DEBUG_ITER:
-			myPrintf( "Print level of QP object is set to display a tabular output for debugging.\n" );
-			break;
-
-		case PL_TABULAR:
-			myPrintf( "Print level of QP object is set to display a tabular output.\n" );
-			break;
-
-		case PL_LOW:
-					myPrintf( "Print level of QP object is low, i.e. only error are printed.\n" );
-			break;
-
-		case PL_MEDIUM:
-			myPrintf( "Print level of QP object is medium, i.e. error and warnings are printed.\n" );
-			break;
-
-		case PL_HIGH:
-			myPrintf( "Print level of QP object is high, i.e. all available output is printed.\n" );
-			break;
-
-		default:
-			break;
-	}
-
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue QProblemB::printOptions( ) const
-{
-	return options.print( );
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue QProblemB::clear( )
-{
-	if ( ( freeHessian == BT_TRUE ) && ( H != 0 ) )
-	{
-		delete H;
-		H = 0;
-	}
-
-	if ( g != 0 )
-	{
-		delete[] g;
-		g = 0;
-	}
-
-	if ( lb != 0 )
-	{
-		delete[] lb;
-		lb = 0;
-	}
-
-	if ( ub != 0 )
-	{
-		delete[] ub;
-		ub = 0;
-	}
-
-	if ( R != 0 )
-	{
-		delete[] R;
-		R = 0;
-	}
-
-	if ( x != 0 )
-	{
-		delete[] x;
-		x = 0;
-	}
-
-	if ( y != 0 )
-	{
-		delete[] y;
-		y = 0;
-	}
-
-	if ( delta_xFR_TMP != 0 )
-	{
-		delete[] delta_xFR_TMP;
-		delta_xFR_TMP = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue QProblemB::copy(	const QProblemB& rhs
-								)
-{
-	uint_t _nV = (uint_t)rhs.getNV( );
-
-	bounds = rhs.bounds;
-
-	freeHessian = rhs.freeHessian;
-
-	if ( freeHessian == BT_TRUE )
-		H = (SymmetricMatrix *)(rhs.H->duplicateSym());
-	else
-		H = rhs.H;
-
-	if ( rhs.g != 0 )
-	{
-		g = new real_t[_nV];
-		setG( rhs.g );
-	}
-	else
-		g = 0;
-
-	if ( rhs.lb != 0 )
-	{
-		lb = new real_t[_nV];
-		setLB( rhs.lb );
-	}
-	else
-		lb = 0;
-
-	if ( rhs.ub != 0 )
-	{
-		ub = new real_t[_nV];
-		setUB( rhs.ub );
-	}
-	else
-		ub = 0;
-
-	if ( rhs.R != 0 )
-	{
-		R = new real_t[_nV*_nV];
-		memcpy( R,rhs.R,_nV*_nV*sizeof(real_t) );
-	}
-	else
-		R = 0;
-
-	haveCholesky = rhs.haveCholesky;
-
-	if ( rhs.x != 0 )
-	{
-		x = new real_t[_nV];
-		memcpy( x,rhs.x,_nV*sizeof(real_t) );
-	}
-	else
-		x = 0;
-
-	if ( rhs.y != 0 )
-	{
-		y = new real_t[_nV];
-		memcpy( y,rhs.y,_nV*sizeof(real_t) );
-	}
-	else
-		y = 0;
-
-	tau = rhs.tau;
-
-	hessianType = rhs.hessianType;
-	regVal = rhs.regVal;
-
-	infeasible = rhs.infeasible;
-	unbounded = rhs.unbounded;
-
-	status = rhs.status;
-
-	count = rhs.count;
-
-	ramp0 = rhs.ramp0;
-	ramp1 = rhs.ramp1;
-	// AW: Following line seemed to be missing
-	rampOffset = rhs.rampOffset;
-
-	delta_xFR_TMP = new real_t[_nV];	/* nFR */
-
-	options = rhs.options;
-	setPrintLevel( options.printLevel );
-
-	flipper = rhs.flipper;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	d e t e r m i n e H e s s i a n T y p e
- */
-returnValue QProblemB::determineHessianType( )
-{
-	int_t i;
-	int_t nV = getNV( );
-	real_t curDiag;
-
-	/* if Hessian type has been set by user, do NOT change it! */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			/* ensure regularisation as default options do not always solve LPs */
-			if ( options.enableRegularisation == BT_FALSE )
-			{
-				options.enableRegularisation = BT_TRUE;
-				options.numRegularisationSteps = 1;
-			}
-			return SUCCESSFUL_RETURN;
-
-		case HST_IDENTITY:
-			return SUCCESSFUL_RETURN;
-
-		case HST_POSDEF:
-        case HST_POSDEF_NULLSPACE:
-        case HST_SEMIDEF:
-		case HST_INDEF:
-			/* if H == 0, continue to reset hessianType to HST_ZERO
-			 *  to avoid segmentation faults! */
-			if ( H != 0 )
-				return SUCCESSFUL_RETURN;
-
-		default:
-			/* HST_UNKNOWN, continue */
-			break;
-	}
-
-	/* if Hessian has not been allocated, assume it to be all zeros! */
-	if ( H == 0 )
-	{
-		hessianType = HST_ZERO;
-		THROWINFO( RET_ZERO_HESSIAN_ASSUMED );
-
-		/* ensure regularisation as default options do not always solve LPs */
-		if ( options.enableRegularisation == BT_FALSE )
-		{
-			options.enableRegularisation = BT_TRUE;
-			options.numRegularisationSteps = 1;
-		}
-
-		return SUCCESSFUL_RETURN;
-	}
-
-	/* 1) If Hessian has outer-diagonal elements,
-	 *    Hessian is assumed to be positive definite. */
-	hessianType = HST_POSDEF;
-	if ( H->isDiag() == BT_FALSE )
-		return SUCCESSFUL_RETURN;
-
-	/* 2) Otherwise it is diagonal and test for identity or zero matrix is performed. */
-	BooleanType isIdentity = BT_TRUE;
-	BooleanType isZero = BT_TRUE;
-
-	for ( i=0; i<nV; ++i )
-	{
-        curDiag = H->diag(i);
-        if ( curDiag >= INFTY )
-            return RET_DIAGONAL_NOT_INITIALISED;
-
-		if ( curDiag < -ZERO )
-		{
-			hessianType = HST_INDEF;
-			if ( options.enableFlippingBounds == BT_FALSE )
-				return THROWERROR( RET_HESSIAN_INDEFINITE );
-			else
-				return SUCCESSFUL_RETURN;
-		}
-
-		if ( getAbs( curDiag - 1.0 ) > EPS )
-			isIdentity = BT_FALSE;
-
-		if ( getAbs( curDiag ) > EPS )
-			isZero = BT_FALSE;
-	}
-
-	if ( isIdentity == BT_TRUE )
-		hessianType = HST_IDENTITY;
-
-	if ( isZero == BT_TRUE )
-	{
-		hessianType = HST_ZERO;
-
-		/* ensure regularisation as default options do not always solve LPs */
-		if ( options.enableRegularisation == BT_FALSE )
-		{
-			options.enableRegularisation = BT_TRUE;
-			options.numRegularisationSteps = 1;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p S u b j e c t T o T y p e
- */
-returnValue QProblemB::setupSubjectToType( )
-{
-	return setupSubjectToType( lb,ub );
-}
-
-
-/*
- *	s e t u p S u b j e c t T o T y p e
- */
-returnValue QProblemB::setupSubjectToType( const real_t* const lb_new, const real_t* const ub_new )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-
-	/* 1) Check if lower bounds are present. */
-	bounds.setNoLower( BT_TRUE );
-	if ( lb_new != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( lb_new[i] > -INFTY )
-			{
-				bounds.setNoLower( BT_FALSE );
-				break;
-			}
-		}
-	}
-
-	/* 2) Check if upper bounds are present. */
-	bounds.setNoUpper( BT_TRUE );
-	if ( ub_new != 0 )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( ub_new[i] < INFTY )
-			{
-				bounds.setNoUpper( BT_FALSE );
-				break;
-			}
-		}
-	}
-
-	/* 3) Determine implicitly fixed and unbounded variables. */
-	if ( ( lb_new != 0 ) && ( ub_new != 0 ) )
-	{
-		for( i=0; i<nV; ++i )
-		{
-			if ( ( lb_new[i] < -INFTY+options.boundTolerance ) && ( ub_new[i] > INFTY-options.boundTolerance )
-					&& (options.enableFarBounds == BT_FALSE))
-			{
-				bounds.setType( i,ST_UNBOUNDED );
-			}
-			else
-			{
-				if (options.enableEqualities
-						&& lb[i] > ub[i] - options.boundTolerance
-						&& lb_new[i] > ub_new[i] - options.boundTolerance)
-					bounds.setType( i,ST_EQUALITY );
-				else
-					bounds.setType( i,ST_BOUNDED );
-			}
-		}
-	}
-	else
-	{
-		if ( ( lb_new == 0 ) && ( ub_new == 0 ) )
-		{
-			for( i=0; i<nV; ++i )
-				bounds.setType( i,ST_UNBOUNDED );
-		}
-		else
-		{
-			for( i=0; i<nV; ++i )
-				bounds.setType( i,ST_BOUNDED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o m p u t e C h o l e s k y
- */
-returnValue QProblemB::computeCholesky( )
-{
-	int_t i, j;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-
-	/* 1) Initialises R with all zeros. */
-	for( i=0; i<nV*nV; ++i )
-		R[i] = 0.0;
-
-	/* 2) Calculate Cholesky decomposition of H (projected to free variables). */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-
-			/* if Hessian is zero matrix and it has been regularised,
-			 * its Cholesky factor is the identity matrix scaled by sqrt(eps). */
-			if ( usingRegularisation( ) == BT_TRUE )
-			{
-				for( i=0; i<nV; ++i )
-					RR(i,i) = getSqrt( regVal );
-			}
-			else
-			{
-				return THROWERROR( RET_CHOLESKY_OF_ZERO_HESSIAN );
-			}
-			break;
-
-
-		case HST_IDENTITY:
-
-			/* if Hessian is identity, so is its Cholesky factor. */
-			for( i=0; i<nV; ++i )
-				RR(i,i) = 1.0;
-			break;
-
-
-		default:
-
-			if ( nFR > 0 )
-			{
-				int_t* FR_idx;
-				bounds.getFree( )->getNumberArray( &FR_idx );
-
-				/* get H */
-				for ( j=0; j < nFR; ++j )
-					H->getCol (FR_idx[j], bounds.getFree (), 1.0, &(R[j*nV]) );
-
-				/* R'*R = H */
-				long info = 0;
-				unsigned long _nFR = (unsigned long)nFR, _nV = (unsigned long)nV;
-
-				POTRF( "U", &_nFR, R, &_nV, &info );
-
-				/* <0 = invalid call, =0 ok, >0 not spd */
-				if (info > 0) {
-					if ( R[0] < 0.0 )
-					{
-						/* Cholesky decomposition has tunneled a negative
-						 * diagonal element. */
-						options.epsRegularisation = getMin( -R[0]+options.epsRegularisation,getSqrt(getAbs(options.epsRegularisation)) );
-					}
-
-					hessianType = HST_SEMIDEF;
-					return RET_HESSIAN_NOT_SPD;
-				}
-
-				/* zero first subdiagonal to make givens updates work */
-				for ( i=0; i<nFR-1; ++i )
-					RR(i+1,i) = 0.0;
-			}
-			break;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p I n i t i a l C h o l e s k y
- */
-returnValue QProblemB::setupInitialCholesky( )
-{
-	returnValue returnvalueCholesky;
-
-	/* If regularisation shall be used, always regularise at beginning
-	 * if initial working set is not empty. */
-	if ( ( getNV() != getNFR()-getNFV() ) && ( options.enableRegularisation == BT_TRUE ) )
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return RET_INIT_FAILED_REGULARISATION;
-
-	returnvalueCholesky = computeCholesky( );
-
-	/* If Hessian is not positive definite, regularise and try again. */
-	if ( returnvalueCholesky == RET_HESSIAN_NOT_SPD )
-	{
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return RET_INIT_FAILED_REGULARISATION;
-
-		returnvalueCholesky = computeCholesky( );
-	}
-
-	if ( returnvalueCholesky != SUCCESSFUL_RETURN )
-		return RET_INIT_FAILED_CHOLESKY;
-
-	haveCholesky = BT_TRUE;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	o b t a i n A u x i l i a r y W o r k i n g S e t
- */
-returnValue QProblemB::obtainAuxiliaryWorkingSet(	const real_t* const xOpt, const real_t* const yOpt,
-													const Bounds* const guessedBounds, Bounds* auxiliaryBounds
-													) const
-{
-	int_t i = 0;
-	int_t nV = getNV( );
-
-
-	/* 1) Ensure that desiredBounds is allocated (and different from guessedBounds). */
-	if ( ( auxiliaryBounds == 0 ) || ( auxiliaryBounds == guessedBounds ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 2) Setup working set for auxiliary initial QP. */
-	if ( guessedBounds != 0 )
-	{
-		/* If an initial working set is specific, use it!
-		 * Moreover, add all implictly fixed variables if specified. */
-		for( i=0; i<nV; ++i )
-		{
-			#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-			if ( bounds.getType( i ) == ST_EQUALITY )
-			{
-				if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-			}
-			else
-			#endif
-			{
-				if ( auxiliaryBounds->setupBound( i,guessedBounds->getStatus( i ) ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-			}
-		}
-	}
-	else	/* No initial working set specified. */
-	{
-		if ( ( xOpt != 0 ) && ( yOpt == 0 ) )
-		{
-			/* Obtain initial working set by "clipping". */
-			for( i=0; i<nV; ++i )
-			{
-				if ( xOpt[i] <= lb[i] + options.boundTolerance )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				if ( xOpt[i] >= ub[i] - options.boundTolerance )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_UPPER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				/* Moreover, add all implictly fixed variables if specified. */
-				#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-				else
-				#endif
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-			}
-		}
-
-		if ( ( xOpt == 0 ) && ( yOpt != 0 ) )
-		{
-			/* Obtain initial working set in accordance to sign of dual solution vector. */
-			for( i=0; i<nV; ++i )
-			{
-				if ( yOpt[i] > EPS )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				if ( yOpt[i] < -EPS )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_UPPER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-					continue;
-				}
-
-				/* Moreover, add all implictly fixed variables if specified. */
-				#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-				else
-				#endif
-				{
-					if ( auxiliaryBounds->setupBound( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-				}
-			}
-		}
-
-		/* If xOpt and yOpt are null pointer and no initial working is specified,
-		 * start with empty working set (or implicitly fixed bounds only)
-		 * for auxiliary QP. */
-		if ( ( xOpt == 0 ) && ( yOpt == 0 ) )
-		{
-			for( i=0; i<nV; ++i )
-			{
-				switch( bounds.getType( i ) )
-				{
-					case ST_UNBOUNDED:
-						if ( auxiliaryBounds->setupBound( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-							return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-						break;
-
-					/* Only add all implictly fixed variables if specified. */
-					#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-					case ST_EQUALITY:
-						if ( auxiliaryBounds->setupBound( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-							return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-						break;
-					#endif
-
-					default:
-						if ( auxiliaryBounds->setupBound( i,options.initialStatusBounds ) != SUCCESSFUL_RETURN )
-							return THROWERROR( RET_OBTAINING_WORKINGSET_FAILED );
-						break;
-				}
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	b a c k s o l v e R
- */
-returnValue QProblemB::backsolveR(	const real_t* const b, BooleanType transposed,
-									real_t* const a
-									) const
-{
-	/* Call standard backsolve procedure (i.e. removingBound == BT_FALSE). */
-	return backsolveR( b,transposed,BT_FALSE,a );
-}
-
-
-/*
- *	b a c k s o l v e R
- */
-returnValue QProblemB::backsolveR(	const real_t* const b, BooleanType transposed,
-									BooleanType removingBound,
-									real_t* const a
-									) const
-{
-	int_t i, j;
-	int_t nV = getNV( );
-	int_t nR = getNZ( );
-
-	real_t sum;
-
-	/* if backsolve is called while removing a bound, reduce nZ by one. */
-	if ( removingBound == BT_TRUE )
-		--nR;
-
-	/* nothing to do */
-	if ( nR <= 0 )
-		return SUCCESSFUL_RETURN;
-
-
-	/* Solve Ra = b, where R might be transposed. */
-	if ( transposed == BT_FALSE )
-	{
-		/* solve Ra = b */
-		for( i=(nR-1); i>=0; --i )
-		{
-			sum = b[i];
-			for( j=(i+1); j<nR; ++j )
-				sum -= RR(i,j) * a[j];
-
-			if ( getAbs( RR(i,i) ) >= ZERO*getAbs( sum ) )
-				a[i] = sum / RR(i,i);
-			else
-				return THROWERROR( RET_DIV_BY_ZERO );
-		}
-	}
-	else
-	{
-		/* solve R^T*a = b */
-		for( i=0; i<nR; ++i )
-		{
-			sum = b[i];
-			for( j=0; j<i; ++j )
-				sum -= RR(j,i) * a[j];
-
-			if ( getAbs( RR(i,i) ) >= ZERO*getAbs( sum ) )
-				a[i] = sum / RR(i,i);
-			else
-				return THROWERROR( RET_DIV_BY_ZERO );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	d e t e r m i n e D a t a S h i f t
- */
-returnValue QProblemB::determineDataShift(	const real_t* const g_new, const real_t* const lb_new, const real_t* const ub_new,
-											real_t* const delta_g, real_t* const delta_lb, real_t* const delta_ub,
-											BooleanType& Delta_bB_isZero
-											)
-{
-	int_t i, ii;
-	int_t nV  = getNV( );
-	int_t nFX = getNFX( );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-
-	/* 1) Calculate shift directions. */
-	for( i=0; i<nV; ++i )
-		delta_g[i]  = g_new[i]  - g[i];
-
-	if ( lb_new != 0 )
-	{
-		for( i=0; i<nV; ++i )
-			delta_lb[i] = lb_new[i] - lb[i];
-	}
-	else
-	{
-		/* if no lower bounds exist, assume the new lower bounds to be -infinity */
-		for( i=0; i<nV; ++i )
-			delta_lb[i] = -INFTY - lb[i];
-	}
-
-	if ( ub_new != 0 )
-	{
-		for( i=0; i<nV; ++i )
-			delta_ub[i] = ub_new[i] - ub[i];
-	}
-	else
-	{
-		/* if no upper bounds exist, assume the new upper bounds to be infinity */
-		for( i=0; i<nV; ++i )
-			delta_ub[i] = INFTY - ub[i];
-	}
-
-	/* 2) Determine if active bounds are to be shifted. */
-	Delta_bB_isZero = BT_TRUE;
-
-	for ( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-
-		if ( ( getAbs( delta_lb[ii] ) > EPS ) || ( getAbs( delta_ub[ii] ) > EPS ) )
-		{
-			Delta_bB_isZero = BT_FALSE;
-			break;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	s e t u p Q P d a t a
- */
-returnValue QProblemB::setupQPdata(	SymmetricMatrix *_H, const real_t* const _g,
-									const real_t* const _lb, const real_t* const _ub
-									)
-{
-	/* 1) Setup Hessian matrix. */
-	setH( _H );
-
-	/* 2) Setup gradient vector. */
-	if ( _g == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	else
-		setG( _g );
-
-	/* 3) Setup lower/upper bounds vector. */
-	setLB( _lb );
-	setUB( _ub );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p Q P d a t a
- */
-returnValue QProblemB::setupQPdata(	const real_t* const _H, const real_t* const _g,
-									const real_t* const _lb, const real_t* const _ub
-									)
-{
-	/* 1) Setup Hessian matrix. */
-	setH( _H );
-
-	/* 2) Setup gradient vector. */
-	if ( _g == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	else
-		setG( _g );
-
-	/* 3) Setup lower/upper bounds vector. */
-	setLB( _lb );
-	setUB( _ub );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p Q P d a t a F r o m F i l e
- */
-returnValue QProblemB::setupQPdataFromFile(	const char* const H_file, const char* const g_file,
-											const char* const lb_file, const char* const ub_file
-											)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	returnValue returnvalue;
-
-
-	/* 1) Load Hessian matrix from file. */
-	if ( H_file != 0 )
-	{
-		real_t* _H = new real_t[nV * nV];
-		returnvalue = readFromFile( _H, nV,nV, H_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] _H;
-			return THROWERROR( returnvalue );
-		}
-		setH( _H );
-		H->doFreeMemory( );
-	}
-	else
-	{
-		real_t* _H = 0;
-		setH( _H );
-	}
-
-	/* 2) Load gradient vector from file. */
-	if ( g_file == 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	returnvalue = readFromFile( g, nV, g_file );
-	if ( returnvalue != SUCCESSFUL_RETURN )
-		return THROWERROR( returnvalue );
-
-	/* 3) Load lower bounds vector from file. */
-	if ( lb_file != 0 )
-	{
-		returnvalue = readFromFile( lb, nV, lb_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-			return THROWERROR( returnvalue );
-	}
-	else
-	{
-		/* if no lower bounds are specified, set them to -infinity */
-		for( i=0; i<nV; ++i )
-			lb[i] = -INFTY;
-	}
-
-	/* 4) Load upper bounds vector from file. */
-	if ( ub_file != 0 )
-	{
-		returnvalue = readFromFile( ub, nV, ub_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-			return THROWERROR( returnvalue );
-	}
-	else
-	{
-		/* if no upper bounds are specified, set them to infinity */
-		for( i=0; i<nV; ++i )
-			ub[i] = INFTY;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	l o a d Q P v e c t o r s F r o m F i l e
- */
-returnValue QProblemB::loadQPvectorsFromFile(	const char* const g_file, const char* const lb_file, const char* const ub_file,
-												real_t* const g_new, real_t* const lb_new, real_t* const ub_new
-												) const
-{
-	int_t nV = getNV( );
-
-	returnValue returnvalue;
-
-
-	/* 1) Load gradient vector from file. */
-	if ( ( g_file != 0 ) && ( g_new != 0 ) )
-	{
-		returnvalue = readFromFile( g_new, nV, g_file );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-			return THROWERROR( returnvalue );
-	}
-	else
-	{
-		/* At least gradient vector needs to be specified! */
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* 2) Load lower bounds vector from file. */
-	if ( lb_file != 0 )
-	{
-		if ( lb_new != 0 )
-		{
-			returnvalue = readFromFile( lb_new, nV, lb_file );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( returnvalue );
-		}
-		else
-		{
-			/* If filename is given, storage must be provided! */
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	/* 3) Load upper bounds vector from file. */
-	if ( ub_file != 0 )
-	{
-		if ( ub_new != 0 )
-		{
-			returnvalue = readFromFile( ub_new, nV, ub_file );
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( returnvalue );
-		}
-		else
-		{
-			/* If filename is given, storage must be provided! */
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t I n f e a s i b i l i t y F l a g
- */
-returnValue QProblemB::setInfeasibilityFlag(	returnValue returnvalue,
-												BooleanType doThrowError
-												)
-{
-	infeasible = BT_TRUE;
-
-	if ( ( doThrowError == BT_TRUE ) || ( options.enableFarBounds == BT_FALSE ) )
-		THROWERROR( returnvalue );
-
-	return returnvalue;
-}
-
-
-/*
- *	a r e B o u n d s C o n s i s t e n t
- */
-returnValue QProblemB::areBoundsConsistent(	const real_t* const lb_new, const real_t* const ub_new ) const
-{
-	if (lb_new && ub_new) {
-		for (int_t i = 0; i < getNV(); ++i) {
-			if (lb_new[i] > ub_new[i]+EPS) {
-				return RET_QP_INFEASIBLE;
-			}
-		}
-	}
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	i s C P U t i m e L i m i t E x c e e d e d
- */
-BooleanType QProblemB::isCPUtimeLimitExceeded(	const real_t* const cputime,
-												real_t starttime,
-												int_t nWSR
-												) const
-{
-	/* Always perform next QP iteration if no CPU time limit is given. */
-	if ( cputime == 0 )
-		return BT_FALSE;
-
-	/* Always perform first QP iteration. */
-	if ( nWSR <= 0 )
-		return BT_FALSE;
-
-	real_t elapsedTime = getCPUtime( ) - starttime;
-	real_t timePerIteration = elapsedTime / ((real_t) nWSR);
-
-	/* Determine if next QP iteration exceed CPU time limit
-	 * considering the (current) average CPU time per iteration. */
-	if ( ( elapsedTime + timePerIteration*1.25 ) <= ( *cputime ) )
-		return BT_FALSE;
-	else
-		return BT_TRUE;
-}
-
-
-/*
- *	r e g u l a r i s e H e s s i a n
- */
-returnValue QProblemB::regulariseHessian( )
-{
-	/* Do nothing if Hessian regularisation is disbaled! */
-	if ( options.enableRegularisation == BT_FALSE )
-		return SUCCESSFUL_RETURN;
-
-	/* Regularisation of identity Hessian not possible. */
-	if ( hessianType == HST_IDENTITY )
-		return THROWERROR( RET_CANNOT_REGULARISE_IDENTITY );
-
-	/* Determine regularisation parameter. */
-	if ( usingRegularisation( ) == BT_TRUE )
-		return SUCCESSFUL_RETURN; /*THROWERROR( RET_HESSIAN_ALREADY_REGULARISED );*/
-	else
-	{
-		/* Regularisation of zero Hessian is done implicitly. */
-		if ( hessianType == HST_ZERO )
-		{
-			regVal = getNorm( g,getNV() ) * options.epsRegularisation;
-		}
-		else
-		{
-			regVal = H->getNorm() * options.epsRegularisation;
-
-			if ( H->addToDiag( regVal ) == RET_NO_DIAGONAL_AVAILABLE )
-				return THROWERROR( RET_CANNOT_REGULARISE_SPARSE );
-		}
-
-		THROWINFO( RET_USING_REGULARISATION );
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *  c r e a t e D i a g S p a r s e M a t
- */
-SymSparseMat* QProblemB::createDiagSparseMat( int_t n, real_t diagVal )
-{
-	real_t* M_val = new real_t[n];
-	sparse_int_t* M_jc = new sparse_int_t[n+1];
-	sparse_int_t* M_ir = new sparse_int_t[n+1];
-
-	for( int_t ii=0; ii<n; ++ii )
-	{
-		M_val[ii] = diagVal;
-		M_jc[ii] = (sparse_int_t)ii;
-		M_ir[ii] = (sparse_int_t)ii;
-	}
-	M_jc[n] = (sparse_int_t)n;
-	M_ir[n] = (sparse_int_t)n;
-
-	SymSparseMat* M = new SymSparseMat( n,n, M_ir,M_jc,M_val );
-	M->createDiagInfo( );
-	M->doFreeMemory( );
-
-	return M;
-}
-
-
-
-/*
- *	p e r f o r m R a t i o T e s t
- */
-returnValue QProblemB::performRatioTest(	int_t nIdx,
-											const int_t* const idxList,
-											const SubjectTo* const subjectTo,
-											const real_t* const num,
-											const real_t* const den,
-											real_t epsNum,
-											real_t epsDen,
-											real_t& t,
-											int_t& BC_idx
-											) const
-{
-	int_t i, ii;
-
-	BC_idx = -1;
-
-	for( i=0; i<nIdx; ++i )
-	{
-		ii = idxList[i];
-
-		if ( subjectTo->getType( ii ) != ST_EQUALITY )
-		{
-			if ( ( subjectTo->getStatus( ii ) == ST_LOWER ) || ( subjectTo->getStatus( ii ) == ST_INACTIVE ) )
-			{
-				if ( isBlocking( num[i],den[i],epsNum,epsDen,t ) == BT_TRUE )
-				{
-					t = num[i] / den[i];
-					BC_idx = ii;
-				}
-			}
-			else
-			if ( subjectTo->getStatus( ii ) == ST_UPPER )
-			{
-				if ( isBlocking( -num[i],-den[i],epsNum,epsDen,t ) == BT_TRUE )
-				{
-					t = num[i] / den[i];
-					BC_idx = ii;
-				}
-			}
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- * g e t R e l a t i v e H o m o t o p y L e n g t h
- */
-real_t QProblemB::getRelativeHomotopyLength(	const real_t* const g_new, const real_t* const lb_new, const real_t* const ub_new
-												)
-{
-	int_t i;
-	int_t nV = getNV( );
-	real_t d, s, len = 0.0;
-
-	/* gradient */
-	for (i = 0; i < nV; i++)
-	{
-		s = getAbs(g_new[i]);
-		if (s < 1.0) s = 1.0;
-		d = getAbs(g_new[i] - g[i]) / s;
-		if (d > len) len = d;
-	}
-	/*fprintf( stderr, "homLen = %e\n", len );*/
-
-	/* lower bounds */
-	if ( lb_new != 0 )
-	{
-		for (i = 0; i < nV; i++)
-		{
-			s = getAbs(lb_new[i]);
-			if (s < 1.0) s = 1.0;
-			d = getAbs(lb_new[i] - lb[i]) / s;
-			if (d > len) len = d;
-		}
-	}
-	/*fprintf( stderr, "homLen = %e\n", len );*/
-
-	/* upper bounds */
-	if ( ub_new != 0 )
-	{
-		for (i = 0; i < nV; i++)
-		{
-			s = getAbs(ub_new[i]);
-			if (s < 1.0) s = 1.0;
-			d = getAbs(ub_new[i] - ub[i]) / s;
-			if (d > len) len = d;
-		}
-	}
-	/*fprintf( stderr, "homLen = %e\n", len );*/
-
-	return len;
-}
-
-
-/*
- * p e r f o r m R a m p i n g
- */
-returnValue QProblemB::performRamping( )
-{
-	int_t nV = getNV( ), bstat, i;
-	real_t t, rampVal;
-
-	/* ramp inactive bounds and active dual variables */
-	for (i = 0; i < nV; i++)
-	{
-		switch (bounds.getType(i))
-		{
-			case ST_EQUALITY: lb[i] = x[i]; ub[i] = x[i]; continue; /* reestablish exact feasibility */
-			case ST_UNBOUNDED: continue;
-			case ST_DISABLED: continue;
-			default: break;
-		}
-
-		t = static_cast<real_t>((i + rampOffset) % nV) / static_cast<real_t>(nV-1);
-		rampVal = (1.0-t) * ramp0 + t * ramp1;
-		bstat = bounds.getStatus(i);
-		if (bstat != ST_LOWER) { lb[i] = x[i] - rampVal; }
-		if (bstat != ST_UPPER) { ub[i] = x[i] + rampVal; }
-		if (bstat == ST_LOWER) { lb[i] = x[i]; y[i] = +rampVal; }
-		if (bstat == ST_UPPER) { ub[i] = x[i]; y[i] = -rampVal; }
-		if (bstat == ST_INACTIVE) y[i] = 0.0; /* reestablish exact complementarity */
-	}
-
-	/* reestablish exact stationarity */
-	setupAuxiliaryQPgradient( );
-
-	/* advance ramp offset to avoid Ramping cycles */
-	rampOffset++;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- * u p d a t e F a r B o u n d s
- */
-returnValue QProblemB::updateFarBounds(	real_t curFarBound, int_t nRamp,
-											const real_t* const lb_new, real_t* const lb_new_far,
-											const real_t* const ub_new, real_t* const ub_new_far
-											) const
-{
-	int_t i;
-	real_t rampVal, t;
-	int_t nV = getNV( );
-
-	if ( options.enableRamping == BT_TRUE )
-	{
-		for ( i=0; i<nV; ++i )
-		{
-			t = static_cast<real_t>((i + rampOffset) % nRamp) / static_cast<real_t>(nRamp-1);
-			rampVal = curFarBound * (1.0 + (1.0-t)*ramp0 + t*ramp1);
-
-			if ( lb_new == 0 )
-				lb_new_far[i] = -rampVal;
-			else
-				lb_new_far[i] = getMax( -rampVal,lb_new[i] );
-
-			if ( ub_new == 0 )
-				ub_new_far[i] = rampVal;
-			else
-				ub_new_far[i] = getMin( rampVal,ub_new[i] );
-		}
-	}
-	else
-	{
-		for ( i=0; i<nV; ++i )
-		{
-			if ( lb_new == 0 )
-				lb_new_far[i] = -curFarBound;
-			else
-				lb_new_far[i] = getMax( -curFarBound,lb_new[i] );
-
-			if ( ub_new == 0 )
-				ub_new_far[i] = curFarBound;
-			else
-				ub_new_far[i] = getMin( curFarBound,ub_new[i] );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-
-
-/*****************************************************************************
- *  P R I V A T E                                                            *
- *****************************************************************************/
-
-/*
- *	s o l v e I n i t i a l Q P
- */
-returnValue QProblemB::solveInitialQP(	const real_t* const xOpt, const real_t* const yOpt,
-										const Bounds* const guessedBounds,
-										const real_t* const _R,
-										int_t& nWSR, real_t* const cputime
-										)
-{
-	int_t i,j;
-	int_t nV = getNV( );
-
-
-	/* start runtime measurement */
-	real_t starttime = 0.0;
-	if ( cputime != 0 )
-		starttime = getCPUtime( );
-
-
-	status = QPS_NOTINITIALISED;
-
-	/* I) ANALYSE QP DATA: */
-	/* 1) Check if Hessian happens to be the identity matrix. */
-	if ( determineHessianType( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 2) Setup type of bounds (i.e. unbounded, implicitly fixed etc.). */
-	if ( setupSubjectToType( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* II) SETUP AUXILIARY QP WITH GIVEN OPTIMAL SOLUTION: */
-	/* 1) Setup bounds data structure. */
-	if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 2) Setup optimal primal/dual solution for auxiliary QP. */
-	if ( setupAuxiliaryQPsolution( xOpt,yOpt ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 3) Obtain linear independent working set for auxiliary QP. */
-	Bounds auxiliaryBounds( nV );
-	if ( obtainAuxiliaryWorkingSet( xOpt,yOpt,guessedBounds, &auxiliaryBounds ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* 4) Setup working set of auxiliary QP and possibly cholesky decomposition. */
-	/* a) Working set of auxiliary QP. */
-	if ( setupAuxiliaryWorkingSet( &auxiliaryBounds,BT_TRUE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_INIT_FAILED );
-
-	/* b) Regularise Hessian if necessary. */
-	if ( ( hessianType == HST_ZERO ) || ( hessianType == HST_SEMIDEF ) )
-	{
-		if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_INIT_FAILED_REGULARISATION );
-	}
-
-	/* c) Copy external Cholesky factor if provided */
-	haveCholesky = BT_FALSE;
-
-	if ( _R != 0 )
-	{
-		if ( options.initialStatusBounds != ST_INACTIVE )
-		{
-			THROWWARNING( RET_NO_CHOLESKY_WITH_INITIAL_GUESS );
-		}
-		else
-		{
-			if ( _R == R )
-			{
-				/* Cholesky factor read from file and already loaded into R. */
-				haveCholesky = BT_TRUE;
-			}
-			else if ( ( xOpt == 0 ) && ( yOpt == 0 ) && ( guessedBounds == 0 ) )
-			{
-				for( i=0; i<nV; ++i )
-					for( j=i; j<nV; ++j )
-						RR(i,j) = _R[i*nV+j];
-				haveCholesky = BT_TRUE;
-			}
-		}
-	}
-
-	/* 5) Store original QP formulation... */
-	real_t* g_original = new real_t[nV];
-	real_t* lb_original = new real_t[nV];
-	real_t* ub_original = new real_t[nV];
-
-	for( i=0; i<nV; ++i )
-	{
-		g_original[i]  = g[i];
-		lb_original[i] = lb[i];
-		ub_original[i] = ub[i];
-	}
-
-	/* ... and setup QP data of an auxiliary QP having an optimal solution
-	 * as specified by the user (or xOpt = yOpt = 0, by default). */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-	{
-		delete[] ub_original; delete[] lb_original; delete[] g_original;
-		return THROWERROR( RET_INIT_FAILED );
-	}
-
-	if ( setupAuxiliaryQPbounds( BT_TRUE ) != SUCCESSFUL_RETURN )
-	{
- 		delete[] ub_original; delete[] lb_original; delete[] g_original;
-		return THROWERROR( RET_INIT_FAILED );
-	}
-
-	status = QPS_AUXILIARYQPSOLVED;
-
-
-	/* III) SOLVE ACTUAL INITIAL QP: */
-
-	/* Allow only remaining CPU time for usual hotstart. */
-	if ( cputime != 0 )
-		*cputime -= getCPUtime( ) - starttime;
-
-	/* Use hotstart method to find the solution of the original initial QP,... */
-	returnValue returnvalue = hotstart( g_original,lb_original,ub_original, nWSR,cputime );
-
-	/* ... deallocate memory,... */
-	delete[] ub_original; delete[] lb_original; delete[] g_original;
-
-	/* ... check for infeasibility and unboundedness... */
-	if ( isInfeasible( ) == BT_TRUE )
-		return THROWERROR( RET_INIT_FAILED_INFEASIBILITY );
-
-	if ( isUnbounded( ) == BT_TRUE )
-		return THROWERROR( RET_INIT_FAILED_UNBOUNDEDNESS );
-
-	/* ... and internal errors. */
-	if ( ( returnvalue != SUCCESSFUL_RETURN ) && ( returnvalue != RET_MAX_NWSR_REACHED ) )
-		return THROWERROR( RET_INIT_FAILED_HOTSTART );
-
-
-	/* stop runtime measurement */
-	if ( cputime != 0 )
-		*cputime = getCPUtime( ) - starttime;
-
-	THROWINFO( RET_INIT_SUCCESSFUL );
-
-	return returnvalue;
-}
-
-
-/*
- *	s o l v e Q P
- */
-returnValue QProblemB::solveQP(	const real_t* const g_new,
-								const real_t* const lb_new, const real_t* const ub_new,
-								int_t& nWSR, real_t* const cputime, int_t nWSRperformed,
-								BooleanType isFirstCall
-								)
-{
-	int_t iter;
-	int_t nV  = getNV( );
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED );
-	}
-
-	/* start runtime measurement */
-	real_t starttime = 0.0;
-	if ( cputime != 0 )
-		starttime = getCPUtime( );
-
-
-	/* I) PREPARATIONS */
-	/* 1) Allocate delta vectors of gradient and bounds,
-	 *    index arrays and step direction arrays. */
-	real_t* delta_xFR = new real_t[nV];
-	real_t* delta_xFX = new real_t[nV];
-	real_t* delta_yFX = new real_t[nV];
-
-	real_t* delta_g  = new real_t[nV];
-	real_t* delta_lb = new real_t[nV];
-	real_t* delta_ub = new real_t[nV];
-
-	returnValue returnvalue;
-	BooleanType Delta_bB_isZero;
-
-	int_t BC_idx;
-	SubjectToStatus BC_status;
-
-	real_t homotopyLength;
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-	/* 2) Update type of bounds, e.g. a formerly implicitly fixed
-	 *    variable might have become a normal one etc. */
-	if ( setupSubjectToType( lb_new,ub_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_HOTSTART_FAILED );
-
-	/* 3) Reset status flags. */
-	infeasible = BT_FALSE;
-	unbounded  = BT_FALSE;
-
-
-	/* II) MAIN HOMOTOPY LOOP */
-	for( iter=nWSRperformed; iter<nWSR; ++iter )
-	{
-		tabularOutput.idxAddB = tabularOutput.idxRemB = tabularOutput.idxAddC = tabularOutput.idxRemC = -1;
-		tabularOutput.excAddB = tabularOutput.excRemB = tabularOutput.excAddC = tabularOutput.excRemC = 0;
-
-		if ( isCPUtimeLimitExceeded( cputime,starttime,iter-nWSRperformed ) == BT_TRUE )
-		{
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			break;
-		}
-
-		status = QPS_PERFORMINGHOMOTOPY;
-
-		#ifndef __SUPPRESSANYOUTPUT__
-		if ( isFirstCall == BT_TRUE )
-			snprintf( messageString,MAX_STRING_LENGTH,"%d ...",(int)iter );
-		else
-			snprintf( messageString,MAX_STRING_LENGTH,"%d* ...",(int)iter );
-		getGlobalMessageHandler( )->throwInfo( RET_ITERATION_STARTED,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#endif
-
-		/* 2) Initialise shift direction of the gradient and the bounds. */
-		returnvalue = determineDataShift(	g_new,lb_new,ub_new,
-											delta_g,delta_lb,delta_ub,
-											Delta_bB_isZero
-											);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_SHIFT_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-		/* 3) Determination of step direction of X and Y. */
-		returnvalue = determineStepDirection(	delta_g,delta_lb,delta_ub,
-												Delta_bB_isZero,
-												delta_xFX,delta_xFR,delta_yFX
-												);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_STEPDIRECTION_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-
-		/* 4) Determination of step length TAU.
-		 *    This step along the homotopy path is also taken (without changing working set). */
-		returnvalue = performStep(	delta_g,delta_lb,delta_ub,
-									delta_xFX,delta_xFR,delta_yFX,
-									BC_idx,BC_status
-									);
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			THROWERROR( RET_STEPLENGTH_DETERMINATION_FAILED );
-			return returnvalue;
-		}
-
-		/* 5) Termination criterion. */
-		homotopyLength = getRelativeHomotopyLength(g_new, lb_new, ub_new);
-		if ( homotopyLength <= options.terminationTolerance )
-		{
-			status = QPS_SOLVED;
-
-			THROWINFO( RET_OPTIMAL_SOLUTION_FOUND );
-
-			if ( printIteration( iter,BC_idx,BC_status,homotopyLength,isFirstCall ) != SUCCESSFUL_RETURN )
-				THROWERROR( RET_PRINT_ITERATION_FAILED ); /* do not pass this as return value! */
-
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-			return SUCCESSFUL_RETURN;
-		}
-
-
-		/* 6) Change active set. */
-		returnvalue = changeActiveSet( BC_idx,BC_status );
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-			delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-			/* Assign number of working set recalculations and stop runtime measurement. */
-			nWSR = iter;
-			if ( cputime != 0 )
-				*cputime = getCPUtime( ) - starttime;
-
-			/* checks for infeasibility... */
-			if ( infeasible == BT_TRUE )
-			{
-				status = QPS_HOMOTOPYQPSOLVED;
-				return setInfeasibilityFlag( RET_HOTSTART_STOPPED_INFEASIBILITY );
-			}
-
-			/* ...unboundedness... */
-			if ( unbounded == BT_TRUE ) /* not necessary since objective function convex! */
-				return THROWERROR( RET_HOTSTART_STOPPED_UNBOUNDEDNESS );
-
-			/* ... and throw unspecific error otherwise */
-			THROWERROR( RET_HOMOTOPY_STEP_FAILED );
-			return returnvalue;
-		}
-
-		/* 6a) Possibly refactorise projected Hessian from scratch. */
-		if ( ( options.enableCholeskyRefactorisation > 0 ) && ( (iter % options.enableCholeskyRefactorisation) == 0 ) )
-		{
-			returnvalue = computeCholesky( );
-			if (returnvalue != SUCCESSFUL_RETURN)
-			{
-				delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-				delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-				return returnvalue;
-			}
-		}
-
-
-		/* 7) Perform Ramping Strategy on zero homotopy step or drift correction (if desired). */
-		 if ( ( tau <= EPS ) && ( options.enableRamping == BT_TRUE ) )
-			performRamping( );
-		else
-		if ( (options.enableDriftCorrection > 0) && ((iter+1) % options.enableDriftCorrection == 0) )
-			performDriftCorrection( );  /* always returns SUCCESSFUL_RETURN */
-
-		/* 8) Output information of successful QP iteration. */
-		status = QPS_HOMOTOPYQPSOLVED;
-
-		if ( printIteration( iter,BC_idx,BC_status,homotopyLength,isFirstCall ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_PRINT_ITERATION_FAILED ); /* do not pass this as return value! */
-	}
-
-	delete[] delta_yFX; delete[] delta_xFX; delete[] delta_xFR;
-	delete[] delta_ub; delete[] delta_lb; delete[] delta_g;
-
-	/* stop runtime measurement */
-	if ( cputime != 0 )
-		*cputime = getCPUtime( ) - starttime;
-
-
-	/* if programm gets to here, output information that QP could not be solved
-	 * within the given maximum numbers of working set changes */
-	if ( options.printLevel == PL_HIGH )
-	{
-		#ifndef __SUPPRESSANYOUTPUT__
-		snprintf( messageString,MAX_STRING_LENGTH,"(nWSR = %d)",(int)iter );
-		return getGlobalMessageHandler( )->throwWarning( RET_MAX_NWSR_REACHED,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#else
-		return RET_MAX_NWSR_REACHED;
-		#endif
-	}
-	else
-	{
-		return RET_MAX_NWSR_REACHED;
-	}
-}
-
-
-/*
- *	s o l v e R e g u l a r i s e d Q P
- */
-returnValue QProblemB::solveRegularisedQP(	const real_t* const g_new,
-											const real_t* const lb_new, const real_t* const ub_new,
-											int_t& nWSR, real_t* const cputime, int_t nWSRperformed,
-											BooleanType isFirstCall
-											)
-{
-	int_t i, step;
-	int_t nV = getNV( );
-
-
-	/* Perform normal QP solution if QP has not been regularised. */
-	if ( usingRegularisation( ) == BT_FALSE )
-		return solveQP( g_new,lb_new,ub_new, nWSR,cputime,nWSRperformed,isFirstCall );
-
-
-	/* I) SOLVE USUAL REGULARISED QP */
-	returnValue returnvalue;
-
-	int_t nWSR_max   = nWSR;
-	int_t nWSR_total = nWSRperformed;
-
-	real_t cputime_total = 0.0;
-	real_t cputime_cur   = 0.0;
-
-	if ( cputime == 0 )
-	{
-		returnvalue = solveQP( g_new,lb_new,ub_new, nWSR,0,nWSRperformed,isFirstCall );
-	}
-	else
-	{
-		cputime_cur = *cputime;
-		returnvalue = solveQP( g_new,lb_new,ub_new, nWSR,&cputime_cur,nWSRperformed,isFirstCall );
-	}
-	nWSR_total     = nWSR;
-	cputime_total += cputime_cur;
-	isFirstCall    = BT_FALSE;
-
-
-	/* Only continue if QP solution has been successful. */
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		if ( cputime != 0 )
-			*cputime = cputime_total;
-
-		if ( returnvalue == RET_MAX_NWSR_REACHED )
-			THROWWARNING( RET_NO_REGSTEP_NWSR );
-
-		return returnvalue;
-	}
-
-
-	/* II) PERFORM SUCCESSIVE REGULARISATION STEPS */
-	real_t* gMod = new real_t[nV];
-
-	for( step=0; step<options.numRegularisationSteps; ++step )
-	{
-		/* 1) Modify gradient: gMod = g - eps*xOpt
-		 *    (assuming regularisation matrix to be regVal*Id). */
-		for( i=0; i<nV; ++i )
-			gMod[i] = g_new[i] - regVal*x[i];
-
-		/* 2) Solve regularised QP with modified gradient allowing
-		 *    only as many working set recalculations and CPU time
-		 *    as have been left from previous QP solutions. */
-		if ( cputime == 0 )
-		{
-			nWSR = nWSR_max;
-			returnvalue = solveQP( gMod,lb_new,ub_new, nWSR,0,nWSR_total,isFirstCall );
-		}
-		else
-		{
-			nWSR = nWSR_max;
-			cputime_cur = *cputime - cputime_total;
-			returnvalue = solveQP( gMod,lb_new,ub_new, nWSR,&cputime_cur,nWSR_total,isFirstCall );
-		}
-
-		nWSR_total     = nWSR;
-		cputime_total += cputime_cur;
-
-		/* Only continue if QP solution has been successful. */
-		if ( returnvalue != SUCCESSFUL_RETURN )
-		{
-			delete[] gMod;
-
-			if ( cputime != 0 )
-				*cputime = cputime_total;
-
-			if ( returnvalue == RET_MAX_NWSR_REACHED )
-				THROWWARNING( RET_FEWER_REGSTEPS_NWSR );
-
-			return returnvalue;
-		}
-	}
-
-	for( i=0; i<nV; ++i )
-		g[i] = g_new[i];
-
-	delete[] gMod;
-
-	if ( cputime != 0 )
-		*cputime = cputime_total;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y W o r k i n g S e t
- */
-returnValue QProblemB::setupAuxiliaryWorkingSet( 	const Bounds* const auxiliaryBounds,
-													BooleanType setupAfresh
-													)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	/* consistency checks */
-	if ( auxiliaryBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-			if ( ( bounds.getStatus( i ) == ST_UNDEFINED ) || ( auxiliaryBounds->getStatus( i ) == ST_UNDEFINED ) )
-				return THROWERROR( RET_UNKNOWN_BUG );
-	}
-	else
-	{
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-
-	/* I) SETUP CHOLESKY FLAG:
-	 *    Cholesky decomposition shall only be updated if working set
-	 *    shall be updated (i.e. NOT setup afresh!) */
-	BooleanType updateCholesky;
-	if ( setupAfresh == BT_TRUE )
-		updateCholesky = BT_FALSE;
-	else
-		updateCholesky = BT_TRUE;
-
-
-	/* II) REMOVE FORMERLY ACTIVE BOUNDS (IF NECESSARY): */
-	if ( setupAfresh == BT_FALSE )
-	{
-		/* Remove all active bounds that shall be inactive AND
-		*  all active bounds that are active at the wrong bound. */
-		for( i=0; i<nV; ++i )
-		{
-			if ( ( bounds.getStatus( i ) == ST_LOWER ) && ( auxiliaryBounds->getStatus( i ) != ST_LOWER ) )
-				if ( removeBound( i,updateCholesky ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-			if ( ( bounds.getStatus( i ) == ST_UPPER ) && ( auxiliaryBounds->getStatus( i ) != ST_UPPER ) )
-				if ( removeBound( i,updateCholesky ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-		}
-	}
-
-
-	/* III) ADD NEWLY ACTIVE BOUNDS: */
-	/*      Add all inactive bounds that shall be active AND
-	 *      all formerly active bounds that have been active at the wrong bound. */
-	for( i=0; i<nV; ++i )
-	{
-		if ( ( bounds.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryBounds->getStatus( i ) != ST_INACTIVE ) )
-		{
-			if ( addBound( i,auxiliaryBounds->getStatus( i ),updateCholesky ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P s o l u t i o n
- */
-returnValue QProblemB::setupAuxiliaryQPsolution(	const real_t* const xOpt, const real_t* const yOpt
-													)
-{
-	int_t i;
-	int_t nV = getNV( );
-
-
-	/* Setup primal/dual solution vectors for auxiliary initial QP:
-	 * if a null pointer is passed, a zero vector is assigned;
-	 * old solution vector is kept if pointer to internal solution vector is passed. */
-	if ( xOpt != 0 )
-	{
-		if ( xOpt != x )
-			for( i=0; i<nV; ++i )
-				x[i] = xOpt[i];
-	}
-	else
-	{
-		for( i=0; i<nV; ++i )
-			x[i] = 0.0;
-	}
-
-	if ( yOpt != 0 )
-	{
-		if ( yOpt != y )
-			for( i=0; i<nV; ++i )
-				y[i] = yOpt[i];
-	}
-	else
-	{
-		for( i=0; i<nV; ++i )
-			y[i] = 0.0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P g r a d i e n t
- */
-returnValue QProblemB::setupAuxiliaryQPgradient( )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	/* Setup gradient vector: g = -H*x + y'*Id. */
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			if ( usingRegularisation( ) == BT_FALSE )
-				for ( i=0; i<nV; ++i )
-					g[i] = y[i];
-			else
-				for ( i=0; i<nV; ++i )
-					g[i] = y[i] - regVal*x[i];
-			break;
-
-		case HST_IDENTITY:
-			for ( i=0; i<nV; ++i )
-				g[i] = y[i] - x[i];
-			break;
-
-		default:
-			/* y'*Id */
-			for ( i=0; i<nV; ++i )
-				g[i] = y[i];
-
-			/* -H*x */
-			H->times(1, -1.0, x, nV, 1.0, g, nV);
-
-			break;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P b o u n d s
- */
-returnValue QProblemB::setupAuxiliaryQPbounds( BooleanType useRelaxation )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-
-	/* Setup bound vectors. */
-	for ( i=0; i<nV; ++i )
-	{
-		switch ( bounds.getStatus( i ) )
-		{
-			case ST_INACTIVE:
-				if ( useRelaxation == BT_TRUE )
-				{
-					if ( bounds.getType( i ) == ST_EQUALITY )
-					{
-						lb[i] = x[i];
-						ub[i] = x[i];
-					}
-					else
-					{
-						lb[i] = x[i] - options.boundRelaxation;
-						ub[i] = x[i] + options.boundRelaxation;
-					}
-				}
-				break;
-
-			case ST_LOWER:
-				lb[i] = x[i];
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					ub[i] = x[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						ub[i] = x[i] + options.boundRelaxation;
-				}
-				break;
-
-			case ST_UPPER:
-				ub[i] = x[i];
-				if ( bounds.getType( i ) == ST_EQUALITY )
-				{
-					lb[i] = x[i];
-				}
-				else
-				{
-					if ( useRelaxation == BT_TRUE )
-						lb[i] = x[i] - options.boundRelaxation;
-				}
-				break;
-
-            case ST_DISABLED:
-                break;
-
-			default:
-				return THROWERROR( RET_UNKNOWN_BUG );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P
- */
-returnValue QProblemB::setupAuxiliaryQP( const Bounds* const guessedBounds )
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	/* nothing to do */
-	if ( guessedBounds == &bounds )
-		return SUCCESSFUL_RETURN;
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* I) SETUP WORKING SET ... */
-	if ( shallRefactorise( guessedBounds ) == BT_TRUE )
-	{
-		/* ... WITH REFACTORISATION: */
-		/* 1) Reset bounds ... */
-		bounds.init( nV );
-
-		/*    ... and set them up afresh. */
-		if ( setupSubjectToType( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* 2) Setup guessed working set afresh. */
-		if ( setupAuxiliaryWorkingSet( guessedBounds,BT_TRUE ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* 3) Calculate Cholesky decomposition. */
-		if ( computeCholesky( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-	else
-	{
-		/* ... WITHOUT REFACTORISATION: */
-		if ( setupAuxiliaryWorkingSet( guessedBounds,BT_FALSE ) != SUCCESSFUL_RETURN )
-			THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-
-
-	/* II) SETUP AUXILIARY QP DATA: */
-	/* 1) Ensure that dual variable is zero for free bounds. */
-	for ( i=0; i<nV; ++i )
-		if ( bounds.getStatus( i ) == ST_INACTIVE )
-			y[i] = 0.0;
-
-	/* 2) Setup gradient and bound vectors. */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-		THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	if ( setupAuxiliaryQPbounds( BT_FALSE ) != SUCCESSFUL_RETURN )
-		THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	d e t e r m i n e S t e p D i r e c t i o n
- */
-returnValue QProblemB::determineStepDirection(	const real_t* const delta_g, const real_t* const delta_lb, const real_t* const delta_ub,
-												BooleanType Delta_bB_isZero,
-												real_t* const delta_xFX, real_t* const delta_xFR,
-												real_t* const delta_yFX
-												)
-{
-	int_t i, ii;
-	int_t r;
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-
-	int_t* FR_idx;
-	int_t* FX_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-
-	/* This routine computes
-	 * delta_xFX := delta_b
-	 * delta_xFR := R \ R' \ -( delta_g + HMX*delta_xFX )
-	 * delta_yFX := HMX'*delta_xFR + HFX*delta_xFX  { + eps*delta_xFX }
-	 */
-
-	/* I) DETERMINE delta_xFX := delta_{l|u}b */
-	if ( Delta_bB_isZero == BT_FALSE )
-	{
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-
-			if ( bounds.getStatus( ii ) == ST_LOWER )
-				delta_xFX[i] = delta_lb[ii];
-			else
-				delta_xFX[i] = delta_ub[ii];
-		}
-	}
-	else
-	{
-		for( i=0; i<nFX; ++i )
-			delta_xFX[i] = 0.0;
-	}
-
-
-	/* delta_xFR_TMP holds the residual, initialized with right hand side
-	 * delta_xFR holds the step that gets refined incrementally */
-	for ( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		delta_xFR_TMP[i] = - delta_g[ii];
-		delta_xFR[i] = 0.0;
-	}
-
-
-	/* Iterative refinement loop for delta_xFR */
-	for ( r=0; r<=options.numRefinementSteps; ++r )
-	{
-		/* II) DETERMINE delta_xFR */
-		if ( nFR > 0 )
-		{
-			/* Add - HMX*delta_xFX
-			 * This is skipped if delta_b=0 or mixed part HM=0 (H=0 or H=Id) */
-			if ( ( hessianType != HST_ZERO ) && ( hessianType != HST_IDENTITY ) && ( Delta_bB_isZero == BT_FALSE ) && ( r == 0 ) )
-				H->times(bounds.getFree(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, delta_xFR_TMP, nFR);
-
-			/* Determine R' \ ( - HMX*delta_xFX - delta_gFR ) where R'R = HFR */
-			if ( backsolveR( delta_xFR_TMP,BT_TRUE,delta_xFR_TMP ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_STEPDIRECTION_FAILED_CHOLESKY );
-
-			/* Determine HFR \ ( - HMX*delta_xFX - delta_gFR ) */
-			if ( backsolveR( delta_xFR_TMP,BT_FALSE,delta_xFR_TMP ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_STEPDIRECTION_FAILED_CHOLESKY );
-		}
-
-		/* refine solution found for delta_xFR so far */
-		for ( i=0; i<nFR; ++i )
-			delta_xFR[i] += delta_xFR_TMP[i];
-
-		if ( options.numRefinementSteps > 0 )
-		{
-			real_t rnrm = 0.0;
-			/* compute new residual in delta_xFR_TMP:
-			 * residual := - HFR*delta_xFR - HMX*delta_xFX - delta_gFR
-			 * set to -delta_gFR */
-			for ( i=0; i<nFR; ++i )
-			{
-				ii = FR_idx[i];
-				delta_xFR_TMP[i] = -delta_g[ii];
-			}
-			/* add - HFR*delta_xFR */
-			switch ( hessianType )
-			{
-				case HST_ZERO:
-					break;
-
-				case HST_IDENTITY:
-					for ( i=0; i<nFR; ++i )
-					{
-						delta_xFR_TMP[i] -= delta_xFR[i];
-
-						/* compute max norm */
-						if (rnrm < getAbs (delta_xFR_TMP[i]))
-							rnrm = getAbs (delta_xFR_TMP[i]);
-					}
-					break;
-
-				default:
-					H->times(bounds.getFree(), bounds.getFree(),  1, -1.0, delta_xFR, nFR, 1.0, delta_xFR_TMP, nFR);
-					H->times(bounds.getFree(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, delta_xFR_TMP, nFR);
-
-					/* compute max norm */
-					for ( i=0; i<nFR; ++i )
-						if (rnrm < getAbs (delta_xFR_TMP[i]))
-							rnrm = getAbs (delta_xFR_TMP[i]);
-
-					break;
-			}
-
-			/* early termination of residual norm small enough */
-			if ( rnrm < options.epsIterRef )
-				break;
-		}
-
-	} /* end of refinement loop for delta_xFR */
-
-	/* III) DETERMINE delta_yFX */
-	if ( nFX > 0 )
-	{
-		if ( ( hessianType == HST_ZERO ) || ( hessianType == HST_IDENTITY ) )
-		{
-			for( i=0; i<nFX; ++i )
-			{
-				/* set to delta_g */
-				ii = FX_idx[i];
-				delta_yFX[i] = delta_g[ii];
-
-				/* add HFX*delta_xFX = {0|I}*delta_xFX */
-				if ( hessianType == HST_ZERO )
-				{
-					if ( usingRegularisation( ) == BT_TRUE )
-						delta_yFX[i] += regVal*delta_xFX[i];
-				}
-				else
-					delta_yFX[i] += delta_xFX[i];
-			}
-		}
-		else
-		{
-			for( i=0; i<nFX; ++i )
-			{
-				/* set to delta_g */
-				ii = FX_idx[i];
-				delta_yFX[i] = delta_g[ii];
-			}
-			H->times(bounds.getFixed(), bounds.getFree(), 1, 1.0, delta_xFR, nFR, 1.0, delta_yFX, nFX);
-			if (Delta_bB_isZero == BT_FALSE)
-				H->times(bounds.getFixed(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, delta_yFX, nFX);
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p e r f o r m S t e p
- */
-returnValue QProblemB::performStep(	const real_t* const delta_g,
-									const real_t* const delta_lb, const real_t* const delta_ub,
-									const real_t* const delta_xFX,
-									const real_t* const delta_xFR,
-									const real_t* const delta_yFX,
-									int_t& BC_idx, SubjectToStatus& BC_status
-									)
-{
-	int_t i, ii;
-	int_t nV = getNV( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-
-	int_t* FR_idx;
-	int_t* FX_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	tau = 1.0;
-	BC_idx = -1;
-	BC_status = ST_UNDEFINED;
-
-	int_t BC_idx_tmp = -1;
-
-	real_t* num = new real_t[nV];
-	real_t* den = new real_t[nV];
-
-
-	/* I) DETERMINE MAXIMUM DUAL STEPLENGTH, i.e. ensure that
-	 *    active dual bounds remain valid (ignoring implicitly fixed variables): */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-		den[i] = -delta_yFX[i];
-	}
-
-	performRatioTest( nFX,FX_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-	if ( BC_idx_tmp >= 0 )
-	{
-		BC_idx = BC_idx_tmp;
-		BC_status = ST_INACTIVE;
-	}
-
-
-	/* II) DETERMINE MAXIMUM PRIMAL STEPLENGTH, i.e. ensure that
-	 *     inactive bounds remain valid (ignoring unbounded variables). */
-	/* 1) Inactive lower bounds. */
-	if ( bounds.hasNoLower( ) == BT_FALSE )
-	{
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			num[i] = getMax( x[ii] - lb[ii],0.0 );
-			den[i] = delta_lb[ii] - delta_xFR[i];
-		}
-
-		performRatioTest( nFR,FR_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_LOWER;
-		}
-	}
-
-	/* 2) Inactive upper bounds. */
-	if ( bounds.hasNoUpper( ) == BT_FALSE )
-	{
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			num[i] = getMax( ub[ii] - x[ii],0.0 );
-			den[i] = delta_xFR[i] - delta_ub[ii];
-		}
-
-		performRatioTest( nFR,FR_idx,&bounds, num,den, options.epsNum,options.epsDen, tau,BC_idx_tmp );
-
-		if ( BC_idx_tmp >= 0 )
-		{
-			BC_idx = BC_idx_tmp;
-			BC_status = ST_UPPER;
-		}
-	}
-
-	delete[] den;
-	delete[] num;
-
-
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-
-	if ( BC_status == ST_UNDEFINED )
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e!",tau );
-	else
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e! (idx = %d, status = %d)",tau,(int)BC_idx,(int)BC_status );
-
-	getGlobalMessageHandler( )->throwInfo( RET_STEPSIZE_NONPOSITIVE,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-	#endif
-
-
-	/* III) PERFORM STEP ALONG HOMOTOPY PATH */
-	if ( tau > ZERO )
-	{
-		/* 1) Perform step in primal und dual space. */
-		for( i=0; i<nFR; ++i )
-		{
-			ii = FR_idx[i];
-			x[ii] += tau*delta_xFR[i];
-		}
-
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			x[ii] += tau*delta_xFX[i];
-			y[ii] += tau*delta_yFX[i];
-		}
-
-		/* 2) Shift QP data. */
-		for( i=0; i<nV; ++i )
-		{
-			g[i]  += tau*delta_g[i];
-			lb[i] += tau*delta_lb[i];
-			ub[i] += tau*delta_ub[i];
-		}
-	}
-	else
-	{
-		/* print a warning if stepsize is zero */
-		#ifndef __SUPPRESSANYOUTPUT__
-		snprintf( messageString,MAX_STRING_LENGTH,"Stepsize is %.15e",tau );
-		getGlobalMessageHandler( )->throwWarning( RET_STEPSIZE,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		#endif
-	}
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c h a n g e A c t i v e S e t
- */
-returnValue QProblemB::changeActiveSet( int_t BC_idx, SubjectToStatus BC_status )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	char messageString[MAX_STRING_LENGTH];
-	#endif
-
-	/* IV) UPDATE ACTIVE SET */
-	switch ( BC_status )
-	{
-		/* Optimal solution found as no working set change detected. */
-		case ST_UNDEFINED:
-			return RET_OPTIMAL_SOLUTION_FOUND;
-
-
-		/* Remove one variable from active set. */
-		case ST_INACTIVE:
-			#ifndef __SUPPRESSANYOUTPUT__
-			snprintf( messageString,MAX_STRING_LENGTH,"bound no. %d.",(int)BC_idx );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeBound( BC_idx,BT_TRUE ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_REMOVE_FROM_ACTIVESET_FAILED );
-
-			y[BC_idx] = 0.0;
-			break;
-
-
-		/* Add one variable to active set. */
-		default:
-			#ifndef __SUPPRESSANYOUTPUT__
-			if ( BC_status == ST_LOWER )
-				snprintf( messageString,MAX_STRING_LENGTH,"lower bound no. %d.",(int)BC_idx );
-			else
-				snprintf( messageString,MAX_STRING_LENGTH,"upper bound no. %d.",(int)BC_idx );
-				getGlobalMessageHandler( )->throwInfo( RET_ADD_TO_ACTIVESET,messageString,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( addBound( BC_idx,BC_status,BT_TRUE ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_ADD_TO_ACTIVESET_FAILED );
-			break;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- * p e r f o r m D r i f t C o r r e c t i o n
- */
-returnValue QProblemB::performDriftCorrection( )
-{
-	int_t i;
-	int_t nV = getNV ();
-
-	for ( i=0; i<nV; ++i )
-	{
-		switch ( bounds.getType ( i ) )
-		{
-			case ST_BOUNDED:
-				switch ( bounds.getStatus ( i ) )
-				{
-					case ST_LOWER:
-						lb[i] = x[i];
-						ub[i] = getMax (ub[i], x[i]);
-						y[i] = getMax (y[i], 0.0);
-						break;
-					case ST_UPPER:
-						lb[i] = getMin (lb[i], x[i]);
-						ub[i] = x[i];
-						y[i] = getMin (y[i], 0.0);
-						break;
-					case ST_INACTIVE:
-						lb[i] = getMin (lb[i], x[i]);
-						ub[i] = getMax (ub[i], x[i]);
-						y[i] = 0.0;
-						break;
-					case ST_UNDEFINED:
-					case ST_INFEASIBLE_LOWER:
-					case ST_INFEASIBLE_UPPER:
-						break;
-				}
-				break;
-			case ST_EQUALITY:
-				lb[i] = x[i];
-				ub[i] = x[i];
-				break;
-			case ST_UNBOUNDED:
-			case ST_UNKNOWN:
-            case ST_DISABLED:
-				break;
-		}
-	}
-
-	return setupAuxiliaryQPgradient( );
-}
-
-
-/*
- *	s h a l l R e f a c t o r i s e
- */
-BooleanType QProblemB::shallRefactorise( const Bounds* const guessedBounds ) const
-{
-	int_t i;
-	int_t nV = getNV( );
-
-	/* always refactorise if Hessian is not known to be positive definite */
-	if ( ( hessianType == HST_SEMIDEF ) || ( hessianType == HST_INDEF ) )
-		return BT_TRUE;
-
-	/* 1) Determine number of bounds that have same status
-	 *    in guessed AND current bounds.*/
-	int_t differenceNumber = 0;
-
-	for( i=0; i<nV; ++i )
-		if ( guessedBounds->getStatus( i ) != bounds.getStatus( i ) )
-			++differenceNumber;
-
-	/* 2) Decide wheter to refactorise or not. */
-	if ( 2*differenceNumber > guessedBounds->getNFX( ) )
-		return BT_TRUE;
-	else
-		return BT_FALSE;
-}
-
-
-/*
- *	a d d B o u n d
- */
-returnValue QProblemB::addBound(	int_t number, SubjectToStatus B_status,
-									BooleanType updateCholesky
-									)
-{
-	int_t i, j;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* Perform cholesky updates only if QProblemB has been initialised! */
-	if ( getStatus( ) == QPS_PREPARINGAUXILIARYQP )
-	{
-		/* UPDATE INDICES */
-		if ( bounds.moveFreeToFixed( number,B_status ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_ADDBOUND_FAILED );
-
-		return SUCCESSFUL_RETURN;
-	}
-
-
-	/* I) PERFORM CHOLESKY UPDATE: */
-	if ( ( updateCholesky == BT_TRUE ) &&
-		 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-	{
-		/* 1) Index of variable to be added within the list of free variables. */
-		int_t number_idx = bounds.getFree( )->getIndex( number );
-
-		real_t c, s, nu;
-
-		/* 2) Use row-wise Givens rotations to restore upper triangular form of R. */
-		for( i=number_idx+1; i<nFR; ++i )
-		{
-			computeGivens( RR(i-1,i),RR(i,i), RR(i-1,i),RR(i,i),c,s );
-			nu = s/(1.0+c);
-
-			for( j=(1+i); j<nFR; ++j ) /* last column of R is thrown away */
-				applyGivens( c,s,nu,RR(i-1,j),RR(i,j), RR(i-1,j),RR(i,j) );
-		}
-
-		/* 3) Delete <number_idx>th column and ... */
-		for( i=0; i<nFR-1; ++i )
-			for( j=number_idx+1; j<nFR; ++j )
-				RR(i,j-1) = RR(i,j);
-		/* ... last column of R. */
-		for( i=0; i<nFR; ++i )
-			RR(i,nFR-1) = 0.0;
-	}
-
-	/* II) UPDATE INDICES */
-	tabularOutput.idxAddB = number;
-	if ( bounds.moveFreeToFixed( number,B_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_ADDBOUND_FAILED );
-
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e B o u n d
- */
-returnValue QProblemB::removeBound(	int_t number,
-									BooleanType updateCholesky
-									)
-{
-	int_t i;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* save index sets and decompositions for flipping bounds strategy */
-	if ( options.enableFlippingBounds == BT_TRUE )
-		flipper.set( &bounds,R );
-
-	/* I) UPDATE INDICES */
-	tabularOutput.idxRemB = number;
-	if ( bounds.moveFixedToFree( number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-	/* Perform cholesky updates only if QProblemB has been initialised! */
-	if ( getStatus( ) == QPS_PREPARINGAUXILIARYQP )
-		return SUCCESSFUL_RETURN;
-
-
-	/* II) PERFORM CHOLESKY UPDATE */
-	if ( ( updateCholesky == BT_TRUE ) &&
-		 ( hessianType != HST_ZERO )   && ( hessianType != HST_IDENTITY ) )
-	{
-		int_t* FR_idx;
-		bounds.getFree( )->getNumberArray( &FR_idx );
-
-		/* 1) Calculate new column of cholesky decomposition. */
-		real_t* rhs = new real_t[nFR+1];
-		real_t* r   = new real_t[nFR];
-
-		real_t r0;
-		switch ( hessianType )
-		{
-			case HST_ZERO: /* TODO: Code can/should? never get here!! */
-				if ( usingRegularisation( ) == BT_FALSE )
-					r0 = 0.0;
-				else
-					r0 = regVal;
-				for( i=0; i<nFR; ++i )
-					rhs[i] = 0.0;
-				break;
-
-			case HST_IDENTITY:
-				r0 = 1.0;
-				for( i=0; i<nFR; ++i )
-					rhs[i] = 0.0;
-				break;
-
-			default:
-				H->getRow(number, bounds.getFree(), 1.0, rhs);
-				r0 = H->diag(number);
-				break;
-		}
-
-		if ( backsolveR( rhs,BT_TRUE,BT_TRUE,r ) != SUCCESSFUL_RETURN )
-		{
-			delete[] rhs; delete[] r;
-			return THROWERROR( RET_REMOVEBOUND_FAILED );
-		}
-
-		for( i=0; i<nFR; ++i )
-			r0 -= r[i]*r[i];
-
-		/* 2) Store new column into R. */
-		for( i=0; i<nFR; ++i )
-			RR(i,nFR) = r[i];
-
-		if ( options.enableFlippingBounds == BT_TRUE )
-		{
-			if ( r0 > options.epsFlipping )
-				RR(nFR,nFR) = getSqrt( r0 );
-			else
-			{
-				hessianType = HST_SEMIDEF;
-
-				flipper.get( &bounds,R );
-				bounds.flipFixed(number);
-
-				switch (bounds.getStatus(number))
-				{
-					case ST_LOWER: lb[number] = ub[number]; break;
-					case ST_UPPER: ub[number] = lb[number]; break;
-					default: delete[] rhs; delete[] r; return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-
-			}
-		}
-		else
-		{
-			if ( r0 > ZERO )
-				RR(nFR,nFR) = getSqrt( r0 );
-			else
-			{
-				delete[] rhs; delete[] r;
-
-				hessianType = HST_SEMIDEF;
-				return THROWERROR( RET_HESSIAN_NOT_SPD );
-			}
-		}
-
-		delete[] rhs; delete[] r;
-	}
-
-	if ( ( hessianType == HST_ZERO ) && ( options.enableFlippingBounds == BT_TRUE ) )
-	{
-		flipper.get( &bounds,R );
-		bounds.flipFixed(number);
-
-		switch (bounds.getStatus(number))
-		{
-			case ST_LOWER: lb[number] = ub[number]; break;
-			case ST_UPPER: ub[number] = lb[number]; break;
-			default: return THROWERROR( RET_MOVING_BOUND_FAILED );
-		}
-
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	p r i n t I t e r a t i o n
- */
-returnValue QProblemB::printIteration( 	int_t iter,
-										int_t BC_idx,	SubjectToStatus BC_status, real_t homotopyLength,
-										BooleanType isFirstCall
-										)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	/* consistency check */
-	if ( iter < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	int_t i;
-	int_t nV = getNV();
-	real_t stat, bfeas, bcmpl;
-	real_t *grad = 0;
-
-	char myPrintfString[MAX_STRING_LENGTH];
-	char info[MAX_STRING_LENGTH];
-	const char excStr[] = " ef";
-
-	switch ( options.printLevel )
-	{
-		case PL_DEBUG_ITER:
-			grad = new real_t[nV];
-			stat = bfeas = bcmpl = 0.0;
-
-			/* stationarity */
-			for (i = 0; i < nV; i++) grad[i] = g[i] - y[i];
-			H->times(1, 1.0, x, nV, 1.0, grad, nV);
-			for (i = 0; i < nV; i++) if (getAbs(grad[i]) > stat) stat = getAbs(grad[i]);
-
-			/* feasibility */
-			for (i = 0; i < nV; i++) if (lb[i] - x[i] > bfeas) bfeas = lb[i] - x[i];
-			for (i = 0; i < nV; i++) if (x[i] - ub[i] > bfeas) bfeas = x[i] - ub[i];
-
-			/* complementarity */
-			for (i = 0; i < nV; i++) if (y[i] > +EPS && getAbs((lb[i] - x[i])*y[i]) > bcmpl) bcmpl = getAbs((lb[i] - x[i])*y[i]);
-			for (i = 0; i < nV; i++) if (y[i] < -EPS && getAbs((ub[i] - x[i])*y[i]) > bcmpl) bcmpl = getAbs((ub[i] - x[i])*y[i]);
-
-			if ( (iter % 10 == 0) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "\n%5s %4s %4s %9s %9s %9s %9s %9s\n",
-						"iter", "addB", "remB", "hom len", "tau", "stat", "bfeas", "bcmpl");
-			}
-			myPrintf( myPrintfString );
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d ",(int)iter );
-			myPrintf( myPrintfString );
-
-			if (tabularOutput.idxAddB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxAddB) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			if (tabularOutput.idxRemB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%4d ",(int)(tabularOutput.idxRemB) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "     " );
-			}
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%9.2e %9.2e %9.2e %9.2e %9.2e\n",
-					homotopyLength, tau, stat, bfeas, bcmpl);
-			myPrintf( myPrintfString );
-
-			delete[] grad;
-			break;
-
-		case PL_TABULAR:
-			if ( (iter % 10 == 0) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "\n%5s %6s %6s %9s %9s\n",
-						"iter", "addB", "remB", "hom len", "tau");
-				myPrintf( myPrintfString );
-			}
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d ",(int)iter );
-			myPrintf( myPrintfString );
-
-			if (tabularOutput.idxAddB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxAddB), excStr[tabularOutput.excAddB]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			if (tabularOutput.idxRemB >= 0)
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH, "%5d%c ",(int)(tabularOutput.idxRemB), excStr[tabularOutput.excRemB]);
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				myPrintf( "       " );
-			}
-
-			snprintf( myPrintfString,MAX_STRING_LENGTH, "%9.2e %9.2e\n", homotopyLength, tau);
-			myPrintf( myPrintfString );
-			break;
-
-		case PL_MEDIUM:
-			/* 1) Print header at first iteration. */
- 			if ( ( iter == 0 ) && ( isFirstCall == BT_TRUE ) )
-			{
-				snprintf( myPrintfString,MAX_STRING_LENGTH,"\n\n#################   qpOASES  --  QP NO. %3.0d   ##################\n\n",(int)count );
-				myPrintf( myPrintfString );
-
-				myPrintf( "    Iter   |    StepLength    |       Info       |   nFX    \n" );
-				myPrintf( " ----------+------------------+------------------+--------- \n" );
-			}
-
-			/* 2) Print iteration line. */
-			if ( BC_status == ST_UNDEFINED )
-			{
-				if ( hessianType == HST_ZERO )
-					snprintf( info,3,"LP" );
-				else
-					snprintf( info,3,"QP" );
-
-				if ( isFirstCall == BT_TRUE )
-					snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d   |   %1.6e   |    %s SOLVED     |  %4.1d   \n", (int)iter,tau,info,(int)getNFX( ) );
-				else
-					snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d*  |   %1.6e   |    %s SOLVED     |  %4.1d   \n", (int)iter,tau,info,(int)getNFX( ) );
-				myPrintf( myPrintfString );
-			}
-			else
-			{
-				if ( BC_status == ST_INACTIVE )
-					snprintf( info,8,"REM BND" );
-				else
-					snprintf( info,8,"ADD BND" );
-
-				snprintf( myPrintfString,MAX_STRING_LENGTH,"   %5.1d   |   %1.6e   |   %s %4.1d   |  %4.1d   \n", (int)iter,tau,info,(int)BC_idx,(int)getNFX( ) );
-				myPrintf( myPrintfString );
-			}
-			break;
-
-		default:
-			/* nothing to display */
-			break;
-	}
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/SQProblem.cpp b/extlibs/qpOASES-3.2.0/src/SQProblem.cpp
deleted file mode 100644
index a787c70..0000000
--- a/extlibs/qpOASES-3.2.0/src/SQProblem.cpp
+++ /dev/null
@@ -1,553 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/SQProblem.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the SQProblem class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming
- *	with varying matrices.
- */
-
-
-#include <qpOASES/SQProblem.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	S Q P r o b l e m
- */
-SQProblem::SQProblem( ) : QProblem( )
-{
-}
-
-
-/*
- *	S Q P r o b l e m
- */
-SQProblem::SQProblem( int_t _nV, int_t _nC, HessianType _hessianType ) : QProblem( _nV,_nC,_hessianType )
-{
-}
-
-
-/*
- *	S Q P r o b l e m
- */
-SQProblem::SQProblem( const SQProblem& rhs ) : QProblem( rhs )
-{
-}
-
-
-/*
- *	~ S Q P r o b l e m
- */
-SQProblem::~SQProblem( )
-{
-}
-
-
-/*
- *	o p e r a t o r =
- */
-SQProblem& SQProblem::operator=( const SQProblem& rhs )
-{
-	if ( this != &rhs )
-	{
-		QProblem::operator=( rhs );
-	}
-
-	return *this;
-}
-
-
-
-/*
- * h o t s t a r t
- */
-returnValue SQProblem::hotstart(	SymmetricMatrix *H_new, const real_t* const g_new, Matrix *A_new,
-									const real_t* const lb_new, const real_t* const ub_new,
-									const real_t* const lbA_new, const real_t* const ubA_new,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-									)
-{
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED );
-	}
-
-
-	real_t starttime = 0.0;
-	real_t auxTime = 0.0;
-
-    if ( cputime != 0 )
-        starttime = getCPUtime( );
-
-
-	/* I) UPDATE QP MATRICES AND VECTORS */
-	if ( setupNewAuxiliaryQP( H_new,A_new,lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-
-	/* II) PERFORM USUAL HOMOTOPY */
-
-	/* Allow only remaining CPU time for usual hotstart. */
-	if ( cputime != 0 )
-	{
-		auxTime = getCPUtime( ) - starttime;
-		*cputime -= auxTime;
-	}
-
-	returnValue returnvalue = QProblem::hotstart(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-													nWSR,cputime,
-													guessedBounds,guessedConstraints
-													);
-	
-	if ( cputime != 0 )
-		*cputime += auxTime;
-
-	return returnvalue;
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue SQProblem::hotstart(	const real_t* const H_new, const real_t* const g_new, const real_t* const A_new,
-									const real_t* const lb_new, const real_t* const ub_new,
-									const real_t* const lbA_new, const real_t* const ubA_new,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-									)
-{
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_HOTSTART_FAILED_AS_QP_NOT_INITIALISED );
-	}
-
-	/* start runtime measurement */
-	real_t starttime = 0.0;
-    if ( cputime != 0 )
-        starttime = getCPUtime( );
-
-
-	/* I) UPDATE QP MATRICES AND VECTORS */
-	if ( setupNewAuxiliaryQP( H_new,A_new,lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-
-	/* II) PERFORM USUAL HOMOTOPY */
-
-	/* Allow only remaining CPU time for usual hotstart. */
-	if ( cputime != 0 )
-		*cputime -= getCPUtime( ) - starttime;
-
-	returnValue returnvalue = QProblem::hotstart(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-													nWSR,cputime,
-													guessedBounds,guessedConstraints
-													);
-
-
-	/* stop runtime measurement */
-	if ( cputime != 0 )
-		*cputime = getCPUtime( ) - starttime;
-
-	return returnvalue;
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue SQProblem::hotstart(	const char* const H_file, const char* const g_file, const char* const A_file,
-									const char* const lb_file, const char* const ub_file,
-									const char* const lbA_file, const char* const ubA_file,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-									)
-{
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	returnValue returnvalue;
-
-	/* consistency checks */
-	if ( ( H_file == 0 ) || ( g_file == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( ( nC > 0 ) && ( A_file == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-
-	/* 1) Load new QP matrices from files. */
-	real_t* H_new  = new real_t[nV*nV];
-	real_t* A_new  = new real_t[nC*nV];
-
-	if ( readFromFile( H_new, nV,nV, H_file ) != SUCCESSFUL_RETURN )
-	{
-		delete[] A_new;
-		delete[] H_new;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	if ( readFromFile( A_new, nC,nV, A_file ) != SUCCESSFUL_RETURN )
-	{
-		delete[] A_new;
-		delete[] H_new;
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	/* 2) Load new QP vectors from files. */
-	real_t* g_new   = new real_t[nV];
-	real_t* lb_new  = ( lb_file != 0 )  ? new real_t[nV] : 0;
-	real_t* ub_new  = ( ub_file != 0 )  ? new real_t[nV] : 0;
-	real_t* lbA_new = ( lbA_file != 0 ) ? new real_t[nC] : 0;
-	real_t* ubA_new = ( ubA_file != 0 ) ? new real_t[nC] : 0;
-
-	returnvalue = loadQPvectorsFromFile(	g_file,lb_file,ub_file,lbA_file,ubA_file,
-											g_new,lb_new,ub_new,lbA_new,ubA_new
-											);
-	if ( returnvalue != SUCCESSFUL_RETURN )
-	{
-		if ( ubA_file != 0 )
-			delete[] ubA_new;
-		if ( lbA_file != 0 )
-			delete[] lbA_new;
-		if ( ub_file != 0 )
-			delete[] ub_new;
-		if ( lb_file != 0 )
-			delete[] lb_new;
-		delete[] g_new;
-		delete[] A_new;
-		delete[] H_new;
-
-		return THROWERROR( RET_UNABLE_TO_READ_FILE );
-	}
-
-	/* 3) Actually perform hotstart. */
-	returnvalue = hotstart(	H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new,
-							nWSR,cputime,
-							guessedBounds,guessedConstraints
-							);
-
-	if ( ubA_file != 0 )
-		delete[] ubA_new;
-	if ( lbA_file != 0 )
-		delete[] lbA_new;
-	if ( ub_file != 0 )
-		delete[] ub_new;
-	if ( lb_file != 0 )
-		delete[] lb_new;
-	delete[] g_new;
-	delete[] A_new;
-	delete[] H_new;
-
-	return returnvalue;
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue SQProblem::hotstart(	const real_t* const g_new,
-									const real_t* const lb_new, const real_t* const ub_new,
-									const real_t* const lbA_new, const real_t* const ubA_new,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-									)
-{
-	/* Call to hotstart function for fixed QP matrices. */
-	return QProblem::hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,cputime, guessedBounds,guessedConstraints );
-}
-
-
-/*
- *	h o t s t a r t
- */
-returnValue SQProblem::hotstart(	const char* const g_file,
-									const char* const lb_file, const char* const ub_file,
-									const char* const lbA_file, const char* const ubA_file,
-									int_t& nWSR, real_t* const cputime,
-									const Bounds* const guessedBounds, const Constraints* const guessedConstraints
-									)
-{
-	/* Call to hotstart function for fixed QP matrices. */
-	return QProblem::hotstart( g_file,lb_file,ub_file,lbA_file,ubA_file, nWSR,cputime, guessedBounds,guessedConstraints );
-}
-
-
-
-#ifdef __MATLAB__
-returnValue SQProblem::resetMatrixPointers( )
-{
-	H = 0;
-	A = 0;
-
-	return SUCCESSFUL_RETURN;
-}
-#endif
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	s e t u p N e w A u x i l i a r y Q P
- */
-returnValue SQProblem::setupNewAuxiliaryQP(	SymmetricMatrix *H_new, Matrix *A_new,
-											const real_t *lb_new, const real_t *ub_new, const real_t *lbA_new, const real_t *ubA_new
-											)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-	returnValue returnvalue;
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED );
-	}
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* I) SETUP NEW QP MATRICES AND VECTORS: */
-	/* 1) Shift constraints' bounds vectors by (A_new - A)'*x_opt to ensure
-	 *    that old optimal solution remains feasible for new QP data. */
-	/*    Firstly, shift by -A'*x_opt and ... */
-	if ( nC > 0 )
-	{
-		if ( A_new == 0 )
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-
-		for ( i=0; i<nC; ++i )
-		{
-			lbA[i] = -Ax_l[i];
-			ubA[i] =  Ax_u[i];
-		}
-
-		/* Set constraint matrix as well as ... */
-		setA( A_new );
-
-		/* ... secondly, shift by +A_new'*x_opt. */
-		for ( i=0; i<nC; ++i )
-		{
-			lbA[i] += Ax[i];
-			ubA[i] += Ax[i];
-		}
-
-		/* update constraint products. */
-		for ( i=0; i<nC; ++i )
-		{
-			Ax_u[i] = ubA[i] - Ax[i];
-			Ax_l[i] = Ax[i] - lbA[i];
-		}
-	}
-
-	/* 2) Set new Hessian matrix, determine Hessian type and
-	 *    regularise new Hessian matrix if necessary. */
-	/* a) Setup new Hessian matrix and determine its type. */
-	if ( H_new != 0 )
-	{
-		setH( H_new );
-
-		hessianType = HST_UNKNOWN;
-		if ( determineHessianType( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* b) Regularise new Hessian if necessary. */
-		if ( ( hessianType == HST_ZERO ) ||
-			 ( hessianType == HST_SEMIDEF ) ||
-			 ( usingRegularisation( ) == BT_TRUE ) )
-		{
-			regVal = 0.0; /* reset previous regularisation */
-
-			if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-		}
-	}
-	else
-	{
-		/* if no Hessian is specified, keep previous trivial Hessian (HST_ZERO or HST_IDENTITY),
-		   otherwise abort */
-		if ( H != 0 )
-			return THROWERROR( RET_NO_HESSIAN_SPECIFIED );
-	}
-
-	/* 3) Setup QP gradient. */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-
-	/* II) SETUP WORKING SETS AND MATRIX FACTORISATIONS: */
-	/* 1) Make a copy of current bounds/constraints ... */
-	Bounds      oldBounds      = bounds;
-	Constraints oldConstraints = constraints;
-
-    /* we're trying to find an active set with positive definite null
-     * space Hessian twice:
-     * - first for the current active set including all equalities
-     * - second after moving all inactive variables to a bound
-     *   (depending on Options). This creates an empty null space and
-     *   is guaranteed to succeed. Thus this loop will exit after n_try=1.
-     */
-    int_t n_try;
-    for (n_try = 0; n_try < 2; ++n_try) {
-
-        if (n_try > 0) {
-            // the current active set leaves an indefinite null space Hessian
-            // move all inactive variables to a bound, creating an empty null space
-            for (int_t ii = 0; ii < nV; ++ii)
-                if (oldBounds.getStatus (ii) == ST_INACTIVE)
-                    oldBounds.setStatus (ii, options.initialStatusBounds);
-        }
-
-        /*    ... reset them ... */
-        bounds.init( nV );
-        constraints.init( nC );
-
-        /*    ... and set them up afresh. */
-        if ( setupSubjectToType(lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN )
-            return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-        if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-            return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-        if ( constraints.setupAllInactive( ) != SUCCESSFUL_RETURN )
-            return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-        /* 2) Setup TQ factorisation. */
-        if ( setupTQfactorisation( ) != SUCCESSFUL_RETURN )
-            return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		// check for equalities that have become bounds ...
-		for (int_t ii = 0; ii < nC; ++ii) {
-			if (oldConstraints.getType (ii) == ST_EQUALITY && constraints.getType (ii) == ST_BOUNDED) {
-				if (oldConstraints.getStatus (ii) == ST_LOWER && y[nV+ii] < 0.0)
-					oldConstraints.setStatus (ii, ST_UPPER);
-				else if (oldConstraints.getStatus (ii) == ST_UPPER && y[nV+ii] > 0.0)
-					oldConstraints.setStatus (ii, ST_LOWER);
-			}
-		}
-
-		// ... and do the same also for the bounds!
-		for (int_t ii = 0; ii < nV; ++ii) {
-			if (oldBounds.getType(ii) == ST_EQUALITY
-					&& bounds.getType(ii) == ST_BOUNDED) {
-				if (oldBounds.getStatus(ii) == ST_LOWER && y[ii] < 0.0)
-					oldBounds.setStatus(ii, ST_UPPER);
-				else if (oldBounds.getStatus(ii) == ST_UPPER && y[ii] > 0.0)
-					oldBounds.setStatus(ii, ST_LOWER);
-			}
-		}
-
-        /* 3) Setup old working sets afresh (updating TQ factorisation). */
-        if ( setupAuxiliaryWorkingSet( &oldBounds,&oldConstraints,BT_TRUE ) != SUCCESSFUL_RETURN )
-            return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-        /* Factorise projected Hessian
-        * this now handles all special cases (no active bounds/constraints, no nullspace) */
-        returnvalue = computeProjectedCholesky( );
-
-        /* leave the loop if decomposition was successful, i.e. we have
-         * found an active set with positive definite null space Hessian */
-        if ( returnvalue == SUCCESSFUL_RETURN )
-            break;
-    }
-
-    /* adjust lb/ub if we changed the old active set in the second try
-     */
-    if (n_try > 0) {
-		// as per setupAuxiliaryQPbounds assumptions ... oh the troubles
-		for (int_t ii = 0; ii < nC; ++ii)
-			Ax_l[ii] = Ax_u[ii] = Ax[ii];
-        setupAuxiliaryQPbounds( &bounds, &constraints, BT_FALSE );
-	}
-
-	status = QPS_AUXILIARYQPSOLVED;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p N e w A u x i l i a r y Q P
- */
-returnValue SQProblem::setupNewAuxiliaryQP(	const real_t* const H_new, const real_t* const A_new,
-											const real_t *lb_new, const real_t *ub_new, const real_t *lbA_new, const real_t *ubA_new
-											)
-{
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	DenseMatrix *dA = 0;
-	SymDenseMat *sH = 0;
-
-	if ( A_new != 0 )
-	{
-		dA = new DenseMatrix(nC, nV, nV, (real_t*) A_new);
-	}
-	else
-	{
-		if ( nC > 0 )
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( H_new != 0 )
-		sH = new SymDenseMat(nV, nV, nV, (real_t*) H_new);
-
-	returnValue returnvalue = setupNewAuxiliaryQP( sH,dA, lb_new,ub_new,lbA_new,ubA_new );
-
-	if ( H_new != 0 )
-		freeHessian = BT_TRUE;
-	freeConstraintMatrix = BT_TRUE;
-
-	return returnvalue;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/SQProblemSchur.cpp b/extlibs/qpOASES-3.2.0/src/SQProblemSchur.cpp
deleted file mode 100644
index e70aa4b..0000000
--- a/extlibs/qpOASES-3.2.0/src/SQProblemSchur.cpp
+++ /dev/null
@@ -1,3626 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2014 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/SQProblemSchur.cpp
- *	\author Andreas Waechter and Dennis Janka, based on QProblem.cpp by Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2012-2015
- *
- *	Implementation of the SQProblemSchur class which is able to use the newly
- *	developed online active set strategy for parametric quadratic programming.
- *	This implementation uses a Schur complement approach to solve the linear
- *	systems.
- */
-
-#include <qpOASES/SQProblemSchur.hpp>
-
-
-#ifndef __MATLAB__
-# include <cstdarg>
-void MyPrintf(const char* pformat, ... )
-{
-  va_list ap;
-  va_start(ap, pformat);
-
-  vfprintf(stdout, pformat, ap);
-
-  va_end(ap);
-}
-#else
-# include <mex.h>
-# define MyPrintf mexPrintf
-#endif
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	Q P r o b l e m
- */
-SQProblemSchur::SQProblemSchur( ) : SQProblem( )
-{
-#ifdef SOLVER_MA57
-	sparseSolver = new Ma57SparseSolver();
-#elif defined SOLVER_MA27
-	sparseSolver = new Ma27SparseSolver();
-#elif defined SOLVER_NONE
-	sparseSolver = new DummySparseSolver();
-#endif
-
-	nSmax = 0;
-	nS = -1;
-	S = 0;
-	Q_ = 0;
-	R_ = 0;
-	detS = 0.0;
-	rcondS = 0.0;
-	schurUpdateIndex = 0;
-	schurUpdate = 0;
-	numFactorizations = 0;
-
-	M_physicallength = 0;
-	M_vals = 0;
-	M_ir = 0;
-	M_jc = 0;
-}
-
-
-/*
- *	Q P r o b l e m
- */
-SQProblemSchur::SQProblemSchur( int_t _nV, int_t _nC, HessianType _hessianType, int_t maxSchurUpdates ) : SQProblem( _nV,_nC,_hessianType )
-{
-	/* We use the variables Q and R to store the QR factorization of S.
-	 * T is not required. */
-	delete [] R; R = 0;
-	delete [] Q; Q = 0;
-	delete [] T; T = 0;
-
-	/* The interface to the sparse linear solver.  In the long run,
-	   different linear solvers might be optionally chosen. */
-#ifdef SOLVER_MA57
-	sparseSolver = new Ma57SparseSolver();
-#elif defined SOLVER_MA27
-	sparseSolver = new Ma27SparseSolver();
-#elif defined SOLVER_NONE
-	sparseSolver = new DummySparseSolver();
-#endif
-
-	nSmax = maxSchurUpdates;
-	nS = -1;
-	if ( nSmax > 0 )
-	{
-		S = new real_t[nSmax*nSmax];
-		schurUpdateIndex = new int_t[nSmax];
-		schurUpdate = new SchurUpdateType[nSmax];
-		Q_ = new real_t[nSmax*nSmax];
-		R_ = new real_t[nSmax*nSmax];
-		M_physicallength = 10*nSmax;  /* TODO: Decide good default. */
-		M_vals = new real_t[M_physicallength];
-		M_ir = new sparse_int_t[M_physicallength];
-		M_jc = new sparse_int_t[nSmax+1];
-		detS = 1.0;
-		rcondS = 1.0;
-	}
-	else
-	{
-		S = 0;
-		Q_ = 0;
-		R_ = 0;
-		detS = 0.0;
-		rcondS = 0.0;
-		schurUpdateIndex = 0;
-		schurUpdate = 0;
-		M_physicallength = 0;
-		M_vals = 0;
-		M_ir = 0;
-		M_jc = 0;
-	}
-	numFactorizations = 0;
-}
-
-
-/*
- *	Q P r o b l e m
- */
-SQProblemSchur::SQProblemSchur( const SQProblemSchur& rhs ) : SQProblem( rhs )
-{
-#ifdef SOLVER_MA57
-	sparseSolver = new Ma57SparseSolver();
-#elif defined SOLVER_MA27
-	sparseSolver = new Ma27SparseSolver();
-#elif defined SOLVER_NONE
-	sparseSolver = new DummySparseSolver();
-#endif
-	copy( rhs );
-}
-
-
-/*
- *	~ Q P r o b l e m
- */
-SQProblemSchur::~SQProblemSchur( )
-{
-	delete sparseSolver;
-
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-SQProblemSchur& SQProblemSchur::operator=( const SQProblemSchur& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		SQProblem::operator=( rhs );
-		copy( rhs );
-	}
-	return *this;
-}
-
-
-/*
- *	r e s e t
- */
-returnValue SQProblemSchur::reset( )
-{
-	/* AW: We probably want to avoid resetting factorization in QProblem */
-	if ( SQProblem::reset( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_RESET_FAILED );
-
-	sparseSolver->reset();
-	nS = -1;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue SQProblemSchur::clear( )
-{
-	nSmax = 0;
-	nS = -1;
-	detS = 0.0;
-	rcondS = 0.0;
-	numFactorizations = 0;
-	delete [] S; S=0;
-	delete [] Q_; Q_=0;
-	delete [] R_; R_=0;
-	delete [] schurUpdateIndex; schurUpdateIndex=0;
-	delete [] schurUpdate; schurUpdate=0;
-	M_physicallength = 0;
-	delete [] M_vals; M_vals=0;
-	delete [] M_ir; M_ir=0;
-	delete [] M_jc; M_jc=0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue SQProblemSchur::copy(	const SQProblemSchur& rhs
-									)
-{
-	int_t i, j, length;
-
-	*sparseSolver = *(rhs.sparseSolver);
-
-	nS = rhs.nS;
-	nSmax = rhs.nSmax;
-	if ( nSmax > 0 )
-	{
-		detS = rhs.detS;
-		rcondS = rhs.rcondS;
-		S = new real_t[nSmax*nSmax];
-		Q_ = new real_t[nSmax*nSmax];
-		R_ = new real_t[nSmax*nSmax];
-		schurUpdateIndex = new int_t[nSmax];
-		schurUpdate = new SchurUpdateType[nSmax];
-
-		if ( nS>0 )
-		{
-			for ( i=0; i<nS; i++)
-				for ( j=0; j<nS; j++)
-				{
-					S[i*nSmax + j] = rhs.S[i*nSmax + j];
-					Q_[i*nSmax + j] = rhs.Q_[i*nSmax + j];
-					R_[i*nSmax + j] = rhs.R_[i*nSmax + j];
-				}
-
-			memcpy( schurUpdateIndex, rhs.schurUpdateIndex, ((unsigned int)nS)*sizeof(int_t));
-			memcpy( schurUpdate, rhs.schurUpdate, ((unsigned int)nS)*sizeof(SchurUpdateType));
-		}
-
-		M_physicallength = rhs.M_physicallength;
-		if ( M_physicallength>0 )
-		{
-			M_vals = new real_t[M_physicallength];
-			M_ir = new sparse_int_t[M_physicallength];
-			M_jc = new sparse_int_t[nSmax+1];
-
-			if ( nS>0 )
-			{
-				memcpy(M_jc, rhs.M_jc, ((unsigned int)(nS+1))*sizeof(sparse_int_t));
-				length = M_jc[nS];
-				memcpy(M_vals, rhs.M_vals, ((unsigned int)length)*sizeof(real_t));
-				memcpy(M_ir, rhs.M_ir, ((unsigned int)length)*sizeof(sparse_int_t));
-			}
-			else if ( nS==0 )
-				M_jc[0] = rhs.M_jc[0];
-		}
-	}
-	else
-	{
-		S = 0;
-		Q_ = 0;
-		R_ = 0;
-		detS = 0.0;
-		rcondS = 0.0;
-		schurUpdateIndex = 0;
-		schurUpdate = 0;
-		M_physicallength = 0;
-		M_vals = 0;
-		M_ir = 0;
-		M_jc = 0;
-	}
-	numFactorizations = rhs.numFactorizations;
-
-	boundsFreeStart = rhs.boundsFreeStart;
-	constraintsActiveStart = rhs.constraintsActiveStart;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y Q P
- */
-returnValue SQProblemSchur::setupAuxiliaryQP(	SymmetricMatrix *H_new,
-												Matrix *A_new,
-												const real_t *lb_new,
-												const real_t *ub_new,
-												const real_t *lbA_new,
-												const real_t *ubA_new
-												)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-	returnValue returnvalue;
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )       ||
-		 ( getStatus( ) == QPS_PREPARINGAUXILIARYQP ) ||
-		 ( getStatus( ) == QPS_PERFORMINGHOMOTOPY )   )
-	{
-		return THROWERROR( RET_UPDATEMATRICES_FAILED_AS_QP_NOT_SOLVED );
-	}
-
-	status = QPS_PREPARINGAUXILIARYQP;
-
-
-	/* I) SETUP NEW QP MATRICES AND VECTORS: */
-	/* 1) Shift constraints' bounds vectors by (A_new - A)'*x_opt to ensure
-	 *    that old optimal solution remains feasible for new QP data. */
-	/*    Firstly, shift by -A'*x_opt and ... */
-	if ( nC > 0 )
-	{
-		if ( A_new == 0 )
-			return THROWERROR( RET_INVALID_ARGUMENTS );
-
-		for ( i=0; i<nC; ++i )
-		{
-			lbA[i] = -Ax_l[i];
-			ubA[i] =  Ax_u[i];
-		}
-
-		/* Set constraint matrix as well as ... */
-		setA( A_new );
-
-		/* ... secondly, shift by +A_new'*x_opt. */
-		for ( i=0; i<nC; ++i )
-		{
-			lbA[i] += Ax[i];
-			ubA[i] += Ax[i];
-		}
-
-		/* update constraint products. */
-		for ( i=0; i<nC; ++i )
-		{
-			Ax_u[i] = ubA[i] - Ax[i];
-			Ax_l[i] = Ax[i] - lbA[i];
-		}
-	}
-
-	/* 2) Set new Hessian matrix,determine Hessian type and
-	 *    regularise new Hessian matrix if necessary. */
-	/* a) Setup new Hessian matrix and determine its type. */
-	if ( H_new != 0 )
-	{
-		setH( H_new );
-
-		hessianType = HST_UNKNOWN;
-		if ( determineHessianType( ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-		/* b) Regularise new Hessian if necessary. */
-		if ( ( hessianType == HST_ZERO ) ||
-			 ( hessianType == HST_SEMIDEF ) ||
-			 ( usingRegularisation( ) == BT_TRUE ) )
-		{
-			regVal = 0.0; /* reset previous regularisation */
-
-			if ( regulariseHessian( ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-		}
-	}
-	else
-	{
-		if ( H != 0 )
-			return THROWERROR( RET_NO_HESSIAN_SPECIFIED );
-	}
-
-	/* 3) Setup QP gradient. */
-	if ( setupAuxiliaryQPgradient( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	/* II) SETUP WORKING SET AND MATRIX FACTORISATION: */
-
-	/* 1) Check if current active set is linearly independent and has the correct inertia */
-	returnvalue = resetSchurComplement( BT_FALSE );
-	int_t neig = sparseSolver->getNegativeEigenvalues( );
-
-	if ( returnvalue == SUCCESSFUL_RETURN && neig == getNAC( ) )
-	{
-		/* a) This means the proposed working set is linearly independent and
-		 *    leaves no zero curvature exposed in the nullspace and can be used to start QP solve. */
-		if ( options.printLevel == PL_HIGH )
-			MyPrintf( "In hotstart for new matrices, old working set is linearly independent and has correct inertia.\n");
-
-		status = QPS_AUXILIARYQPSOLVED;
-		return SUCCESSFUL_RETURN;
-	}
-	else if ( returnvalue == SUCCESSFUL_RETURN && neig > getNAC( ) )
-	{
-		/* b) KKT matrix has too many negative eigenvalues. Try to correct the inertia by adding bounds (reduce nullspace dimension). */
-		if ( options.printLevel == PL_HIGH )
-			MyPrintf( "WARNING: In hotstart for new matrices, reduced Hessian for initial working set has %i negative eigenvalues, should be %i.\n", neig, getNAC( ) );
-
-		/* If enabling inertia correction is disabled, exit here */
-		if ( options.enableInertiaCorrection )
-		{
-			returnvalue = correctInertia();
-			if ( returnvalue == SUCCESSFUL_RETURN )
-			{
-				status = QPS_AUXILIARYQPSOLVED;
-				return SUCCESSFUL_RETURN;
-			}
-		}
-		else
-			return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-
-	/* 2) If inertia correction has failed or factorization yielded some other error,
-	 *    try to rebuild the active set with all simple bounds set according to initialStatusBounds
-	 *    (Note: in exact arithmetic, this cannot happen) */
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "WARNING: hotstart for old active set failed. Trying to rebuild a working set.\n");
-
-	Bounds      oldBounds      = bounds;
-	Constraints oldConstraints = constraints;
-
-	/* Move all inactive variables to a bound */
-	for ( i=0; i<nV; i++ )
-	{
-		#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-		if ( bounds.getType( i ) == ST_EQUALITY )
-		{
-			if ( oldBounds.setStatus( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-		}
-		else
-		#endif
-		{
-			if ( oldBounds.getStatus( i ) == ST_INACTIVE )
-				if ( oldBounds.setStatus( i, options.initialStatusBounds ) != SUCCESSFUL_RETURN )
-					return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-		}
-	}
-
-	/* Set all equalities active */
-	#ifdef __ALWAYS_INITIALISE_WITH_ALL_EQUALITIES__
-	for( i=0; i<nC; ++i )
-	{
-		if ( constraints.getType( i ) == ST_EQUALITY )
-			if ( oldConstraints.setStatus( i,ST_LOWER ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-	#endif
-
-	/* Set all inequalities inactive */
-	for( i=0; i<nC; ++i )
-	{
-		if ( constraints.getType( i ) != ST_EQUALITY )
-			if ( oldConstraints.setStatus( i,ST_INACTIVE ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-	}
-
-	/* Reset bounds and constraints */
-	bounds.init( nV );
-	constraints.init( nC );
-
-	if ( setupSubjectToType(lb_new,ub_new,lbA_new,ubA_new ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	if ( bounds.setupAllFree( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	if ( constraints.setupAllInactive( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	/* Setup working sets afresh. */
-	if ( setupAuxiliaryWorkingSet( &oldBounds,&oldConstraints,BT_TRUE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_AUXILIARYQP_FAILED );
-
-	/* adjust lb/ub */
-	for (int_t ii = 0; ii < nC; ++ii)
-		Ax_l[ii] = Ax_u[ii] = Ax[ii];
-	setupAuxiliaryQPbounds (&bounds, &constraints, BT_FALSE);
-
-	status = QPS_AUXILIARYQPSOLVED;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p A u x i l i a r y W o r k i n g S e t
- */
-returnValue SQProblemSchur::setupAuxiliaryWorkingSet(	const Bounds* const auxiliaryBounds,
-														const Constraints* const auxiliaryConstraints,
-														BooleanType setupAfresh
-														)
-{
-	int_t i;
-	int_t nV = getNV( );
-	int_t nC = getNC( );
-
-	/* consistency checks */
-	if ( auxiliaryBounds != 0 )
-	{
-		for( i=0; i<nV; ++i )
-			if ( ( bounds.getStatus( i ) == ST_UNDEFINED ) || ( auxiliaryBounds->getStatus( i ) == ST_UNDEFINED ) )
-				return THROWERROR( RET_UNKNOWN_BUG );
-	}
-	else
-	{
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( auxiliaryConstraints != 0 )
-	{
-		for( i=0; i<nC; ++i )
-			if ( ( constraints.getStatus( i ) == ST_UNDEFINED ) || ( auxiliaryConstraints->getStatus( i ) == ST_UNDEFINED ) )
-				return THROWERROR( RET_UNKNOWN_BUG );
-	}
-	else
-	{
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	/* I.) REMOVE INEQUALITY BOUNDS/CONSTRAINTS */
-
-	/* I.1) Remove inequality bounds that are active now but shall be
-	 *      inactive or active at the other bound according to auxiliaryBounds */
-	for( i=0; i<nV; ++i )
-	{
-		if ( ( bounds.getStatus( i ) == ST_LOWER ) && ( auxiliaryBounds->getStatus( i ) != ST_LOWER ) )
-			if ( bounds.moveFixedToFree( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-		if ( ( bounds.getStatus( i ) == ST_UPPER ) && ( auxiliaryBounds->getStatus( i ) != ST_UPPER ) )
-			if ( bounds.moveFixedToFree( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-	}
-
-	/* I.2.) Remove inequality constraints that are active now but shall be
-	 *       inactive or active at the other bound according to auxiliaryConstraints */
-	for( i=0; i<nC; ++i )
-	{
-		if ( ( constraints.getStatus( i ) == ST_LOWER ) && ( auxiliaryConstraints->getStatus( i ) != ST_LOWER ) )
-			if ( constraints.moveActiveToInactive( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-		if ( ( constraints.getStatus( i ) == ST_UPPER ) && ( auxiliaryConstraints->getStatus( i ) != ST_UPPER ) )
-			if ( constraints.moveActiveToInactive( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-	}
-
-	/* II.) ADD BOUNDS/CONSTRAINTS */
-
-	/* II.1.) Add bounds according to auxiliaryBounds */
-	for( i=0; i<nV; ++i )
-	{
-		if ( ( bounds.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryBounds->getStatus( i ) != ST_INACTIVE ) )
-			if ( bounds.moveFreeToFixed( i, auxiliaryBounds->getStatus( i ) ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-	}
-
-	/* II.2.) Add constraints according to auxiliaryConstraints */
-	for( i=0; i<nC; ++i )
-	{
-		if ( ( constraints.getStatus( i ) == ST_INACTIVE ) && ( auxiliaryConstraints->getStatus( i ) != ST_INACTIVE ) )
-			if ( constraints.moveInactiveToActive( i,auxiliaryConstraints->getStatus( i ) ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-	}
-
-	/* III) FACTORIZATION */
-
-	/* III.1.) Factorize (resolves linear dependency) */
-	if( resetSchurComplement( BT_FALSE ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-
-	/* III.2.) Check if inertia is correct. If so, we now have a linearly independent working set with a pos def reduced Hessian */
-	int_t neig = sparseSolver->getNegativeEigenvalues( );
-	if ( neig == getNAC( ) )
-	{
-		/* We now have a linearly independent working set with a pos def reduced Hessian.
-		 * We need to correct the QP bounds and gradient after this. */
-		return SUCCESSFUL_RETURN;
-	}
-
-	/* IV.) INERTIA CORRECTION IF NECESSARY */
-
-	/* We now have a fresh factorization and can start the usual inertia correction routine */
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "WARNING: In setupAuxiliaryWorkingSet: Initial working set reduced Hessian has %i negative eigenvalues, should be %i.\n", neig, getNAC( ) );
-
-	if ( options.enableInertiaCorrection == BT_TRUE )
-		return correctInertia( );
-	else
-		return THROWERROR( RET_SETUP_WORKINGSET_FAILED );
-}
-
-
-/*
- *	c h o l e s k y D e c o m p o s i t i o n P r o j e c t e d
- */
-returnValue SQProblemSchur::computeProjectedCholesky( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o m p u t e I n i t i a l C h o l e s k y
- */
-returnValue SQProblemSchur::computeInitialCholesky( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p T Q f a c t o r i s a t i o n
- */
-returnValue SQProblemSchur::setupTQfactorisation( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a d d C o n s t r a i n t
- */
-returnValue SQProblemSchur::addConstraint(	int_t number, 
-											SubjectToStatus C_status,
-											BooleanType updateCholesky,
-											BooleanType ensureLI
-											)
-{
-	int_t idxDeleted = -1;
-
-	/* consistency checks */
-	if ( constraints.getStatus( number ) != ST_INACTIVE )
-		return THROWERROR( RET_CONSTRAINT_ALREADY_ACTIVE );
-
-	if ( ( constraints.getNC( ) - getNAC( ) ) == constraints.getNUC( ) )
-		return THROWERROR( RET_ALL_CONSTRAINTS_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
-		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-
-	/* I) ENSURE LINEAR INDEPENDENCE OF THE WORKING SET,
-	 *    i.e. remove a constraint or bound if linear dependence occurs. */
-	if ( ensureLI == BT_TRUE )
-	{
-		returnValue ensureLIreturnvalue = addConstraint_ensureLI( number,C_status );
-
-		switch ( ensureLIreturnvalue )
-		{
-			case SUCCESSFUL_RETURN:
-				break;
-
-			case RET_LI_RESOLVED:
-				break;
-
-			case RET_ENSURELI_FAILED_NOINDEX:
-				return RET_ADDCONSTRAINT_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_FAILED_CYCLING:
-				return RET_ADDCONSTRAINT_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_DROPPED:
-				return SUCCESSFUL_RETURN;
-
-			default:
-				return THROWERROR( RET_ENSURELI_FAILED );
-		}
-	}
-
-	/* IV) UPDATE INDICES */
-	tabularOutput.idxAddC = number;
-	if ( constraints.moveInactiveToActive( number,C_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-
-	/* Also update the Schur complement. */
-
-	/* First check if this constraint had been removed before. In that
-	   case delete this constraint from the Schur complement. */
-	bool found = false;
-	for ( int_t i=0; i<nS; i++ )
-	{
-		if ( schurUpdate[i] == SUT_ConRemoved && number == schurUpdateIndex[i] )
-		{
-			if ( deleteFromSchurComplement( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-			found = true;
-			idxDeleted = i;
-			break;
-		}
-	}
-	if ( !found )
-	{
-		if ( nS < 0 || nS==nSmax )
-		{
-			/* The schur complement has become too large, reset. */
-			/* Correct inertia if necessary. */
-			returnValue retval = resetSchurComplement( BT_TRUE );
-			if ( retval != SUCCESSFUL_RETURN )
-			{
-				if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-					MyPrintf( "In addConstraint: KKT matrix singular when resetting Schur complement\n" );
-				else if ( options.printLevel == PL_HIGH )
-					MyPrintf( "In addConstraint, resetSchurComplement failed with retval = %d\n", retval);
-				return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-			}
-			found = true;
-		}
-		else
-		{
-			/* If the constraint was not yet in Schur complement, add it now. */
-			int_t nFRStart = boundsFreeStart.getLength();
-			int_t* FR_idxStart;
-			boundsFreeStart.getNumberArray( &FR_idxStart );
-
-			sparse_int_t* MNpos = new sparse_int_t[nFRStart+nS]; // This is an overestimate
-			real_t* MNvals = new real_t[nFRStart+nS];
-
-			int_t* irn = new int_t[nFRStart+nS];
-			int_t* jcn = new int_t[nFRStart+nS];
-			real_t* vals = new real_t[nFRStart+nS];
-			int_t* icolsNumber = new int_t[nFRStart+nS];
-			int_t* icolsSIdx = new int_t[nS];
-
-			for ( int_t i=0; i<nFRStart; i++)
-				icolsNumber[i] = FR_idxStart[i];
-
-			int_t icolsLength = nFRStart;
-			for ( int_t i=0; i<nS; i++)
-				if ( schurUpdate[i] == SUT_VarFreed )
-				{
-					icolsNumber[icolsLength] = schurUpdateIndex[i];
-					icolsSIdx[icolsLength-nFRStart] = i;
-					icolsLength++;
-				}
-
-			if ( constraintProduct != 0 )
-			{
-				MyPrintf( "In SQProblemSchur::addConstraint, constraintProduct not yet implemented.\n");
-				return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-			}
-			int_t numNonzerosA;
-			A->getSparseSubmatrix( 1, &number, icolsLength, icolsNumber, 0, 0, numNonzerosA, irn, jcn, vals );
-			delete [] irn;
-
-			int_t numNonzerosM = 0;
-			int_t numNonzerosN = 0;
-			for ( int_t i=0; i<numNonzerosA; i++ )
-				if ( jcn[i] < nFRStart )
-				{
-					MNpos[numNonzerosM] = jcn[i];
-					MNvals[numNonzerosM] = vals[i];
-					numNonzerosM++;
-				}
-				else
-				{
-					MNpos[nFRStart+numNonzerosN] = icolsSIdx[jcn[i]-nFRStart];
-					MNvals[nFRStart+numNonzerosN] = vals[i];
-					numNonzerosN++;
-				}
-
-			returnValue returnvalue = addToSchurComplement( number, SUT_ConAdded, numNonzerosM, MNpos, MNvals, numNonzerosN, MNpos+nFRStart, MNvals+nFRStart, 0.0 );
-
-			delete [] icolsSIdx;
-			delete [] icolsNumber;
-			delete [] vals;
-			delete [] jcn;
-			delete [] MNvals;
-			delete [] MNpos;
-
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-
-			found = true;
-		}
-	}
-
-	if ( !found )
-		return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-
-	updateSchurQR( idxDeleted );
-
-	/* If reciprocal of condition number becomes to small, refactorize KKT matrix */
-	if( rcondS < options.rcondSMin )
-	{
-		returnValue retval = resetSchurComplement( BT_TRUE );
-		if ( retval != SUCCESSFUL_RETURN )
-		{
-			if ( retval == RET_KKT_MATRIX_SINGULAR  && options.printLevel == PL_HIGH )
-				MyPrintf( "In addConstraint: KKT matrix singular when resetting Schur complement\n" );
-			else if ( options.printLevel == PL_HIGH )
-				MyPrintf( "In addConstraint, resetSchurComplement failed with retval = %d\n", retval);
-			return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*
- *	a d d C o n s t r a i n t _ c h e c k L I
- */
-returnValue SQProblemSchur::addConstraint_checkLI( int_t number )
-{
-	/* Get space for the multipliers xi in linear independence test */
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	real_t *xiC = new real_t[nAC];
-	real_t *xiB = new real_t[nFX];
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addConstraint_checkLISchur( number, xiC, xiB );
-
-	delete [] xiB;
-	delete [] xiC;
-
-	return returnvalueCheckLI;
-}
-
-
-/*
- *	a d d C o n s t r a i n t _ c h e c k L I S c h u r
- */
-returnValue SQProblemSchur::addConstraint_checkLISchur( int_t number, real_t* xiC, real_t* xiB )
-{
-	returnValue returnvalue = RET_LINEARLY_DEPENDENT;
-
-	int_t ii;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nC  = getNC( );
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	int_t *FR_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	/* For the Schur complement version we only use options.enableFullLITests = TRUE */
-	{
-		/*
-		 * expensive LI test. Backsolve with refinement using special right
-		 * hand side. This gives an estimate for what should be considered
-		 * "zero". We then check linear independence relative to this estimate.
-		 */
-
-		int_t *FX_idx, *AC_idx, *IAC_idx;
-
-		real_t *delta_g   = new real_t[nV];
-		real_t *delta_xFX = new real_t[nFX];
-		real_t *delta_xFR = new real_t[nFR];
-		real_t *delta_yAC = xiC;
-		real_t *delta_yFX = xiB;
-
-		bounds.getFixed( )->getNumberArray( &FX_idx );
-		constraints.getActive( )->getNumberArray( &AC_idx );
-		constraints.getInactive( )->getNumberArray( &IAC_idx );
-
-		int_t dim = (nC>nV)?nC:nV;
-		real_t *nul = new real_t[dim];
-		for (ii = 0; ii < dim; ++ii)
-			nul[ii]=0.0;
-
-		A->getRow (number, 0, 1.0, delta_g);
-
-		returnValue dsdreturnvalue = determineStepDirection ( delta_g,
-											  nul, nul, nul, nul,
-											  BT_FALSE, BT_FALSE,
-											  delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		if (dsdreturnvalue!=SUCCESSFUL_RETURN)
-			returnvalue = dsdreturnvalue;
-
-		delete[] nul;
-
-		/* compute the weight in inf-norm */
-		real_t weight = 0.0;
-		for (ii = 0; ii < nAC; ++ii)
-		{
-			real_t a = getAbs (delta_yAC[ii]);
-			if (weight < a) weight = a;
-		}
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_yFX[ii]);
-			if (weight < a) weight = a;
-		}
-
-		/* look at the "zero" in a relative inf-norm */
-		real_t zero = 0.0;
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_xFX[ii]);
-			if (zero < a) zero = a;
-		}
-		for (ii = 0; ii < nFR; ++ii)
-		{
-			real_t a = getAbs (delta_xFR[ii]);
-			if (zero < a) zero = a;
-		}
-
-		/* relative test against zero in inf-norm */
-		if (zero > options.epsLITests * weight)
-			returnvalue = RET_LINEARLY_INDEPENDENT;
-
-		delete[] delta_xFR;
-		delete[] delta_xFX;
-		delete[] delta_g;
-
-	}
-	return THROWINFO( returnvalue );
-}
-
-
-/*
- *	a d d C o n s t r a i n t _ e n s u r e L I
- */
-returnValue SQProblemSchur::addConstraint_ensureLI( int_t number, SubjectToStatus C_status )
-{
-	/* Get space for the multipliers xi in linear independence test */
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	real_t *xiC = new real_t[nAC];
-	real_t *xiB = new real_t[nFX];
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addConstraint_checkLISchur( number, xiC, xiB );
-
-	if ( returnvalueCheckLI == RET_INDEXLIST_CORRUPTED )
-	{
-		delete [] xiB;
-		delete [] xiC;
-		return THROWERROR( RET_ENSURELI_FAILED );
-	}
-
-	if ( returnvalueCheckLI == RET_LINEARLY_INDEPENDENT )
-	{
-		delete [] xiB;
-		delete [] xiC;
-		return SUCCESSFUL_RETURN;
-	}
-
- 	/* II) NEW BOUND IS LINEARLY DEPENDENT: */
-	/* 1) Coefficients of linear combination, have already been computed, but we need to correct the sign.  */
-	int_t i, ii;
-
-	if ( C_status != ST_LOWER )
-	{
-		for( i=0; i<nAC; ++i )
-			xiC[i] = -xiC[i];
-		for( i=0; i<nFX; ++i )
-			xiB[i] = -xiB[i];
-	}
-
-	int_t nV  = getNV( );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	real_t* num = new real_t[nV];
-
-	real_t y_min = options.maxDualJump;
-	int_t y_min_number = -1;
-	int_t y_min_number_bound = -1;
-	BooleanType y_min_isBound = BT_FALSE;
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	/* III) DETERMINE CONSTRAINT/BOUND TO BE REMOVED. */
-
-	/* 1) Constraints. */
-	for( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-		num[i] = y[nV+ii];
-	}
-
-	performRatioTest (nAC, AC_idx, &constraints, num, xiC, options.epsNum, options.epsDen, y_min, y_min_number);
-
-	/* 2) Bounds. */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-	}
-
-	performRatioTest (nFX, FX_idx, &bounds, num, xiB, options.epsNum, options.epsDen, y_min, y_min_number_bound);
-
-	if ( y_min_number_bound >= 0 )
-	{
-		y_min_number = y_min_number_bound;
-		y_min_isBound = BT_TRUE;
-	}
-
-	#ifndef __XPCTARGET__
-	/* setup output preferences */
-	char messageString[80];
-	#endif
-
-	/* IV) REMOVE CONSTRAINT/BOUND FOR RESOLVING LINEAR DEPENDENCE: */
-	if ( y_min_number >= 0 )
-	{
-		/* Update Lagrange multiplier... */
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			y[nV+ii] -= y_min * xiC[i];
-		}
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			y[ii] -= y_min * xiB[i];
-		}
-
-		/* ... also for newly active constraint... */
-		if ( C_status == ST_LOWER )
-			y[nV+number] = y_min;
-		else
-			y[nV+number] = -y_min;
-
-		/* ... and for constraint to be removed. */
-		if ( y_min_isBound == BT_TRUE )
-		{
-			#ifndef __XPCTARGET__
-			snprintf( messageString,80,"bound no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeBound( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemB = 1;
-
-			y[y_min_number] = 0.0;
-		}
-		else
-		{
-			#ifndef __XPCTARGET__
-			snprintf( messageString,80,"constraint no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeConstraint( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemC = 1;
-
-			y[nV+y_min_number] = 0.0;
-		}
-	}
-	else
-	{
-		if (options.enableDropInfeasibles == BT_TRUE) {
-			/* dropping of infeasible constraints according to drop priorities */
-			returnvalue = dropInfeasibles (number, C_status, BT_FALSE, xiB, xiC);
-		}
-		else
-		{
-			/* no constraint/bound can be removed => QP is infeasible! */
-			returnvalue = RET_ENSURELI_FAILED_NOINDEX;
-			setInfeasibilityFlag( returnvalue );
-		}
-	}
-
-farewell:
-	delete[] num;
-	delete [] xiB;
-	delete [] xiC;
-
-	getGlobalMessageHandler( )->throwInfo( RET_LI_RESOLVED,0,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-
-	return (returnvalue != SUCCESSFUL_RETURN) ? THROWERROR (returnvalue) : returnvalue;
-}
-
-
-/*
- *	a d d B o u n d
- */
-returnValue SQProblemSchur::addBound(	int_t number,
-										SubjectToStatus B_status,
-										BooleanType updateCholesky,
-										BooleanType ensureLI
-										)
-{
-	int_t idxDeleted = -1;
-
-	/* consistency checks */
-	if ( bounds.getStatus( number ) != ST_INACTIVE )
-		return THROWERROR( RET_BOUND_ALREADY_ACTIVE );
-
-	if ( getNFR( ) == bounds.getNUV( ) )
-		return THROWERROR( RET_ALL_BOUNDS_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-
-	/* I) ENSURE LINEAR INDEPENDENCE OF THE WORKING SET,
-	 *    i.e. remove a constraint or bound if linear dependence occurs. */
-	if ( ensureLI == BT_TRUE )
-	{
-		returnValue ensureLIreturnvalue = addBound_ensureLI( number,B_status );
-
-		switch ( ensureLIreturnvalue )
-		{
-			case SUCCESSFUL_RETURN:
-				break;
-
-			case RET_LI_RESOLVED:
-				break;
-
-			case RET_ENSURELI_FAILED_NOINDEX:
-				return RET_ADDBOUND_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_FAILED_CYCLING:
-				return RET_ADDBOUND_FAILED_INFEASIBILITY;
-
-			case RET_ENSURELI_DROPPED:
-				return SUCCESSFUL_RETURN;
-
-			default:
-				return THROWERROR( RET_ENSURELI_FAILED );
-		}
-	}
-
-	/* II) UPDATE INDICES */
-	tabularOutput.idxAddB = number;
-	if ( bounds.moveFreeToFixed( number,B_status ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_ADDBOUND_FAILED );
-
-	/* Also update the Schur complement. */
-
-	/* First check if this variable had been freed before. In that
-	   case delete this variable from the Schur complement. */
-	bool found = false;
-	for ( int_t i=0; i<nS; i++ )
-	{
-		if ( schurUpdate[i] == SUT_VarFreed && number == schurUpdateIndex[i] )
-		{
-			if ( deleteFromSchurComplement( i ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_ADDBOUND_FAILED );
-			found = true;
-			idxDeleted = i;
-			break;
-		}
-	}
-	if ( !found )
-	{
-		if ( nS < 0 || nS==nSmax )
-		{
-			/* The schur complement has become too large, reset. */
-			/* Correct inertia if necessary. */
-			returnValue retval = resetSchurComplement( BT_TRUE );
-			if ( retval != SUCCESSFUL_RETURN )
-			{
-				if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-					MyPrintf( "In addBound: KKT matrix singular when resetting Schur complement\n" );
-				else if ( options.printLevel == PL_HIGH )
-					MyPrintf( "In addBound, resetSchurComplement failed with retval = %d\n", retval);
-				return THROWERROR( RET_ADDBOUND_FAILED );
-			}
-			found = true;
-		}
-		else
-		{
-			/* If the variable was not yet in Schur complement, add it now. */
-			int_t nFRStart = boundsFreeStart.getLength();
-			int_t* FR_idxStart;
-			boundsFreeStart.getNumberArray( &FR_idxStart );
-			for ( int_t i=0; i<nFRStart; i++ )
-				if ( FR_idxStart[i] == number )
-				{
-					real_t one = 1.0;
-					sparse_int_t pos = i;
-					if ( addToSchurComplement( number, SUT_VarFixed, 1, &pos, &one, 0, 0, 0, 0.0 ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_ADDBOUND_FAILED );
-					found = true;
-					break;
-				}
-		}
-	}
-
-	if ( !found )
-		return THROWERROR( RET_ADDBOUND_FAILED );
-
-	updateSchurQR( idxDeleted );
-
-	/* If reciprocal of condition number becomes to small, refactorize KKT matrix */
-	if( rcondS < options.rcondSMin )
-	{
-		returnValue retval = resetSchurComplement( BT_TRUE );
-		if ( retval != SUCCESSFUL_RETURN )
-		{
-			if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-				MyPrintf( "In addBound: KKT matrix singular when resetting Schur complement\n" );
-			else if ( options.printLevel == PL_HIGH )
-				MyPrintf( "In addBound, resetSchurComplement failed with retval = %d\n", retval);
-			return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a d d B o u n d _ c h e c k L I
- */
-returnValue SQProblemSchur::addBound_checkLI( int_t number )
-{
-	/* Get space for the multipliers xi in linear independence test */
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	real_t *xiC = new real_t[nAC];
-	real_t *xiB = new real_t[nFX];
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addBound_checkLISchur( number, xiC, xiB );
-
-	delete [] xiB;
-	delete [] xiC;
-
-	return returnvalueCheckLI;
-}
-
-/*
- *	a d d B o u n d _ c h e c k L I S c h u r
- */
-returnValue SQProblemSchur::addBound_checkLISchur( int_t number, real_t* xiC, real_t* xiB )
-{
-	returnValue returnvalue = RET_LINEARLY_DEPENDENT;
-
-
-	int_t ii;
-	int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nC  = getNC( );
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	int_t *FR_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-
-	/* For the Schur complement version we only use options.enableFullLITests = TRUE */
-	{
-		/*
-		 * expensive LI test. Backsolve with refinement using special right
-		 * hand side. This gives an estimate for what should be considered
-		 * "zero". We then check linear independence relative to this estimate.
-		 */
-
-		real_t *delta_g   = new real_t[nV];
-		real_t *delta_xFX = new real_t[nFX];
-		real_t *delta_xFR = new real_t[nFR];
-		real_t *delta_yAC = xiC;
-		real_t *delta_yFX = xiB;
-
-		for (ii = 0; ii < nV; ++ii)
-			delta_g[ii] = 0.0;
-		delta_g[number] = 1.0;
-
-		int_t dim = (nC>nV)?nC:nV;
-		real_t *nul = new real_t[dim];
-		for (ii = 0; ii < dim; ++ii)
-			nul[ii]=0.0;
-
-		returnValue dsdReturnValue = determineStepDirection (
-				delta_g, nul, nul, nul, nul, BT_FALSE, BT_FALSE,
-				delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		if (dsdReturnValue != SUCCESSFUL_RETURN)
-			returnvalue = dsdReturnValue;
-
-		/* compute the weight in inf-norm */
-		real_t weight = 0.0;
-		for (ii = 0; ii < nAC; ++ii)
-		{
-			real_t a = getAbs (delta_yAC[ii]);
-			if (weight < a) weight = a;
-		}
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_yFX[ii]);
-			if (weight < a) weight = a;
-		}
-
-		/* look at the "zero" in a relative inf-norm */
-		real_t zero = 0.0;
-		for (ii = 0; ii < nFX; ++ii)
-		{
-			real_t a = getAbs (delta_xFX[ii]);
-			if (zero < a) zero = a;
-		}
-		for (ii = 0; ii < nFR; ++ii)
-		{
-			real_t a = getAbs (delta_xFR[ii]);
-			if (zero < a) zero = a;
-		}
-
-		/* relative test against zero in inf-norm */
-		if (zero > options.epsLITests * weight)
-			returnvalue = RET_LINEARLY_INDEPENDENT;
-
-		delete[] nul;
-		delete[] delta_xFR;
-		delete[] delta_xFX;
-		delete[] delta_g;
-
-	}
-	return THROWINFO( returnvalue );
-}
-
-
-/*
- *	a d d B o u n d _ e n s u r e L I
- */
-returnValue SQProblemSchur::addBound_ensureLI( int_t number, SubjectToStatus B_status )
-{
-	/* Get space for the multipliers xi in linear independence test */
-	int_t nAC = getNAC();
-	int_t nFX = getNFX();
-	real_t *xiC = new real_t[nAC];
-	real_t *xiB = new real_t[nFX];
-
-	/* I) Check if new constraint is linearly independent from the active ones. */
-	returnValue returnvalueCheckLI = addBound_checkLISchur( number, xiC, xiB );
-
-	if ( returnvalueCheckLI == RET_INDEXLIST_CORRUPTED )
-	{
-		delete [] xiB;
-		delete [] xiC;
-		return THROWERROR( RET_ENSURELI_FAILED );
-	}
-
-	if ( returnvalueCheckLI == RET_LINEARLY_INDEPENDENT )
-	{
-		delete [] xiB;
-		delete [] xiC;
-		return SUCCESSFUL_RETURN;
-	}
-
- 	/* II) NEW BOUND IS LINEARLY DEPENDENT: */
-	/* 1) Coefficients of linear combination, have already been computed, but we need to correct the sign.  */
-	int_t i, ii;
-
-	if ( B_status != ST_LOWER )
-	{
-		for( i=0; i<nAC; ++i )
-			xiC[i] = -xiC[i];
-		for( i=0; i<nFX; ++i )
-			xiB[i] = -xiB[i];
-	}
-
-	int_t nV  = getNV( );
-
-	int_t* FX_idx;
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-
-	int_t* AC_idx;
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-	real_t* num = new real_t[nV];
-
-	real_t y_min = options.maxDualJump;
-	int_t y_min_number = -1;
-	int_t y_min_number_bound = -1;
-	BooleanType y_min_isBound = BT_FALSE;
-
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	/* III) DETERMINE CONSTRAINT/BOUND TO BE REMOVED. */
-
-	/* 1) Constraints. */
-	for( i=0; i<nAC; ++i )
-	{
-		ii = AC_idx[i];
-		num[i] = y[nV+ii];
-	}
-
-	performRatioTest( nAC,AC_idx,&constraints, num,xiC, options.epsNum, options.epsDen, y_min,y_min_number );
-
-	/* 2) Bounds. */
-	for( i=0; i<nFX; ++i )
-	{
-		ii = FX_idx[i];
-		num[i] = y[ii];
-	}
-
-	performRatioTest( nFX,FX_idx,&bounds, num,xiB, options.epsNum, options.epsDen, y_min,y_min_number_bound );
-
-	if ( y_min_number_bound >= 0 )
-	{
-		y_min_number = y_min_number_bound;
-		y_min_isBound = BT_TRUE;
-	}
-
-	/* IV) REMOVE CONSTRAINT/BOUND FOR RESOLVING LINEAR DEPENDENCE: */
-	char messageString[80];
-
-	if ( y_min_number >= 0 )
-	{
-		/* Update Lagrange multiplier... */
-		for( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			y[nV+ii] -= y_min * xiC[i];
-		}
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-			y[ii] -= y_min * xiB[i];
-		}
-
-		/* ... also for newly active bound ... */
-		if ( B_status == ST_LOWER )
-			y[number] = y_min;
-		else
-			y[number] = -y_min;
-
-		/* ... and for bound to be removed. */
-		if ( y_min_isBound == BT_TRUE )
-		{
-			#ifndef __XPCTARGET__
-			snprintf( messageString,80,"bound no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeBound( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemB = 1;
-
-			y[y_min_number] = 0.0;
-		}
-		else
-		{
-			#ifndef __XPCTARGET__
-			snprintf( messageString,80,"constraint no. %d.",(int)y_min_number );
-			getGlobalMessageHandler( )->throwInfo( RET_REMOVE_FROM_ACTIVESET,messageString,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-			#endif
-
-			if ( removeConstraint( y_min_number,BT_TRUE,BT_FALSE,BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				returnvalue = RET_REMOVE_FROM_ACTIVESET_FAILED;
-				goto farewell;
-			}
-			tabularOutput.excRemC = 1;
-
-			y[nV+y_min_number] = 0.0;
-		}
-	}
-	else
-	{
-		if (options.enableDropInfeasibles == BT_TRUE) {
-			/* dropping of infeasible constraints according to drop priorities */
-			returnvalue = dropInfeasibles (number, B_status, BT_TRUE, xiB, xiC);
-		}
-		else
-		{
-			/* no constraint/bound can be removed => QP is infeasible! */
-			returnvalue = RET_ENSURELI_FAILED_NOINDEX;
-			setInfeasibilityFlag( returnvalue );
-		}
-	}
-
-farewell:
-	delete[] num;
-	delete[] xiB;
-	delete[] xiC;
-
-	getGlobalMessageHandler( )->throwInfo( RET_LI_RESOLVED,0,__FUNCTION__,__FILE__,__LINE__,VS_VISIBLE );
-
-	return (returnvalue != SUCCESSFUL_RETURN) ? THROWERROR (returnvalue) : returnvalue;
-}
-
-
-
-/*
- *	r e m o v e C o n s t r a i n t
- */
-returnValue SQProblemSchur::removeConstraint(	int_t number,
-												BooleanType updateCholesky,
-												BooleanType allowFlipping,
-												BooleanType ensureNZC
-												)
-{
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-
-	int_t sModType = 0;
-	int_t idxDeleted = -1;
-	SubjectToStatus oldStatus;
-	real_t oldDet, newDet;
-
-	/* consistency check */
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )            )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* some definitions */
-	int_t nAC = getNAC( );
-	int_t number_idx = constraints.getActive( )->getIndex( number );
-
-	int_t addIdx;
-	BooleanType addBoundNotConstraint;
-	SubjectToStatus addStatus;
-	BooleanType exchangeHappened = BT_FALSE;
-
-
-	/* consistency checks */
-	if ( constraints.getStatus( number ) == ST_INACTIVE )
-		return THROWERROR( RET_CONSTRAINT_NOT_ACTIVE );
-
-	if ( ( number_idx < 0 ) || ( number_idx >= nAC ) )
-		return THROWERROR( RET_CONSTRAINT_NOT_ACTIVE );
-
-	/* N) PERFORM ZERO CURVATURE TEST. */
-	if (ensureNZC == BT_TRUE)
-	{
-		returnvalue = ensureNonzeroCurvature(BT_FALSE, number, exchangeHappened, addBoundNotConstraint, addIdx, addStatus);
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return returnvalue;
-	}
-
-	/* save old constraint status and determinant of old S for flipping strategy */
-	oldStatus = constraints.getStatus( number );
-	oldDet = detS;
-
-	/* I) UPDATE INDICES */
-	tabularOutput.idxRemC = number;
-	if ( constraints.moveActiveToInactive( number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-
-	/* Also update the Schur complement. */
-
-	/* First check if this constraint had been added before. In that
-	   case delete this constraint from the Schur complement. */
-	bool found = false;
-	for ( int_t i=0; i<nS; i++ )
-	{
-		if ( schurUpdate[i] == SUT_ConAdded && number == schurUpdateIndex[i] )
-		{
-			if ( deleteFromSchurComplement( i, BT_TRUE ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-			found = true;
-			idxDeleted = i;
-			sModType = 2;
-			break;
-		}
-	}
-	if ( !found )
-	{
-		if ( nS < 0 || nS==nSmax )
-		{
-			/* The schur complement has become too large, reset. */
-			/* Don't check inertia here, may be corrected later! */
-			returnValue retval = resetSchurComplement( BT_FALSE );
-			if ( retval != SUCCESSFUL_RETURN )
-			{
-				if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-					MyPrintf( "In removeConstraint: KKT matrix singular when resetting Schur complement\n" );
-				else if ( options.printLevel == PL_HIGH )
-					MyPrintf( "In removeConstraint, resetSchurComplement failed with retval = %d\n", retval);
-				return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-			}
-			found = true;
-			sModType = 3;
-		}
-		else
-		{
-			/* If the constraint was not yet in Schur complement, add it now. */
-			int_t nFRStart = boundsFreeStart.getLength();
-			int_t nACStart = constraintsActiveStart.getLength();
-			int_t* AC_idxStart;
-			constraintsActiveStart.getNumberArray( &AC_idxStart );
-
-			for ( int_t i=0; i<nACStart; i++ )
-				if ( AC_idxStart[i] == number )
-				{
-					real_t one = 1.0;
-					sparse_int_t pos = nFRStart+i;
-					if ( addToSchurComplement( number, SUT_ConRemoved, 1, &pos, &one, 0, 0, 0, 0.0 ) != SUCCESSFUL_RETURN )
-						return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-					found = true;
-					break;
-				}
-
-			sModType = 1;
-		}
-	}
-
-	if ( !found )
-		return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-
-	/* Now we have a new Schur complement (might be smaller, larger, or empty). Update QR factorization. */
-
-	/* Flipping bounds strategy */
-	if ( ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) && ( exchangeHappened == BT_FALSE ) )
-	{
-		if ( sModType == 1 )
-		{/* Case 1: We added a row and column to S. */
-
-			/* Check if a direction of negative curvature showed up, i.e. determinants have THE SAME sign */
-			newDet = calcDetSchur( idxDeleted );
-
-			if ( oldDet * newDet > 0 )
-			{
-				hessianType = HST_SEMIDEF;
-
-				/* Restore old S */
-				nS--;
-
-				/* Flip bounds */
-				tabularOutput.idxAddC = number;
-				tabularOutput.excAddC = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						constraints.moveInactiveToActive( number, ST_UPPER );
-						ubA[number] = lbA[number];
-						Ax_l[number] = -Ax_u[number];
-						break;
-					case ST_UPPER:
-						constraints.moveInactiveToActive( number, ST_LOWER );
-						lbA[number] = ubA[number];
-						Ax_u[number] = -Ax_l[number];
-						break;
-					default:
-						return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-				}
-			}
-			else
-			{/* Determinants have the correct sign, compute QR of new (larger) S */
-				updateSchurQR( idxDeleted );
-			}
-		}
-		else if ( sModType == 2 )
-		{/* Case 2: We deleted a row and column of S. */
-
-			/* Check if a direction of negative curvature showed up, i.e. determinants have DIFFERENT signs */
-			newDet = calcDetSchur( idxDeleted );
-
-			if ( oldDet * newDet < 0.0 )
-			{
-				hessianType = HST_SEMIDEF;
-
-				/* Restore old S */
-				undoDeleteFromSchurComplement( idxDeleted );
-
-				/* Flip bounds */
-				tabularOutput.idxAddC = number;
-				tabularOutput.excAddC = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						constraints.moveInactiveToActive( number, ST_UPPER );
-						ubA[number] = lbA[number];
-						Ax_l[number] = -Ax_u[number];
-						break;
-					case ST_UPPER:
-						constraints.moveInactiveToActive( number, ST_LOWER );
-						lbA[number] = ubA[number];
-						Ax_u[number] = -Ax_l[number];
-						break;
-					default:
-						return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-				}
-			}
-			else
-			{/* Determinants have the correct sign, compute QR of new (smaller) S */
-				updateSchurQR( idxDeleted );
-			}
-		}
-		else if ( sModType == 3 )
-		{/* Case 3: S was reset. */
-
-			/* Check inertia of new factorization given by the sparse solver: must be ( nFR, nAC, 0 ) */
-			int_t neig = sparseSolver->getNegativeEigenvalues( );
-			if( neig > getNAC( ) ) // Wrong inertia!
-			{
-				/* Flip bounds and update Schur complement */
-				tabularOutput.idxAddC = number;
-				tabularOutput.excAddC = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						ubA[number] = lbA[number];
-						Ax_l[number] = -Ax_u[number];
-						addConstraint( number, ST_UPPER, BT_TRUE, BT_FALSE );
-						break;
-					case ST_UPPER:
-						lbA[number] = ubA[number];
-						Ax_u[number] = -Ax_l[number];
-						addConstraint( number, ST_LOWER, BT_TRUE, BT_FALSE );
-						break;
-					default:
-						return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-				}
-			}
-
-			/* Check if flipping deleted the negative eigenvalue */
-			if( correctInertia( ) )
-				return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-		}
-		else
-		{/* None of the three cases happened */
-			return THROWERROR( RET_REMOVECONSTRAINT_FAILED );
-		}
-	}
-	else
-	{/* No flipping strategy, update QR factorization of S */
-		updateSchurQR( idxDeleted );
-	}
-
-	/* If reciprocal of condition number becomes to small, refactorize KKT matrix */
-	if( rcondS < options.rcondSMin )
-	{
-		returnValue retval = resetSchurComplement( BT_TRUE );
-		if ( retval != SUCCESSFUL_RETURN )
-		{
-			if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-				MyPrintf( "In removeConstraint: KKT matrix singular when resetting Schur complement\n" );
-			else if ( options.printLevel == PL_HIGH )
-				MyPrintf( "In removeConstraint, resetSchurComplement failed with retval = %d\n", retval);
-			return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-		}
-	}
-
-	if ( exchangeHappened == BT_TRUE )
-	{
-		/* add bound or constraint */
-
-		if ( addBoundNotConstraint )
-		{
-			addBound(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddB = 1;
-		}
-		else
-		{
-			addConstraint(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddC = 1;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e B o u n d
- */
-returnValue SQProblemSchur::removeBound(	int_t number,
-											BooleanType updateCholesky,
-											BooleanType allowFlipping,
-											BooleanType ensureNZC
-											)
-{
-	returnValue returnvalue = SUCCESSFUL_RETURN;
-	int_t addIdx;
-	BooleanType addBoundNotConstraint;
-	SubjectToStatus addStatus;
-	BooleanType exchangeHappened = BT_FALSE;
-
-	int_t sModType = 0;
-	int_t idxDeleted = -1;
-	SubjectToStatus oldStatus;
-	real_t oldDet, newDet;
-
-	/* consistency checks */
-	if ( bounds.getStatus( number ) == ST_INACTIVE )
-		return THROWERROR( RET_BOUND_NOT_ACTIVE );
-
-	if ( ( getStatus( ) == QPS_NOTINITIALISED )    ||
-		 ( getStatus( ) == QPS_AUXILIARYQPSOLVED ) ||
-		 ( getStatus( ) == QPS_HOMOTOPYQPSOLVED )  ||
- 		 ( getStatus( ) == QPS_SOLVED )           )
-	{
-		return THROWERROR( RET_UNKNOWN_BUG );
-	}
-
-	/* N) PERFORM ZERO CURVATURE TEST. */
-	if (ensureNZC == BT_TRUE)
-	{
-		returnvalue = ensureNonzeroCurvature(BT_TRUE, number, exchangeHappened, addBoundNotConstraint, addIdx, addStatus);
-
-		if (returnvalue != SUCCESSFUL_RETURN)
-			return returnvalue;
-	}
-
-	/* save old bound status and determinant of old S for flipping strategy */
-	oldStatus = bounds.getStatus( number );
-	oldDet = detS;
-
-	/* I) UPDATE INDICES */
-	tabularOutput.idxRemB = number;
-	if ( bounds.moveFixedToFree( number ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-	/* Also update the Schur complement. */
-
-	/* First check if this variable had been fixed before. In that
-	   case delete this variable from the Schur complement. */
-	bool found = false;
-	for ( int_t i=0; i<nS; i++ )
-	{
-		if ( schurUpdate[i] == SUT_VarFixed && number == schurUpdateIndex[i] )
-		{
-			if ( deleteFromSchurComplement( i, BT_TRUE ) != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_REMOVEBOUND_FAILED );
-			found = true;
-			idxDeleted = i;
-			sModType = 2;
-			break;
-		}
-	}
-	if ( !found )
-	{
-		if ( nS < 0 || nS==nSmax )
-		{
-			/* The schur complement has become too large, reset. */
-			/* Don't correct inertia here, may be corrected by flipping bounds! */
-			returnValue retval = resetSchurComplement( BT_FALSE );
-			if ( retval != SUCCESSFUL_RETURN )
-			{
-				if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH  )
-					MyPrintf( "In removeBound: KKT matrix singular when resetting Schur complement\n" );
-				else if ( options.printLevel == PL_HIGH )
-					MyPrintf( "In removeBound, resetSchurComplement failed with retval = %d\n", retval);
-				return THROWERROR( RET_REMOVEBOUND_FAILED );
-			}
-			found = true;
-			sModType = 3;
-		}
-		else
-		{
-			/* If the variable was not yet in Schur complement, add it now. */
-			int_t nFRStart = boundsFreeStart.getLength();
-			int_t nACStart = constraintsActiveStart.getLength();
-			int_t* FR_idxStart;
-			boundsFreeStart.getNumberArray( &FR_idxStart );
-			int_t* AC_idxStart;
-			constraintsActiveStart.getNumberArray( &AC_idxStart );
-
-			int_t numNonzerosM = 0;
-			sparse_int_t* Mpos = new sparse_int_t[nFRStart+nACStart+nS]; // This is an overestimate
-			real_t* Mvals = new real_t[nFRStart+nACStart+nS];
-			int_t numNonzerosN = 0;
-			sparse_int_t* Npos = new sparse_int_t[nFRStart+nACStart+nS]; // This is an overestimate
-			real_t* Nvals = new real_t[nFRStart+nACStart+nS];
-			real_t N_diag;
-
-			int_t* irn = new int_t[nFRStart+nACStart+nS+1];
-			int_t* jcn = new int_t[nFRStart+nACStart+nS+1];
-			real_t* vals = new real_t[nFRStart+nACStart+nS+1];
-			int_t iLength;
-			int_t* iNumber = new int_t[nFRStart+nACStart+nS+1];
-			int_t numNonzeros;
-			int_t* iSIdx = new int_t[nS];
-
-			/* First the Hessian part. */
-			real_t regularisation = options.epsRegularisation;
-			switch ( hessianType )
-			{
-				case HST_ZERO:
-					N_diag = regularisation;
-					break;
-
-				case HST_IDENTITY:
-					N_diag = 1.0 + regularisation;
-					break;
-
-				default:
-					N_diag = regularisation;
-					for ( int_t i=0; i<nFRStart; i++ )
-						iNumber[i] = FR_idxStart[i];
-					iLength = nFRStart;
-					for ( int_t i=0; i<nS; i++ )
-						if ( schurUpdate[i] == SUT_VarFreed )
-						{
-							iNumber[iLength] = schurUpdateIndex[i];
-							iSIdx[iLength-nFRStart] = i;
-							iLength++;
-						}
-					iNumber[iLength++] = number;
-
-					H->getSparseSubmatrix( iLength, iNumber, 1, &number, 0, 0, numNonzeros, irn, jcn, vals );
-
-					for ( int_t i=0; i<numNonzeros; i++ )
-					{
-						if ( irn[i] < nFRStart )
-						{
-							Mpos[numNonzerosM] = irn[i];
-							Mvals[numNonzerosM] = vals[i];
-							numNonzerosM++;
-						}
-						else if ( irn[i] != iLength-1 )
-						{
-							Npos[numNonzerosN] = iSIdx[irn[i] - nFRStart];
-							Nvals[numNonzerosN] = vals[i];
-							numNonzerosN++;
-						}
-						else
-							N_diag += vals[i];
-					}
-					break;
-			}
-
-			if ( constraintProduct != 0 )
-			{
-				MyPrintf( "In SQProblemSchur::removeBound, constraintProduct not yet implemented.\n");
-				return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-			}
-
-			for ( int_t i=0; i<nACStart; i++ )
-				iNumber[i] = AC_idxStart[i];
-			iLength = nACStart;
-			for ( int_t i=0; i<nS; i++ )
-				if ( schurUpdate[i] == SUT_ConAdded )
-				{
-					iNumber[iLength] = schurUpdateIndex[i];
-					iSIdx[iLength-nACStart] = i;
-					iLength++;
-				}
-
-			A->getSparseSubmatrix( iLength, iNumber, 1, &number, 0, 0, numNonzeros, irn, jcn, vals );
-
-			for ( int_t i=0; i<numNonzeros; i++ )
-			{
-				if ( irn[i] < nACStart )
-				{
-					Mpos[numNonzerosM] = irn[i] + nFRStart;
-					Mvals[numNonzerosM] = vals[i];
-					numNonzerosM++;
-				}
-				else
-				{
-					Npos[numNonzerosN] = iSIdx[irn[i] - nACStart];
-					Nvals[numNonzerosN] = vals[i];
-					numNonzerosN++;
-				}
-			}
-
-			delete [] iSIdx;
-			delete [] iNumber;
-			delete [] vals;
-			delete [] jcn;
-			delete [] irn;
-
-			returnvalue = addToSchurComplement( number, SUT_VarFreed, numNonzerosM, Mpos, Mvals, numNonzerosN, Npos, Nvals, N_diag );
-
-			delete [] Mvals;
-			delete [] Mpos;
-			delete [] Nvals;
-			delete [] Npos;
-
-			if ( returnvalue != SUCCESSFUL_RETURN )
-				return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-			found = true;
-			sModType = 1;
-		}
-	}
-
-	if ( !found )
-		return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-	/* Now we have a new Schur complement (might be smaller, larger, or empty). Update QR factorization. */
-
-	/* Flipping bounds strategy */
-	if ( ( options.enableFlippingBounds == BT_TRUE ) && ( allowFlipping == BT_TRUE ) && ( exchangeHappened == BT_FALSE ) )
-	{
-		if ( sModType == 1 )
-		{/* Case 1: We added a row and column to S. */
-
-			/* Check if a direction of negative curvature showed up, i.e. determinants have THE SAME sign */
-			newDet = calcDetSchur( idxDeleted );
-
-			if ( oldDet * newDet > 0.0 )
-			{
-				hessianType = HST_SEMIDEF;
-
-				/* Restore old S */
-				nS--;
-
-				/* Flip bounds */
-				tabularOutput.idxAddB = number;
-				tabularOutput.excAddB = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						bounds.moveFreeToFixed( number, ST_UPPER );
-						ub[number] = lb[number];
-						break;
-					case ST_UPPER:
-						bounds.moveFreeToFixed( number, ST_LOWER );
-						lb[number] = ub[number];
-						break;
-					default:
-						return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-			}
-			else
-			{/* Determinants have the correct sign, compute QR of new (larger) S */
-				updateSchurQR( idxDeleted );
-			}
-		}
-		else if ( sModType == 2 )
-		{/* Case 2: We deleted a row and column of S. */
-
-			/* Check if a direction of negative curvature showed up, i.e. determinants have DIFFERENT signs */
-			newDet = calcDetSchur( idxDeleted );
-
-			if ( oldDet * newDet < 0.0 )
-			{
-				hessianType = HST_SEMIDEF;
-
-				/* Restore old S */
-				undoDeleteFromSchurComplement( idxDeleted );
-
-				/* Flip bounds */
-				tabularOutput.idxAddB = number;
-				tabularOutput.excAddB = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						bounds.moveFreeToFixed( number, ST_UPPER );
-						ub[number] = lb[number];
-						break;
-					case ST_UPPER:
-						bounds.moveFreeToFixed( number, ST_LOWER );
-						lb[number] = ub[number];
-						break;
-					default:
-						return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-			}
-			else
-			{/* Determinants have the correct sign, compute QR of new (smaller) S */
-				updateSchurQR( idxDeleted );
-			}
-		}
-		else if ( sModType == 3 )
-		{/* Case 3: S was reset. */
-
-			/* Check inertia of new factorization given by the sparse solver: must be ( nFR, nAC, 0 ) */
-			int_t neig = sparseSolver->getNegativeEigenvalues( );
-			if( neig > getNAC( ) ) // Wrong inertia, flip bounds!
-			{
-				/* Flip bounds and update Schur complement */
-				tabularOutput.idxAddB = number;
-				tabularOutput.excAddB = 2;
-				switch ( oldStatus )
-				{
-					case ST_LOWER:
-						ub[number] = lb[number];
-						addBound( number, ST_UPPER, BT_TRUE, BT_FALSE );
-						break;
-					case ST_UPPER:
-						lb[number] = ub[number];
-						addBound( number, ST_LOWER, BT_TRUE, BT_FALSE );
-						break;
-					default:
-						return THROWERROR( RET_MOVING_BOUND_FAILED );
-				}
-			}
-
-			/* Check if flipping deleted the negative eigenvalue */
-			if( correctInertia( ) )
-				return THROWERROR( RET_REMOVEBOUND_FAILED );
-		}
-		else
-		{/* None of the three cases happened */
-			return THROWERROR( RET_REMOVEBOUND_FAILED );
-		}
-	}
-	else
-	{/* No flipping strategy, update QR factorization of S */
-		updateSchurQR( idxDeleted );
-	}
-
-	/* If reciprocal of condition number becomes to small, refactorize KKT matrix */
-	if( rcondS < options.rcondSMin )
-	{
-		returnValue retval = resetSchurComplement( BT_TRUE );
-		if ( retval != SUCCESSFUL_RETURN )
-		{
-			if ( retval == RET_KKT_MATRIX_SINGULAR && options.printLevel == PL_HIGH )
-				MyPrintf( "In removeBound: KKT matrix singular when resetting Schur complement\n" );
-			else if ( options.printLevel == PL_HIGH )
-				MyPrintf( "In removeBound, resetSchurComplement failed with retval = %d\n", retval);
-			return THROWERROR( RET_ADDCONSTRAINT_FAILED );
-		}
-	}
-
-	if ( exchangeHappened == BT_TRUE )
-	{
-		/* add bound or constraint */
-
-		if ( addBoundNotConstraint )
-		{
-			addBound(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddB = 1;
-		}
-		else
-		{
-			addConstraint(addIdx, addStatus, BT_TRUE, BT_FALSE);
-			tabularOutput.excAddC = 1;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s e t u p T Q f a c t o r i s a t i o n
- */
-returnValue SQProblemSchur::backsolveT( const real_t* const b, BooleanType transposed, real_t* const a ) const
-{
-	return THROWERROR( RET_UNKNOWN_BUG );
-}
-
-
-/*
- *	b a c k s o l v e R
- */
-returnValue SQProblemSchur::backsolveR(	const real_t* const b, BooleanType transposed, real_t* const a 	) const
-{
-	return THROWERROR( RET_UNKNOWN_BUG );
-}
-
-
-/*
- *	b a c k s o l v e R
- */
-returnValue SQProblemSchur::backsolveR(	const real_t* const b, BooleanType transposed, BooleanType removingBound, real_t* const a ) const
-{
-	return THROWERROR( RET_UNKNOWN_BUG );
-}
-
-
-/*
- *	c a l c D e t S c h u r
- */
-real_t SQProblemSchur::calcDetSchur( int_t idxDel )
-{
-	if ( nS <= 0 )
-		return 1.0;
-
-	real_t newDet;
-	int_t i, j;
-	real_t c, s, nu;
-
-	/* Case 1: S has been bordered by one row and column */
-	if( idxDel < 0 )
-	{
-		/* Do a solve with the old S to check determinant of new (bordered) S */
-		real_t *temp1 = new real_t[nS-1];
-		real_t *temp2 = new real_t[nS-1];
-		for( i=0; i<nS-1; i++ )
-			temp1[i] = S[i + (nS-1)*nSmax];
-		backsolveSchurQR( nS-1, temp1, 1, temp2 );
-
-		newDet = S[(nS-1) + (nS-1)*nSmax];
-		for( i=0; i<nS-1; i++ )
-			newDet -= temp1[i]*temp2[i];
-		newDet *= detS;
-		delete [] temp1;
-		delete [] temp2;
-	}
-	/* Case 2: row and column idxDel have been deleted from S */
-	else
-	{
-		const int_t dim = nS+1;
-		real_t *tempR = new real_t[dim*(dim-1)];
-		real_t *tempColQ = new real_t[dim];
-
-		/* Copy current R without column idxDel*/
-		for( j=0; j<idxDel; j++ )
-			for( i=0; i<dim; i++ )
-				tempR[i+j*dim] = R_[i+j*nSmax];
-		for( j=idxDel; j<dim-1; j++ )
-			for( i=0; i<dim; i++ )
-				tempR[i+j*dim] = R_[i+(j+1)*nSmax];
-		/* Copy row idxDel of Q */
-		for( j=0; j<dim; j++ )
-			tempColQ[j] = Q_[idxDel+j*nSmax];
-
-		/* Bring tempR to triangular form with nS-idxDel Givens rotations */
-		for ( i=idxDel; i<nS; i++ )
-		{
-			computeGivens( tempR[i+i*dim], tempR[(i+1)+i*dim], tempR[i+i*dim], tempR[(i+1)+i*dim], c, s );
-			nu = s/(1.0+c);
-			/// \todo I think we do not need to transform all columns of R, i+3 or so should be sufficient
-			for ( j=i+1; j<nS; j++ )
-				applyGivens( c, s, nu, tempR[i+j*dim], tempR[(i+1)+j*dim], tempR[i+j*dim], tempR[(i+1)+j*dim] );
-
-			/* Simultaneously transform relevant column of Q**T */
-			applyGivens( c, s, nu, tempColQ[i], tempColQ[i+1], tempColQ[i], tempColQ[i+1] );
-		}
-
-		/* Delete row: nS Givens rotations to transform last column (and row!) of (old) Q**T to getAbs((nS+1)-th unity vector) */
-		for ( i=nS; i>0; i-- )
-		{
-			computeGivens( tempColQ[nS], tempColQ[i-1], tempColQ[nS], tempColQ[i-1], c, s );
-			nu = s/(1.0+c);
-
-			/* Simultaneously transform diagonal elements of R (coldim is already one less than Q) */
-			applyGivens( c, s, nu, tempR[nS+(i-1)*dim], tempR[(i-1)+(i-1)*dim], tempR[nS+(i-1)*dim], tempR[(i-1)+(i-1)*dim] );
-		}
-
-		/* Note that we implicitly did a row permutation of Q.
-		 * If we did an  odd permutation AND deleted a positive unity vector or
-		 * if we did an even permutation AND deleted a negative unity vector, then det(Q)=-1
-		 * ->Change signs of first column of Q and first row of R */
-		if ( (( (nS - idxDel) % 2 == 1 ) && ( tempColQ[nS] > 0.0 )) ||
-			(( (nS - idxDel) % 2 == 0 ) && ( tempColQ[nS] < 0.0 )) )
-		{
-			tempR[0] = -tempR[0];
-		}
-
-		newDet = 1.0;
-		//for( i=0; i<nS; i++ )
-			//newDet *= tempR[i+i*dim];
-		for( i=0; i<nS; i++ )
-			if( tempR[i+i*dim] < 0.0 ) newDet = -newDet;
-		delete [] tempR;
-		delete [] tempColQ;
-	}
-
-	return newDet;
-}
-
-
-/*
- *	u p d a t e S c h u r Q R
- */
-returnValue SQProblemSchur::updateSchurQR( int_t idxDel )
-{
-	int_t i, j;
-	real_t c, s, nu;
-
-	if ( nS <= 0 )
-	{
-		detS = 1.0;
-		rcondS = 1.0;
-		return SUCCESSFUL_RETURN;
-	}
-
-	/* Case 1: S has been bordered by one row and column */
-	if ( idxDel < 0 )
-	{
-		/* I: Augment Q**T by nS-th unity vector (row and column) */
-		for ( i=0; i<nS; i++ )
-		{
-			Q_[i+(nS-1)*nSmax] = 0.0;
-			Q_[(nS-1)+i*nSmax] = 0.0;
-		}
-		Q_[(nS-1)+(nS-1)*nSmax] = 1.0;
-
-		/* IIa: Augment rows of R by last row of S */
-		for ( i=0; i<nS; i++ )
-			R_[(nS-1)+i*nSmax] = S[(nS-1)+i*nSmax];
-
-		/* IIb: Augment columns of R by Q**T * S[nS,:] */
-		for ( i=0; i<nS; i++ )
-		{
-			R_[i+(nS-1)*nSmax] = 0.0;
-			for ( j=0; j<nS; j++ )
-				R_[i+(nS-1)*nSmax] += Q_[j+i*nSmax] * S[j+(nS-1)*nSmax];
-		}
-
-		/* III: Restore triangular form of R by nS-1 Givens rotations */
-		for ( i=0; i<nS-1; i++ )
-		{
-			computeGivens( R_[i+i*nSmax], R_[(nS-1)+i*nSmax], R_[i+i*nSmax], R_[(nS-1)+i*nSmax], c, s );
-			nu = s/(1.0+c);
-			for ( j=i+1; j<nS; j++ )
-				applyGivens( c, s, nu, R_[i+j*nSmax], R_[(nS-1)+j*nSmax], R_[i+j*nSmax], R_[(nS-1)+j*nSmax] );
-
-			/* Simultaneously transform Q**T */
-			for ( j=0; j<nS; j++ )
-				applyGivens( c, s, nu, Q_[j+i*nSmax], Q_[j+(nS-1)*nSmax], Q_[j+i*nSmax], Q_[j+(nS-1)*nSmax] );
-		}
-	}
-	/* Case 2: row and column idxDel have been deleted from S */
-	else
-	{
-		/* I: Delete column idxDel of R */
-		for ( j=idxDel; j<nS; j++ )
-			for ( i=0; i<nS+1; i++ )
-				R_[i+j*nSmax] = R_[i+(j+1)*nSmax];
-
-		/* II: Bring R back to triangular form with nS-idxDel Givens rotations */
-		for ( i=idxDel; i<nS; i++ )
-		{
-			computeGivens( R_[i+i*nSmax], R_[(i+1)+i*nSmax], R_[i+i*nSmax], R_[(i+1)+i*nSmax], c, s );
-			nu = s/(1.0+c);
-			for ( j=i+1; j<nS; j++ )
-				applyGivens( c, s, nu, R_[i+j*nSmax], R_[(i+1)+j*nSmax], R_[i+j*nSmax], R_[(i+1)+j*nSmax] );
-
-			/* Simultaneously transform (old) Q**T (coldim is one larger)*/
-			for ( j=0; j<nS+1; j++ )
-				applyGivens( c, s, nu, Q_[j+i*nSmax], Q_[j+(i+1)*nSmax], Q_[j+i*nSmax], Q_[j+(i+1)*nSmax] );
-		}
-
-		/* III: Permute rows of Q: move row idxDel to position nS */
-		real_t temp;
-		for ( j=0; j<nS+1; j++ )
-		{
-			temp = Q_[idxDel+j*nSmax];
-			for ( i=idxDel; i<nS; i++ )
-				Q_[i+j*nSmax] = Q_[(i+1)+j*nSmax];
-			Q_[nS+j*nSmax] = temp;
-		}
-
-		/* IV: Delete row: nS Givens rotations to transform last column (and row!) of (old) Q**T to getAbs((nS+1)-th unity vector) */
-		for ( i=nS; i>0; i-- )
-		{
-			computeGivens( Q_[nS+nS*nSmax], Q_[nS+(i-1)*nSmax], Q_[nS+nS*nSmax], Q_[nS+(i-1)*nSmax], c, s );
-			nu = s/(1.0+c);
-			for ( j=0; j<nS; j++ )
-				applyGivens( c, s, nu, Q_[j+nS*nSmax], Q_[j+(i-1)*nSmax], Q_[j+nS*nSmax], Q_[j+(i-1)*nSmax] );
-
-			/* Simultaneously transform R (coldim is already one less than Q) */
-			for ( j=i-1; j<nS; j++ )
-				applyGivens( c, s, nu, R_[nS+j*nSmax], R_[(i-1)+j*nSmax], R_[nS+j*nSmax], R_[(i-1)+j*nSmax] );
-		}
-
-		/* If we did an  odd permutation AND deleted a positive unity vector or
-		 * if we did an even permutation AND deleted a negative unity vector, then det(Q)=-1
-		 * ->Change signs of first column of Q and first row of R s.t. we always maintain det(Q)=1 */
-		if ( (( (nS - idxDel) % 2 == 1 ) && ( Q_[nS+nS*nSmax] > 0.0 )) ||
-			(( (nS - idxDel) % 2 == 0 ) && ( Q_[nS+nS*nSmax] < 0.0 )) )
-		{
-			for ( i=0; i<nS+1; i++ )
-				Q_[i] = -Q_[i];
-			for ( i=0; i<nS; i++ )
-				R_[i*nSmax] = -R_[i*nSmax];
-		}
-	}
-
-	/* Compute determinant */
-	detS = 1.0;
-	//for ( i=0; i<nS; i++ )
-		//detS *= R_[i+i*nSmax];
-	for ( i=0; i<nS; i++ )
-		if( R_[i+i*nSmax] < 0.0 ) detS = -detS;
-
-	/* Estimate condition number of R (= condition number of S)*/
-	real_t *WORK;
-	unsigned long N = (unsigned long)nS;
-	unsigned long LDA = (unsigned long)nSmax;
-	unsigned long *IWORK;
-	long INFO = 0;
-	IWORK = new unsigned long[N];
-	WORK = new real_t[3*N];
-	TRCON( "1", "U", "N", &N, R_, &LDA, &rcondS, WORK, IWORK, &INFO );
-	if ( INFO != 0 )
-	{
-		MyPrintf( "TRCON returns INFO = %d\n",(int)INFO );
-	}
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "1/cond(S) = %23.16e.\n", rcondS );
-
-	delete[] IWORK;
-	delete[] WORK;
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	b a c k s o l v e S c h u r Q R
- */
-returnValue SQProblemSchur::backsolveSchurQR( int_t dimS, const real_t* const rhs, int_t dimRhs, real_t* const sol )
-{
-	if( dimS < 1 || dimRhs < 1 )
-		return SUCCESSFUL_RETURN;
-
-	if( dimRhs > 1 )
-	{
-		MyPrintf("backsolve not implemented for dimRhs = %d\n", dimRhs);
-		return RET_QR_FACTORISATION_FAILED;
-	}
-
-	int_t i, j;
-	long INFO = 0;
-	unsigned long NRHS = 1;
-	unsigned long M = (unsigned long)dimS;
-	unsigned long LDA = (unsigned long)nSmax;
-	unsigned long LDC = (unsigned long)dimS;
-
-	for( i=0; i<dimS; i++ )
-		sol[i] = 0.0;
-
-	/* Compute sol = Q**T * rhs */
-	for( i=0; i<dimS; i++ )
-		for( j=0; j<dimS; j++ )
-			sol[i] += Q_[j+i*nSmax] * rhs[j];
-
-	/* Solve Rx = sol */
-	TRTRS( "U", "N", "N", &M, &NRHS, R_, &LDA, sol, &LDC, &INFO );
-	if ( INFO != 0 )
-	{
-		MyPrintf("TRTRS returns INFO = %d\n", INFO);
-		return RET_QR_FACTORISATION_FAILED;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SQProblemSchur::stepCalcRhs(	int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx, real_t& rhs_max, 
-											const real_t* const delta_g, const real_t* const delta_lbA, const real_t* const delta_ubA,
-											const real_t* const delta_lb, const real_t* const delta_ub,
-											BooleanType Delta_bC_isZero, BooleanType Delta_bB_isZero,
-											real_t* const delta_xFX, real_t* const delta_xFR,
-											real_t* const delta_yAC, real_t* const delta_yFX
-											)
-{
-	int_t i, ii;
-	returnValue retval;
-
-	if ( nS < 0 )
-	{
-		retval = resetSchurComplement( BT_FALSE );
-		if (retval != SUCCESSFUL_RETURN)
-		{
-			MyPrintf( "In SQProblemSchur::stepCalcRhs, resetSchurComplement returns %d\n", retval);
-			return THROWERROR( retval );
-		}
-	}
-
-	/* tempA and tempB hold the residuals in gFR and bA (= lbA or ubA)
-	 * delta_xFR, delta_yAC hold the steps that get refined */
-	for ( i=0; i<nFR; ++i )
-	{
-		ii = FR_idx[i];
-		tempA[i] = delta_g[ii];
-		delta_xFR[i] = 0.0;
-	}
-	for ( i=0; i<nAC; ++i )
-		delta_yAC[i] = 0.0;
-	if ( Delta_bC_isZero == BT_FALSE )
-	{
-		for ( i=0; i<nAC; ++i )
-		{
-			ii = AC_idx[i];
-			if ( constraints.getStatus( ii ) == ST_LOWER )
-				tempB[i] = delta_lbA[ii];
-			else
-				tempB[i] = delta_ubA[ii];
-		}
-	}
-	else
-	{
-		for ( i=0; i<nAC; ++i )
-			tempB[i] = 0.0;
-	}
-	if ( ( hessianType != HST_IDENTITY ) && ( hessianType != HST_ZERO ) )
-	{
-		/* tempA becomes RHS for reduced augmented system, gFR+H_FX*delta_xFR */
-		H->times(bounds.getFree(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, tempA, nFR);
-	}
-	/* tempB becomes RHS for reduced augmented system, bA-A_CX*delta_xFR */
-	A->times(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, tempB, nAC);
-
-	/* If iterative refinement is requested, compute max-norm of RHS for termination test. */
-	rhs_max = 0.0;
-	if ( options.numRefinementSteps > 0 )
-	{
-		for ( i=0; i<nFR; i++ )
-			rhs_max = getMax(rhs_max, getAbs(tempA[i]));
-		for ( i=0; i<nAC; i++ )
-			rhs_max = getMax(rhs_max, getAbs(tempB[i]));
-	}
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::stepCalcReorder(int_t nFR, int_t nAC, int_t* FR_idx, int_t* AC_idx, int_t nFRStart, int_t nACStart, int_t* FR_idxStart, int_t* AC_idxStart, int_t* FR_iSort, int_t* FR_iSortStart, int_t* AC_iSort, int_t* AC_iSortStart, real_t* rhs)
-{
-	int_t i, ii;
-	/* Reorder information for the new to the old free variables. */
-	i = 0;
-	ii = 0;
-	while ( ii < nFRStart )
-	{
-		if ( i == nFR )
-			rhs[FR_iSortStart[ii++]] = 0.0;
-		else
-		{
-			int_t idx = FR_idx[FR_iSort[i]];
-			int_t idxStart = FR_idxStart[FR_iSortStart[ii]];
-
-			if ( idx == idxStart )
-				rhs[FR_iSortStart[ii++]] = -tempA[FR_iSort[i++]];
-			else if ( idx < idxStart )
-				i++;
-			else
-				rhs[FR_iSortStart[ii++]] = 0.0;
-		}
-	}
-	/* Reorder information for the new to the old active constraints. */
-	i = 0;
-	ii = 0;
-	while ( ii < nACStart )
-	{
-		if ( i == nAC )
-			rhs[nFRStart+AC_iSortStart[ii++]] = 0.0;
-		else
-		{
-			int_t idx = AC_idx[AC_iSort[i]];
-			int_t idxStart = AC_idxStart[AC_iSortStart[ii]];
-
-			if ( idx == idxStart )
-				rhs[nFRStart+AC_iSortStart[ii++]] = tempB[AC_iSort[i++]];
-			else if ( idx < idxStart )
-				i++;
-			else
-				rhs[nFRStart+AC_iSortStart[ii++]] = 0.0;
-		}
-	}
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::stepCalcBacksolveSchur( int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx, int_t dim, real_t* rhs, real_t* sol )
-{
-	returnValue retval;
-	int_t i, ii;
-
-	real_t* q = new real_t[nS];
-
-	/* Compute extra compoments of the RHS */
-	for ( ii=0; ii<nS; ii++ )
-	{
-		int_t idx = schurUpdateIndex[ii];
-		switch ( schurUpdate[ii] ) // TODO: All the loops below could be done faster by binary search or so
-		{
-			case SUT_VarFixed:
-				q[ii] = 0.0;
-				break;
-
-			case SUT_VarFreed:
-				/* Find index of freed variable */
-				for( i=0; i<nFR; ++i )
-					if ( FR_idx[i] == idx )
-					{
-						q[ii] = -tempA[i];
-						break;
-					}
-				break;
-
-			case SUT_ConAdded:
-				/* Find index of added constraint */
-				for( i=0; i<nAC; ++i )
-					if ( AC_idx[i] == idx )
-					{
-						q[ii] = tempB[i];
-						break;
-					}
-				break;
-
-			case SUT_ConRemoved:
-				q[ii] = 0.0;
-				break;
-
-			default:
-				return THROWERROR( RET_UNKNOWN_BUG );
-		}
-	}
-
-	/* compute q = M^T K^{-1} r - q */
-	computeMTransTimes(1.0, sol, -1.0, q);
-
-	/* Solve linear system with Schur complement. */
-	real_t* p = new real_t[nS];
-	backsolveSchurQR( nS, q, 1, p );
-
-	computeMTimes(-1.0, p, 1.0, rhs);
-
-	retval = sparseSolver->solve(dim, rhs, sol);
-	if (retval != SUCCESSFUL_RETURN)
-	{
-		MyPrintf( "sparseSolver->solve (second time) failed.\n");
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED); // TODO: Different return code
-	}
-
-	/* Transfer extra compoments of the Schur complement solution to the correct place. */
-	for ( ii=0; ii<nS; ii++ )
-	{
-		int_t idx = schurUpdateIndex[ii];
-		switch ( schurUpdate[ii] ) // TODO: All the loops below could be done faster by binary search or so
-		{
-			case SUT_VarFixed:
-				break;
-
-			case SUT_VarFreed:
-				/* Find index of freed variable */
-				for( i=0; i<nFR; ++i )
-					if ( FR_idx[i] == idx )
-					{
-						delta_xFR_TMP[i] = p[ii];
-						break;
-					}
-				break;
-
-			case SUT_ConAdded:
-				/* Find index of added constraint */
-				for( i=0; i<nAC; ++i )
-					if ( AC_idx[i] == idx )
-					{
-						delta_yAC_TMP[i] = -p[ii];
-						break;
-					}
-				break;
-
-			case SUT_ConRemoved:
-				break;
-
-			default:
-				return THROWERROR( RET_UNKNOWN_BUG );
-		}
-	}
-
-	delete [] p;
-	delete [] q;
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::stepCalcReorder2(int_t nFR, int_t nAC, int_t* FR_idx, int_t* AC_idx, int_t nFRStart, int_t nACStart, int_t* FR_idxStart, int_t* AC_idxStart, int_t* FR_iSort, int_t* FR_iSortStart, int_t* AC_iSort, int_t* AC_iSortStart, real_t* sol, real_t* const delta_xFR, real_t* const delta_yAC)
-{
-	int_t i, ii;
-			i = 0;
-			ii = 0;
-			while ( ii < nFRStart && i < nFR )
-			{
-				int_t idx = FR_idx[FR_iSort[i]];
-				int_t idxStart = FR_idxStart[FR_iSortStart[ii]];
-
-				if ( idx == idxStart )
-					delta_xFR_TMP[FR_iSort[i++]] = sol[FR_iSortStart[ii++]];
-				else if ( idx < idxStart )
-					i++;
-				else
-					ii++;
-			}
-			/* Transfer Schur complement solution for the active constraint multipliers to the correct places */
-			i = 0;
-			ii = 0;
-			while ( ii < nACStart && i < nAC )
-			{
-				int_t idx = AC_idx[AC_iSort[i]];
-				int_t idxStart = AC_idxStart[AC_iSortStart[ii]];
-
-				if ( idx == idxStart )
-					delta_yAC_TMP[AC_iSort[i++]] = -sol[nFRStart+AC_iSortStart[ii++]];
-				else if ( idx < idxStart )
-					i++;
-				else
-					ii++;
-			}
-
-			/* refine the solution found so far */
-			for ( i=0; i<nFR; ++i )
-				delta_xFR[i] += delta_xFR_TMP[i];
-			for ( i=0; i<nAC; ++i )
-				delta_yAC[i] += delta_yAC_TMP[i];
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::stepCalcResid(int_t nFR, int_t nFX, int_t nAC, int_t* FR_idx, int_t* FX_idx, int_t* AC_idx, BooleanType Delta_bC_isZero, real_t* const delta_xFX, real_t* const delta_xFR, real_t* const delta_yAC, const real_t* const delta_g, const real_t* const delta_lbA, const real_t* const delta_ubA, real_t& rnrm)
-{
-	int_t i, ii;
-				/* compute residuals in tempA and tempB, and max-norm */
-				for ( i=0; i<nFR; ++i )
-				{
-					ii = FR_idx[i];
-					tempA[i] = delta_g[ii];
-				}
-
-				switch ( hessianType )
-				{
-					case HST_ZERO:
-						break;
-
-					case HST_IDENTITY:
-						for ( i=0; i<nFR; ++i )
-							tempA[i] += delta_xFR[i];
-						break;
-
-					default:
-						H->times(bounds.getFree(), bounds.getFree(),  1, 1.0, delta_xFR, nFR, 1.0, tempA, nFR);
-						H->times(bounds.getFree(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, tempA, nFR);
-						break;
-				}
-
-				for ( i=0; i<nFR; ++i )
-					tempA[i] += options.epsRegularisation*delta_xFR[i];
-
-				A->transTimes(constraints.getActive(), bounds.getFree(), 1, -1.0, delta_yAC, nAC, 1.0, tempA, nFR);
-				rnrm = 0.0;
-				for ( i=0; i<nFR; ++i )
-					if (rnrm < getAbs (tempA[i]))
-						rnrm = getAbs (tempA[i]);
-
-				if (!Delta_bC_isZero)
-				{
-					for ( i=0; i<nAC; ++i )
-					{
-						ii = AC_idx[i];
-						if ( constraints.getStatus( ii ) == ST_LOWER )
-							tempB[i] = delta_lbA[ii];
-						else
-							tempB[i] = delta_ubA[ii];
-					}
-				}
-				else
-				{
-					for ( i=0; i<nAC; ++i )
-						tempB[i] = 0.0;
-				}
-
-				A->times(constraints.getActive(), bounds.getFree(), 1, -1.0, delta_xFR, nFR, 1.0, tempB, nAC);
-
-				A->times(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_xFX, nFX, 1.0, tempB, nAC);
-				for ( i=0; i<nAC; ++i )
-					if (rnrm < getAbs (tempB[i]))
-						rnrm = getAbs (tempB[i]);
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::stepCalcDeltayFx(int_t nFR, int_t nFX, int_t nAC, int_t* FX_idx, const real_t* const delta_g, real_t* const delta_xFX, real_t* const delta_xFR, real_t* const delta_yAC, real_t* const delta_yFX)
-{
-	int_t i;
-		for( i=0; i<nFX; ++i )
-			delta_yFX[i] = delta_g[FX_idx[i]];
-
-		A->transTimes(constraints.getActive(), bounds.getFixed(), 1, -1.0, delta_yAC, nAC, 1.0, delta_yFX, nFX);
-
-		if ( hessianType == HST_ZERO )
-		{
-		  // TODO: if ( usingRegularisation( ) == BT_TRUE )
-				for( i=0; i<nFX; ++i )
-					delta_yFX[i] += options.epsRegularisation*delta_xFX[i];
-		}
-		else if ( hessianType == HST_IDENTITY )
-		{
-			for( i=0; i<nFX; ++i )
-				delta_yFX[i] += delta_xFX[i];
-		}
-		else
-		{
-			H->times(bounds.getFixed(), bounds.getFree(), 1, 1.0, delta_xFR, nFR, 1.0, delta_yFX, nFX);
-			H->times(bounds.getFixed(), bounds.getFixed(), 1, 1.0, delta_xFX, nFX, 1.0, delta_yFX, nFX);
-		}
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::determineStepDirection(	const real_t* const delta_g, const real_t* const delta_lbA, const real_t* const delta_ubA,
-												const real_t* const delta_lb, const real_t* const delta_ub,
-												BooleanType Delta_bC_isZero, BooleanType Delta_bB_isZero,
-												real_t* const delta_xFX, real_t* const delta_xFR,
-												real_t* const delta_yAC, real_t* const delta_yFX
-												)
-{
-	returnValue retval = determineStepDirection2(	delta_g, delta_lbA, delta_ubA, delta_lb, delta_ub,
-													Delta_bC_isZero, Delta_bB_isZero, delta_xFX, delta_xFR,
-													delta_yAC, delta_yFX
-													);
-
-	if ( retval == RET_QR_FACTORISATION_FAILED )
-	{
-		retval = resetSchurComplement( BT_FALSE );
-		if (retval != SUCCESSFUL_RETURN)
-		{
-			MyPrintf( "In SQProblem::determineStepDirection, resetSchurComplement returns %d\n", retval);
-			return THROWERROR( retval );
-		}
-		retval = determineStepDirection2(	delta_g, delta_lbA, delta_ubA, delta_lb, delta_ub,
-													Delta_bC_isZero, Delta_bB_isZero, delta_xFX, delta_xFR,
-													delta_yAC, delta_yFX
-													);
-	}
-	return retval;
-}
-
-/*
- *	d e t e r m i n e S t e p D i r e c t i o n
- */
-returnValue SQProblemSchur::determineStepDirection2(	const real_t* const delta_g, const real_t* const delta_lbA, const real_t* const delta_ubA,
-												const real_t* const delta_lb, const real_t* const delta_ub,
-												BooleanType Delta_bC_isZero, BooleanType Delta_bB_isZero,
-												real_t* const delta_xFX, real_t* const delta_xFR,
-												real_t* const delta_yAC, real_t* const delta_yFX
-												)
-{
-	/* The linear system to be solved here is this:
-
-	   / H_FF  H_FX  A_CF^T  0 \ /  delta_xFR \   / -delta_g_F \
-	   | H_XF  H_XX  A_CX^T  I | |  delta_xFX |   | -delta_g_X |
-	   | A_CF  A_CX    0     0 | | -delta_yAC | = |  delta_bA  |  <-- active entries of delta_lbA and delta_ubA with corresponding sign
-	   \  0     I      0     0 / \ -delta_yFX /   \  delta_bX  /  <-- fixed entries of delta_lb and delta_ub with corresponding sign
-
-	*/
-
-
-	int_t i, ii, r;
-
-	returnValue retval;
-
-  //int_t nV  = getNV( );
-	int_t nFR = getNFR( );
-	int_t nFX = getNFX( );
-	int_t nAC = getNAC( );
-
-	int_t* FR_idx;
-	int_t* FX_idx;
-	int_t* AC_idx;
-
-	bounds.getFree( )->getNumberArray( &FR_idx );
-	bounds.getFixed( )->getNumberArray( &FX_idx );
-	constraints.getActive( )->getNumberArray( &AC_idx );
-
-
-	/* I) DETERMINE delta_xFX (this is exact, does not need refinement) */
-	if ( Delta_bB_isZero == BT_FALSE )
-	{
-		for( i=0; i<nFX; ++i )
-		{
-			ii = FX_idx[i];
-
-			if ( bounds.getStatus( ii ) == ST_LOWER )
-				delta_xFX[i] = delta_lb[ii];
-			else
-				delta_xFX[i] = delta_ub[ii];
-		}
-	}
-	else
-	{
-		for( i=0; i<nFX; ++i )
-			delta_xFX[i] = 0.0;
-	}
-
-	if ( nFR+nAC>0 ) {
-		real_t rhs_max = 0.0;
-		retval = stepCalcRhs( nFR, nFX, nAC, FR_idx, FX_idx, AC_idx, rhs_max, delta_g, delta_lbA, delta_ubA,
-							  delta_lb, delta_ub, Delta_bC_isZero, Delta_bB_isZero, delta_xFX, delta_xFR,
-							  delta_yAC, delta_yFX );
-
-		if (retval != SUCCESSFUL_RETURN)
-			return retval;
-		int_t nFRStart = boundsFreeStart.getLength();
-		int_t nACStart = constraintsActiveStart.getLength();
-
-		int_t* FR_iSort;
-		int_t* AC_iSort;
-		bounds.getFree( )->getISortArray( &FR_iSort );
-		constraints.getActive( )->getISortArray( &AC_iSort );
-
-		int_t* FR_idxStart;
-		int_t* AC_idxStart;
-		boundsFreeStart.getNumberArray( &FR_idxStart );
-		constraintsActiveStart.getNumberArray( &AC_idxStart );
-
-		int_t* FR_iSortStart;
-		int_t* AC_iSortStart;
-		boundsFreeStart.getISortArray( &FR_iSortStart );
-		constraintsActiveStart.getISortArray( &AC_iSortStart );
-
-		int_t dim = nFRStart + nACStart;
-		real_t* rhs = new real_t[dim];
-		real_t* sol = new real_t[dim];
-
-		/* Iterative refinement loop for delta_xFR, delta_yAC */
-		for ( r=0; r<=options.numRefinementSteps; ++r )
-		{
-		  retval = stepCalcReorder(nFR, nAC, FR_idx, AC_idx, nFRStart, nACStart, FR_idxStart, AC_idxStart, FR_iSort, FR_iSortStart, AC_iSort, AC_iSortStart, rhs);
-			if (retval != SUCCESSFUL_RETURN)
-				return retval;
-
-			retval = sparseSolver->solve(dim, rhs, sol);
-
-			if (retval != SUCCESSFUL_RETURN)
-			{
-				MyPrintf( "sparseSolver->solve (first time) failed.\n");
-				return THROWERROR(RET_MATRIX_FACTORISATION_FAILED); // TODO: Different return code
-			}
-
-			if ( nS > 0 )
-			{
-				retval = stepCalcBacksolveSchur( nFR, nFX, nAC, FR_idx, FX_idx, AC_idx, dim, rhs, sol );
-				if (retval != SUCCESSFUL_RETURN)
-					return retval;
-			}
-
-			/* Transfer Schur complement solution for the free variables to the correct places */
-			retval = stepCalcReorder2(nFR, nAC, FR_idx, AC_idx, nFRStart, nACStart, FR_idxStart, AC_idxStart, FR_iSort, FR_iSortStart, AC_iSort, AC_iSortStart, sol, delta_xFR, delta_yAC);
-			if (retval != SUCCESSFUL_RETURN)
-				return retval;
-
-			if ( r < options.numRefinementSteps ) // TODO: use "<" to avoid computation in last round
-			{
-				real_t rnrm;
-				retval = stepCalcResid(nFR, nFX, nAC, FR_idx, FX_idx, AC_idx, Delta_bC_isZero, delta_xFX, delta_xFR, delta_yAC, delta_g, delta_lbA, delta_ubA, rnrm);
-				if (retval != SUCCESSFUL_RETURN)
-					return retval;
-
-				/* early termination of residual norm small enough */
-				if ( options.printLevel == PL_HIGH )
-					MyPrintf( "In iterative refinement (iter %d) rnrm = %e and epsIterRef*rhs_max = %e.\n", r, rnrm, options.epsIterRef*rhs_max);
-
-				if ( rnrm <= options.epsIterRef*rhs_max )
-					break;
-			}
-
-		}
-
-		delete [] sol;
-		delete [] rhs;
-	}
-
-	/* IV) DETERMINE delta_yFX */
-	if ( nFX > 0 )
-	{
-		retval = stepCalcDeltayFx(nFR, nFX, nAC, FX_idx, delta_g, delta_xFX, delta_xFR, delta_yAC, delta_yFX);
-		if (retval != SUCCESSFUL_RETURN)
-			return retval;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::resetSchurComplement( BooleanType allowInertiaCorrection )
-{
-	int_t j;
-	int_t nFR = getNFR( );
-	int_t nAC = getNAC( );
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "Resetting Schur complement.\n");
-
-	nS = 0;
-	detS = 1.0;
-	rcondS = 1.0;
-	boundsFreeStart = *bounds.getFree();
-	constraintsActiveStart = *constraints.getActive();
-
-	if ( nSmax > 0 )
-		M_jc[0] = 0;
-
-	int_t dim = nFR+nAC;
-	// Count the number of nonzeros
-	int_t numNonzeros;
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			numNonzeros = 0;
-			break;
-
-		case HST_IDENTITY:
-			numNonzeros = nFR;
-			break;
-
-		default:
-			H->getSparseSubmatrix( bounds.getFree(), bounds.getFree(), 1, 1, numNonzeros, 0, 0, 0, BT_TRUE);
-			break;
-	}
-	// TODO: For now, we regularize every time
-	if (options.epsRegularisation > 0.0)
-		numNonzeros += nFR;
-
-	int_t numNonzerosA;
-
-	if ( constraintProduct != 0 )
-	{
-		MyPrintf( "In SQProblemSchur::determineStepDirection, constraintProduct not yet implemented.\n");
-		return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-	}
-	A->getSparseSubmatrix( constraints.getActive(), bounds.getFree(), nFR+1, 1, numNonzerosA, 0, 0, 0, BT_FALSE);
-	numNonzeros += numNonzerosA;
-
-	// Get the values
-	real_t* avals = new real_t[numNonzeros];
-	int_t* irn = new int_t[numNonzeros];
-	int_t* jcn = new int_t[numNonzeros];
-	numNonzeros = 0;
-	switch ( hessianType )
-	{
-		case HST_ZERO:
-			break;
-
-		case HST_IDENTITY:
-			numNonzeros += nFR;
-			for (j = 0; j<nFR; j++)
-			{
-				irn[j] = j+1;
-				jcn[j] = j+1;
-				avals[j] = 1.0;
-			}
-			break;
-
-		default:
-			H->getSparseSubmatrix( bounds.getFree(), bounds.getFree(), 1, 1, numNonzeros, irn, jcn, avals, BT_TRUE);
-			break;
-	}
-
-	// For now, we regularize every time
-	if (options.epsRegularisation > 0.0)
-	{
-		for (j = 0; j<nFR; j++)
-		{
-			irn[numNonzeros] = j+1;
-			jcn[numNonzeros] = j+1;
-			avals[numNonzeros++] = options.epsRegularisation;
-		}
-	}
-
-	A->getSparseSubmatrix( constraints.getActive(), bounds.getFree(), nFR+1, 1, numNonzerosA, irn+numNonzeros, jcn+numNonzeros, avals+numNonzeros, BT_FALSE);
-	numNonzeros += numNonzerosA;
-
-	// Call the linear solver
-	sparseSolver->reset();
-	returnValue retval = sparseSolver->setMatrixData(dim, numNonzeros, irn, jcn, avals);
-	delete [] jcn;
-	delete [] irn;
-	delete [] avals;
-	
-	if (retval != SUCCESSFUL_RETURN)
-		return THROWERROR(RET_NO_SPARSE_SOLVER);
-
-	// Factorize the matrix for later backsolves
-	retval = sparseSolver->factorize();
-	numFactorizations++;
-
-	// If matrix is singular, add bounds/remove constraints according to zero pivots
-	if (retval == RET_KKT_MATRIX_SINGULAR)
-	{
-		if( repairSingularWorkingSet( ) == SUCCESSFUL_RETURN )
-			return resetSchurComplement( allowInertiaCorrection );
-		else
-			return RET_KKT_MATRIX_SINGULAR;
-	}
-
-	// If matrix has wrong inertia, add bounds until inertia is correct
-	if (retval == SUCCESSFUL_RETURN && allowInertiaCorrection)
-	{
-		int_t neig = sparseSolver->getNegativeEigenvalues( );
-		if( neig > getNAC( ) )
-		{
-			if ( options.printLevel == PL_HIGH )
-				MyPrintf( "WARNING: After new factorization, reduced Hessian has %i negative eigenvalues, should be %i.\n", neig, getNAC( ) );
-
-			retval = correctInertia();
-		}
-	}
-
-	if (retval != SUCCESSFUL_RETURN)
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-
-	nS = 0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::computeMTimes( real_t alpha, const real_t* const x_, real_t beta, real_t* const y_ )
-{
-	if ( isEqual( alpha, -1.0 ) == BT_FALSE || isEqual( beta, 1.0 ) == BT_FALSE )
-		return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-
-	int_t i, j;
-
-	for ( j=0; j<nS; j++ )
-	{
-		const real_t xval = x_[j];
-		for ( i=M_jc[j]; i<M_jc[j+1]; i++)
-			y_[M_ir[i]] -= M_vals[i]*xval;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::computeMTransTimes( real_t alpha, const real_t* const x_, real_t beta, real_t* const y_ )
-{
-	if ( isEqual( alpha, 1.0 ) == BT_FALSE || ( isZero( beta ) == BT_FALSE && isEqual( beta, -1.0 ) == BT_FALSE ) )
-		return THROWERROR(RET_NOT_YET_IMPLEMENTED);
-
-	int_t i, j;
-
-	if ( isZero( beta ) == BT_TRUE )
-	{
-		for ( j=0; j<nS; j++ )
-		{
-			y_[j] = 0.0;
-			for ( i=M_jc[j]; i<M_jc[j+1]; i++)
-				y_[j] += M_vals[i]*x_[M_ir[i]];
-		}
-	}
-	else
-	{
-		for ( j=0; j<nS; j++ )
-		{
-			y_[j] = -y_[j];
-			for ( i=M_jc[j]; i<M_jc[j+1]; i++)
-				y_[j] += M_vals[i]*x_[M_ir[i]];
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::addToSchurComplement( int_t number, SchurUpdateType update, int_t numNonzerosM, const sparse_int_t* Mpos, const real_t* const Mvals, int_t numNonzerosN, const sparse_int_t* Npos, const real_t* const Nvals, real_t N_diag )
-{
-	int_t i;
-
-	int_t nFRStart = boundsFreeStart.getLength();
-	int_t nACStart = constraintsActiveStart.getLength();
-
-	real_t* new_Scol = new real_t[nS];
-
-	int_t dim = nFRStart + nACStart;
-	real_t* rhs = new real_t[dim];
-	real_t* sol = new real_t[dim];
-
-	for ( i=0; i<dim; i++ )
-		rhs[i] = 0.0;
-
-	for ( i=0; i<numNonzerosM; i++ )
-		rhs[Mpos[i]] = Mvals[i];
-
-	returnValue retval = sparseSolver->solve(dim, rhs, sol);
-	if (retval != SUCCESSFUL_RETURN)
-	{
-		MyPrintf( "sparseSolver->solve in SQProblemSchur::addToSchurComplement failed.\n");
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED); // TODO: Different return code
-	}
-
-	computeMTransTimes(1.0, sol, 0.0, new_Scol);
-
-	/* Take care of off-diagonal elements in N. */
-	for ( i=0; i<numNonzerosN; i++ )
-		new_Scol[Npos[i]] -= Nvals[i];
-
-	real_t sdiag = -N_diag;
-	for ( i=0; i<numNonzerosM; i++ )
-		sdiag += Mvals[i] * sol[Mpos[i]];
-
-	/* Now augment S */
-	for ( i=0; i<nS; i++)
-		S[nS*nSmax + i] = new_Scol[i];
-	for ( i=0; i<nS; i++)
-		S[i*nSmax + nS] = new_Scol[i];
-	S[nS*nSmax + nS] = sdiag;
-
-	schurUpdateIndex[nS] = number;
-	schurUpdate[nS] = update;
-
-	/* Augment M matrix.  */
-	if ( M_physicallength < M_jc[nS] + numNonzerosM )
-	{
-		/* If necessary, allocate more memory for M. */
-		int_t M_physicallength_new = getMax(2*M_physicallength, M_physicallength + 2*numNonzerosM);
-		real_t* M_vals_new = new real_t[M_physicallength_new];
-		sparse_int_t* M_ir_new = new sparse_int_t[M_physicallength_new];
-		memcpy( M_vals_new, M_vals, ((unsigned int)(M_jc[nS]))*sizeof(real_t) );
-		memcpy( M_ir_new, M_ir, ((unsigned int)(M_jc[nS]))*sizeof(sparse_int_t) );
-		M_physicallength = M_physicallength_new;
-		delete [] M_vals;
-		delete [] M_ir;
-		M_vals = M_vals_new;
-		M_ir = M_ir_new;
-	}
-
-	for ( i=0; i<numNonzerosM; i++ )
-	{
-		M_vals[M_jc[nS] + i] = Mvals[i];
-		M_ir[M_jc[nS] + i] = Mpos[i];
-	}
-	M_jc[nS+1] = M_jc[nS] + numNonzerosM;
-
-	nS++;
-
-	delete [] sol;
-	delete [] rhs;
-	delete [] new_Scol;
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "added index %d with update type %d to Schur complement.  nS = %d\n", number, update, nS);
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SQProblemSchur::deleteFromSchurComplement( int_t idx, BooleanType allowUndo )
-{
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "deleting entry %d with idx = %d and type %d from Schur complement.", idx, schurUpdateIndex[idx], schurUpdate[idx]);
-
-	if ( idx != nS-1 )
-	{
-		real_t *temp_vals = NULL;
-		int_t *temp_ir = NULL;
-		int_t schurUpdateIndexTemp = -1;
-		SchurUpdateType schurUpdateTemp = SUT_UNDEFINED;
-
-		/* temporarily save the column of S to be deleted */
-		if( allowUndo == BT_TRUE )
-		{
-			temp_vals = new real_t[nS];
-			for ( int_t i=0; i<nS; i++ )
-				temp_vals[i] = S[idx*nSmax + i];
-
-			schurUpdateIndexTemp = schurUpdateIndex[idx];
-			schurUpdateTemp = schurUpdate[idx];
-		}
-
-		/* Shift rows and columns >idx of S by one to the upper left */
-		for ( int_t i=0; i<idx; i++ )
-			for ( int_t j=idx+1; j<nS; j++ )
-				S[i*nSmax + j-1] = S[i*nSmax + j];
-		for ( int_t i=idx+1; i<nS; i++ )
-		{
-			for ( int_t j=0; j<idx; j++ )
-				S[(i-1)*nSmax + j] = S[i*nSmax + j];
-			for ( int_t j=idx+1; j<nS; j++ )
-				S[(i-1)*nSmax + j-1] = S[i*nSmax + j];
-		}
-		for ( int_t i=idx+1; i<nS; i++ )
-		{
-			schurUpdateIndex[i-1] = schurUpdateIndex[i];
-			schurUpdate[i-1] = schurUpdate[i];
-		}
-
-		/* Store deleted row/column in the last row/column of S, can retrieve it from there later */
-		if( allowUndo == BT_TRUE )
-		{
-			for ( int_t i=0; i<nS; i++ )
-			{
-				S[(nS-1)*nSmax + i] = temp_vals[i];
-				S[i*nSmax + (nS-1)] = temp_vals[i];
-			}
-			schurUpdateIndex[nS-1] = schurUpdateIndexTemp;
-			schurUpdate[nS-1] = schurUpdateTemp;
-			delete[] temp_vals;
-		}
-
-		/* temporarily save the (sparse) column of M to be deleted */
-		int_t numEntries = M_jc[idx+1] - M_jc[idx];
-		if( allowUndo == BT_TRUE )
-		{
-			temp_ir = new int_t[numEntries];
-			temp_vals = new real_t[numEntries];
-
-			for ( int_t i=M_jc[idx]; i<M_jc[idx+1]; i++ )
-			{
-				temp_ir[i-M_jc[idx]] = M_ir[i];
-				temp_vals[i-M_jc[idx]] = M_vals[i];
-			}
-		}
-
-		/* Shift all columns >idx one to the left */
-		for ( int_t i=M_jc[idx+1]; i<M_jc[nS]; i++ )
-		{
-			M_ir[i-numEntries] = M_ir[i];
-			M_vals[i-numEntries] = M_vals[i];
-		}
-		for ( int_t i=idx; i<nS; i++ )
-			M_jc[i] = M_jc[i+1] - numEntries;
-
-		/* Store deleted column of M in the last column, can retrieve it from there later */
-		if( allowUndo == BT_TRUE )
-		{
-			for ( int_t i=M_jc[nS-1]; i<M_jc[nS]; i++ )
-			{
-				M_ir[i] = temp_ir[i-M_jc[nS-1]];
-				M_vals[i] = temp_vals[i-M_jc[nS-1]];
-			}
-
-			delete[] temp_ir;
-			delete[] temp_vals;
-		}
-	}
-
-	nS--;
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "  nS = %d\n", nS);
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-returnValue SQProblemSchur::undoDeleteFromSchurComplement( int_t idx )
-{
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "undo deletion of entry %d with idx = %d and type %d from Schur complement. nS = %i\n", idx, schurUpdateIndex[nS-1], schurUpdate[nS-1],nS+1);
-
-	if ( idx != nS )
-	{
-		real_t *temp_vals;
-		int_t *temp_ir;
-		int_t schurUpdateIndexTemp = -1;
-		SchurUpdateType schurUpdateTemp = SUT_UNDEFINED;
-
-		/* temporarily save the last column of S */
-		temp_vals = new real_t[nS+1];
-		for ( int_t i=0; i<nS+1; i++ )
-			temp_vals[i] = S[i+nS*nSmax];
-
-		schurUpdateIndexTemp = schurUpdateIndex[nS];
-		schurUpdateTemp = schurUpdate[nS];
-
-		/* Shift rows and columns =>idx of S by one to the lower right */
-		for ( int_t i=idx-1; i>-1; i-- )
-			for ( int_t j=nS-1; j>idx-1; j-- )
-				S[(j+1)+i*nSmax] = S[j+i*nSmax];
-		for ( int_t i=nS-1; i>idx-1; i-- )
-		{
-			for ( int_t j=idx-1; j>-1; j-- )
-				S[j+(i+1)*nSmax] = S[j+i*nSmax];
-			for ( int_t j=nS-1; j>idx-1; j-- )
-				S[(j+1)+(i+1)*nSmax] = S[j+i*nSmax];
-		}
-		for ( int_t i=nS-1; i>idx-1; i-- )
-		{
-			schurUpdateIndex[i+1] = schurUpdateIndex[i];
-			schurUpdate[i+1] = schurUpdate[i];
-		}
-
-		/* Insert stored row/column of S at position idx */
-		for ( int_t i=0; i<nS+1; i++ )
-		{
-			S[idx*nSmax + i] = temp_vals[i];
-			S[i*nSmax + idx] = temp_vals[i];
-		}
-		schurUpdateIndex[idx] = schurUpdateIndexTemp;
-		schurUpdate[idx] = schurUpdateTemp;
-		delete[] temp_vals;
-
-		/* temporarily save the last (sparse) column of M */
-		int_t numEntries = M_jc[nS+1] - M_jc[nS];
-		temp_ir = new int_t[numEntries];
-		temp_vals = new real_t[numEntries];
-		for ( int_t i=M_jc[nS]; i<M_jc[nS+1]; i++ )
-		{
-			temp_ir[i-M_jc[nS]] = M_ir[i];
-			temp_vals[i-M_jc[nS]] = M_vals[i];
-		}
-
-		/* Shift all columns =>idx one to the right */
-		for ( int_t i=M_jc[nS]-1; i>M_jc[idx]-1; i-- )
-		{
-			M_ir[i+numEntries] = M_ir[i];
-			M_vals[i+numEntries] = M_vals[i];
-		}
-		for ( int_t i=nS; i>idx-1; i-- )
-			M_jc[i+1] = M_jc[i] + numEntries;
-
-		/* Insert stored column of M at position idx */
-		for ( int_t i=M_jc[idx]; i<M_jc[idx+1]; i++ )
-		{
-			M_ir[i] = temp_ir[i-M_jc[idx]];
-			M_vals[i] = temp_vals[i-M_jc[idx]];
-		}
-
-		delete[] temp_ir;
-		delete[] temp_vals;
-	}
-
-	nS++;
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "  nS = %d\n", nS);
-
-	return SUCCESSFUL_RETURN;
-}
-
-returnValue SQProblemSchur::correctInertia( )
-{
-	SubjectToStatus B_status;
-	real_t oldDetS;
-	int_t nFR = getNFR( );
-	int_t k, number, neig, nAdded;
-	int_t *freeBoundIdx = new int_t[nFR];
-	int_t *numberarray;
-
-	/* method may only be called after refactorization or if one bound/constraint
-	 * has been added, i.e. when a bound has flipped after refactorization */
-	if( nS != 0 && nS != 1 )
-		return THROWERROR( RET_INERTIA_CORRECTION_FAILED );
-	neig = sparseSolver->getNegativeEigenvalues( );
-
-	/* if a bound flipped, check if it did in fact remove a negative eigenvalue */
-	if( nS == 1 && detS < 0 )
-		neig--;
-
-	/* if this method is triggered after flipping bounds, inertia is now probably correct */
-	if( neig == getNAC( ) )
-		return SUCCESSFUL_RETURN;
-
-	/* get bound numbers in the order in which they are in the non-basis */
-	bounds.getFree()->getNumberArray( &numberarray );
-	for( k=0; k<nFR; k++ )
-		freeBoundIdx[k] = numberarray[k];
-
-	k = 0;
-	nAdded = getNFR( );
-	while ( neig > getNAC( ) && k < nFR )
-	{
-		oldDetS = detS;
-
-		/* If it's linearly independent, fix the next free variable at the nearest bound */
-		number = freeBoundIdx[k];
-		if( addBound_checkLI( number ) == RET_LINEARLY_INDEPENDENT )
-		{
-			/* This is just heuristics: we need the bound which gives correct multiplier sign */
-			if ( x[number] - lb[number] < ub[number] - x[number] )
-				B_status = ST_LOWER;
-			else
-				B_status = ST_UPPER;
-
-			/* Update Schur complement */
-			if( addBound( number, B_status, BT_TRUE, BT_FALSE ) != SUCCESSFUL_RETURN )
-			{
-				if ( options.printLevel == PL_HIGH )
-					MyPrintf("In correctInertia: Adding bound[%i] = %i failed!\n", k, number );
-				return THROWERROR( RET_INERTIA_CORRECTION_FAILED );
-			}
-
-			/* Adjust bounds */
-			if ( B_status == ST_LOWER )
-				lb[number] = x[number];
-			else
-				ub[number] = x[number];
-		}
-		else
-		{
-			if ( options.printLevel == PL_HIGH )
-				MyPrintf("bound[%i] = %i is linearly dependent. Do not add.\n", k, number );
-			k++;
-			continue;
-		}
-
-		/* Case 1: Schur complement has been reset, check inertia of new factorization */
-		if( nS == 0 )
-			neig = sparseSolver->getNegativeEigenvalues( );
-		/* Case 2: Schur complement has grown, check if determinant changed sign */
-		else if( oldDetS * detS < 0 )
-			neig--;
-		/* NB: Case 3: (Schur complement has shrunk) cannot happen here:
-		 * This method is called after a factorization reset or after ONE bound has been added */
-
-		k++;
-	}
-	nAdded -= getNFR( );
-
-	delete[] freeBoundIdx;
-
-	/* if there are still too many negative eigenvalues, exit */
-	if( neig > getNAC( ) )
-	{
-		if ( options.printLevel == PL_HIGH )
-			MyPrintf( "Added %i bounds but KKT matrix still has %i negative eigenvalues, should be %i.\n", nAdded, neig, getNAC( ) );
-		return THROWERROR( RET_INERTIA_CORRECTION_FAILED );
-	}
-	else
-	{
-		if ( options.printLevel == PL_HIGH )
-			MyPrintf( "After adding %i bounds, reduced Hessian has correct inertia.\n", nAdded, neig );
-		return SUCCESSFUL_RETURN;
-	}
-}
-
-
-returnValue SQProblemSchur::repairSingularWorkingSet( )
-{
-	int_t k, number;
-	SubjectToStatus B_status;
-	int_t rank = sparseSolver->getRank( );
-	int_t nFR = getNFR( );
-	int_t defect = nFR + getNAC( ) - rank;
-
-	/* Rank detection not supported by linear solver */
-	if ( rank < 0 )
-		return RET_KKT_MATRIX_SINGULAR;
-
-	/* Consistency check */
-	if ( defect <= 0 )
-		return RET_UNKNOWN_BUG;
-
-	/* Determine zero pivots */
-	int_t *zeroPivots = new int_t[defect];
-	sparseSolver->getZeroPivots( zeroPivots );
-
-	/* Determination of zero pivots not supported by linear solver */
-	if ( zeroPivots == 0 )
-		return RET_KKT_MATRIX_SINGULAR;
-
-	/* We assume implicitly that pivots are sorted in ascending order */
-	/// \todo make sure that this is so.
-	/* Remove the one with the highest index first so not to mess up index lists */
-	int_t bndsAdded = 0;
-	for ( k=defect-1; k>-1; k-- )
-	{
-		/* Zero curvature in the Hessian: add a bound */
-		if ( zeroPivots[k] < nFR )
-		{
-			number = bounds.getFree()->getNumber( zeroPivots[k] );
-
-			if ( options.printLevel == PL_HIGH )
-				MyPrintf( "WARNING: KKT matrix singular! Add bound %i before refactorization.\n", number);
-
-			/* This is just heuristics: we need the bound which gives correct multiplier sign */
-			if ( x[number] - lb[number] < ub[number] - x[number] )
-				B_status = ST_LOWER;
-			else
-				B_status = ST_UPPER;
-
-			/* Here we do not need to update the Schur complement because KKT matrix is factorized afterwards */
-			if ( bounds.moveFreeToFixed( number, B_status ) != SUCCESSFUL_RETURN )
-				return RET_ADDBOUND_FAILED;
-
-			/* Adjust bounds */
-			if ( B_status == ST_LOWER )
-				lb[number] = x[number];
-			else
-				ub[number] = x[number];
-
-			bndsAdded++;
-		}
-		/* Linearly dependent row in the Jacobian: remove a constraint */
-		else
-		{
-			number = constraints.getActive()->getNumber( zeroPivots[k]-nFR );
-			if ( options.printLevel == PL_HIGH )
-				MyPrintf( "WARNING: KKT matrix singular! Removing constraint %i before refactorization.\n", number);
-
-			if ( constraints.moveActiveToInactive( number ) != SUCCESSFUL_RETURN )
-				return RET_REMOVECONSTRAINT_FAILED;
-
-			// AW: If this is an equality constraint, it is now inactive and
-			// will not be considered in the step computation which leads to
-			// violation of that constraint in the future. Here, I try to
-			// fix this by simply making this constraint no longer an
-			// equality.
-			// TODO: This is probably also necessary for bound constraints
-			if ( constraints.getType(number) == ST_EQUALITY )
-			{
-				if ( options.printLevel == PL_HIGH )
-					MyPrintf( "WARNING: Making this constraint no longer an equality.\n");
-				constraints.setType( number, ST_BOUNDED );
-			}
-
-			/* Adjust dual variable */
-			y[number] = 0.0;
-		}
-	}
-
-	if ( options.printLevel == PL_HIGH )
-		MyPrintf( "WARNING: KKT matrix singular! Removed %i constraints and added %i bounds before refactorization.\n",
-					defect-bndsAdded, bndsAdded );
-
-	delete[] zeroPivots;
-
-	return SUCCESSFUL_RETURN;
-}
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/SolutionAnalysis.cpp b/extlibs/qpOASES-3.2.0/src/SolutionAnalysis.cpp
deleted file mode 100644
index ee69d7d..0000000
--- a/extlibs/qpOASES-3.2.0/src/SolutionAnalysis.cpp
+++ /dev/null
@@ -1,681 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/SolutionAnalysis.cpp
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Implementation of the SolutionAnalysis class designed to perform
- *	additional analysis after solving a QP with qpOASES.
- *
- */
-
-
-#include <qpOASES/extras/SolutionAnalysis.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	S o l u t i o n A n a l y s i s
- */
-SolutionAnalysis::SolutionAnalysis( )
-{
-
-}
-
-
-/*
- *	S o l u t i o n A n a l y s i s
- */
-SolutionAnalysis::SolutionAnalysis( const SolutionAnalysis& rhs )
-{
-
-}
-
-
-/*
- *	~ S o l u t i o n A n a l y s i s
- */
-SolutionAnalysis::~SolutionAnalysis( )
-{
-
-}
-
-
-/*
- *	o p e r a t o r =
- */
-SolutionAnalysis& SolutionAnalysis::operator=( const SolutionAnalysis& rhs )
-{
-	if ( this != &rhs )
-	{
-
-	}
-
-	return *this;
-}
-
-
-
-/*
- *	g e t K k t V i o l a t i o n
- */
-real_t SolutionAnalysis::getKktViolation(	QProblemB* const qp,
-											real_t* const maxStat, real_t* const maxFeas, real_t* const maxCmpl
-											) const
-{
-	int_t i;
-	int_t nV = qp->getNV();
-
-	if ( qp == 0 )
-		return INFTY;
-
-	/* setup Hessian matrix array (or pass NULL pointer) */
-	real_t* H_ptr = 0;
-	BooleanType hasIdentityHessian = BT_FALSE;
-
-	switch( qp->getHessianType() )
-	{
-		case HST_ZERO:
-			break;
-
-		case HST_IDENTITY:
-			hasIdentityHessian = BT_TRUE;
-			break;
-
-		default:
-			H_ptr = qp->H->full();
-			if ( qp->usingRegularisation() == BT_TRUE )
-				for( i=0; i<nV; ++i )
-					H_ptr[i*nV+i] -= qp->regVal;
-	}
-
-	real_t* workingSetB = new real_t[nV];
-	qp->getWorkingSetBounds( workingSetB );
-
-	/* determine maximum KKT violation */
-	real_t maxKktViolation=0.0, stat=0.0, feas=0.0, cmpl=0.0;
-
-	returnValue returnvalue = REFER_NAMESPACE_QPOASES getKktViolation(	nV,
-																		H_ptr,qp->g,
-																		qp->lb,qp->ub,
-																		qp->x,qp->y,
-																		stat,feas,cmpl,
-																		workingSetB,hasIdentityHessian
-																		);
-	if ( workingSetB != 0 )
-		delete[] workingSetB;
-
-	if ( H_ptr != 0 )
-		delete[] H_ptr;
-
-	if ( returnvalue != SUCCESSFUL_RETURN )
-		THROWERROR( returnvalue );
-
-	/* assign return values */
-	if ( maxStat != 0 )
-		*maxStat = stat;
-
-	if ( maxFeas != 0 )
-		*maxFeas = feas;
-
-	if ( maxCmpl != 0 )
-		*maxCmpl = cmpl;
-
-	maxKktViolation = getMax( maxKktViolation,stat );
-	maxKktViolation = getMax( maxKktViolation,feas );
-	maxKktViolation = getMax( maxKktViolation,cmpl );
-
-	return maxKktViolation;
-}
-
-
-/*
- *	g e t K k t V i o l a t i o n
- */
-real_t SolutionAnalysis::getKktViolation(	QProblem* const qp,
-											real_t* const maxStat, real_t* const maxFeas, real_t* const maxCmpl
-											) const
-{
-	int_t i;
-	int_t nV = qp->getNV();
-	int_t nC = qp->getNC();
-
-	if ( qp == 0 )
-		return INFTY;
-
-	/* setup Hessian matrix array (or pass NULL pointer) */
-	real_t* H_ptr = 0;
-	BooleanType hasIdentityHessian = BT_FALSE;
-
-	switch( qp->getHessianType() )
-	{
-		case HST_ZERO:
-			break;
-
-		case HST_IDENTITY:
-			hasIdentityHessian = BT_TRUE;
-			break;
-
-		default:
-			H_ptr = qp->H->full();
-			if ( qp->usingRegularisation() == BT_TRUE )
-				for( i=0; i<nV; ++i )
-					H_ptr[i*nV+i] -= qp->regVal;
-	}
-
-	/* setup constraint matrix array */
-	real_t* A_ptr = qp->A->full();
-
-	real_t* workingSetB = new real_t[nV];
-	qp->getWorkingSetBounds( workingSetB );
-
-	real_t* workingSetC = new real_t[nC];
-	qp->getWorkingSetConstraints( workingSetC );
-
-	/* determine maximum KKT violation */
-	real_t maxKktViolation=0.0, stat=0.0, feas=0.0, cmpl=0.0;
-
-	returnValue returnvalue = REFER_NAMESPACE_QPOASES getKktViolation(	nV,nC,
-																		H_ptr,qp->g,A_ptr,
-																		qp->lb,qp->ub,qp->lbA,qp->ubA,
-																		qp->x,qp->y,
-																		stat,feas,cmpl,
-																		workingSetB,workingSetC,hasIdentityHessian
-																		);
-
-	if ( workingSetC != 0 )
-		delete[] workingSetC;
-
-	if ( workingSetB != 0 )
-		delete[] workingSetB;
-
-	if ( A_ptr != 0 )
-		delete[] A_ptr;
-
-	if ( H_ptr != 0 )
-		delete[] H_ptr;
-
-	if ( returnvalue != SUCCESSFUL_RETURN )
-		THROWERROR( returnvalue );
-
-	/* assign return values */
-	if ( maxStat != 0 )
-		*maxStat = stat;
-
-	if ( maxFeas != 0 )
-		*maxFeas = feas;
-
-	if ( maxCmpl != 0 )
-		*maxCmpl = cmpl;
-
-	maxKktViolation = getMax( maxKktViolation,stat );
-	maxKktViolation = getMax( maxKktViolation,feas );
-	maxKktViolation = getMax( maxKktViolation,cmpl );
-
-	return maxKktViolation;
-}
-
-
-/*
- *	g e t K k t V i o l a t i o n
- */
-real_t SolutionAnalysis::getKktViolation(	SQProblem* const qp,
-											real_t* const maxStat, real_t* const maxFeas, real_t* const maxCmpl
-											) const
-{
-	return getKktViolation( (QProblem*)qp, maxStat,maxFeas,maxCmpl );
-}
-
-
-
-/*
- *	g e t V a r i a n c e C o v a r i a n c e
- */
-returnValue SolutionAnalysis::getVarianceCovariance(	QProblemB* const qp,
-														const real_t* const g_b_bA_VAR, real_t* const Primal_Dual_VAR
-														) const
-{
-	return THROWERROR( RET_NOT_YET_IMPLEMENTED );
-}
-
-
-/*
- *	g e t V a r i a n c e C o v a r i a n c e
- */
-returnValue SolutionAnalysis::getVarianceCovariance(	QProblem* qp,
-														const real_t* const g_b_bA_VAR, real_t* const Primal_Dual_VAR
-														) const
-{
-
-  /* DEFINITION OF THE DIMENSIONS nV AND nC:
-   * --------------------------------------- */
-  int_t nV  = qp->getNV( );                      /* dimension of x / the bounds */
-  int_t nC  = qp->getNC( );                      /* dimension of the constraints */
-  int_t dim = 2*nV+nC;                           /* dimension of input and output */
-                                               /* variance-covariance matrix */
-  int_t run1, run2, run3;                        /* simple run variables (for loops). */
-
-
-  /* ALLOCATION OF MEMORY:
-   * --------------------- */
-  real_t* delta_g_cov    = new real_t[nV];     /* a covariance-vector of g */
-  real_t* delta_lb_cov   = new real_t[nV];     /* a covariance-vector of lb */
-  real_t* delta_ub_cov   = new real_t[nV];     /* a covariance-vector of ub */
-  real_t* delta_lbA_cov  = new real_t[nC];     /* a covariance-vector of lbA */
-  real_t* delta_ubA_cov  = new real_t[nC];     /* a covariance-vector of ubA */
-
-  returnValue returnvalue;                     /* the return value */
-  BooleanType Delta_bC_isZero = BT_FALSE;      /* (just use FALSE here) */
-  BooleanType Delta_bB_isZero = BT_FALSE;      /* (just use FALSE here) */
-
-
-
-  /* ASK FOR THE NUMBER OF FREE AND FIXED VARIABLES:
-   * (ASSUMES THAT ACTIVE SET IS CONSTANT FOR THE
-   *  VARIANCE-COVARIANCE EVALUATION)
-   * ----------------------------------------------- */
-  int_t nFR, nFX, nAC;
-
-  nFR = qp->getNFR( );
-  nFX = qp->getNFX( );
-  nAC = qp->getNAC( );
-
-
-  /* ASK FOR THE CORRESPONDING INDEX ARRAYS:
-   * --------------------------------------- */
-  int_t *FR_idx, *FX_idx, *AC_idx;
-
-  if ( qp->bounds.getFree( )->getNumberArray( &FR_idx ) != SUCCESSFUL_RETURN )
-       return THROWERROR( RET_HOTSTART_FAILED );
-
-  if ( qp->bounds.getFixed( )->getNumberArray( &FX_idx ) != SUCCESSFUL_RETURN )
-       return THROWERROR( RET_HOTSTART_FAILED );
-
-  if ( qp->constraints.getActive( )->getNumberArray( &AC_idx ) != SUCCESSFUL_RETURN )
-       return THROWERROR( RET_HOTSTART_FAILED );
-
-
-
-  /* INTRODUCE VARIABLES TO MEASURE THE REACTION OF THE QP-SOLUTION TO
-   * THE VARIANCE-COVARIANCE DISTURBANCE:
-   * ----------------------------------------------------------------- */
-  real_t *delta_xFR = new real_t[nFR];
-  real_t *delta_xFX = new real_t[nFX];
-  real_t *delta_yAC = new real_t[nAC];
-  real_t *delta_yFX = new real_t[nFX];
-
-  real_t* K             = new real_t[dim*dim];  /* matrix to store */
-                                                /* an intermediate */
-                                                /* result. */
-
-  /* SOME INITIALIZATIONS:
-   * --------------------- */
-  for( run1 = 0; run1 < dim*dim; run1++ ){
-    K              [run1] = 0.0;
-    Primal_Dual_VAR[run1] = 0.0;
-  }
-
-
-  /* ================================================================= */
-
-  /* FIRST MATRIX MULTIPLICATION (OBTAINS THE INTERMEDIATE RESULT
-   *  K := [ ("ACTIVE" KKT-MATRIX OF THE QP)^(-1) * g_b_bA_VAR ]^T )
-   * THE EVALUATION OF THE INVERSE OF THE KKT-MATRIX OF THE QP
-   * WITH RESPECT TO THE CURRENT ACTIVE SET
-   * USES THE EXISTING CHOLESKY AND TQ-DECOMPOSITIONS. FOR DETAILS
-   * cf. THE (protected) FUNCTION determineStepDirection. */
-
-  for( run3 = 0; run3 < dim; run3++ ){
-
-
-    for( run1 = 0; run1 < nV; run1++ ){
-      delta_g_cov  [run1]   = g_b_bA_VAR[run3*dim+run1];
-      delta_lb_cov [run1]   = g_b_bA_VAR[run3*dim+nV+run1];         /*  LINE-WISE LOADING OF THE INPUT */
-      delta_ub_cov [run1]   = g_b_bA_VAR[run3*dim+nV+run1];         /*  VARIANCE-COVARIANCE            */
-    }
-    for( run1 = 0; run1 < nC; run1++ ){
-      delta_lbA_cov [run1]  = g_b_bA_VAR[run3*dim+2*nV+run1];
-      delta_ubA_cov [run1]  = g_b_bA_VAR[run3*dim+2*nV+run1];
-    }
-
-
-    /* EVALUATION OF THE STEP:
-     * ------------------------------------------------------------------------------ */
-
-    returnvalue = qp->determineStepDirection( delta_g_cov, delta_lbA_cov, delta_ubA_cov, delta_lb_cov, delta_ub_cov,
-                                              Delta_bC_isZero, Delta_bB_isZero, delta_xFX,delta_xFR,
-                                              delta_yAC,delta_yFX );
-
-    /* ------------------------------------------------------------------------------ */
-
-
-    /* STOP THE ALGORITHM IN THE CASE OF NO SUCCESFUL RETURN:
-     * ------------------------------------------------------ */
-    if ( returnvalue != SUCCESSFUL_RETURN ){
-
-      delete[] delta_g_cov;
-      delete[] delta_lb_cov;
-      delete[] delta_ub_cov;
-      delete[] delta_lbA_cov;
-      delete[] delta_ubA_cov;
-      delete[] delta_xFR;
-      delete[] delta_xFX;
-      delete[] delta_yAC;
-      delete[] delta_yFX;
-      delete[] K;
-
-      THROWERROR( RET_STEPDIRECTION_DETERMINATION_FAILED );
-      return returnvalue;
-    }
-
-
-
-    for( run1=0; run1<nFR; run1++ ){
-      run2                  = FR_idx[run1];
-      K[run3*dim+run2]      = delta_xFR[run1];
-    }                                                               /*  LINE WISE                  */
-    for( run1=0; run1<nFX; run1++ ){                                /*  STORAGE OF THE QP-REACTION */
-      run2                  = FX_idx[run1];                         /*  (uses the index list)      */
-      K[run3*dim+run2]      = delta_xFX[run1];
-      K[run3*dim+nV+run2]   = delta_yFX[run1];
-    }
-    for( run1=0; run1<nAC; run1++ ){
-      run2                  = AC_idx[run1];
-      K[run3*dim+2*nV+run2] = delta_yAC[run1];
-    }
-
-  }
-
-
-  /* ================================================================= */
-
-  /* SECOND MATRIX MULTIPLICATION (OBTAINS THE FINAL RESULT
-   * Primal_Dual_VAR := ("ACTIVE" KKT-MATRIX OF THE QP)^(-1) * K )
-   * THE APPLICATION OF THE KKT-INVERSE IS AGAIN REALIZED
-   * BY USING THE PROTECTED FUNCTION
-   * determineStepDirection */
-
-  for( run3 = 0; run3 < dim; run3++ ){
-
-    for( run1 = 0; run1 < nV; run1++ ){
-      delta_g_cov  [run1]   = K[run3+     run1*dim];
-      delta_lb_cov [run1]   = K[run3+(nV+run1)*dim];                /*  ROW WISE LOADING OF THE */
-      delta_ub_cov [run1]   = K[run3+(nV+run1)*dim];                /*  INTERMEDIATE RESULT K   */
-    }
-    for( run1 = 0; run1 < nC; run1++ ){
-      delta_lbA_cov [run1]  = K[run3+(2*nV+run1)*dim];
-      delta_ubA_cov [run1]  = K[run3+(2*nV+run1)*dim];
-    }
-
-
-    /* EVALUATION OF THE STEP:
-     * ------------------------------------------------------------------------------ */
-
-    returnvalue = qp->determineStepDirection( delta_g_cov, delta_lbA_cov, delta_ubA_cov, delta_lb_cov, delta_ub_cov,
-                                              Delta_bC_isZero, Delta_bB_isZero, delta_xFX,delta_xFR,
-                                              delta_yAC,delta_yFX);
-
-
-    /* ------------------------------------------------------------------------------ */
-
-
-    /* STOP THE ALGORITHM IN THE CASE OF NO SUCCESFUL RETURN:
-     * ------------------------------------------------------ */
-    if ( returnvalue != SUCCESSFUL_RETURN ){
-
-      delete[] delta_g_cov;
-      delete[] delta_lb_cov;
-      delete[] delta_ub_cov;
-      delete[] delta_lbA_cov;
-      delete[] delta_ubA_cov;
-      delete[] delta_xFR;
-      delete[] delta_xFX;
-      delete[] delta_yAC;
-      delete[] delta_yFX;
-      delete[] K;
-
-      THROWERROR( RET_STEPDIRECTION_DETERMINATION_FAILED );
-      return returnvalue;
-    }
-
-
-
-    for( run1=0; run1<nFR; run1++ ){
-      run2                                = FR_idx[run1];
-      Primal_Dual_VAR[run3+run2*dim]      = delta_xFR[run1];
-    }
-    for( run1=0; run1<nFX; run1++ ){                                 /*  ROW-WISE STORAGE */
-      run2                  = FX_idx[run1];                          /*  OF THE RESULT.   */
-      Primal_Dual_VAR[run3+run2*dim     ]   = delta_xFX[run1];
-      Primal_Dual_VAR[run3+(nV+run2)*dim]   = delta_yFX[run1];
-    }
-    for( run1=0; run1<nAC; run1++ ){
-      run2                                  = AC_idx[run1];
-      Primal_Dual_VAR[run3+(2*nV+run2)*dim] = delta_yAC[run1];
-    }
-
-  }
-
-
-  /* DEALOCATE MEMORY:
-   * ----------------- */
-
-  delete[] delta_g_cov;
-  delete[] delta_lb_cov;
-  delete[] delta_ub_cov;
-  delete[] delta_lbA_cov;
-  delete[] delta_ubA_cov;
-  delete[] delta_xFR;
-  delete[] delta_xFX;
-  delete[] delta_yAC;
-  delete[] delta_yFX;
-  delete[] K;
-
-  return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t V a r i a n c e C o v a r i a n c e
- */
-returnValue SolutionAnalysis::getVarianceCovariance(	SQProblem* const qp,
-														const real_t* const g_b_bA_VAR, real_t* const Primal_Dual_VAR
-														) const
-{
-	/* Call QProblem variant. */
-	return getVarianceCovariance( (QProblem*)qp,g_b_bA_VAR,Primal_Dual_VAR );
-}
-
-
-/*
- *	c h e c k C u r v a t u r e O n S e t S
- */
-returnValue SolutionAnalysis::checkCurvatureOnStronglyActiveConstraints( SQProblem* qp )
-{
-  printf("checkCurvatureOnStronglyActiveConstraints( SQProblem* qp ) not yet implemented for standard qpOASES!\n");
-  return RET_INERTIA_CORRECTION_FAILED;
-}
-
-
-/*
- *	c h e c k C u r v a t u r e O n S t r o n g l y A c t i v e C o n s t r a i n t s
- */
-returnValue SolutionAnalysis::checkCurvatureOnStronglyActiveConstraints( SQProblemSchur* qp )
-{
-  real_t eps = 1.0e-16;
-  returnValue ret;
-  Bounds saveBounds;
-  QProblemStatus saveStatus;
-  int_t k, neig, nAC, nFX, *FX_idx;
-
-  nFX = qp->getNFX( );
-  nAC = qp->getNAC( );
-
-  // If no bounds are active reduced Hessian is positive definite (otherwise qpOASES wouldnt have finished)
-  if( nFX == 0 )
-    return SUCCESSFUL_RETURN;
-
-  // Get active bounds (deep copy)
-  qp->getBounds( saveBounds );
-  saveBounds.getFixed( )->getNumberArray( &FX_idx );
-
-  // We have to change the status to modify the active set
-  saveStatus = qp->getStatus();
-  qp->status = QPS_PERFORMINGHOMOTOPY;
-
-  // If a variable is active now but has not been in the previous major iteration remove it
-  for( k=0; k<nFX; k++ )
-    if( getAbs(qp->x[FX_idx[k]]) > eps )
-      if ( qp->bounds.moveFixedToFree( FX_idx[k] ) != SUCCESSFUL_RETURN )
-	return THROWERROR( RET_REMOVEBOUND_FAILED );
-
-  // Do a new factorization and check the inertia
-  ret = qp->resetSchurComplement( BT_FALSE );
-  neig = qp->sparseSolver->getNegativeEigenvalues( );
-  if( ret == SUCCESSFUL_RETURN && neig != nAC )
-    ret = RET_INERTIA_CORRECTION_FAILED;
-
-  // Add all bounds that have been removed
-  for( k=0; k<nFX; k++ )
-    if( qp->bounds.getStatus( FX_idx[k] ) == ST_INACTIVE )
-      qp->bounds.moveFreeToFixed( FX_idx[k], saveBounds.getStatus( FX_idx[k] ) );
-
-  qp->status = saveStatus;
-  return ret;
-}
-
-
-//int_t SolutionAnalysis::checkCurvatureOnStronglyActiveConstraints( SQProblemSchur* qp )
-//{
-  //real_t eps = 1.0e-16;
-  //real_t oldDet, newDet;
-  //int_t oldNS;
-  //returnValue ret;
-  //Bounds saveBounds;
-  //QProblemStatus saveStatus;
-  //int_t nFX, *FX_idx;
-  //int_t k, fail, neig, rmCnt, nAC;
-
-  //// Get active bounds (deep copy)
-  //nFX = qp->getNFX( );
-  //nAC = qp->getNAC( );
-  //qp->getBounds( saveBounds );
-  //saveBounds.getFixed( )->getNumberArray( &FX_idx );
-
-  //// If no bounds are active reduced Hessian is positive definite (otherwise qpOASES wouldnt have finished)
-  //if( nFX == 0 )
-    //return 0;
-
-  //// We have to modify the status to call removeBound()
-  //saveStatus = qp->getStatus();
-  //qp->status = QPS_PERFORMINGHOMOTOPY;
-
-  //// If a variable is active but was not active in the previous major iteration
-  //// remove it to see if a negative eigenvalue appears
-  //rmCnt = 0;
-  //fail = 0;
-  //for( k=0; k<nFX; k++ )
-    //if( getAbs(qp->x[FX_idx[k]]) > eps )
-    //{
-      //oldDet = qp->detS;
-      //oldNS = qp->nS;
-
-      //ret = qp->removeBound( FX_idx[k], BT_TRUE, BT_FALSE, BT_FALSE );
-      //if( ret != SUCCESSFUL_RETURN )
-      //{
-	//fail = 1;
-	//break;
-      //}
-
-      //newDet = qp->detS;
-      //rmCnt++;
-
-      //// Case 1: S has grown by 1 row and column
-      //if( qp->nS == oldNS + 1 )
-      //{
-	//// If the determinant does not change sign, then S has gained a positive eigenvalue.
-	//// That means there is a negative eigenvalue in the (extended) reduced Hessian!
-	//if ( ( oldDet <= 0.0 && newDet <= 0.0 ) || ( oldDet >= 0.0 && newDet >= 0.0 ) )
-	//{
-	  //fail = 1;
-	  //break;
-	//}
-      //}
-      //// Case 2: S has shrunk by 1 row and column
-      //else if( qp->nS == oldNS - 1 )
-      //{
-	//// If the determinant changes sign, then S has lost a negative eigenvalue.
-	//// That means there is a negative eigenvalue in the (extended) reduced Hessian!
-	//if ( ( oldDet <= 0.0 && newDet > 0.0 ) || ( oldDet >= 0.0 && newDet < 0.0 ) )
-	//{
-	  //fail = 1;
-	  //break;
-	//}
-      //}
-      //// Case 3: S was reset
-      //else if( qp->nS == 0 )
-      //{
-	//// Check inertia of KKT matrix
-	//neig = qp->sparseSolver->getNegativeEigenvalues( );
-	//if( neig > nAC )
-	//{
-	  //fail = 1;
-	  //break;
-	//}
-      //}
-      //else
-	//printf("ERROR!\n");
-    //}
-
-  //// If test is successful, add all bounds that have been removed
-  //// If not, don't bother with that because we will discard this QP object anyway
-  //if( fail == 0 )
-    //for( k=0; k<nFX; k++ )
-    //{
-      //ret = qp->addBound( FX_idx[k], saveBounds.getStatus( FX_idx[k] ), BT_TRUE, BT_FALSE );
-      //if( ret != SUCCESSFUL_RETURN && ret != RET_BOUND_ALREADY_ACTIVE )
-	//printf( "addBound() in checkCurvatureOnStronglyActiveConstraints(): %s\n", getGlobalMessageHandler()->getErrorCodeMessage( ret ) );
-    //}
-
-  //qp->status = saveStatus;
-  //return fail;
-//}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/SparseSolver.cpp b/extlibs/qpOASES-3.2.0/src/SparseSolver.cpp
deleted file mode 100644
index defba5e..0000000
--- a/extlibs/qpOASES-3.2.0/src/SparseSolver.cpp
+++ /dev/null
@@ -1,1103 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *
- *	Copyright (C) 2012 by Andreas Waechter. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/SparseSolver.cpp
- *	\author Andreas Waechter, Dennis Janka
- *	\version 3.2
- *	\date 2012-2015
- *
- *	Interfaces to sparse linear solvers that are used in a Schur-complement
- *	implementation in qpOASES.
- */
-
-
-#include <qpOASES/SparseSolver.hpp>
-
-#ifndef __MATLAB__
-# include <cstdarg>
-void MyPrintf(const char* pformat, ... );
-#else
-# include <mex.h>
-# define MyPrintf mexPrintf
-#endif
-
-//#define __DEBUG_ITER__
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- ****************************************************************************/
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-SparseSolver::SparseSolver( )
-{
-}
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-SparseSolver::SparseSolver( const SparseSolver& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ S p a r s e S o l v e r B a s e
- */
-SparseSolver::~SparseSolver( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-SparseSolver& SparseSolver::operator=( const SparseSolver& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-/*
- *	r e s e t
- */
-returnValue SparseSolver::reset( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	g e t N e g a t i v e E i g e n v a l u e s
- */
-int_t SparseSolver::getNegativeEigenvalues( )
-{
-	return -1;
-}
-
-/*
- *	g e t R a n k
- */
-int_t SparseSolver::getRank( )
-{
-	return -1;
-}
-
-/*
- *	g e t Z e r o P i v o t s
- */
-returnValue SparseSolver::getZeroPivots( int_t *&zeroPivots )
-{
-	if ( zeroPivots ) delete[] zeroPivots;
-	zeroPivots = 0;
-	return SUCCESSFUL_RETURN;
-}
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue SparseSolver::clear( )
-{
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue SparseSolver::copy( 	const SparseSolver& rhs
-									)
-{
-	return SUCCESSFUL_RETURN;
-}
-
-#ifdef SOLVER_MA27
-
-/*****************************************************************************
- *****************************************************************************
- *****************************************************************************
- *  M A 2 7 S P A R E S E S O L V E R                                        *
- *****************************************************************************
- *****************************************************************************
- *****************************************************************************/
-
-#define MA27ID ma27id_
-#define MA27AD ma27ad_
-#define MA27BD ma27bd_
-#define MA27CD ma27cd_
-
-extern "C" {
-  void MA27ID(fint* ICNTL, double* CNTL);
-  void MA27AD(fint *N, fint *NZ, const fint *IRN, const fint* ICN,
-                               fint *IW, fint* LIW, fint* IKEEP, fint *IW1,
-                               fint* NSTEPS, fint* IFLAG, fint* ICNTL,
-                               double* CNTL, fint *INFO, double* OPS);
-  void MA27BD(fint *N, fint *NZ, const fint *IRN, const fint* ICN,
-                               double* A, fint* LA, fint* IW, fint* LIW,
-                               fint* IKEEP, fint* NSTEPS, fint* MAXFRT,
-                               fint* IW1, fint* ICNTL, double* CNTL,
-                               fint* INFO);
-  void MA27CD(fint *N, double* A, fint* LA, fint* IW,
-                               fint* LIW, double* W, fint* MAXFRT,
-                               double* RHS, fint* IW1, fint* NSTEPS,
-                               fint* ICNTL, double* CNTL);
-}
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- ****************************************************************************/
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-Ma27SparseSolver::Ma27SparseSolver( ) : SparseSolver()
-{
-	a_ma27 = 0;
-	irn_ma27 = 0;
-	jcn_ma27 = 0;
-	iw_ma27 = 0;
-	ikeep_ma27 = 0;
-	clear( );
-
-	/* Set default options for MA27 */
-	MA27ID(icntl_ma27, cntl_ma27);
-	icntl_ma27[0] = 0;       // Suppress error messages
-	icntl_ma27[1] = 0;       // Suppress diagnostic messages
-	cntl_ma27[0] = 1e-8;     // Set pivot tolerance
-}
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-Ma27SparseSolver::Ma27SparseSolver( const Ma27SparseSolver& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ S p a r s e S o l v e r B a s e
- */
-Ma27SparseSolver::~Ma27SparseSolver( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Ma27SparseSolver& Ma27SparseSolver::operator=( const SparseSolver& rhs )
-{
-	const Ma27SparseSolver* ma27_rhs = dynamic_cast<const Ma27SparseSolver*>(&rhs);
-	if (!ma27_rhs)
-	{
-		fprintf(getGlobalMessageHandler()->getOutputFile(),"Error in Ma27SparseSolver& Ma27SparseSolver::operator=( const SparseSolver& rhs )\n");
-		throw; // TODO: More elegant exit?
-	}
-	if ( this != ma27_rhs )
-	{
-		clear( );
-		SparseSolver::operator=( rhs );
-		copy( *ma27_rhs );
-	}
-
-	return *this;
-}
-
-/*
- *	s e t M a t r i x D a t a
- */
-returnValue Ma27SparseSolver::setMatrixData( int_t dim_,
-						   int_t numNonzeros_,
-						   const int_t* const irn,
-						   const int_t* const jcn,
-						   const real_t* const avals
-						   )
-{
-	reset( );
-	dim = dim_;
-	numNonzeros = numNonzeros_;
-
-	if ( numNonzeros_ > 0 )
-	{
-		a_ma27 = new double[numNonzeros_];
-		irn_ma27 = new fint[numNonzeros_];
-		jcn_ma27 = new fint[numNonzeros_];
-
-		numNonzeros=0;
-		for (int_t i=0; i<numNonzeros_; ++i)
-			if ( avals[i] != 0 )
-			{
-				a_ma27[numNonzeros] = avals[i];
-				irn_ma27[numNonzeros] = irn[i];
-				jcn_ma27[numNonzeros] = jcn[i];
-				numNonzeros++;
-			}
-	}
-	else
-	{
-		numNonzeros = 0;
-		a_ma27 = 0;
-		irn_ma27 = 0;
-		jcn_ma27 = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	f a c t o r i z e
- */
-returnValue Ma27SparseSolver::factorize( )
-{
-	if ( dim == 0 )
-	{
-		have_factorization = true;
-		neig = 0;
-		rank = 0;
-		return SUCCESSFUL_RETURN;
-	}
-
-	/******************************************
-	 * Call MA27AD for symbolic factorization *
-	******************************************/
-
-	// Overstimation factor for LIW (20% recommended in MA27 documentation)
-	const double LiwFact = 2.0;   // This is 200% overestimation
-	liw_ma27 = (fint)(LiwFact*(double(2*numNonzeros+3*dim+1)));
-	iw_ma27 = new fint[liw_ma27];
-
-	ikeep_ma27 = new fint[3*dim];
-
-	fint iflag_ma27 = 0;
-	double ops_ma27;
-	fint info_ma27[20];
-	fint* iw1_ma27 = new fint[2*dim];
-	MA27AD(&dim, &numNonzeros, irn_ma27, jcn_ma27, iw_ma27, &liw_ma27, ikeep_ma27,
-                            iw1_ma27, &nsteps_ma27, &iflag_ma27, icntl_ma27, cntl_ma27,
-                            info_ma27, &ops_ma27);
-
-	/* Receive some information from MA27AD */
-	fint iflag = info_ma27[0];   // Information flag
-	fint ierror = info_ma27[1];  // Error flag
-	fint nrlnec = info_ma27[4];  // recommended value for la
-	fint nirnec = info_ma27[5];  // recommended value for liw
-	if (iflag != 0)
-	{
-		MyPrintf("MA27AD returns iflag = %d with ierror = %d\n", iflag, ierror);
-		delete [] iw1_ma27;
-		clear( );
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-	}
-
-	/* Allocate memory for actual factorization */
-	delete [] iw_ma27;
-	double liw_init_factor = 5.0; // This could be an option.
-	liw_ma27 = (fint)(liw_init_factor * (double)(nirnec));
-	iw_ma27 = new fint[liw_ma27];
-
-	double la_init_factor = 20.0; // This could be an option.
-	la_ma27 = getMax(numNonzeros,(fint)(la_init_factor * (double)(nrlnec)));
-	double* a_new = new double[la_ma27];
-	for (int_t i=0; i<numNonzeros; ++i)
-		a_new[i] = a_ma27[i];
-	delete [] a_ma27;
-	a_ma27 = a_new;
-
-    /*******************************************
-	 * Call MA27BD for numerical factorization *
-     *******************************************/
-
-	MA27BD(&dim, &numNonzeros, irn_ma27, jcn_ma27, a_ma27,
-		   &la_ma27, iw_ma27, &liw_ma27, ikeep_ma27, &nsteps_ma27,
-		   &maxfrt_ma27, iw1_ma27, icntl_ma27, cntl_ma27, info_ma27);
-
-	delete [] iw1_ma27;
-	/* Receive some information from MA27BD */
-	iflag = info_ma27[0];   // Information flag
-	ierror = info_ma27[1];  // Error flag
-	neig = info_ma27[14];   // Number of negative eigenvalues
-	if (iflag == 3)
-	{
-		rank = info_ma27[1];
-		return RET_KKT_MATRIX_SINGULAR;
-	}
-	else if (iflag == -5)
-	{ //DJ: I think this is more severe. Can this actually happen?
-		rank = -1;
-		return RET_KKT_MATRIX_SINGULAR;
-	}
-	else if (iflag != 0)
-	{
-		MyPrintf("MA27BD returns iflag = %d with ierror = %d\n", iflag, ierror);
-		clear( );
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-	}
-	else
-		rank = dim;
-
-	have_factorization = true;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s o l v e
- */
-returnValue Ma27SparseSolver::solve( int_t dim_,
-					   const real_t* const rhs,
-					   real_t* const sol
-					   )
-{
-	/* consistency check */
-	if ( dim_ != dim )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( !have_factorization )
-	{
-	  MyPrintf("Factorization not called before solve in Ma27SparseSolver::solve.\n");
-	  return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( dim == 0 )
-		return SUCCESSFUL_RETURN;
-
-	/* Call MA27CD to solve the system */
-	double* w_ma27 = new double[maxfrt_ma27];
-	fint* iw1_ma27 = new fint[nsteps_ma27];
-
-	/* MA27CD overwrites rhs */
-	for (int_t i=0; i<dim; ++i) sol[i] = rhs[i];
-	MA27CD(&dim, a_ma27, &la_ma27, iw_ma27, &liw_ma27, w_ma27, &maxfrt_ma27,
-		   sol, iw1_ma27, &nsteps_ma27, icntl_ma27, cntl_ma27);
-
-	delete [] iw1_ma27;
-	delete [] w_ma27;
-
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	r e s e t
- */
-returnValue Ma27SparseSolver::reset( )
-{
-	/* AW: We probably want to avoid resetting factorization in QProblem */
-	if ( SparseSolver::reset( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_RESET_FAILED );
-
-	clear( );
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	g e t N e g a t i v e E i g e n v a l u e s
- */
-int_t Ma27SparseSolver::getNegativeEigenvalues( )
-{
-	if( !have_factorization )
-		return -1;
-	else
-		return neig;
-}
-
-/*
- *	g e t R a n k
- */
-int_t Ma27SparseSolver::getRank( )
-{
-	return rank;
-}
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Ma27SparseSolver::clear( )
-{
-	delete [] a_ma27;
-	delete [] irn_ma27;
-	delete [] jcn_ma27;
-	delete [] iw_ma27;
-	delete [] ikeep_ma27;
-
-	dim = -1;
-	numNonzeros = -1;
-	neig = -1;
-	rank = -1;
-	la_ma27 = -1;
-	a_ma27 = 0;
-	irn_ma27 = 0;
-	jcn_ma27 = 0;
-
-	liw_ma27 = -1;
-	iw_ma27 = 0;
-	ikeep_ma27 = 0;
-	nsteps_ma27 = -1;
-	maxfrt_ma27 = -1;
-
-	have_factorization = false;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Ma27SparseSolver::copy( 	const Ma27SparseSolver& rhs
-										)
-{
-	dim = rhs.dim;
-	numNonzeros = rhs.numNonzeros;
-	la_ma27 = rhs.la_ma27;
-	if ( rhs.a_ma27 != 0 )
-	{
-	  if (rhs.have_factorization)
-		{
-		  a_ma27 = new double[la_ma27];
-		  memcpy( a_ma27,rhs.a_ma27,la_ma27*sizeof(double) );
-		}
-	  else
-		{
-		  a_ma27 = new double[numNonzeros];
-		  memcpy( a_ma27,rhs.a_ma27,numNonzeros*sizeof(double) );
-		}
-	}
-	else
-		a_ma27 = 0;
-
-	if ( rhs.irn_ma27 != 0 )
-	{
-		irn_ma27 = new fint[numNonzeros];
-		memcpy( irn_ma27,rhs.irn_ma27,numNonzeros*sizeof(fint) );
-	}
-	else
-		irn_ma27 = 0;
-
-	if ( rhs.jcn_ma27 != 0 )
-	{
-		jcn_ma27 = new fint[numNonzeros];
-		memcpy( jcn_ma27,rhs.jcn_ma27,numNonzeros*sizeof(fint) );
-	}
-	else
-		jcn_ma27 = 0;
-
-	for ( int_t i=0; i<30; ++i)
-		icntl_ma27[i] = rhs.icntl_ma27[i];
-
-	for ( int_t i=0; i<5; ++i)
-		cntl_ma27[i] = rhs.cntl_ma27[i];
-
-	liw_ma27 = rhs.liw_ma27;
-
-	if ( rhs.iw_ma27 != 0 )
-	{
-		iw_ma27 = new fint[liw_ma27];
-		memcpy( iw_ma27,rhs.iw_ma27,liw_ma27*sizeof(fint) );
-	}
-	else
-		iw_ma27 = 0;
-
-	if ( rhs.ikeep_ma27 != 0 )
-	{
-		ikeep_ma27 = new fint[3*dim];
-		memcpy( ikeep_ma27,rhs.ikeep_ma27,3*dim*sizeof(fint) );
-	}
-	else
-		ikeep_ma27 = 0;
-
-	nsteps_ma27 = rhs.nsteps_ma27;
-	maxfrt_ma27 = rhs.maxfrt_ma27;
-
-	have_factorization = rhs.have_factorization;
-	neig = rhs.neig;
-	rank = rhs.rank;
-
-	return SUCCESSFUL_RETURN;
-}
-
-#endif // SOLVER_MA27
-
-#ifdef SOLVER_MA57
-
-/*****************************************************************************
- *****************************************************************************
- *****************************************************************************
- *  M A 5 7 S P A R E S E S O L V E R                                        *
- *****************************************************************************
- *****************************************************************************
- *****************************************************************************/
-
-#define MA57ID ma57id_
-#define MA57AD ma57ad_
-#define MA57BD ma57bd_
-#define MA57CD ma57cd_
-
-extern "C"
-{
-	/*
-	*  MA57ID -- Initialize solver.
-	*/
-	extern void  MA57ID (
-		double	*cntl,
-		fint		*icntl);
-
-	/*
-	*  MA57AD -- Symbolic Factorization.
-	*/
-	extern void  MA57AD (
-		fint		*n,		/* Order of matrix. */
-		fint		*ne,	/* Number of entries. */
-		const fint	*irn,	/* Matrix nonzero row structure */
-		const fint	*jcn,	/* Matrix nonzero column structure */
-		fint		*lkeep,	/* Workspace for the pivot order of lenght 3*n */
-		fint		*keep,	/* Workspace for the pivot order of lenght 3*n */
-							/* Automatically iflag = 0; ikeep pivot order iflag = 1 */
-		fint		*iwork,	/* Integer work space. */
-		fint		*icntl,	/* Integer Control parameter of length 30*/
-		fint		*info,	/* Statistical Information; Integer array of length 20 */
-		double		*rinfo);/* Double Control parameter of length 5 */
-
-	/*
-	* MA57BD -- Numerical Factorization.
-	*/
-	extern void  MA57BD (
-		fint	*n,			/* Order of matrix. */
-		fint	*ne,		/* Number of entries. */
-		double	*a,			/* Numerical values. */
-		double	*fact,		/* Entries of factors. */
-		fint	*lfact,		/* Length of array `fact'. */
-		fint	*ifact,		/* Indexing info for factors. */
-		fint	*lifact,	/* Length of array `ifact'. */
-		fint	*lkeep,		/* Length of array `keep'. */
-		fint	*keep,		/* Integer array. */
-		fint	*iwork,		/* Workspace of length `n'. */
-		fint	*icntl,		/* Integer Control parameter of length 20. */
-		double	*cntl,		/* Double Control parameter of length 5. */
-		fint	*info,		/* Statistical Information; Integer array of length 40. */
-		double	*rinfo);	/* Statistical Information; Real array of length 20. */
-
-	/*
-	* MA57CD -- Solution.
-	*/
-	extern void  MA57CD (
-		fint	*job,		/* Solution job.  Solve for... */
-							/* JOB <= 1:  A */
-							/* JOB == 2:  PLP^t */
-							/* JOB == 3:  PDP^t */
-							/* JOB >= 4:  PL^t P^t */
-		fint	*n,			/* Order of matrix. */
-		double	*fact,		/* Entries of factors. */
-		fint	*lfact,		/* Length of array `fact'. */
-		fint	*ifact,		/* Indexing info for factors. */
-		fint	*lifact,	/* Length of array `ifact'. */
-		fint	*nrhs,		/* Number of right hand sides. */
-		double	*rhs,		/* Numerical Values. */
-		fint	*lrhs,		/* Leading dimensions of `rhs'. */
-		double	*work,		/* Real workspace. */
-		fint	*lwork,		/* Length of `work', >= N*NRHS. */
-		fint	*iwork,		/* Integer array of length `n'. */
-		fint	*icntl,		/* Integer Control parameter array of length 20. */
-		fint	*info);		/* Statistical Information; Integer array of length 40. */
-}
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- ****************************************************************************/
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-Ma57SparseSolver::Ma57SparseSolver( ) : SparseSolver()
-{
-	a_ma57 = 0;
-	irn_ma57 = 0;
-	jcn_ma57 = 0;
-	fact_ma57 = 0;
-	ifact_ma57 = 0;
-	pivots = 0;
-	clear( );
-
-	/* Set default options for MA57 */
-	MA57ID( cntl_ma57, icntl_ma57 );
-
-	icntl_ma57[0] = -1;			// Suppress error messages
-	icntl_ma57[1] = -1;			// Suppress warning messages
-	icntl_ma57[2] = -1;			// Suppress monitoring messages
-	//icntl_ma57[4] = 4;		// Print everything (for debugging)
-	icntl_ma57[15] = 1;			// Place small pivots at the end of the factorization (default: 0)
-
-	/// \todo good default values?
-	//cntl_ma57[1] = 5.0e-16;	// Pivots smaller than this are treated as zero and are placed at the end of the factorization (default: 1e-20)
-	//cntl_ma57[0] = 0.5;		// Set pivot tolerance: Higher values = more stable but slower/less sparse (default: 0.01, max 0.5)
-}
-
-
-/*
- *	S p a r s e S o l v e r B a s e
- */
-Ma57SparseSolver::Ma57SparseSolver( const Ma57SparseSolver& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ S p a r s e S o l v e r B a s e
- */
-Ma57SparseSolver::~Ma57SparseSolver( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-Ma57SparseSolver& Ma57SparseSolver::operator=( const SparseSolver& rhs )
-{
-	const Ma57SparseSolver* ma57_rhs = dynamic_cast<const Ma57SparseSolver*>(&rhs);
-	if (!ma57_rhs)
-	{
-		fprintf(getGlobalMessageHandler()->getOutputFile(),"Error in Ma57SparseSolver& Ma57SparseSolver::operator=( const SparseSolver& rhs )\n");
-		throw; // TODO: More elegant exit?
-	}
-	if ( this != ma57_rhs )
-	{
-		clear( );
-		SparseSolver::operator=( rhs );
-		copy( *ma57_rhs );
-	}
-
-	return *this;
-}
-
-/*
- *	s e t M a t r i x D a t a
- */
-returnValue Ma57SparseSolver::setMatrixData(	int_t dim_,
-												int_t numNonzeros_,
-												const int_t* const irn,
-												const int_t* const jcn,
-												const real_t* const avals
-												)
-{
-	reset( );
-	dim = dim_;
-	numNonzeros = numNonzeros_;
-
-	if ( numNonzeros_ > 0 )
-	{
-		a_ma57 = new double[numNonzeros_];
-		irn_ma57 = new fint[numNonzeros_];
-		jcn_ma57 = new fint[numNonzeros_];
-
-		numNonzeros=0;
-		for (int_t i=0; i<numNonzeros_; ++i)
-			if ( isZero(avals[i]) == BT_FALSE )
-			{
-				a_ma57[numNonzeros] = avals[i];
-				irn_ma57[numNonzeros] = irn[i];
-				jcn_ma57[numNonzeros] = jcn[i];
-				numNonzeros++;
-			}
-	}
-	else
-	{
-		numNonzeros = 0;
-		a_ma57 = 0;
-		irn_ma57 = 0;
-		jcn_ma57 = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	f a c t o r i z e
- */
-returnValue Ma57SparseSolver::factorize( )
-{
-	if ( dim == 0 )
-	{
-		have_factorization = true;
-		neig = 0;
-		rank = 0;
-		return SUCCESSFUL_RETURN;
-	}
-
-	/******************************************
-	 * Call MA57AD for symbolic factorization *
-	******************************************/
-
-	fint lkeep_ma57 = 5*dim + numNonzeros + getMax(numNonzeros,dim) + 42;
-	fint *keep_ma57 = new fint[lkeep_ma57];
-	fint *iwork_ma57 = new fint[5*dim];
-
-	fint info_ma57[40];
-	double rinfo_ma57[20];
-
-	MA57AD(&dim, &numNonzeros, irn_ma57, jcn_ma57, &lkeep_ma57, keep_ma57,
-			iwork_ma57, icntl_ma57, info_ma57, rinfo_ma57);
-
-	/* Receive some information from MA57AD */
-	fint iflag = info_ma57[0];   // Information flag
-	fint ierror = info_ma57[1];  // Error flag
-	if (iflag != 0)
-	{
-		MyPrintf("MA57AD returns iflag = %d with ierror = %d\n", iflag, ierror);
-		delete [] keep_ma57;
-		delete [] iwork_ma57;
-		clear( );
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-	}
-
-	/* Allocate memory for actual factorization */
-	double lfact_factor = 10.0; // This could be an option
-
-	lfact_ma57 = (fint)(lfact_factor * (double)(info_ma57[8]));
-	fact_ma57 = new double[lfact_ma57];
-
-	lifact_ma57 = (fint)(lfact_factor * (double)(info_ma57[9]));
-	ifact_ma57 = new int_t[lifact_ma57];
-
-    /*******************************************
-	 * Call MA57BD for numerical factorization *
-     *******************************************/
-
-	MA57BD(	&dim, &numNonzeros, a_ma57, fact_ma57, &lfact_ma57,
-			ifact_ma57, &lifact_ma57, &lkeep_ma57, keep_ma57,
-			iwork_ma57, icntl_ma57, cntl_ma57, info_ma57, rinfo_ma57 );
-
-	delete [] iwork_ma57;
-	delete [] keep_ma57;
-
-	/* Receive some information from MA57BD */
-	iflag = info_ma57[0];   // Information flag
-	ierror = info_ma57[1];  // Error flag
-	neig = info_ma57[23];   // Number of negative eigenvalues
-	rank = info_ma57[24];   // Rank of matrix
-
-	/* Read pivot sequence (see MA57UD source code) */
-	pivots = new fint[dim];
-	fint nrows, ncols;
-	fint nblk = ifact_ma57[2];
-	int_t iwpos = 3; // = 4-1
-    int_t k, kk, count = 0;
-    for ( k=0; k<nblk; k++ )
-    {
-        ncols = ifact_ma57[iwpos];
-        nrows = ifact_ma57[iwpos+1];
-
-        for ( kk=0; kk<nrows; kk++ )
-            pivots[count++] = ifact_ma57[iwpos+2+kk]-1; //convert Fortran to C indices!
-
-        iwpos = iwpos+ncols+2;
-    }
-
-	if (iflag == 4)
-	{
-		//MyPrintf("dim = %i, rank = %i. Pivots: ", dim, rank);
-		//for( k=rank; k<dim; k++ )
-			//MyPrintf("%i ", pivots[k]);
-		//MyPrintf("\n");
-
-		return RET_KKT_MATRIX_SINGULAR;
-	}
-	else if (iflag != 0)
-	{
-		MyPrintf("MA57BD returns iflag = %d with ierror = %d\n", iflag, ierror);
-		clear( );
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-	}
-
-	have_factorization = true;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s o l v e
- */
-returnValue Ma57SparseSolver::solve(	int_t dim_,
-										const real_t* const rhs,
-										real_t* const sol
-										)
-{
-	/* consistency check */
-	if ( dim_ != dim )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	if ( !have_factorization )
-	{
-	  MyPrintf("Factorization not called before solve in Ma57SparseSolver::solve.\n");
-	  return THROWERROR( RET_INVALID_ARGUMENTS );
-	}
-
-	if ( dim == 0 )
-		return SUCCESSFUL_RETURN;
-
-	/* Call MA57CD to solve the system */
-	fint job_ma57 = 1;
-	fint nrhs_ma57 = 1;
-	fint lrhs_ma57 = dim;
-	fint info_ma57[40];
-
-	fint lwork_ma57 = dim*nrhs_ma57;
-	double* work_ma57 = new double[lwork_ma57];
-	fint* iwork_ma57 = new fint[dim];
-
-	/* MA57CD overwrites rhs */
-	for (int_t i=0; i<dim; ++i) sol[i] = rhs[i];
-	MA57CD(&job_ma57, &dim, fact_ma57, &lfact_ma57, ifact_ma57, &lifact_ma57,
-			&nrhs_ma57, sol, &lrhs_ma57, work_ma57, &lwork_ma57, iwork_ma57,
-			icntl_ma57, info_ma57);
-
-	delete [] work_ma57;
-	delete [] iwork_ma57;
-
-	fint iflag = info_ma57[0];   // Information flag
-	fint ierror = info_ma57[1];  // Error flag
-	if (iflag != 0)
-	{
-		MyPrintf("MA57CD returns iflag = %d with ierror = %d\n", iflag, ierror);
-		clear( );
-		return THROWERROR(RET_MATRIX_FACTORISATION_FAILED);
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	r e s e t
- */
-returnValue Ma57SparseSolver::reset( )
-{
-	/* AW: We probably want to avoid resetting factorization in QProblem */
-	if ( SparseSolver::reset( ) != SUCCESSFUL_RETURN )
-		return THROWERROR( RET_RESET_FAILED );
-
-	clear( );
-	return SUCCESSFUL_RETURN;
-}
-
-/*
- *	g e t N e g a t i v e E i g e n v a l u e s
- */
-int_t Ma57SparseSolver::getNegativeEigenvalues( )
-{
-	if( !have_factorization )
-		return -1;
-	else
-		return neig;
-}
-
-/*
- *	g e t R a n k
- */
-int_t Ma57SparseSolver::getRank( )
-{
-	return rank;
-}
-
-/*
- *	g e t Z e r o P i v o t s
- */
-returnValue Ma57SparseSolver::getZeroPivots( int_t *&zeroPivots )
-{
-	for ( int_t k=0; k<dim-rank; k++ )
-		zeroPivots[k] = pivots[rank+k];
-
-	return SUCCESSFUL_RETURN;
-}
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue Ma57SparseSolver::clear( )
-{
-	delete [] a_ma57;
-	delete [] irn_ma57;
-	delete [] jcn_ma57;
-	delete [] fact_ma57;
-	delete [] ifact_ma57;
-	delete [] pivots;
-
-	dim = -1;
-	numNonzeros = -1;
-	neig = -1;
-	rank = -1;
-	pivots = 0;
-
-	a_ma57 = 0;
-	irn_ma57 = 0;
-	jcn_ma57 = 0;
-
-	fact_ma57 = 0;
-	lfact_ma57 = -1;
-	ifact_ma57 = 0;
-	lifact_ma57 = -1;
-
-	have_factorization = false;
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue Ma57SparseSolver::copy( 	const Ma57SparseSolver& rhs
-										)
-{
-	dim = rhs.dim;
-	numNonzeros = rhs.numNonzeros;
-	neig = rhs.neig;
-	rank = rhs.rank;
-	have_factorization = rhs.have_factorization;
-
-	if ( rhs.a_ma57 != 0 )
-	{
-		a_ma57 = new double[numNonzeros];
-		memcpy( a_ma57,rhs.a_ma57,numNonzeros*sizeof(double) );
-	}
-	else
-		a_ma57 = 0;
-
-	if ( rhs.irn_ma57 != 0 )
-	{
-		irn_ma57 = new fint[numNonzeros];
-		memcpy( irn_ma57,rhs.irn_ma57,numNonzeros*sizeof(fint) );
-	}
-	else
-		irn_ma57 = 0;
-
-	if ( rhs.jcn_ma57 != 0 )
-	{
-		jcn_ma57 = new fint[numNonzeros];
-		memcpy( jcn_ma57,rhs.jcn_ma57,numNonzeros*sizeof(fint) );
-	}
-	else
-		jcn_ma57 = 0;
-
-	for ( int_t i=0; i<30; ++i)
-		icntl_ma57[i] = rhs.icntl_ma57[i];
-
-	for ( int_t i=0; i<5; ++i)
-		cntl_ma57[i] = rhs.cntl_ma57[i];
-
-	lfact_ma57 = rhs.lfact_ma57;
-	if ( rhs.fact_ma57 != 0 )
-	{
-		fact_ma57 = new double[lfact_ma57];
-		memcpy( fact_ma57,rhs.fact_ma57,lfact_ma57*sizeof(double) );
-	}
-	else
-		fact_ma57 = 0;
-
-	lifact_ma57 = rhs.lifact_ma57;
-	if ( rhs.ifact_ma57 != 0 )
-	{
-		ifact_ma57 = new fint[lifact_ma57];
-		memcpy( ifact_ma57,rhs.ifact_ma57,lifact_ma57*sizeof(fint) );
-	}
-	else
-		ifact_ma57 = 0;
-
-	if ( have_factorization )
-	{
-		pivots = new fint[dim];
-		memcpy( pivots, rhs.pivots, dim*sizeof(fint) );
-	}
-	else
-		pivots = 0;
-
-	return SUCCESSFUL_RETURN;
-}
-
-#endif // SOLVER_MA57
-
-
-#ifdef SOLVER_NONE
-
-returnValue DummySparseSolver::setMatrixData( 	int_t dim, /**< Dimension of the linear system. */
-												int_t numNonzeros, /**< Number of nonzeros in the matrix. */
-												const int_t* const airn, /**< Row indices for each matrix entry. */
-												const int_t* const acjn, /**< Column indices for each matrix entry. */
-												const real_t* const avals /**< Values for each matrix entry. */
-												)
-{
-	return THROWERROR(RET_NO_SPARSE_SOLVER);
-}
-
-returnValue DummySparseSolver::factorize( )
-{
-	return THROWERROR(RET_NO_SPARSE_SOLVER);
-}
-
-returnValue DummySparseSolver::solve(	int_t dim, /**< Dimension of the linear system. */
-										const real_t* const rhs, /**< Values for the right hand side. */
-										real_t* const sol /**< Solution of the linear system. */
-										)
-{
-	return THROWERROR(RET_NO_SPARSE_SOLVER);
-}
-
-#endif // SOLVER_NONE
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/SubjectTo.cpp b/extlibs/qpOASES-3.2.0/src/SubjectTo.cpp
deleted file mode 100644
index b41475f..0000000
--- a/extlibs/qpOASES-3.2.0/src/SubjectTo.cpp
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/SubjectTo.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of the SubjectTo class designed to manage working sets of
- *	constraints and bounds within a QProblem.
- */
-
-
-#include <qpOASES/SubjectTo.hpp>
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*****************************************************************************
- *  P U B L I C                                                              *
- *****************************************************************************/
-
-
-/*
- *	S u b j e c t T o
- */
-SubjectTo::SubjectTo( )
-{
-	type   = 0;
-	status = 0;
-
-	init( );
-}
-
-
-/*
- *	S u b j e c t T o
- */
-SubjectTo::SubjectTo( int_t _n )
-{
-	type   = 0;
-	status = 0;
-
-	init( _n );
-}
-
-
-/*
- *	S u b j e c t T o
- */
-SubjectTo::SubjectTo( const SubjectTo& rhs )
-{
-	copy( rhs );
-}
-
-
-/*
- *	~ S u b j e c t T o
- */
-SubjectTo::~SubjectTo( )
-{
-	clear( );
-}
-
-
-/*
- *	o p e r a t o r =
- */
-SubjectTo& SubjectTo::operator=( const SubjectTo& rhs )
-{
-	if ( this != &rhs )
-	{
-		clear( );
-		copy( rhs );
-	}
-
-	return *this;
-}
-
-
-/*
- *	i n i t
- */
-returnValue SubjectTo::init(	int_t _n
-								)
-{
-	int_t i;
-
-	if ( _n < 0 )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	clear( );
-
-	n = _n;
-	noLower = BT_TRUE;
-	noUpper = BT_TRUE;
-
-	if ( n > 0 )
-	{
-		type   = new SubjectToType[n];
-		status = new SubjectToStatus[n];
-
-		for( i=0; i<n; ++i )
-		{
-			type[i]   = ST_UNKNOWN;
-			status[i] = ST_UNDEFINED;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-
-/*****************************************************************************
- *  P R O T E C T E D                                                        *
- *****************************************************************************/
-
-/*
- *	c l e a r
- */
-returnValue SubjectTo::clear( )
-{
-	if ( type != 0 )
-	{
-		delete[] type;
-		type = 0;
-	}
-
-	if ( status != 0 )
-	{
-		delete[] status;
-		status = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o p y
- */
-returnValue SubjectTo::copy(	const SubjectTo& rhs
-								)
-{
-	int_t i;
-
-	n = rhs.n;
-	noLower = rhs.noLower;
-	noUpper = rhs.noUpper;
-
-	if ( rhs.n != 0 )
-	{
-		type   = new SubjectToType[n];
-		status = new SubjectToStatus[n];
-
-		for( i=0; i<n; ++i )
-		{
-			type[i]   = rhs.type[i];
-			status[i] = rhs.status[i];
-		}
-	}
-	else
-	{
-		type   = 0;
-		status = 0;
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	a d d I n d e x
- */
-returnValue SubjectTo::addIndex(	Indexlist* const indexlist,
-									int_t newnumber, SubjectToStatus newstatus
-									)
-{
-	if ( status != 0 )
-	{
-		/* consistency check */
-		if ( status[newnumber] == newstatus )
-			return THROWERROR( RET_INDEX_ALREADY_OF_DESIRED_STATUS );
-
-		status[newnumber] = newstatus;
-	}
-	else
-		return THROWERROR( RET_ADDINDEX_FAILED );
-
-	if ( indexlist != 0 )
-	{
-		if ( indexlist->addNumber( newnumber ) == RET_INDEXLIST_EXCEEDS_MAX_LENGTH )
-			return THROWERROR( RET_ADDINDEX_FAILED );
-	}
-	else
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e m o v e I n d e x
- */
-returnValue SubjectTo::removeIndex(	Indexlist* const indexlist,
-									int_t removenumber
-									)
-{
-	if ( status != 0 )
-		status[removenumber] = ST_UNDEFINED;
-	else
-		return THROWERROR( RET_REMOVEINDEX_FAILED );
-
-	if ( indexlist != 0 )
-	{
-		if ( indexlist->removeNumber( removenumber ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_REMOVEINDEX_FAILED );
-	}
-	else
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	s w a p I n d e x
- */
-returnValue SubjectTo::swapIndex(	Indexlist* const indexlist,
-									int_t number1, int_t number2
-									)
-{
-	/* consistency checks */
-	if ( status != 0 )
-	{
-		if ( status[number1] != status[number2] )
-			return THROWERROR( RET_SWAPINDEX_FAILED );
-	}
-	else
-		return THROWERROR( RET_SWAPINDEX_FAILED );
-
-	if ( number1 == number2 )
-	{
-		THROWWARNING( RET_NOTHING_TO_DO );
-		return SUCCESSFUL_RETURN;
-	}
-
-	if ( indexlist != 0 )
-	{
-		if ( indexlist->swapNumbers( number1,number2 ) != SUCCESSFUL_RETURN )
-			return THROWERROR( RET_SWAPINDEX_FAILED );
-	}
-	else
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/src/Utils.cpp b/extlibs/qpOASES-3.2.0/src/Utils.cpp
deleted file mode 100644
index 68fb0d9..0000000
--- a/extlibs/qpOASES-3.2.0/src/Utils.cpp
+++ /dev/null
@@ -1,1061 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file src/Utils.cpp
- *	\author Hans Joachim Ferreau, Andreas Potschka, Christian Kirches (thanks to Eckhard Arnold)
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Implementation of some utility functions for working with qpOASES.
- */
-
-
-#include <math.h>
-
-#if defined(__WIN32__) || defined(WIN32)
-  #include <windows.h>
-#elif defined(LINUX) || defined(__LINUX__)
-  #include <sys/stat.h>
-  #include <sys/time.h>
-#endif
-
-#ifdef __MATLAB__
-  #include "mex.h"
-#endif
-
-#ifdef __SCILAB__
-  #include <scilab/sciprint.h>
-#endif
-
-
-#include <qpOASES/Utils.hpp>
-
-
-#ifdef __NO_SNPRINTF__
-#if (!defined(_MSC_VER)) || defined(__DSPACE__) || defined(__XPCTARGET__)
-/* If snprintf is not available, provide an empty implementation. */
-int snprintf( char* s, size_t n, const char* format, ... )
-{
-	if ( n > 0 )
-		s[0] = '\0';
-
-	return 0;
-}
-#endif
-#endif /* __NO_SNPRINTF__ */
-
-
-BEGIN_NAMESPACE_QPOASES
-
-
-/*
- *	p r i n t
- */
-returnValue print( const real_t* const v, int_t n, const char* name )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Print vector name. */
-	if ( name != 0 )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH,"%s = \n", name );
-		myPrintf( myPrintfString );
-	}
-
-	/* Print vector data. */
-	for( i=0; i<n; ++i )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH," %.16e\t", v[i] );
-		myPrintf( myPrintfString );
-	}
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue print(	const real_t* const v, int_t n, const int_t* const V_idx, const char* name )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Print vector name. */
-	if ( name != 0 )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH,"%s = \n", name );
-		myPrintf( myPrintfString );
-	}
-
-	/* Print a permuted vector data. */
-	for( i=0; i<n; ++i )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH," %.16e\t", v[ V_idx[i] ] );
-		myPrintf( myPrintfString );
-	}
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue print( const real_t* const M, int_t nrow, int_t ncol, const char* name )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Print matrix name. */
-	if ( name != 0 )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH,"%s = \n", name );
-		myPrintf( myPrintfString );
-	}
-
-	/* Print a matrix data as a collection of row vectors. */
-	for( i=0; i<nrow; ++i )
-		print( &(M[i*ncol]), ncol );
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue print(	const real_t* const M, int_t nrow, int_t ncol, const int_t* const ROW_idx, const int_t* const COL_idx, const char* name )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Print matrix name. */
-	if ( name != 0 )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH,"%s = \n", name );
-		myPrintf( myPrintfString );
-	}
-
-	/* Print a permuted matrix data as a collection of permuted row vectors. */
-	for( i=0; i<nrow; ++i )
-		print( &( M[ ROW_idx[i]*ncol ] ), ncol, COL_idx );
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t
- */
-returnValue print( const int_t* const index, int_t n, const char* name )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	char myPrintfString[MAX_STRING_LENGTH];
-
-	/* Print indexlist name. */
-	if ( name != 0 )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH,"%s = \n", name );
-		myPrintf( myPrintfString );
-	}
-
-	/* Print a indexlist data. */
-	for( i=0; i<n; ++i )
-	{
-		snprintf( myPrintfString,MAX_STRING_LENGTH," %d\t", (int)(index[i]) );
-		myPrintf( myPrintfString );
-	}
-	myPrintf( "\n" );
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	m y P r i n t f
- */
-returnValue myPrintf( const char* s )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-
-		if ( s == 0 )
-			return RET_INVALID_ARGUMENTS;
-
-		#ifdef __MATLAB__
-			mexPrintf( s );
-		#else
-			#ifdef __SCILAB__
-				sciprint( s );
-			#else
-				FILE* outputfile = getGlobalMessageHandler( )->getOutputFile( );
-				if ( outputfile == 0 )
-					return THROWERROR( RET_NO_GLOBAL_MESSAGE_OUTPUTFILE );
-				fprintf( outputfile, "%s", s );
-			#endif /* __SCILAB__ */
-		#endif /* __MATLAB__ */
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	p r i n t C o p y r i g h t N o t i c e
- */
-returnValue printCopyrightNotice( )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-		#ifndef __XPCTARGET__
-		#ifndef __DSPACE__
-		#ifndef __NO_COPYRIGHT__
-		myPrintf( "\nqpOASES -- An Implementation of the Online Active Set Strategy.\nCopyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,\nChristian Kirches et al. All rights reserved.\n\nqpOASES is distributed under the terms of the \nGNU Lesser General Public License 2.1 in the hope that it will be \nuseful, but WITHOUT ANY WARRANTY; without even the implied warranty \nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. \nSee the GNU Lesser General Public License for more details.\n\n" );
-		#endif /* __NO_COPYRIGHT__ */
-		#endif /* __DSPACE__ */
-		#endif /* __XPCTARGET__ */
-	#endif /* __SUPPRESSANYOUTPUT__ */
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	r e a d F r o m F i l e
- */
-returnValue readFromFile(	real_t* data, int_t nrow, int_t ncol,
-							const char* datafilename
-							)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i, j;
-	real_t float_data;
-	FILE* datafile;
-
-	/* 1) Open file. */
-	if ( ( datafile = fopen( datafilename, "r" ) ) == 0 )
-	{
-		char errstr[MAX_STRING_LENGTH];
-		snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-		return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-	}
-
-	/* 2) Read data from file. */
-	for( i=0; i<nrow; ++i )
-	{
-		for( j=0; j<ncol; ++j )
-		{
-			#ifdef __USE_SINGLE_PRECISION__
-			if ( fscanf( datafile, "%f ", &float_data ) == 0 )
-			#else
-			if ( fscanf( datafile, "%lf ", &float_data ) == 0 )
-			#endif /* __USE_SINGLE_PRECISION__ */
-			{
-				fclose( datafile );
-				char errstr[MAX_STRING_LENGTH];
-				snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-				return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_READ_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-			}
-			data[i*ncol + j] = ( (real_t) float_data );
-		}
-	}
-
-	/* 3) Close file. */
-	fclose( datafile );
-
-	return SUCCESSFUL_RETURN;
-
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	r e a d F r o m F i l e
- */
-returnValue readFromFile(	real_t* data, int_t n,
-							const char* datafilename
-							)
-{
-	return readFromFile( data, n, 1, datafilename );
-}
-
-
-
-/*
- *	r e a d F r o m F i l e
- */
-returnValue readFromFile(	int_t* data, int_t n,
-							const char* datafilename
-							)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-	FILE* datafile;
-
-	/* 1) Open file. */
-	if ( ( datafile = fopen( datafilename, "r" ) ) == 0 )
-	{
-		char errstr[MAX_STRING_LENGTH];
-		snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-		return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-	}
-
-	/* 2) Read data from file. */
-	for( i=0; i<n; ++i )
-	{
-		#ifdef __USE_LONG_INTEGERS__
-		if ( fscanf( datafile, "%ld\n", &(data[i]) ) == 0 )
-		#else
-		if ( fscanf( datafile, "%d\n", &(data[i]) ) == 0 )
-		#endif
-		{
-			fclose( datafile );
-			char errstr[MAX_STRING_LENGTH];
-			snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-			return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_READ_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		}
-	}
-
-	/* 3) Close file. */
-	fclose( datafile );
-
-	return SUCCESSFUL_RETURN;
-
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	w r i t e I n t o F i l e
- */
-returnValue writeIntoFile(	const real_t* const data, int_t nrow, int_t ncol,
-							const char* datafilename, BooleanType append
-							)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i, j;
-	FILE* datafile;
-
-	/* 1) Open file. */
-	if ( append == BT_TRUE )
-	{
-		/* append data */
-		if ( ( datafile = fopen( datafilename, "a" ) ) == 0 )
-		{
-			char errstr[MAX_STRING_LENGTH];
-			snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-			return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		}
-	}
-	else
-	{
-		/* do not append data */
-		if ( ( datafile = fopen( datafilename, "w" ) ) == 0 )
-		{
-			char errstr[MAX_STRING_LENGTH];
-			snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-			return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		}
-	}
-
-	/* 2) Write data into file. */
-	for( i=0; i<nrow; ++i )
-	{
-		for( j=0; j<ncol; ++j )
-		 	fprintf( datafile, "%.16e ", data[i*ncol+j] );
-
-		fprintf( datafile, "\n" );
-	}
-
-	/* 3) Close file. */
-	fclose( datafile );
-
-	return SUCCESSFUL_RETURN;
-
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	w r i t e I n t o F i l e
- */
-returnValue writeIntoFile(	const real_t* const data, int_t n,
-							const char* datafilename, BooleanType append
-							)
-{
-	return writeIntoFile( data,1,n,datafilename,append );
-}
-
-
-/*
- *	w r i t e I n t o F i l e
- */
-returnValue writeIntoFile(	const int_t* const integer, int_t n,
-							const char* datafilename, BooleanType append
-							)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i;
-
-	FILE* datafile;
-
-	/* 1) Open file. */
-	if ( append == BT_TRUE )
-	{
-		/* append data */
-		if ( ( datafile = fopen( datafilename, "a" ) ) == 0 )
-		{
-			char errstr[MAX_STRING_LENGTH];
-			snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-			return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		}
-	}
-	else
-	{
-		/* do not append data */
-		if ( ( datafile = fopen( datafilename, "w" ) ) == 0 )
-		{
-			char errstr[MAX_STRING_LENGTH];
-			snprintf( errstr,MAX_STRING_LENGTH,"(%s)",datafilename );
-			return getGlobalMessageHandler( )->throwError( RET_UNABLE_TO_OPEN_FILE,errstr,__FUNC__,__FILE__,__LINE__,VS_VISIBLE );
-		}
-	}
-
-	/* 2) Write data into file. */
-	for( i=0; i<n; ++i )
-		fprintf( datafile, "%d\n",(int)(integer[i]) );
-
-	/* 3) Close file. */
-	fclose( datafile );
-
-	return SUCCESSFUL_RETURN;
-
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	w r i t e I n t o M a t F i l e
- */
-returnValue writeIntoMatFile(	FILE* const matFile,
-								const real_t* const data, int_t nRows, int_t nCols, const char* name
-								)
-{
-	/*  Note, this code snippet has been inspired from the document
-	 *  "Matlab(R) MAT-file Format, R2013b" by MathWorks */
-
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	if ( ( matFile == 0 ) || ( data == 0 ) || ( nRows < 0 ) || ( nCols < 0 ) || ( name == 0 ) )
-		return RET_INVALID_ARGUMENTS;
-
-	MatMatrixHeader var;
-
-	// setup variable header
-	var.numericFormat = 0000;  /* IEEE Little Endian - reserved - double precision (64 bits) - numeric full matrix */
-	var.nRows         = nRows; /* number of rows */
-	var.nCols         = nCols; /* number of columns */
-	var.imaginaryPart = 0;     /* no imaginary part */
-	var.nCharName     = (long)(strlen(name))+1; /* matrix name length */
-
-	/* write variable header to mat file */
-	if ( fwrite( &var, sizeof(MatMatrixHeader),1,  matFile ) < 1 )
-		return RET_UNABLE_TO_WRITE_FILE;
-
-	if ( fwrite( name, sizeof(char),(unsigned long)(var.nCharName), matFile ) < 1 )
-		return RET_UNABLE_TO_WRITE_FILE;
-
-	int_t ii, jj;
-	double curData;
-
-	for ( ii=0; ii<nCols; ++ii )
-		for ( jj=0; jj<nRows; ++jj )
-		{
-			curData = (real_t)data[jj*nCols+ii];
-			if ( fwrite( &curData, sizeof(double),1, matFile ) < 1 )
-				return RET_UNABLE_TO_WRITE_FILE;
-		}
-
-	return SUCCESSFUL_RETURN;
-
-	#else /* __SUPPRESSANYOUTPUT__ */
-
-	return RET_NOT_YET_IMPLEMENTED;
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-
-
-/*
- *	w r i t e I n t o M a t F i l e
- */
-returnValue writeIntoMatFile(	FILE* const matFile,
-								const int_t* const data, int_t nRows, int_t nCols, const char* name
-								)
-{
-	real_t* realData = new real_t[nRows*nCols];
-
-	int_t ii, jj;
-
-	for ( ii=0; ii<nRows; ++ii )
-		for ( jj=0; jj<nCols; ++jj )
-			realData[ ii*nCols+jj ] = (real_t) data[ ii*nCols+jj ];
-
-	returnValue returnvalue = writeIntoMatFile( matFile,realData,nRows,nCols,name );
-	delete[] realData;
-
-	return returnvalue;
-}
-
-
-/*
- *	g e t C P U t i m e
- */
-real_t getCPUtime( )
-{
-	real_t current_time = -1.0;
-
-	#if defined(__WIN32__) || defined(WIN32)
-	LARGE_INTEGER counter, frequency;
-	QueryPerformanceFrequency(&frequency);
-	QueryPerformanceCounter(&counter);
-	current_time = ((real_t) counter.QuadPart) / ((real_t) frequency.QuadPart);
-	#elif defined(LINUX) || defined(__LINUX__)
-	struct timeval theclock;
-	gettimeofday( &theclock,0 );
-	current_time =  1.0*(real_t) theclock.tv_sec + 1.0e-6* (real_t) theclock.tv_usec;
-	#endif
-
-	return current_time;
-}
-
-
-/*
- *	g e t N o r m
- */
-real_t getNorm( const real_t* const v, int_t n, int_t type )
-{
-	int_t i;
-
-	real_t norm = 0.0;
-
-	switch ( type )
-	{
-		case 2:
-			for( i=0; i<n; ++i )
-				norm += v[i]*v[i];
-			return getSqrt( norm );
-
-		case 1:
-			for( i=0; i<n; ++i )
-				norm += getAbs( v[i] );
-			return norm;
-
-		default:
-			THROWERROR( RET_INVALID_ARGUMENTS );
-			return -INFTY;
-	}
-}
-
-
-/*
- *	g e t K k t V i o l a t i o n
- */
-returnValue getKktViolation(	int_t nV, int_t nC,
-								const real_t* const H, const real_t* const g, const real_t* const A,
-								const real_t* const lb, const real_t* const ub, const real_t* const lbA, const real_t* const ubA,
-								const real_t* const x, const real_t* const y,
-								real_t& stat, real_t& feas, real_t& cmpl,
-								const real_t* const workingSetB, const real_t* const workingSetC, BooleanType hasIdentityHessian
-								)
-{
-	/* Tolerance for dual variables considered zero. */
-	const real_t dualActiveTolerance = 1.0e3 * EPS;
-
-	int_t i, j;
-	real_t sum, prod;
-
-	/* Initialize residuals */
-	stat = feas = cmpl = 0.0;
-
-	/* check stationarity */
-	for (i = 0; i < nV; i++)
-	{
-		/* g term and variable bounds dual term */
-		if ( g != 0 )
-			sum = g[i] - y[i];
-		else
-			sum = 0.0 - y[i];
-
-		/* H*x term */
-		if ( H != 0 )
-			for (j = 0; j < nV; j++) sum += H[i*nV+j] * x[j];
-		else
-		{
-			if ( hasIdentityHessian == BT_TRUE )
-				for (j = 0; j < nV; j++) sum += x[j];
-		}
-
-		/* A'*y term */
-		if ( A != 0 )
-			for (j = 0; j < nC; j++) sum -= A[j*nV+i] * y[nV+j];
-
-		/* update stat */
-		if (getAbs(sum) > stat) stat = getAbs(sum);
-	}
-
-	/* check primal feasibility and complementarity of bounds */
-	/* feasibility */
-	for (i = 0; i < nV; i++)
-	{
-		if ( lb != 0 )
-			if (lb[i] - x[i] > feas)
-				feas = lb[i] - x[i];
-
-		if ( ub != 0 )
-			if (x[i] - ub[i] > feas)
-				feas = x[i] - ub[i];
-	}
-
-	/* complementarity */
-	if ( workingSetB == 0 )
-	{
-		for (i = 0; i < nV; i++)
-		{
-			prod = 0.0;
-
-			/* lower bound */
-			if ( lb != 0 )
-				if (y[i] > dualActiveTolerance)
-					prod = (x[i] - lb[i]) * y[i];
-
-			/* upper bound */
-			if ( ub != 0 )
-				if (y[i] < -dualActiveTolerance)
-					prod = (x[i] - ub[i]) * y[i];
-
-			if (getAbs(prod) > cmpl) cmpl = getAbs(prod);
-		}
-	}
-	else
-	{
-		for (i = 0; i < nV; i++)
-		{
-			prod = 0.0;
-
-			/* lower bound */
-			if ( lb != 0 )
-			{
-				if ( isEqual(workingSetB[i],-1.0) == BT_TRUE )
-					prod = (x[i] - lb[i]) * y[i];
-			}
-
-			/* upper bound */
-			if ( ub != 0 )
-			{
-				if ( isEqual(workingSetB[i],1.0) == BT_TRUE )
-					prod = (x[i] - ub[i]) * y[i];
-			}
-
-			if (getAbs(prod) > cmpl) cmpl = getAbs(prod);
-		}
-	}
-
-	/* check primal feasibility and complementarity of constraints */
-	for (i = 0; i < nC; i++)
-	{
-		/* compute sum = (A*x)_i */
-		sum = 0.0;
-		if ( A != 0 )
-			for (j = 0; j < nV; j++)
-				sum += A[i*nV+j] * x[j];
-
-		/* feasibility */
-		if ( lbA != 0 )
-			if (lbA[i] - sum > feas)
-				feas = lbA[i] - sum;
-
-		if ( ubA != 0 )
-			if (sum - ubA[i] > feas)
-				feas = sum - ubA[i];
-
-		/* complementarity */
-		prod = 0.0;
-
-		/* lower bound */
-		if ( lbA != 0 )
-		{
-			if ( workingSetC == 0 )
-			{
-				if (y[nV+i] > dualActiveTolerance)
-					prod = (sum - lbA[i]) * y[nV+i];
-			}
-			else
-			{
-				if ( isEqual(workingSetC[i],-1.0) == BT_TRUE )
-					prod = (sum - lbA[i]) * y[nV+i];
-			}
-		}
-
-		/* upper bound */
-		if ( ubA != 0 )
-		{
-			if ( workingSetC == 0 )
-			{
-				if (y[nV+i] < -dualActiveTolerance)
-					prod = (sum - ubA[i]) * y[nV+i];
-			}
-			else
-			{
-				if ( isEqual(workingSetC[i],1.0) == BT_TRUE )
-					prod = (sum - ubA[i]) * y[nV+i];
-			}
-		}
-
-		if (getAbs(prod) > cmpl) cmpl = getAbs(prod);
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t K k t V i o l a t i o n
- */
-returnValue getKktViolation(	int_t nV,
-								const real_t* const H, const real_t* const g,
-								const real_t* const lb, const real_t* const ub,
-								const real_t* const x, const real_t* const y,
-								real_t& stat, real_t& feas, real_t& cmpl,
-								const real_t* const workingSetB, BooleanType hasIdentityHessian
-								)
-{
-	return getKktViolation(	nV,0,
-							H,g,0,lb,ub,0,0,
-							x,y,
-							stat,feas,cmpl,
-							workingSetB,0,hasIdentityHessian
-							);
-}
-
-
-/*
- *	c o n v e r t B o o l e a n T y p e T o S t r i n g
- */
-returnValue convertBooleanTypeToString( BooleanType value, char* const string )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	if ( value == BT_FALSE )
-		snprintf( string,20,"BT_FALSE" );
-	else
-		snprintf( string,20,"BT_TRUE" );
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o n v e r t S u b j e c t T o S t a t u s T o S t r i n g
- */
-returnValue convertSubjectToStatusToString( SubjectToStatus value, char* const string )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	switch( value )
-	{
-		case ST_INACTIVE:
-			snprintf( string,20,"ST_INACTIVE" );
-			break;
-
-		case ST_LOWER:
-			snprintf( string,20,"ST_LOWER" );
-			break;
-
-		case ST_UPPER:
-			snprintf( string,20,"ST_UPPER" );
-			break;
-
-		case ST_UNDEFINED:
-			snprintf( string,20,"ST_UNDEFINED" );
-			break;
-
-		case ST_INFEASIBLE_LOWER:
-			snprintf( string,20,"ST_INFEASIBLE_LOWER" );
-			break;
-
-		case ST_INFEASIBLE_UPPER:
-			snprintf( string,20,"ST_INFEASIBLE_UPPER" );
-			break;
-
-		default:
-			snprintf( string,20,"<invalid value>" );
-			break;
-	}
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	c o n v e r t P r i n t L e v e l T o S t r i n g
- */
-returnValue convertPrintLevelToString( PrintLevel value, char* const string )
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-	switch( value )
-	{
-		case PL_NONE:
-			snprintf( string,20,"PL_NONE" );
-			break;
-
-		case PL_LOW:
-			snprintf( string,20,"PL_LOW" );
-			break;
-
-		case PL_MEDIUM:
-			snprintf( string,20,"PL_MEDIUM" );
-			break;
-
-		case PL_HIGH:
-			snprintf( string,20,"PL_HIGH" );
-			break;
-
-		case PL_TABULAR:
-			snprintf( string,20,"PL_TABULAR" );
-			break;
-
-		case PL_DEBUG_ITER:
-			snprintf( string,20,"PL_DEBUG_ITER" );
-			break;
-
-		default:
-			snprintf( string,20,"<invalid value>" );
-			break;
-	}
-	#endif /* __SUPPRESSANYOUTPUT__ */
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-/*
- *	g e t S i m p l e S t a t u s
- */
-int_t getSimpleStatus(	returnValue returnvalue,
-						BooleanType doPrintStatus
-						)
-{
-	int_t simpleStatus = -1;
-
-	/* determine simple status from returnvalue */
-	switch ( returnvalue )
-	{
-		case SUCCESSFUL_RETURN:
-			simpleStatus = 0;
-			break;
-
-		case RET_MAX_NWSR_REACHED:
-			simpleStatus = 1;
-			break;
-
-		case RET_INIT_FAILED_INFEASIBILITY:
-		case RET_HOTSTART_STOPPED_INFEASIBILITY:
-			simpleStatus = -2;
-			break;
-
-		case RET_INIT_FAILED_UNBOUNDEDNESS:
-		case RET_HOTSTART_STOPPED_UNBOUNDEDNESS:
-			simpleStatus = -3;
-			break;
-
-		default:
-			simpleStatus = -1;
-			break;
-	}
-
-	if ( doPrintStatus == BT_TRUE )
-	{
-		VisibilityStatus vsInfo = getGlobalMessageHandler( )->getInfoVisibilityStatus( );
-		getGlobalMessageHandler( )->setInfoVisibilityStatus( VS_VISIBLE );
-		getGlobalMessageHandler( )->setErrorCount( -1 );
-
-		int_t retValNumber = (int_t)RET_SIMPLE_STATUS_P0 - simpleStatus;
-		THROWINFO( (returnValue)retValNumber );
-
-		getGlobalMessageHandler( )->setInfoVisibilityStatus( vsInfo );
-	}
-
-	return simpleStatus;
-}
-
-
-/*
- *	n o r m a l i s e C o n s t r a i n t s
- */
-returnValue normaliseConstraints(	int_t nV, int_t nC,
-									real_t* A, real_t* lbA, real_t* ubA,
-									int_t type
-									)
-{
-	int_t ii, jj;
-	real_t curNorm;
-
-	if ( ( nV <= 0 ) || ( nC <= 0 ) || ( A == 0 ) )
-		return THROWERROR( RET_INVALID_ARGUMENTS );
-
-	for( ii=0; ii<nC; ++ii )
-	{
-		/* get row norm */
-		curNorm = getNorm( &(A[ii*nV]),nV,type );
-
-		if ( curNorm > EPS )
-		{
-			/* normalise if norm is positive */
-			for( jj=0; jj<nV; ++jj )
-				A[ii*nV + jj] /= curNorm;
-
-			if ( lbA != 0 ) lbA[ii] /= curNorm;
-			if ( ubA != 0 ) ubA[ii] /= curNorm;
-		}
-		else
-		{
-			/* if row norm is (close to) zero, kind of erase constraint */
-			if ( type == 1 )
-			{
-				for( jj=0; jj<nV; ++jj )
-					A[ii*nV + jj] = 1.0 / ((real_t)nV);
-			}
-			else
-			{
-				/* assume type == 2 */
-				for( jj=0; jj<nV; ++jj )
-					A[ii*nV + jj] = 1.0 / getSqrt((real_t)nV);
-			}
-
-			if ( lbA != 0 ) lbA[ii] = -INFTY;
-			if ( ubA != 0 ) ubA[ii] =  INFTY;
-		}
-	}
-
-	return SUCCESSFUL_RETURN;
-}
-
-
-#ifdef __DEBUG__
-/*
- *	g d b _ p r i n t m at
- */
-extern "C" void gdb_printmat(const char *fname, real_t *M, int_t n, int_t m, int_t ldim)
-{
-	#ifndef __SUPPRESSANYOUTPUT__
-
-	int_t i, j;
-	FILE *fid;
-
-	fid = fopen(fname, "wt");
-	if (!fid)
-	{
-		perror("Error opening file: ");
-		return;
-	}
-
-	for (i = 0; i < n; i++)
-	{
-		for (j = 0; j < m; j++)
-			fprintf(fid, " %23.16e", M[j*ldim+i]);
-		fprintf(fid, "\n");
-	}
-	fclose(fid);
-
-	#endif /* __SUPPRESSANYOUTPUT__ */
-}
-#endif /* __DEBUG__ */
-
-
-
-#if defined(__DSPACE__) || defined(__XPCTARGET__) || defined(__C_WRAPPER__)
-/*
- *	_ _ c x a _ p u r e _ v i r t u a l
- */
-void __cxa_pure_virtual( void )
-{
-	/* put your customized implementation here! */
-}
-#endif /* __DSPACE__ || __XPCTARGET__ || __C_WRAPPER__ */
-
-
-
-END_NAMESPACE_QPOASES
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/c/Makefile b/extlibs/qpOASES-3.2.0/testing/c/Makefile
deleted file mode 100644
index 54ca481..0000000
--- a/extlibs/qpOASES-3.2.0/testing/c/Makefile
+++ /dev/null
@@ -1,78 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/c/Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014-2015
-##
-
-
-
-include ../../make.mk
-
-##
-##	flags
-##
-
-IFLAGS      =  -I. \
-               -I${IDIR} \
-			   -I${TOP}/interfaces/c
-
-QPOASES_TEST_EXES = \
-	${BINDIR}/test_c_example1${EXE} \
-	${BINDIR}/test_c_example1a${EXE} \
-	${BINDIR}/test_c_example1b${EXE}
-
-
-##
-##	targets
-##
-
-all: ${QPOASES_TEST_EXES}
-
-${BINDIR}/%${EXE}: %.${OBJEXT} ${LINK_DEPENDS_WRAPPER}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK_WRAPPER} ${LINK_LIBRARIES_WRAPPER}
-
-
-clean:
-	@${ECHO} "Cleaning up (testing/cpp)"
-	@${RM} -f *.${OBJEXT} ${QPOASES_TEST_EXES}
-
-clobber: clean
-
-
-${LINK_DEPENDS_WRAPPER}:
-	@cd ../..; ${MAKE} -s c_wrapper
-
-%.${OBJEXT}: %.c
-	@${ECHO} "Creating" $@
-	@${CC} ${DEF_TARGET} -c ${IFLAGS} ${CPPFLAGS} $<
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1.c b/extlibs/qpOASES-3.2.0/testing/c/test_c_example1.c
deleted file mode 100644
index 801418e..0000000
--- a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1.c
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/c/test_c_example1.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using QProblem class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-	int_t nWSR;
-	qpOASES_Options options;
-	
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	real_t obj;
-	int_t status;
-
-	qpOASES_Options_init( &options,0 );
-	options.printLevel = PL_MEDIUM;
-
-
-	QProblem_setup(	2,1,HST_UNKNOWN );
-
-	/* Solve first QP. */
-	nWSR = 10;
-	QProblem_init(	H,g,A,lb,ub,lbA,ubA,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	QProblem_hotstart(	g_new,lb_new,ub_new,lbA_new,ubA_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-	
-	QProblem_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1a.c b/extlibs/qpOASES-3.2.0/testing/c/test_c_example1a.c
deleted file mode 100644
index afe78ba..0000000
--- a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1a.c
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/c/test_c_example1a.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using SQProblem class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-	int_t nWSR;
-
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	real_t obj;
-	int_t status;
-
-	qpOASES_Options options;
-	qpOASES_Options_init( &options,0 );
-
-	
-	SQProblem_setup( 2,1,HST_UNKNOWN );
-	
-	/* Solve first QP. */
-	nWSR = 10;
-	SQProblem_init(	H,g,A,lb,ub,lbA,ubA,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	SQProblem_hotstart(	H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2], obj );
-
-	
-	SQProblem_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1b.c b/extlibs/qpOASES-3.2.0/testing/c/test_c_example1b.c
deleted file mode 100644
index b57fefc..0000000
--- a/extlibs/qpOASES-3.2.0/testing/c/test_c_example1b.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/c/test_example1b.c
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using QProblemB class through C interface).
- */
-
-#include <stdio.h>
-
-#include <qpOASES_wrapper.h>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-
-	int_t nWSR;
-	qpOASES_Options options;
-
-	real_t xOpt[2];
-	real_t yOpt[2];
-	real_t obj;
-	int_t status;
-
-	qpOASES_Options_init( &options,0 );
-	/*options.enableFlippingBounds = 0; */
-	options.initialStatusBounds = ST_INACTIVE;
-	options.numRefinementSteps = 1;
-	options.enableCholeskyRefactorisation = 1;
-
-
-	QProblemB_setup( 2,HST_UNKNOWN );
-
-	/* Solve first QP. */
-	nWSR = 10;
-	QProblemB_init(	H,g,lb,ub,
-					&nWSR,0,&options,
-					xOpt,yOpt,&obj,&status
-					);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1], obj );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	QProblemB_hotstart(	g_new,lb_new,ub_new,
-						&nWSR,0,
-						xOpt,yOpt,&obj,&status
-						);
-
-	/* Print solution of first QP. */	
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1], obj );
-
-	
-	QProblemB_cleanup();
-	
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/checkForMemoryLeaks b/extlibs/qpOASES-3.2.0/testing/checkForMemoryLeaks
deleted file mode 100755
index 0224769..0000000
--- a/extlibs/qpOASES-3.2.0/testing/checkForMemoryLeaks
+++ /dev/null
@@ -1,109 +0,0 @@
-#!/usr/bin/env bash
-
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/checkForMemoryLeaks
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014-2015
-
-# defining colors for output
-red='\e[0;31m'
-green='\e[0;32m'
-NC='\e[0m' # No Color
-
-# runs valgrind on a number of examples to detect possible memory leaks
-
-function callValgrind {
-	echo -n "Checking for memory leaks in $2 $3... "
-
-	valgrind --tool=memcheck --leak-check=yes --error-exitcode=42 -q $2 $3 > dummy.txt;
-	retVal=$?;
-	rm -rf dummy.txt;
-
-	if [ $retVal == 42 ]; then
-		echo -e "${red}failed!${NC}"
-		counter=$[counter+1];
-	else
-		if [ $retVal == 99 ]; then
-			echo "problem data missing!"
-		else
-			echo -e "${green}passed!${NC}"
-		fi
-	fi
-}
-
-
-cd ..;
-make examples testing;
-cd testing;
-
-counter=0;
-
-# run examples in /examples
-callValgrind $counter ../bin/example1;
-callValgrind $counter ../bin/example1a;
-callValgrind $counter ../bin/example1b;
-callValgrind $counter ../bin/example2;
-callValgrind $counter ../bin/example3;
-callValgrind $counter ../bin/example3b;
-callValgrind $counter ../bin/example4;
-callValgrind $counter ../bin/example5;
-callValgrind $counter ../bin/exampleLP;
-callValgrind $counter ../bin/qrecipe;
-callValgrind $counter ../bin/qrecipeSchur;
-
-# run examples in /testing ...
-callValgrind $counter ../bin/test_matrices;
-callValgrind $counter ../bin/test_matrices2;
-callValgrind $counter ../bin/test_indexlist;
-callValgrind $counter ../bin/test_example6;
-callValgrind $counter ../bin/test_example7;
-callValgrind $counter ../bin/test_infeasible1;
-callValgrind $counter ../bin/test_sebastien1;
-callValgrind $counter ../bin/test_vanBarelsUnboundedQP;
-callValgrind $counter ../bin/test_janick1;
-callValgrind $counter ../bin/test_janick2;
-callValgrind $counter ../bin/test_constraintProduct1;
-callValgrind $counter ../bin/test_constraintProduct2;
-callValgrind $counter ../bin/test_guessedWS1;
-callValgrind $counter ../bin/test_externalChol1;
-callValgrind $counter ../bin/test_runAllOqpExamples;
-
-
-# ... including testbench with different settings
-callValgrind $counter ../bin/test_bench Odd; # default dense
-callValgrind $counter ../bin/test_bench Ods; # default sparse
-callValgrind $counter ../bin/test_bench Omd; # MPC dense
-callValgrind $counter ../bin/test_bench Ors; # reliable dense
-
-
-if [ $counter == 0 ]; then
-	echo -e "${green}All available tests passed successfully!${NC}"
-else
-	echo -e "${red}$counter test(s) failed!${NC}"
-	exit 1
-fi
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/Makefile b/extlibs/qpOASES-3.2.0/testing/cpp/Makefile
deleted file mode 100644
index 6f62d1c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/Makefile
+++ /dev/null
@@ -1,136 +0,0 @@
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/cpp/Makefile
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2007-2015
-##
-
-
-include ../../make.mk
-
-##
-##	flags
-##
-
-IFLAGS      =  -I. \
-               -I${IDIR}
-
-QPOASES_TEST_EXES = \
-	${BINDIR}/test_bench${EXE} \
-	${BINDIR}/test_matrices${EXE} \
-	${BINDIR}/test_matrices2${EXE} \
-	${BINDIR}/test_matrices3${EXE} \
-	${BINDIR}/test_indexlist${EXE} \
-	${BINDIR}/test_example1${EXE} \
-	${BINDIR}/test_example1a${EXE} \
-	${BINDIR}/test_example1b${EXE} \
-	${BINDIR}/test_example2${EXE} \
-	${BINDIR}/test_example4${EXE} \
-	${BINDIR}/test_example5${EXE} \
-	${BINDIR}/test_example6${EXE} \
-	${BINDIR}/test_example7${EXE} \
-	${BINDIR}/test_exampleLP${EXE} \
-	${BINDIR}/test_qrecipe${EXE} \
-	${BINDIR}/test_qrecipeSchur${EXE} \
-	${BINDIR}/test_infeasible1${EXE} \
-	${BINDIR}/test_hs268${EXE} \
-	${BINDIR}/test_gradientShift${EXE} \
-	${BINDIR}/test_runAllOqpExamples${EXE} \
-	${BINDIR}/test_sebastien1${EXE} \
-	${BINDIR}/test_vanBarelsUnboundedQP${EXE} \
-	${BINDIR}/test_janick1${EXE} \
-	${BINDIR}/test_janick2${EXE} \
-	${BINDIR}/test_constraintProduct1${EXE} \
-	${BINDIR}/test_constraintProduct2${EXE} \
-	${BINDIR}/test_guessedWS1${EXE} \
-	${BINDIR}/test_externalChol1${EXE}
-
-
-##
-##	targets
-##
-
-all: ${QPOASES_TEST_EXES}
-
-runTests: ${QPOASES_TEST_EXES}
-	@cd .. && ./runUnitTests && ./checkForMemoryLeaks && cd cpp
-
-${BINDIR}/%${EXE}: %.${OBJEXT} ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/test_matrices2${EXE}: test_matrices2.${OBJEXT} test_qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/test_matrices3${EXE}: test_matrices3.${OBJEXT} test_qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/test_qrecipe${EXE}: test_qrecipe.${OBJEXT} test_qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-${BINDIR}/test_qrecipeSchur${EXE}: test_qrecipeSchur.${OBJEXT} test_qrecipe_data.hpp ${LINK_DEPENDS}
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${CPPFLAGS} $< ${QPOASES_LINK} ${LINK_LIBRARIES}
-
-
-clean:
-	@${ECHO} "Cleaning up (testing/cpp)"
-	@${RM} -f *.${OBJEXT} ${QPOASES_TEST_EXES}
-
-clobber: clean
-
-
-${LINK_DEPENDS}:
-	@cd ../..; ${MAKE} -s src
-
-test_matrices2.${OBJEXT}: test_matrices2.cpp test_qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-test_matrices3.${OBJEXT}: test_matrices3.cpp test_qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-test_qrecipe.${OBJEXT}: test_qrecipe.cpp test_qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-test_qrecipeSchur.${OBJEXT}: test_qrecipeSchur.cpp test_qrecipe_data.hpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-%.${OBJEXT}: %.cpp
-	@${ECHO} "Creating" $@
-	@${CPP} ${DEF_TARGET} ${IFLAGS} ${CPPFLAGS} -c $<
-
-
-##
-##	end of file
-##
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/data/fetch_cpp_data b/extlibs/qpOASES-3.2.0/testing/cpp/data/fetch_cpp_data
deleted file mode 100755
index 5e10392..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/data/fetch_cpp_data
+++ /dev/null
@@ -1,34 +0,0 @@
-#!/usr/bin/env bash
-
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/cpp/data/fetch_cpp_data
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014
-
-
-svn export https://projects.coin-or.org/svn/qpOASES/misc/testingdata/cpp . --force
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_bench.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_bench.cpp
deleted file mode 100644
index dc03fc9..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_bench.cpp
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_bench.cpp
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2010-2015
- *
- *	Unit test running all benchmark examples stored in problems directory.
- */
-
-
-
-#include <dirent.h>
-#include <cstring>
-#include <cstdlib>
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Run benchmark examples. */
-int main( int argc, char *argv[] )
-{
-	USING_NAMESPACE_QPOASES
-	#ifdef __USE_SINGLE_PRECISION__
-	const real_t TOL = 5e-2;
-	#else
-	const real_t TOL = 1e-5;
-	#endif
-
-	/* 1) Define benchmark arguments. */
-	BooleanType isSparse = BT_FALSE;
-	//BooleanType isSparse = BT_TRUE;
-	Options options;
- 	options.setToDefault();
-	//options.setToMPC();
-	//options.setToReliable();
-	options.printLevel = PL_LOW;
-	//options.printLevel = PL_MEDIUM;
-	//options.printLevel = PL_TABULAR;
-	//options.enableFarBounds = BT_FALSE;
-
-// 	options.initialStatusBounds = ST_LOWER;
-	//options.numRegularisationSteps = 1;
-	//options.epsRegularisation = 1.0e3 * EPS;
- 	
-	//options.enableFlippingBounds = BT_FALSE;
-	//options.enableFlippingBounds = BT_FALSE;
-	//options.enableRamping = BT_TRUE;
-	//options.enableFarBounds = BT_FALSE;
-	//options.enableNZCTests = BT_FALSE;
-	//options.epsNZCTests = 1.0e4 * EPS;
-	//options.epsFlipping = 1.0e5 * EPS;
-	//options.enableFullLITests = BT_TRUE;
- 	//options.enableDriftCorrection = 1;
- 	//options.enableEqualities = BT_TRUE;
-	//options.enableEqualities = BT_FALSE;
- 	//options.epsNum = -1.0e3 * EPS;
- 	//options.epsDen =  1.0e3 * EPS;
-
-
-	int_t nWSR;
-	real_t maxCPUtime; /* seconds */
-	real_t maxStationarity = 0.0, maxFeasibility = 0.0, maxComplementarity = 0.0;
-	real_t avgStationarity = 0.0, avgFeasibility = 0.0, avgComplementarity = 0.0;
-
-	int_t scannedDir = 0;
-	int_t nfail = 0, npass = 0;
-	int_t nproblems, i;
-	struct dirent **namelist;
-	char resstr[MAX_STRING_LENGTH], oqpProblem[MAX_STRING_LENGTH];
-	char *problem;
-	returnValue returnvalue;
-
-	int_t expectedNumSolvedProblems = 44;
-	real_t expectedAvgStationarity    = TOL;
-	real_t expectedAvgFeasibility     = TOL;
-	real_t expectedAvgComplementarity = TOL;
-
-	
-	if ( argv[argc-1][0] == 'O' )
-	{
-		if ( strlen(argv[argc-1]) != 3 )
-		{
-			fprintf( stdout,"ERROR (testbench): Invalid options passed!\n" );
-			return TEST_DATA_NOT_FOUND;
-		}
-		
-		fprintf( stdout,"Analysing passed options:  " );
-		switch ( argv[argc-1][1] )
-		{
-			case 'd':
-				fprintf( stdout,"default options, " );
-				options.setToDefault();
-				if ( argv[argc-1][2] == 's' )
-				{
-					expectedNumSolvedProblems  = 44;
-					expectedAvgStationarity    = 1e-9;
-					expectedAvgFeasibility     = 1e-9;
-					expectedAvgComplementarity = 5e-7;
-				}
-				else
-				{
-					expectedNumSolvedProblems  = 44;
-					expectedAvgStationarity    = 5e-10;
-					expectedAvgFeasibility     = 5e-10;
-					expectedAvgComplementarity = 5e-8;
-				}
-				break;
-				
-			case 'r':
-				fprintf( stdout,"reliable options, " );
-				options.setToReliable();
-				if ( argv[argc-1][2] == 's' )
-				{
-					expectedNumSolvedProblems  = 44;
-					expectedAvgStationarity    = 2e-9;
-					expectedAvgFeasibility     = 2e-11;
-					expectedAvgComplementarity = 3e-9;
-				}
-				else
-				{
-					expectedNumSolvedProblems  = 44;
-					expectedAvgStationarity    = 2e-9;
-					expectedAvgFeasibility     = 2e-9;
-					expectedAvgComplementarity = 3e-7;
-				}
-				break;
-				
-			case 'm':
-				fprintf( stdout,"MPC options, " );
-				options.setToMPC();
-				if ( argv[argc-1][2] == 's' )
-				{
-					expectedNumSolvedProblems  = 42;
-					expectedAvgStationarity    = 2e-8;
-					expectedAvgFeasibility     = 1e-8;
-					expectedAvgComplementarity = 2e-7;
-				}
-				else
-				{
-					expectedNumSolvedProblems  = 42;
-					expectedAvgStationarity    = 3e-8;
-					expectedAvgFeasibility     = 1e-8;
-					expectedAvgComplementarity = 5e-8;
-				}
-				break;
-				
-			default:
-				fprintf( stdout,"ERROR (testbench): Invalid options passed!\n" );
-				return TEST_DATA_NOT_FOUND;
-		}
-		
-		switch ( argv[argc-1][2] )
-		{
-			case 's':
-				fprintf( stdout,"sparse QP data\n" );
-				isSparse = BT_TRUE;
-				break;
-				
-			case 'd':
-				fprintf( stdout,"dense QP data\n" );
-				isSparse = BT_FALSE;
-				break;
-				
-			default:
-				fprintf( stdout,"ERROR (testbench): Invalid options passed!\n" );
-				return TEST_DATA_NOT_FOUND;
-		}
-		options.printLevel = PL_NONE;
-		//options.enableFlippingBounds = BT_FALSE;
-		
-		nproblems = argc-2;
-	}
-	else
-	{
-		nproblems = argc-1;
-	}
-
-	
-	if (nproblems == 0)
-	{
-		/* 2a) Scan problem directory */
-		nproblems = scandir("../testing/cpp/data/problems", &namelist, NULL, alphasort);
-		if (nproblems <= 0)
-		{
-			myPrintf( "No test problems found!\n" );
-			return TEST_DATA_NOT_FOUND;
-		}
-		scannedDir = 1;
-	}
-	else
-	{
-		/* 2b) Use problem list given by arguments */
-		scannedDir = 0;
-	}
-
-	/* 3) Run benchmark. */
-	printf("%10s %9s %9s %9s %6s  %-12s\n", "problem", "stat",
-			"feas", "compl", "nWSR", "result");
-	for (i = 0; i < nproblems; i++)
-	{
-		if (scannedDir)
-		{
-			/* skip special directories and zip file cuter.*bz2 */
-			if (namelist[i]->d_name[0] == '.' || namelist[i]->d_name[0] == 'c')
-			{
-				free(namelist[i]);
-				continue;
-			}
-			problem = namelist[i]->d_name;
-		}
-		else
-		{
-			problem = argv[i+1];
-		}
-
-		fprintf(stdFile, "%-10s ", problem);
-		fflush(stdFile);
-
-		snprintf(oqpProblem, MAX_STRING_LENGTH, "../testing/cpp/data/problems/%s/", problem);
-		maxCPUtime = 300.0;
-		nWSR = 2500;
-
-		returnvalue = runOqpBenchmark(	oqpProblem, isSparse, options,
-										nWSR, maxCPUtime, maxStationarity, maxFeasibility, maxComplementarity 
-										);
-		if (returnvalue	== SUCCESSFUL_RETURN
-				&& maxStationarity < TOL
-				&& maxFeasibility < TOL
-				&& maxComplementarity < TOL)
-		{
-			npass++;
-			
-			avgStationarity    += maxStationarity;
-			avgFeasibility     += maxFeasibility;
-			avgComplementarity += maxComplementarity;
-
-			strncpy(resstr, "pass", MAX_STRING_LENGTH);
-		}
-		else
-		{
-			if ( returnvalue == RET_BENCHMARK_ABORTED )
-				return TEST_DATA_NOT_FOUND;
-
-			nfail++;
-			snprintf (resstr, MAX_STRING_LENGTH, "fail (%d)",(int)returnvalue);
-		}
-		fprintf(stdFile, "%9.2e %9.2e %9.2e %6d  %-12s\n", maxStationarity,
-				maxFeasibility, maxComplementarity, (int)nWSR, resstr);
-
-		if (scannedDir) free(namelist[i]);
-	}
-	if (scannedDir) free(namelist);
-
-	avgStationarity    /= npass;
-	avgFeasibility     /= npass;
-	avgComplementarity /= npass;
-
-
-	/* 4) Print results. */
-	printf( "\n\n" );
-	printf( "Testbench results:\n" );
-	printf( "======================\n\n" );
-	printf( "Pass:  %3d\n",(int)npass );
-	printf( "Fail:  %3d\n",(int)nfail );
-	printf( "Ratio: %5.1f%%\n", 100.0 * (real_t)npass / (real_t)(npass+nfail) );
-	printf( "\n" );
-
-	QPOASES_TEST_FOR_TRUE( npass >= expectedNumSolvedProblems );
-
-
-	printf( "avg. stat:  %e\n", avgStationarity    );
-	printf( "avg. feas:  %e\n", avgFeasibility     );
-	printf( "avg. cmpl:  %e\n", avgComplementarity );
-
-	QPOASES_TEST_FOR_TOL( avgStationarity,    expectedAvgStationarity    );
-	QPOASES_TEST_FOR_TOL( avgFeasibility,     expectedAvgFeasibility     );
-	QPOASES_TEST_FOR_TOL( avgComplementarity, expectedAvgComplementarity );
-
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct1.cpp
deleted file mode 100644
index 1c95dd6..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct1.cpp
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_constraintProduct1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Another example for testing qpOASES using the possibility to specify 
- *	user-defined constraint product function.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-
-USING_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Example illustrating the use of the \a ConstraintProduct class.
- *
- *	Example illustrating the use of the \a ConstraintProduct class.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.1
- *	\date 2007-2015
- */
-class MpcConstraintProduct : public ConstraintProduct
-{
-	public:
-		/** Default constructor. */
-		MpcConstraintProduct( ) {};
-
-		/** Constructor. */
-		MpcConstraintProduct(	int_t _nV,
-								int_t _nC,
-								int_t _diagOffset,
-								real_t* _A
-								)
-		{
-			nV = _nV;
-			nC = _nC;
-			diagOffset = _diagOffset;
-			A  = _A;
-		};
-
-		/** Copy constructor (flat copy). */
-		MpcConstraintProduct(	const MpcConstraintProduct& rhs
-								)
-		{
-			nV = rhs.nV;
-			nC = rhs.nC;
-			diagOffset = rhs.diagOffset;
-			A  = rhs.A;
-		};
-
-		/** Destructor. */
-		virtual ~MpcConstraintProduct( ) {};
-		
-		/** Assignment operator (flat copy). */
-		MpcConstraintProduct& operator=(	const MpcConstraintProduct& rhs
-											)
-		{
-			if ( this != &rhs )
-			{
-				nV = rhs.nV;
-				nC = rhs.nC;
-				diagOffset = rhs.diagOffset;
-				A  = rhs.A;
-			}
-			else
-				return *this;
-		};
-
-		virtual int_t operator() (	int_t constrIndex,
-									const real_t* const x,
-									real_t* const constrValue
-									) const
-		{
-			int_t i;
-			int_t maxI = (int_t)(((real_t)constrIndex) * ((real_t)nV) / ((real_t)nC)) + diagOffset;
-			maxI = getMin( maxI,nV );
-
-			constrValue[0] = 0.0;
-
-			for( i=0; i<maxI; ++i )
-				constrValue[0] += A[constrIndex*nV + i] * x[i];
-
-			return 0;
-		};
-
-	protected:
-		int_t nV;			/**< Number of variables. */
-		int_t nC;			/**< Number of constraints. */
-		int_t diagOffset;	/**< ... */
-		real_t* A;			/**< Pointer to full constraint matrix (typically not needed!). */
-		
-};
-
-
-
-/**	Example for qpOASES main function using the possibility to specify 
- *	user-defined constraint product function. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t nQP, nV, nC, nEC;
-	real_t *H, *g, *A, *lb, *ub, *lbA, *ubA;
-	real_t cputime;
-
-	real_t xOpt[1000];
-	real_t yOpt[1000];
-	real_t xOptCP[1000+1000];
-	real_t yOptCP[1000+1000];
-	
-	const char* path = "./cpp/data/oqp/chain80w/";
-	int_t k = 10; //th problem
-	
-		
-	if ( readOqpDimensions(	path, nQP,nV,nC,nEC ) != SUCCESSFUL_RETURN )
-		return TEST_DATA_NOT_FOUND;
-	
-	readOqpData(	path, nQP,nV,nC,nEC,
-					&H,&g,&A,&lb,&ub,&lbA,&ubA,
-					0,0,0
-					);
-	
-	Options myOptions;
-	//myOptions.setToMPC();
-	myOptions.printLevel = PL_LOW;
-
-	int_t nWSR = 500;
-	cputime = 20.0;
-	QProblem qp( nV,nC );
-	qp.setOptions( myOptions );
-	qp.init( H,&(g[k*nV]),A,&(lb[k*nV]),&(ub[k*nV]),&(lbA[k*nC]),&(ubA[k*nC]),nWSR,&cputime );
-	qp.getPrimalSolution( xOpt );
-	qp.getDualSolution( yOpt );
-	printf( "cputime without constraintProduct: %.3ems\n", cputime*1000.0 );
-	
-
-	nWSR = 500;
-	cputime = 20.0;
-	MpcConstraintProduct myCP( nV,nC,2,A );
-	QProblem qpCP( nV,nC );
-	qpCP.setOptions( myOptions );
-	qpCP.setConstraintProduct( &myCP );
-	qpCP.init( H,&(g[k*nV]),A,&(lb[k*nV]),&(ub[k*nV]),&(lbA[k*nC]),&(ubA[k*nC]),nWSR,&cputime );
-	qpCP.getPrimalSolution( xOptCP );
-	qpCP.getDualSolution( yOptCP );
-	printf( "cputime with    constraintProduct: %.3ems\n", cputime*1000.0 );
-	
-	delete[] ubA;
-	delete[] lbA;
-	delete[] ub;
-	delete[] lb;
-	delete[] A;
-	delete[] g;
-	delete[] H;
-
-	for( int ii=0; ii<nV; ++ii )
-		QPOASES_TEST_FOR_NEAR( xOptCP[ii],xOpt[ii] );
-
-	for( int ii=0; ii<nV+nC; ++ii )
-		QPOASES_TEST_FOR_NEAR( yOptCP[ii],yOpt[ii] );
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct2.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct2.cpp
deleted file mode 100644
index 8ae27cb..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_constraintProduct2.cpp
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_constraintProduct2.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Another example for testing qpOASES using the possibility to specify 
- *	user-defined constraint product function.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-
-USING_NAMESPACE_QPOASES
-
-
-/** 
- *	\brief Example illustrating the use of the \a ConstraintProduct class.
- *
- *	Example illustrating the use of the \a ConstraintProduct class.
- *
- *	\author Hans Joachim Ferreau
- *	\version 3.1
- *	\date 2007-2015
- */
-class MpcConstraintProduct : public ConstraintProduct
-{
-	public:
-		/** Default constructor. */
-		MpcConstraintProduct( ) {};
-
-		/** Constructor. */
-		MpcConstraintProduct(	int_t _nV,
-								int_t _nC,
-								int_t _diagOffset,
-								real_t* _A
-								)
-		{
-			nV = _nV;
-			nC = _nC;
-			diagOffset = _diagOffset;
-			A  = _A;
-		};
-
-		/** Copy constructor (flat copy). */
-		MpcConstraintProduct(	const MpcConstraintProduct& rhs
-								)
-		{
-			nV = rhs.nV;
-			nC = rhs.nC;
-			diagOffset = rhs.diagOffset;
-			A  = rhs.A;
-		};
-
-		/** Destructor. */
-		virtual ~MpcConstraintProduct( ) {};
-		
-		/** Assignment operator (flat copy). */
-		MpcConstraintProduct& operator=(	const MpcConstraintProduct& rhs
-										)
-		{
-			if ( this != &rhs )
-			{
-				nV = rhs.nV;
-				nC = rhs.nC;
-				diagOffset = rhs.diagOffset;
-				A  = rhs.A;
-			}
-			else
-				return *this;
-		};
-
-		virtual int_t operator() (	int_t constrIndex,
-									const real_t* const x,
-									real_t* const constrValue
-									) const
-		{
-			int_t i;
-			int_t maxI = (int_t)(((real_t)constrIndex) * ((real_t)nV) / ((real_t)nC)) + diagOffset;
-			maxI = getMin( maxI,nV );
-
-			constrValue[0] = 0.0;
-
-			for( i=0; i<maxI; ++i )
-				constrValue[0] += A[constrIndex*nV + i] * x[i];
-
-			return 0;
-		};
-
-	protected:
-		int_t nV;			/**< Number of variables. */
-		int_t nC;			/**< Number of constraints. */
-		int_t diagOffset;	/**< ... */
-		real_t* A;			/**< Pointer to full constraint matrix (typically not needed!). */
-		
-};
-
-
-/**	Example for qpOASES main function using the possibility to specify 
- *	user-defined constraint product function. */
-int main( )
-{
-	int_t nQP, nV, nC, nEC;
-	real_t *H, *g, *A, *lb, *ub, *lbA, *ubA;
-	real_t cputime;
-	
-	real_t xOpt[1000];
-	real_t yOpt[1000];
-	real_t xOptCP[1000+1000];
-	real_t yOptCP[1000+1000];
-		
-	const char* path = "./cpp/data/oqp/diesel/";
-	int_t k = 200; //th problem
-	
-	
-	if ( readOqpDimensions(	path, nQP,nV,nC,nEC ) != SUCCESSFUL_RETURN )
-		return TEST_DATA_NOT_FOUND;
-
-	readOqpData(	path, nQP,nV,nC,nEC,
-					&H,&g,&A,&lb,&ub,&lbA,&ubA,
-					0,0,0
-					);
-	
-	Options myOptions;
-	myOptions.setToMPC();
-	myOptions.printLevel = PL_LOW;
-	
-	int_t nWSR = 500;
-	cputime = 10.0;
-	QProblem qp( nV,nC );
-	qp.setOptions( myOptions );
-	qp.init( H,&(g[k*nV]),A,&(lb[k*nV]),&(ub[k*nV]),&(lbA[k*nC]),&(ubA[k*nC]),nWSR,&cputime );
-	qp.getPrimalSolution( xOpt );
-	qp.getDualSolution( yOpt );
-	printf( "cputime without constraintProduct: %.3ems\n", cputime*1000.0 );
-	
-	
-	nWSR = 500;
-	cputime = 10.0;
-	MpcConstraintProduct myCP( nV,nC,1,A );
-	QProblem qpCP( nV,nC );
-	qpCP.setOptions( myOptions );
-	qpCP.setConstraintProduct( &myCP );
-	qpCP.init( H,&(g[k*nV]),A,&(lb[k*nV]),&(ub[k*nV]),&(lbA[k*nC]),&(ubA[k*nC]),nWSR,&cputime );
-	qpCP.getPrimalSolution( xOptCP );
-	qpCP.getDualSolution( yOptCP );
-	printf( "cputime without constraintProduct: %.3ems\n", cputime*1000.0 );
-	
-	delete[] ubA;
-	delete[] lbA;
-	delete[] ub;
-	delete[] lb;
-	delete[] A;
-	delete[] g;
-	delete[] H;
-	
-	for( int_t ii=0; ii<nV; ++ii )
-		QPOASES_TEST_FOR_NEAR( xOptCP[ii],xOpt[ii] );
-
-	for( int_t ii=0; ii<nV+nC; ++ii )
-		QPOASES_TEST_FOR_NEAR( yOptCP[ii],yOpt[ii] );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example1.cpp
deleted file mode 100644
index 9c32536..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1.cpp
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES (using QProblem class).
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up QProblem object. */
-	QProblem example( 2,1 );
-
-	Options options;
-	example.setOptions( options );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1a.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example1a.cpp
deleted file mode 100644
index 925307d..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1a.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example1a.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES using the SQProblem class.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the SQProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up SQProblem object. */
-	SQProblem example( 2,1 );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1b.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example1b.cpp
deleted file mode 100644
index 05a6d98..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example1b.cpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example1b.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Very simple example for testing qpOASES using the QProblemB class.
- */
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the QProblemB class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-
-
-	/* Setting up QProblemB object. */
-	QProblemB example( 2 );
-
-	Options options;
-	//options.enableFlippingBounds = BT_FALSE;
-	options.initialStatusBounds = ST_INACTIVE;
-	options.numRefinementSteps = 1;
-	options.enableCholeskyRefactorisation = 1;
-	example.setOptions( options );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,lb,ub, nWSR,0 );
-// 	printf( "\nnWSR = %d\n\n", nWSR );
-
-	real_t xOpt[2];
-	real_t yOpt[2];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new, nWSR,0 );
-// 	printf( "\nnWSR = %d\n\n", nWSR );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example2.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example2.cpp
deleted file mode 100644
index 9caf502..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example2.cpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example2.cpp
- *	\author Hans Joachim Ferreau (thanks to Boris Houska)
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Very simple example for testing qpOASES in combination
- *  with the SolutionAnalysis class.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the SolutionAnalysis class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t H_new[2*2] = { 1.0, 0.5, 0.5, 0.5 };
-	real_t A_new[1*2] = { 1.0, 5.0 };
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up SQProblem object and solution analyser. */
-	SQProblem example( 2,1 );
-	SolutionAnalysis analyser;
-
-	/* Solve first QP ... */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	/* ... and analyse it. */
-	real_t maxKktViolation = analyser.getKktViolation( &example );
-    printf( "maxKktViolation: %e\n", maxKktViolation );
-
-	QPOASES_TEST_FOR_TOL( maxKktViolation,1e-15 );
-
-
-	/* Solve second QP ... */
-	nWSR = 10;
-	example.hotstart( H_new,g_new,A_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-	/* ... and analyse it. */
-	maxKktViolation = analyser.getKktViolation( &example );
-    printf( "maxKktViolation: %e\n", maxKktViolation );
-
-	QPOASES_TEST_FOR_TOL( maxKktViolation,1e-15 );
-
-
-//  ------------ VARIANCE-COVARIANCE EVALUATION --------------------
-
-        real_t *Var              = new real_t[5*5];
-        real_t *Primal_Dual_Var  = new real_t[5*5];
-
-        int_t run1, run2;
-        for( run1 = 0; run1 < 5*5; run1++ )
-            Var[run1] = 0.0;
-
-        Var[0] = 1.0;
-        Var[6] = 1.0;
-
-//                  (  1   0   0   0   0   )
-//                  (  0   1   0   0   0   )
-//     Var     =    (  0   0   0   0   0   )
-//                  (  0   0   0   0   0   )
-//                  (  0   0   0   0   0   )
-
-
-        analyser.getVarianceCovariance( &example, Var,Primal_Dual_Var );
-
-        printf("\nPrimal_Dual_VAR = \n");
-        for( run1 = 0; run1 < 5; run1++ ){
-          for( run2 = 0; run2 < 5; run2++ ){
-            printf(" %10f", Primal_Dual_Var[run1*5+run2]);
-          }
-          printf("\n");
-        }
-
-        delete[] Primal_Dual_Var;
-        delete[] Var;
-
-		QPOASES_TEST_FOR_NEAR( Primal_Dual_Var[3*5+3], 26.0 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example4.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example4.cpp
deleted file mode 100644
index 98b320c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example4.cpp
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example4.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2009-2015
- *
- *	Very simple example for testing qpOASES (using the possibility to specify 
- *	user-defined constraint product function).
- */
-
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "../../examples/example4CP.cpp"
-#include <qpOASES/UnitTesting.hpp>
-
-
-/**	Example for qpOASES main function using the possibility to specify 
- *	user-defined constraint product function. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t i,j;
-
-	/* Setup data of first QP... */
-	real_t H[7*7];
-	real_t A[50*7];
-	real_t g[7];
-	real_t lbA[50];
-
-	/*	    ( 1.0 0.5 |                    )
-	 *	    ( 0.5 2.0 |                    )
-	 *	    ( --------+------------------- )
-	 *	H = (         | 1e-6               )
-	 *	    (         |      1e-6          )
-	 *	    (         |           ...      )
-	 *	    (         |               1e-6 ) */
-	for( i=0; i<7*7; ++i )
-		H[i] = 0.0;
-	for( i=2; i<7; ++i )
-		H[i*7+i] = 1.0e-6;
-	H[0] = 1.0;
-	H[1] = 0.5;
-	H[7] = 0.5;
-	H[8] = 2.0;
-
-	/*	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x | ...             )
-	 *	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x |     1.0         )
-	 *	A = ( x.x x.x |     ...         )
-	 *	    ( x.x x.x |     1.0         )
-	 *	    ( x.x x.x |         ...     )
-	 *	    ( x.x x.x |             1.0 )
-	 *	    ( x.x x.x |             ... )
-	 *	    ( x.x x.x |             1.0 ) */
-	for( i=0; i<50*7; ++i )
-		A[i] = 0.0;
-	for( i=0; i<50; ++i )
-	{
-		for( j=0; j<2; ++j )
-			A[i*7+j] = (real_t)rand() / (real_t)RAND_MAX;
-
-		A[i*7 + (i/10)+2] = 1.0;
-	}
-
-	/*	    ( -1.0 )
-	 *	    ( -0.5 )
-	 *	    ( ---- )
-	 *	g = (      )
-	 *	    (      )
-	 *	    (      )
-	 *	    (      ) */
-	for( i=0; i<7; ++i )
-		g[i] = 0.0;
-	g[0] = -1.0;
-	g[1] = -0.5;
-
-	for( i=0; i<50; ++i )
-		lbA[i] = 1.0;
-
-	/* ... and setting up user-defined constraint product function. */
-	MyConstraintProduct myCP( 7,50,A );
-
-
-	/* Setting up QProblem object and set construct product function. */
-	QProblem exampleCP( 7,50 );
-	exampleCP.setPrintLevel( PL_NONE );
-	
-	exampleCP.setConstraintProduct( &myCP );
-
-
-	/* Solve first QP. */
-	real_t cputime = 1.0;
-	int_t nWSR = 100;
-	exampleCP.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-
-
-	/* Solve second QP using a modified gradient. */
-	g[0] = -2.0;
-	g[1] =  0.5;
-
-	cputime = 1.0;
-	nWSR = 100;
-	exampleCP.hotstart( g,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of second QP. */
-	real_t xOptCP[7];
-	real_t yOptCP[7+50];
-	exampleCP.getPrimalSolution( xOptCP );
-	exampleCP.getDualSolution( yOptCP );
-	printf( "\nxOpt = [ %e, %e, %e ... ];  objVal = %e\n", xOptCP[0],xOptCP[1],xOptCP[2],exampleCP.getObjVal() );
-	printf( "CPU time:  %.3f microseconds\n\n", cputime*1.0e6 ); 
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzerCP;
-
-	analyzerCP.getKktViolation( &exampleCP, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-	
-	
-	/* Do the same without specifying constraint product. */
-	QProblem example( 7,50 );
-	example.setPrintLevel( PL_NONE );
-	
-	/* Solve first QP. */
-	g[0] = -1.0;
-	g[1] = -0.5;
-	
-	cputime = 1.0;
-	nWSR = 100;
-	example.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-	
-	/* Solve second QP using a modified gradient. */
-	g[0] = -2.0;
-	g[1] =  0.5;
-
-	cputime = 1.0;
-	nWSR = 100;
-	example.hotstart( g,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[7];
-	real_t yOpt[7+50];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e, %e ... ];  objVal = %e\n", xOpt[0],xOpt[1],xOpt[2],example.getObjVal() );
-	printf( "CPU time:  %.3f microseconds\n\n", cputime*1.0e6 ); 
-
-	/* Compute KKT tolerances */
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	for( int_t ii=0; ii<7; ++ii )
-		QPOASES_TEST_FOR_NEAR( xOptCP[ii],xOpt[ii] );
-
-	for( int_t ii=0; ii<7+50; ++ii )
-		QPOASES_TEST_FOR_NEAR( yOptCP[ii],yOpt[ii] );
-
-	QPOASES_TEST_FOR_NEAR( exampleCP.getObjVal(),example.getObjVal() );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example5.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example5.cpp
deleted file mode 100644
index 452cdda..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example5.cpp
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example5.cpp
- *	\author Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2011-2015
- *
- *	Very simple example for testing qpOASES (using the possibility to
- *  compute the local linear feedback law)
- */
-
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include "../../examples/example4CP.cpp"
-#include <qpOASES/UnitTesting.hpp>
-
-
-/**	Example for qpOASES main function using the possibility to specify
- *	user-defined constraint product function. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t i,j,jj;
-	real_t d = 0.0;
-
-	/* Setup data of first QP... */
-	real_t H[7*7];
-	real_t A[50*7];
-	real_t g[7];
-	real_t lbA[50];
-
-	/*	    ( 1.0 0.5 |                    )
-	 *	    ( 0.5 2.0 |                    )
-	 *	    ( --------+------------------- )
-	 *	H = (         | 1e-6               )
-	 *	    (         |      1e-6          )
-	 *	    (         |           ...      )
-	 *	    (         |               1e-6 ) */
-	for( i=0; i<7*7; ++i )
-		H[i] = 0.0;
-	for( i=2; i<7; ++i )
-		H[i*7+i] = 1.0e-6;
-	H[0] = 1.0;
-	H[1] = 0.5;
-	H[7] = 0.5;
-	H[8] = 2.0;
-
-	/*	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x | ...             )
-	 *	    ( x.x x.x | 1.0             )
-	 *	    ( x.x x.x |     1.0         )
-	 *	A = ( x.x x.x |     ...         )
-	 *	    ( x.x x.x |     1.0         )
-	 *	    ( x.x x.x |         ...     )
-	 *	    ( x.x x.x |             1.0 )
-	 *	    ( x.x x.x |             ... )
-	 *	    ( x.x x.x |             1.0 ) */
-	for( i=0; i<50*7; ++i )
-		A[i] = 0.0;
-	for( i=0; i<50; ++i )
-	{
-		for( j=0; j<2; ++j )
-			A[i*7+j] = (real_t)rand() / (real_t)RAND_MAX;
-
-		A[i*7 + (i/10)+2] = 1.0;
-	}
-
-	/*	    ( -1.0 )
-	 *	    ( -0.5 )
-	 *	    ( ---- )
-	 *	g = (      )
-	 *	    (      )
-	 *	    (      )
-	 *	    (      ) */
-	for( i=0; i<7; ++i )
-		g[i] = 0.0;
-	g[0] = -1.0;
-	g[1] = -0.5;
-
-	for( i=0; i<50; ++i )
-		lbA[i] = 1.0;
-
-	/* ... and setting up user-defined constraint product function. */
-	MyConstraintProduct myCP( 7,50,A );
-
-
-	/* Setting up QProblem object and set construct product function. */
-	QProblem example( 7,50 );
-	example.setConstraintProduct( &myCP );
-
-
-	/* Solve first QP. */
-	real_t cputime = 1.0;
-	int_t nWSR = 100;
-	example.init( H,g,A,0,0,lbA,0, nWSR,&cputime );
-
-	/* Get and print solution of QP. */
-	real_t xOpt[7], yOpt[7+50];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-
-
-	/* Compute local linear feedback law */
-	const int_t n_rhs = 7+7+50;
-	real_t g_in[7*n_rhs];
-	real_t b_in[7*n_rhs];
-	real_t bA_in[50*n_rhs];
-	real_t x_out[7*n_rhs];
-	real_t y_out[(7+50)*n_rhs];
-
-	int_t ii;
-	memset (g_in, 0, sizeof (g_in));
-	memset (b_in, 0, sizeof (b_in));
-	memset (bA_in, 0, sizeof (bA_in));
-
-	for ( ii = 0; ii < 7; ++ii )
-		g_in[ii*7 + ii] = 1.0;
-	for ( ii = 0; ii < 7; ++ii )
-		b_in[(ii+7)*7 + ii] = 1.0;
-	for ( ii = 0; ii < 50; ++ii )
-		bA_in[(ii+14)*50 + ii] = 1.0;
-
-	example.solveCurrentEQP ( n_rhs, g_in, b_in, b_in, bA_in, bA_in, x_out, y_out );
-
-	/* Verify validity of local feedback law by perturbation and hot starts */
-	real_t perturb = 1.0e-6;
-	real_t nrm = 0.0;
-	for ( ii = 0; ii < n_rhs; ++ii )
-	{
-		for ( jj = 0; jj < 7; ++jj )
-			g_in[ii*7 + jj] = g[jj] + g_in[ii*7+jj]*perturb;
-		for ( jj = 0; jj < 50; ++jj )
-			bA_in[ii*50 + jj] = lbA[jj] + bA_in[ii*50+jj]*perturb;
-
-		nWSR = 100;
-		example.hotstart( &g_in[ii*7],0,0,&bA_in[ii*50],0, nWSR, 0 );
-
-		real_t xPer[7], yPer[7+50];
-		example.getPrimalSolution( xPer );
-		example.getDualSolution( yPer );
-
-		for ( jj = 0; jj < 7; ++jj )
-		{
-			d = getAbs (x_out[ii*7+jj]*perturb - (xPer[jj]-xOpt[jj]) );
-			if (nrm < d) nrm=d;
-		}
-		for ( jj = 0; jj < 7+50; ++jj )
-		{
-			d = getAbs (y_out[ii*(7+50)+jj]*perturb - (yPer[jj]-yOpt[jj]) );
-			if (nrm < d) nrm=d;
-		}
-	}
-	printf ("Maximum perturbation over all directions: %e\n", nrm);
-
-	QPOASES_TEST_FOR_TOL( nrm,1e-15 );
-
-
-	/* // print feedback matrix
-	for (ii = 0; ii < n_rhs; ++ii)
-	{
-		printf ("x: ");
-		for (jj = 0; jj < 7; ++jj )
-			printf ("%8.2e ", x_out[ii*7+jj]);
-		printf (" y: ");
-		for (jj = 0; jj < 7+50; ++jj )
-			printf ("%8.2e ", y_out[ii*(7+50)+jj]);
-		printf("\n");
-	}
-*/
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example6.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example6.cpp
deleted file mode 100644
index d85c0aa..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example6.cpp
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example6.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Example that caused troubles in an earlier release.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[5*5] = {	1.224642131370767e+01, 2.908638763113702e+00, 0.0, 0.0, 0.0,
-						2.908638763113702e+00, 2.497106275003180e+00, 0.0, 0.0, 0.0,
-						0.0, 0.0, 1.0, 0.0, 0.0,
-						0.0, 0.0, 0.0, 5.158460640334052e-02, 4.723556059962540e-02,
-						0.0, 0.0, 0.0, 4.723556059962540e-02, 4.325317843302175e-02 };
-	real_t A[2*5] = { 	-1.404358970692652e+00, -2.556613491156063e+00, 3.202524559238066e+00, -1.0, 0.0,
-						6.587910295430314e-01, -5.349454475937998e-01, 4.391976356955536e-01, 0.0, -1.0 };
-	real_t g[5] = { 	2.474135331302147e+01,
-						5.857286430296258e+00,
-						2.359382646348721e-01,
-						1.721047069188781e-01,
-						1.575947337774199e-01 };
-	real_t lb[5] = { -10.0, -10.0, -10.0, -10.0, -10.0 };
-	real_t ub[5] = {  10.0,  10.0,  10.0,  10.0,  10.0 };
-	real_t lbA[2] = { 1.643135416077167e+00, 1.056813028189597e+00 };
-	real_t ubA[2] = { 1.643135416077167e+00, 1.056813028189597e+00 };
-
-	/* Setting up QProblem object. */
-	QProblem example( 5,2 );
-
-	Options options;
- 	//options.enableFlippingBounds = BT_FALSE;
-	//options.enableEqualities = BT_TRUE;
-	//options.initialStatusBounds = ST_INACTIVE;
-	example.setOptions( options );
-	example.setPrintLevel( PL_NONE );
-	
-	/* Solve first QP. */
-	returnValue retVal;
-	int_t simpleStatus = -1;
-
-	int_t nWSR = 10;
-	retVal = example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-	simpleStatus = getSimpleStatus( retVal,BT_TRUE );
-
-	QPOASES_TEST_FOR_TRUE( simpleStatus == 0 );
-
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[5];
-	real_t yOpt[5+2];
-	
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e, ... ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-14 );
-	QPOASES_TEST_FOR_TOL( feas,1e-14 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_example7.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_example7.cpp
deleted file mode 100644
index cd026cc..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_example7.cpp
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_example7.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Example that caused troubles in an earlier release.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	real_t H[5*5] = {0.8514828085899353, -0.15739890933036804, -0.081726007163524628, -0.530426025390625, 0.16773293912410736, -0.15739890933036804, 1.1552412509918213, 0.57780224084854126, -0.0072606131434440613, 0.010559185408055782, -0.081726007163524628, 0.57780224084854126, 0.28925251960754395, 5.324830453901086e-006, -3.0256599075073609e-006, -0.530426025390625, -0.0072606131434440613, 5.324830453901086e-006, 0.35609596967697144, -0.15124998986721039, 0.16773293912410736, 0.010559185408055782, -3.0256599075073609e-006, -0.15124998986721039, 0.15129712224006653};
-	real_t g[5] = {0.30908384919166565, 0.99325823783874512, 0.49822014570236206, -0.26309865713119507, 0.024296050891280174};
-	real_t A[5*5] =   {1,0,0,0,0,
-					   0,1,0,0,0,
-					   0,0,1,0,0,              
-					   0,0,0,1,0,
-					   0,0,0,0,1};
-	real_t lb[5] = {-0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359938621520996};
-	real_t ub[5] = { 0.052359879016876221, 0.052359879016876221, 0.052359879016876221, 0, 0};
-	real_t lbA[5] = {-0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359879016876221, -0.052359938621520996};
-	real_t ubA[5] = {0.052359879016876221, 0.052359879016876221, 0.052359879016876221, 0, 0};
-
-	/* Setting up QProblem object. */
-	QProblem example( 5,5 );
-
-	/* Solve first QP. */
-	int_t nWSR = 100;
-	returnValue retVal = example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-	printf( "nWSR = %d,  retVal = %d (%s)\n", (int)nWSR,retVal,getGlobalMessageHandler( )->getErrorCodeMessage(retVal) );
-	
-	
-	real_t sol[5]    = {0};
-	real_t yOpt[5+5] = {0};
-	example.getPrimalSolution(sol);
-	example.getDualSolution(yOpt);
-	
-	printf("l1 = %f, l2 = %f, l3 = %f, l4 = %f, l5 = %f\n",(float) lb[0], (float) lb[1], (float) lb[2], (float) lb[3], (float) lb[4]);
-	printf("x1 = %f, x2 = %f, x3 = %f, x4 = %f, x5 = %f\n",(float) sol[0], (float) sol[1], (float) sol[2], (float) sol[3], (float) sol[4]);
-	printf("u1 = %f, u2 = %f, u3 = %f, u4 = %f, u5 = %f\n",(float) ub[0], (float) ub[1], (float) ub[2], (float) ub[3], (float) ub[4]);
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_exampleLP.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_exampleLP.cpp
deleted file mode 100644
index 5057746..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_exampleLP.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_exampleLP.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2008-2015
- *
- *	Very simple example for solving a LP sequence using qpOASES.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function solving LPs. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	real_t tol = 1e-14;
-
-	/* Setup data of first LP. */
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second LP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-
-
-	/* Setting up QProblem object with zero Hessian matrix. */
-	QProblem example( 2,1,HST_ZERO );
-
-	Options options;
- 	/*options.setToMPC();*/
-	example.setOptions( options );
-
-	/* Solve first LP. */
-	int_t nWSR = 10;
-	example.init( 0,g,A,lb,ub,lbA,ubA, nWSR,0 );
-
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-	printf( "%d\n",example.getHessianType() );
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,tol );
-	QPOASES_TEST_FOR_TOL( feas,tol );
-	QPOASES_TEST_FOR_TOL( cmpl,tol );
-
-
-	/* Solve second LP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR,0 );
-
-
-	/* Get and print solution of second LP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],example.getObjVal() );
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,tol );
-	QPOASES_TEST_FOR_TOL( feas,tol );
-	QPOASES_TEST_FOR_TOL( cmpl,tol );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_externalChol1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_externalChol1.cpp
deleted file mode 100644
index eb32987..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_externalChol1.cpp
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_externalChol1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2015
- *
- *	Very simple example for testing qpOASES using the QProblem class
- *	and providing a pre-computed Cholesky factor of the Hessian matrix.
- */
-
-
-
-#include <qpOASES.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.5 };
-	real_t A[1*2] = { 1.0, 1.0 };
-	real_t g[2] = { 1.5, 1.0 };
-	real_t lb[2] = { 0.5, -2.0 };
-	real_t ub[2] = { 5.0, 2.0 };
-	real_t lbA[1] = { -1.0 };
-	real_t ubA[1] = { 2.0 };
-
-	/* Setup data of second QP. */
-	real_t g_new[2] = { 1.0, 1.5 };
-	real_t lb_new[2] = { 0.0, -1.0 };
-	real_t ub_new[2] = { 5.0, -0.5 };
-	real_t lbA_new[1] = { -2.0 };
-	real_t ubA_new[1] = { 1.0 };
-	
-	real_t R[2*2] = { sqrt(1.0), 0.0, 0.0, sqrt(0.5) };
-
-
-	/* Setting up QProblem object. */
-	QProblem example( 2,1 );
-
-	Options options;
-	example.setOptions( options );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0, 0,0,0,0, R );
-
-	/* Get and print solution of first QP. */
-	real_t xOpt[2];
-	real_t yOpt[2+1];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-	
-	/* Solve second QP. */
-	nWSR = 10;
-	example.hotstart( g_new,lb_new,ub_new,lbA_new,ubA_new, nWSR );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf( "\nxOpt = [ %e, %e ];  yOpt = [ %e, %e, %e ];  objVal = %e\n\n", 
-			xOpt[0],xOpt[1],yOpt[0],yOpt[1],yOpt[2],example.getObjVal() );
-
-	example.printOptions();
-	/*example.printProperties();*/
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_gradientShift.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_gradientShift.cpp
deleted file mode 100644
index 200b093..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_gradientShift.cpp
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2009 by Hans Joachim Ferreau et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_gradientShift.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Simple test case which caused troubles in version 2.0.
- */
-
- 
-
-#include <math.h>
-#include <iostream>
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Running simple test case which caused troubles in version 2.0. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	
-	real_t H[2*2] 	= { 0.055944055944055944,0, 0, 0 };
-	real_t A[1*2] 	= { 0.70514808036997589, -1 };
-	//real_t g[2]	= { -15.830543073928741, 0};
-	real_t g[2]		= { 0, 0 };
-	real_t lb[2]	= { 137.00242299940646, 154.0 };
-	real_t ub[2]	= { 282.19008595111382, 198.98579740786641};
-	real_t lbA[1]	= {0.0};
-	real_t ubA[1]	= {0.0};
-	
-	real_t gStart=-16.4;
- 
-	/* Setting up QProblem object. */
-	QProblem example( 2,1 );
-	Options options;
-	options.setToMPC();
-	options.printLevel = REFER_NAMESPACE_QPOASES PL_NONE;
-	example.setOptions( options );
-	
-	returnValue ret;
-	int_t nWSR = 10;
-	real_t Xopt[2]={0.0,0.0};
-	//fprintf(stdFile, "g[0]\t,\tReturn code\n");
-	int_t errorCount=0;
-	int_t i=0;
-	real_t granularity=0.00001;
-	g[0]=gStart;
-	for( i=0; i< 70000; i++)
-	{
-
-		g[0] += granularity;
-		/* Solve first QP. */
-		nWSR = 10;
-		ret= example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-		if (ret != SUCCESSFUL_RETURN)
-		{
-			//fprintf(stdFile, "%f\t,\t%d\n",g[0],ret);
-			errorCount++;
-		}
-		//fprintf(stdFile, "%f\t,\t%d\n",g[0],ret);
-	}
-	example.printProperties();
-	fprintf( stdFile, "#Number of optimizer runs: %d\n",(int)i );
-	fprintf( stdFile, "#g[0] test interval: %f < g[0] < %f\n",gStart,g[0] );
-	fprintf( stdFile, "#Granularity: %f\n",granularity);
-	real_t errorPercent = real_t(errorCount)/real_t(i)*100.0;
-	fprintf( stdFile, "#Number of errors (error): %d (%f)\n",(int)errorCount,errorPercent );
-
-	example.getPrimalSolution(Xopt);
-	fprintf( stdFile,"#Optimization primary result : LD=%f BD=%f\n",Xopt[0], Xopt[1]);
-
-	real_t Yopt[3]={0.0,0.0,0.0};
-	example.getDualSolution(Yopt);
-	fprintf( stdFile,"#Optimization dual result : %f %f %f8\n",Yopt[0], Yopt[1], Yopt[2]);
-
-	int_t Nc=0;
-	Nc=example.getNC();
-	fprintf( stdFile,"#Number of constraints : %d\n",(int)Nc );
-
-	int_t Nec=0;
-	Nec=example.getNEC();
-	fprintf( stdFile,"#Number of equality constraints : %d\n",(int)Nec );
-
-	int_t Nac=0;
-	Nac=example.getNAC();
-	fprintf( stdFile,"#Number of active constraints : %d\n",(int)Nac );
-
-	int_t Niac=0;
-	Niac=example.getNIAC();
-	fprintf( stdFile,"#Number of inactive constraints : %d\n",(int)Niac );
-
-	QPOASES_TEST_FOR_TRUE( errorCount == 0 )
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_guessedWS1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_guessedWS1.cpp
deleted file mode 100644
index 61cb9ad..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_guessedWS1.cpp
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_guessedWS1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Very simple example for testing qpOASES (using QProblem class).
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[4*4] = { 1.0, 0.0, 0.0, 0.5, 
-	                  0.0, 1.0, 0.0, 0.0,
-	                  0.0, 0.0, 1.0, 0.0,
-	                  0.5, 0.0, 0.0, 1.0 };
-	real_t A[3*4] = { 1.0, 1.0, 0.0, 0.0,
-	                  1.0, 1.0, 1.0, 0.0,
-	                  1.0, 1.0, 1.0, 1.0 };
-	real_t g[4] = { 1.5, 1.0, -1.0, -1.0 };
-	real_t lb[4] = { 0.5, -2.0, 0.0, 0.0 };
-	real_t ub[4] = { 1.0, 2.0, 1.0, 0.5 };
-	real_t lbA[3] = { -1.0, -1.0, -1.0 };
-	real_t ubA[3] = { 0.0, 0.25, 1.0 };
-
-	
-
-	/* Setting up QProblem object. */
-	QProblem example( 4,3 );
-
-	Options options;
-	example.setOptions( options );
-
-	/* Solve first QP. */
-	int_t nWSR = 10;
-	example.init( H,g,A,lb,ub,lbA,ubA, nWSR );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[4];
-	real_t yOpt[4+3];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	print( xOpt,4,"xOpt" );
-	print( yOpt,4+3,"yOpt" );
-	printf( "objVal = %e\n\n", example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-	/* Solve first QP again (with optimal guess for working set). */
-	Bounds prevBounds;
-	Constraints prevConstraints;
-	
-	example.getBounds( prevBounds );
-	example.getConstraints( prevConstraints );
-
-	nWSR = 10;
-	example.hotstart( g,lb,ub,lbA,ubA, nWSR,0,&prevBounds,&prevConstraints );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	print( xOpt,4,"xOpt" );
-	print( yOpt,4+3,"yOpt" );
-	printf( "objVal = %e\n\n", example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-	/* Solve first QP again (with inaccurate guess for working set). */
-	prevBounds.print();
-	prevBounds.rotate(1);
-	//prevBounds.moveFixedToFree(0);
-	prevBounds.print();
-
-	prevConstraints.print();
-	//prevConstraints.moveInactiveToActive(0,ST_LOWER);
-	prevConstraints.moveActiveToInactive(1);
-	prevConstraints.print();
-
-	nWSR = 10;
-	example.hotstart( g,lb,ub,lbA,ubA, nWSR,0,&prevBounds,&prevConstraints );
-
-	/* Get and print solution of second QP. */
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	print( xOpt,4,"xOpt" );
-	print( yOpt,4+3,"yOpt" );
-	printf( "objVal = %e\n\n", example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-15 );
-	QPOASES_TEST_FOR_TOL( feas,1e-15 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_hs268.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_hs268.cpp
deleted file mode 100644
index eb0a3f7..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_hs268.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_hs268.cpp
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2010-2015
- *
- *	Unit test running all benchmark examples stored in problems directory.
- */
-
-
-
-#include <dirent.h>
-#include <cstring>
-#include <cstdlib>
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Run benchmark examples. */
-int main( int argc, char *argv[] )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* 1) Define benchmark arguments. */
-	BooleanType isSparse = BT_FALSE;
-	//BooleanType isSparse = BT_TRUE;
-	Options options;
- 	options.setToDefault();
-	//options.setToMPC();
-	//options.setToReliable();
-	//options.printLevel = PL_LOW;
-	//options.printLevel = PL_MEDIUM;
-	options.printLevel = PL_TABULAR;
-
-
-	int_t nWSR;
-	int_t npass = 0;
-	real_t maxCPUtime; /* seconds */
-	real_t maxStationarity = 0.0, maxFeasibility = 0.0, maxComplementarity = 0.0;
-
-	char oqpProblem[MAX_STRING_LENGTH];
-	char problem[] = "HS268";
-	returnValue returnvalue;
-
-	
-	/* 3) Run benchmark. */
-	fprintf(stdFile, "%-10s ", problem);
-	fflush(stdFile);
-
-	snprintf(oqpProblem, MAX_STRING_LENGTH, "../testing/cpp/data/problems/%s/", problem);
-	maxCPUtime = 100.0;
-	nWSR = 100;
-
-	returnvalue = runOqpBenchmark(	oqpProblem, isSparse, options,
-									nWSR, maxCPUtime, maxStationarity, maxFeasibility, maxComplementarity 
-									);
-
-	if(returnvalue == SUCCESSFUL_RETURN) {
-		npass += 1;
-	}
-
-	QPOASES_TEST_FOR_TRUE( npass >= 1 );
-
-	printf( "\n" );
-	printf( "stat:  %e\n", maxStationarity    );
-	printf( "feas:  %e\n", maxFeasibility     );
-	printf( "cmpl:  %e\n", maxComplementarity );
-
-	QPOASES_TEST_FOR_TOL( maxStationarity,    1e-11 );
-	QPOASES_TEST_FOR_TOL( maxFeasibility,     1e-14 );
-	QPOASES_TEST_FOR_TOL( maxComplementarity, 1e-14 );
-
-
-	return 0;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_indexlist.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_indexlist.cpp
deleted file mode 100644
index 9c80f92..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_indexlist.cpp
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_indexlist.cpp
- *	\author Andreas Potschka, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2010-2015
- *
- *	Unit test for Indexlist class.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Test Indexlist sorting */
-int main()
-{
-	USING_NAMESPACE_QPOASES
-
-	Indexlist il(10);
-	int_t i, *numbers;
-
-	il.addNumber(1);
-	il.addNumber(3);
-	il.addNumber(5);
-	il.addNumber(2);
-	il.addNumber(4);
-	il.addNumber(0);
-	il.addNumber(7);
-	il.addNumber(6);
-	il.addNumber(8);
-	il.addNumber(9);
-
-	il.getNumberArray(&numbers);
-	fprintf(stdFile, "Unsorted numbers: ");
-	for (i = 0; i < 10; i++)
-		fprintf(stdFile, " %2d", (int)(numbers[i]) );
-	fprintf(stdFile, "\n");
-
-	fprintf(stdFile, "Unsorted index of number 0: %3d\n", (int)(il.getIndex(0)) );
-
-	QPOASES_TEST_FOR_TRUE( il.getIndex(0) == 5 )
-
-	il.removeNumber(5);
-	fprintf(stdFile, "Unsorted index of (removed) number 5: %3d\n", (int)(il.getIndex(5)) );
-
-	QPOASES_TEST_FOR_TRUE( il.getIndex(5) == -1 )
-
-	il.getNumberArray(&numbers);
-	fprintf(stdFile, "Unsorted numbers: ");
-	for (i = 0; i < 9; i++)
-		fprintf(stdFile, " %2d", (int)(numbers[i]) );
-	fprintf(stdFile, "\n");
-
-	il.swapNumbers(2, 7);
-
-	il.getNumberArray(&numbers);
-	fprintf(stdFile, "Unsorted numbers: ");
-	for (i = 0; i < 9; i++)
-		fprintf(stdFile, " %2d", (int)(numbers[i]) );
-	fprintf(stdFile, "\n");
-
-	QPOASES_TEST_FOR_TRUE( numbers[2] == 7 )
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_infeasible1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_infeasible1.cpp
deleted file mode 100644
index 85289e9..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_infeasible1.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_infeasible1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2015
- *
- *	Example to test occurence of infeasible QP.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the QProblem class. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* Setup data of first QP. */
-	real_t H[5*5] = {	1.224642131370767e+01, 2.908638763113702e+00, 0.0, 0.0, 0.0,
-						2.908638763113702e+00, 2.497106275003180e+00, 0.0, 0.0, 0.0,
-						0.0, 0.0, 1.0, 0.0, 0.0,
-						0.0, 0.0, 0.0, 5.158460640334052e-02, 4.723556059962540e-02,
-						0.0, 0.0, 0.0, 4.723556059962540e-02, 4.325317843302175e-02 };
-	real_t A[2*5] = { 	-1.404358970692652e+00, -2.556613491156063e+00, 3.202524559238066e+00, -1.0, 0.0,
-						6.587910295430314e-01, -5.349454475937998e-01, 4.391976356955536e-01, 0.0, -1.0 };
-	real_t g[5] = { 	2.474135331302147e+01,
-						5.857286430296258e+00,
-						2.359382646348721e-01,
-						1.721047069188781e-01,
-						1.575947337774199e-01 };
-	real_t lb[5] = {   5.0,  5.0,    8.0,   9.0,   5.0 };
-	real_t ub[5] = {  10.0,  10.0,  10.0,  10.0,  10.0 };
-	real_t lbA[2] = { 1.643135416077167e+00, 1.056813028189597e+00 };
-	real_t ubA[2] = { 1.643135416077167e+00, 1.056813028189597e+00 };
-
-	/* Setting up QProblem object. */
-	QProblem example( 5,2 );
-
-	Options options;
- 	//options.enableFlippingBounds = BT_FALSE;
-	//options.enableEqualities = BT_TRUE;
-	//options.initialStatusBounds = ST_INACTIVE;
-	example.setOptions( options );
-	example.setPrintLevel( PL_NONE );
-	
-	/* Solve first QP. */
-	returnValue retVal;
-	int_t simpleStatus = -1;
-
-	int_t nWSR = 10;
-	retVal = example.init( H,g,A,lb,ub,lbA,ubA, nWSR,0 );
-	simpleStatus = getSimpleStatus( retVal,BT_TRUE );
-
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[5];
-	real_t yOpt[5+2];
-	
-	printf( "getPrimalSolution = %d\n", example.getPrimalSolution( xOpt ) );
-	printf( "getDualSolution   = %d\n", example.getDualSolution( yOpt ) );
-	printf( "\nxOpt = [ %e, %e, %e, %e, %e ];  objVal = %e\n\n", xOpt[0],xOpt[1],xOpt[2],xOpt[3],xOpt[4],example.getObjVal() );
-	
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	
-	getKktViolation( 5,2, H,g,A,lb,ub,lbA,ubA, xOpt,yOpt, stat,feas,cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-	
-	QPOASES_TEST_FOR_TRUE( simpleStatus == -2 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_janick1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_janick1.cpp
deleted file mode 100644
index ea69968..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_janick1.cpp
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_janick1.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- *
- *	Example that causes troubles when hotstarting.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-#include <stdio.h>
-
-
-//#define __MAKE_POS_DEF__
-#undef __MAKE_POS_DEF__
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t nWSR = 100;
-	/* Setting up QProblem object. */
-	SQProblem example( 11,3 );
-
-	Options options;
-	options.setToFast();
-	//options.setToDefault();
-	//options.initialStatusBounds = qpOASES::ST_INACTIVE;
-	example.setOptions( options );
-
-
-	/* Setup data of first QP. */
-	real_t H[11*11] = {
-	6.20100988531485e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-7.43268431723266e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 5.41188294952735e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304826562310e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.01000000000000e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-7.43268431723266e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304826562310e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.73544778892019e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+01
-	};
-	real_t g[11] =	{
-	-1.28196485091041e-07,	 1.13322235104306e-08,	 4.52417455660281e-06,	 1.95881304363781e-07,	 1.61991589634459e-06,	 2.69786724710014e-09,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.18185813270785e+02,	 9.58903285459640e-06,	 3.82276791847511e-06
-	};
-	real_t zLow[11] =	{
-	-1.07876236159966e+01,	-1.00000000002784e+12,	-1.00000000000000e+12,	 0.00000000000000e+00,	-7.00000000000000e+00,	-2.60479553037772e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-4.50000000000000e+01,	-1.00000000000000e+12
-	};
-	real_t zUpp[11] =	{
-	9.99999999989212e+11,	 9.99999999972157e+11,	 1.00000000000000e+12,	 4.68471854329546e+01,	 7.00000000000000e+00,	 9.99999999997395e+11,	 1.00000000000000e+12,	 1.00000000000000e+12,	 0.00000000000000e+00,	 4.50000000000000e+01,	 1.00000000000000e+12
-	};
-	real_t D[11*3] =	{
-	1.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-1.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-1.00000000000000e-02,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00
-	};
-	real_t dLow[3] =	{
-	-1.00000000000000e+12,	-1.00000000000000e+12,	-1.00000000000000e+12
-	};
-	real_t dUpp[3] =	{
-	2.12376384003361e-01,	 4.78762361599664e+00,	 8.95204469622285e-01
-	};
-
-	#ifdef __MAKE_POS_DEF__
-	H[9*11+9] += 30;
-	#endif
-	returnValue status = example.init( H,g,D,zLow,zUpp,dLow,dUpp, nWSR );
-	printf("\nqpOASES_status = %d\n", (int)status );
-
-	/* Get and print solution of first QP. */
-	real_t xOpt[11];
-	real_t yOpt[11+3];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf("first QP:\n");
-	for (int_t ii =0; ii<11; ++ii )	{
-		printf("x[%d] = %.3e\n", (int)ii, xOpt[ii]);
-	}
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "\nstat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-9 );
-	QPOASES_TEST_FOR_TOL( feas,1e-7 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-
-	nWSR = 100;
-
-	/* Setup data of second QP. */
-	real_t H2[11*11] = {
-	6.20100988531485e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-7.43268433147671e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 5.41188294952735e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304827446359e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.01000000000000e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-7.43268433147671e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304827446359e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.73544778550554e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+01
-	};
-	real_t g2[11] =	{
-	-6.57752219998813e-04,	 3.61759517784935e-04,	-7.51224940044046e-05,	 6.01232615232452e-04,	 1.23562395380546e-04,	 4.59040118744990e-05,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.18185813270785e+02,	 3.38813178901720e-21,	 0.00000000000000e+00
-	};
-	real_t zLow2[11] =	{
-	-2.41857058824735e-08,	-2.77410094895458e-10,	-9.90563843681406e-09,	-3.85694249871449e-08,	 4.50633213817586e-14,	-2.22044604925031e-15,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-4.49999952054836e+01,	-1.00000000000000e+12
-	};
-	real_t zUpp2[11] =	{
-	-2.41857058824735e-08,	-2.77410094895458e-10,	-9.90563843681406e-09,	-3.85694249871449e-08,	 4.50633213817586e-14,	-2.22044604925031e-15,	 1.00000000000000e+12,	 1.00000000000000e+12,	 0.00000000000000e+00,	 4.50000047945164e+01,	 1.00000000000000e+12,
-	};
-	real_t D2[11*3] =	{
-	1.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-1.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-1.00000000000000e-02,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,
-	0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00
-	};
-	real_t dLow2[3] =	{
-	-1.00000000000000e+12,	-1.00000000000000e+12,	-1.00000000000000e+12
-	};
-	real_t dUpp2[3] =	{
-	2.12376363329877e-01,	 4.78762363667012e+00,	 8.95204496600957e-01
-	};
-	#ifdef __MAKE_POS_DEF__
-	H2[9*11+9] += 30;
-	#endif
-
-
-	status = example.hotstart( H2,g2,D2,zLow2,zUpp2,dLow2,dUpp2, nWSR );
-	printf("qpOASES_status = %d\n", (int)status );
-
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf("second QP:\n");
-	for (int_t ii =0; ii<11; ++ii )	{
-		printf("x[%d] = %.3e\n", (int)ii, xOpt[ii]);
-	}
-
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-9 );
-	QPOASES_TEST_FOR_TOL( feas,1e-7 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-12 );
-
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_janick2.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_janick2.cpp
deleted file mode 100644
index c1c6b5e..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_janick2.cpp
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_janick2.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2011-2015
- *
- *	Example that causes troubles when hotstarting.
- */
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-#include <stdio.h>
-
-#define __MAKE_POS_DEF__
-// #undef __MAKE_POS_DEF__
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	int_t nWSR = 100;
-	/* Setting up QProblem object. */
-	SQProblem example( 11,3 );
-
-	Options options;
-	options.setToFast();
-// 	options.setToDefault();
-	options.initialStatusBounds = REFER_NAMESPACE_QPOASES ST_INACTIVE;
-
-	//options.terminationTolerance = 1.e-12;
-	options.initialStatusBounds = REFER_NAMESPACE_QPOASES ST_INACTIVE;
-	//options.enableFarBounds = REFER_NAMESPACE_QPOASES BT_FALSE;
-	//options.enableRegularisation = REFER_NAMESPACE_QPOASES BT_FALSE;
-
-	example.setOptions( options );
-
-
-	/* Setup data of first QP. */
-	real_t H[11*11] = {
-	 6.20100988531485e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-7.43268431723266e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-3.84861756786704e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 5.41188294952735e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304826562310e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.01000000000000e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-7.43268431723266e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304826562310e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.73544778892019e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+01,
-	};
-	real_t g[11] =	{
-//	 9.13378607947379e-07,
-//	 0.00000000000000e+00,
-//	 0.00000000000000e+00,
-//	-1.12448469735682e-06,
-//	 0.00000000000000e+00,
-//	 0.00000000000000e+00,
-//	 0.00000000000000e+00,
-//	 0.00000000000000e+00,
-//	-1.18185650936822e+02,
-//	 0.00000000000000e+00,
-//	 0.00000000000000e+00,
-	 -6.93766478421491e-04,
-	  3.84943289898669e-04,
-	 -3.63779116055460e-05,
-	  6.38114176725135e-04,
-	  1.85797765355698e-04,
-	  6.21922122437904e-05,
-	  0.00000000000000e+00,
-	  0.00000000000000e+00,
-	 -1.18185758699839e+02,
-	  1.54357580390960e-05,
-	  5.39852809009711e-06,
-	};
-	real_t zLow[11] =	{
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	-4.50000000000000e+01,
-	-1.00000000000000e+12,
-	};
-	real_t zUpp[11] =	{
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 1.00000000000000e+12,
-	 1.00000000000000e+12,
-	 0.00000000000000e+00,
-	 4.50000000000000e+01,
-	 1.00000000000000e+12,
-	};
-	real_t D[11*3] =	{
-	 1.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-1.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-1.00000000000000e-02,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	};
-	real_t dLow[3] =	{
-	-1.00000000000000e+12,
-	-1.00000000000000e+12,
-	-1.00000000000000e+12,
-	};
-	real_t dUpp[3] =	{
-	 2.12376384003361e-01,
-	 4.78762361599664e+00,
-	 8.95204469622285e-01,
-	};
-
-
-	#ifdef __MAKE_POS_DEF__
-// 	H[9*11+9] += 30;
-	H[8*11+8] += 30;
-	#endif
-	returnValue status = example.init( H,g,D,zLow,zUpp,dLow,dUpp, nWSR );
-	printf("qpOASES_status = %d\n", (int)status );
-
-	/* Get and print solution of second QP. */
-	real_t xOpt[11];
-	real_t yOpt[11+3];
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf("first QP:\n");
-	for (int_t ii =0; ii<11; ++ii )	{
-		printf("x[%d] = %.3e\n", (int)ii, xOpt[ii]);
-	}
-
-	/* Compute KKT tolerances */
-	real_t stat, feas, cmpl;
-	SolutionAnalysis analyzer;
-
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "\nstat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-9 );
-	QPOASES_TEST_FOR_TOL( feas,1e-7 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-	nWSR = 100;
-
-	/* Setup data of second QP. */
-	real_t H2[11*11] = {
-	 6.20101055067033e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-3.84861780549400e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-7.43268533746787e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-3.84861780549400e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 5.41188396792859e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304896387257e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e-01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.01000000000000e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.10000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-7.43268533746787e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 4.61304896387257e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.73544780086860e+01,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+00,	 0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 2.00000000000000e+01,
-	};
-	real_t g2[11] =	{
-	-8.92227256391600e-08,
-	 6.89531726031141e-08,
-	-1.91970120006650e-07,
-	 1.77206607789402e-07,
-	-3.83145267945144e-09,
-	-1.88284265021358e-08,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	-1.18185657392775e+02,
-	 1.45337027424899e-17,
-	-6.04156175796480e-20,
-	};
-	real_t zLow2[11] =	{
-	-1.07876236566374e+01,
-	-1.00000000002784e+12,
-	-1.00000000000000e+12,
-	-8.30554585107279e-08,
-	-7.00000003695781e+00,
-	-2.60479531522807e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	 0.00000000000000e+00,
-	-4.50000000018062e+01,
-	-1.00000000000000e+12,
-	};
-	real_t zUpp2[11] =	{
-	 9.99999999989212e+11,
-	 9.99999999972157e+11,
-	 1.00000000000000e+12,
-	 4.68471853498991e+01,
-	 6.99999996304219e+00,
-	 9.99999999997395e+11,
-	 1.00000000000000e+12,
-	 1.00000000000000e+12,
-	 0.00000000000000e+00,
-	 4.49999999981938e+01,
-	 1.00000000000000e+12,
-	};
-	real_t D2[11*3] =	{
-	 1.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	-1.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-1.00000000000000e-02,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,	-0.00000000000000e+00,
-	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,	 1.00000000000000e+00,	 0.00000000000000e+00,	-1.00000000000000e-02,	 0.00000000000000e+00,	 0.00000000000000e+00,	 0.00000000000000e+00,
-	};
-	real_t dLow2[3] =	{
-	-1.00000000000000e+12,
-	-1.00000000000000e+12,
-	-1.00000000000000e+12,
-	};
-	real_t dUpp2[3] =	{
-	 2.12376343362616e-01,
-	 4.78762365663739e+00,
-	 8.95204684771929e-01,
-	};
-	#ifdef __MAKE_POS_DEF__
-	H2[8*11+8] += 30;
-// 	H2[9*11+9] += 30;
-	#endif
-
-
-	status = example.hotstart( H2,g2,D2,zLow2,zUpp2,dLow2,dUpp2, nWSR );
-	printf("qpOASES_status = %d\n", (int)status );
-
-	example.getPrimalSolution( xOpt );
-	example.getDualSolution( yOpt );
-	printf("second QP:\n");
-	for (int_t ii =0; ii<11; ++ii )	{
-		printf("x[%d] = %.3e\n", (int)ii, xOpt[ii]);
-	}
-	
-	printf( "\nQP objective value: %.3e\n", example.getObjVal() );
-
-	/* Compute KKT tolerances */
-	analyzer.getKktViolation( &example, &stat,&feas,&cmpl );
-	printf( "\nstat = %e\nfeas = %e\ncmpl = %e\n", stat,feas,cmpl );
-
-	QPOASES_TEST_FOR_TOL( stat,1e-9 );
-	QPOASES_TEST_FOR_TOL( feas,1e-7 );
-	QPOASES_TEST_FOR_TOL( cmpl,1e-15 );
-
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices.cpp
deleted file mode 100644
index a5c2339..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices.cpp
+++ /dev/null
@@ -1,903 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_matrices.cpp
- *	\author Andreas Potschka, Christian Kirches, Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2010-2015
- *
- *	Unit test for Matrix classes.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-USING_NAMESPACE_QPOASES
-
-
-/** Compare deviations when computing dot product. */
-int sumOfSquares()
-{
-	int_t i;
-
-	/* sum of first n squares */
-	const int_t N = 100;
-	real_t *av = new real_t[N];
-	real_t *aTv = new real_t[N];
-	real_t *bv = new real_t[N];
-	real_t c;
-
-	for (i = 0; i < N; i++) av[i] = i+1.0;
-	for (i = 0; i < N; i++) aTv[i] = i+1.0;
-	for (i = 0; i < N; i++) bv[i] = i+1.0;
-
-	DenseMatrix a(1, N, N, av);
-	DenseMatrix aT(N, 1, 1, aTv);
-
-	a.times(1, 1.0, bv, N, 0.0, &c, 1);
-	real_t err = c - (1.0/6.0)*N*(N+1)*(2*N+1);
-	fprintf(stdFile, "Dot product; Error in sum of first %d squares: %9.2e\n", (int)N, err );
-	
-	aT.transTimes(1, 1.0, bv, N, 0.0, &c, 1);
-	real_t errT = c - (1.0/6.0)*N*(N+1)*(2*N+1);
-	fprintf(stdFile, "Transpose; Error in sum of first %d squares: %9.2e\n", (int)N, errT);
-
-	delete[] bv;
-	aT.free ();	// or delete[] aTv;
-	a.free (); // or delete[] av;
-
-	QPOASES_TEST_FOR_TOL( err ,1e-10 )
-	QPOASES_TEST_FOR_TOL( errT,1e-10 )
-	
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying Hilbert matrix with its inverse. */
-int hilbert()
-{
-	int_t i, j;
-	real_t d, err;
-
-	/* permuted 4x4 Hilbert matrix, row major format */
-	real_t _Av[] = {1.0/3.0, 1.0, 0.5, 0.25,
-		0.25, 0.5, 1.0/3.0, 0.2,
-		0.2, 1.0/3.0, 0.25, 1.0/6.0,
-		1.0/6.0, 0.25, 0.2, 1.0/7.0};
-	/* and its inverse, column major format */
-	real_t Bv[] = {240, 16, -120, -140,
-		-2700, -120, 1200, 1680,
-		6480, 240, -2700, -4200,
-		-4200, -140, 1680, 2800};
-
-	/* result */
-	real_t *Av = new real_t[4*4];
-	real_t *Cv = new real_t[4*4];
-
-	DenseMatrix A(4, 4, 4, Av);
-
-	for (i = 0; i < 16; i++) Av[i] = _Av[i];
-
-	A.times(4, 1.0, Bv, 4, 0.0, Cv, 4);
-
-	err = 0.0;
-	for (j = 0; j < 4; j++)
-	{
-		for (i = 0; i < 4; i++)
-		{
-			d = getAbs(Cv[j*4+i] - static_cast<real_t>(i == j));
-			if (d > err) err = d;
-		}
-	}
-	fprintf(stdFile, "Hilbert; Deviation from identity: %9.2e\n", err);
-
-	delete[] Cv;
-	A.free ();	// or delete[] Av;
-
-	QPOASES_TEST_FOR_TOL( err,1e-12 )
-	
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying sub-matrices. */
-int submatrix()
-{
-	int_t i, j;
-	real_t d, err;
-
-	/* 2x3 transposed submatrix */
-	real_t _Asubv[] = {1.0/3.0, 0.25,
-		1.0, 0.5,
-		0.5, 1.0/3.0,
-		0.25, 0.2};
-	real_t Bsubv[] = {240, 16, -120, -140,
-		-2700, -120, 1200, 1680};
-	real_t Csubv[2*2];
-
-	real_t *Asubv = new real_t[2*4];
-
-	for (i = 0; i < 8; i++) Asubv[i] = _Asubv[i];
-
-	DenseMatrix Asub(4, 2, 2, Asubv);
-
-	Asub.transTimes(2, 1.0, Bsubv, 4, 0.0, Csubv, 2);
-
-	err = 0.0;
-	for (j = 0; j < 2; j++)
-	{
-		for (i = 0; i < 2; i++)
-		{
-			d = getAbs(Csubv[j*2+i] - static_cast<real_t>(i == j));
-			if (d > err) err = d;
-		}
-	}
-	fprintf(stdFile, "Submatrix transpose; Deviation from identity: %9.2e\n", err);
-	
-	Asub.free ();	// or delete[] Asubv;
-
-	QPOASES_TEST_FOR_TOL( err,1e-13 )
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying dense sub-matrices via index lists. */
-int indexDenseSubmatrix()
-{
-	/* dense submatrices via index lists */
-	const int_t M = 20, N = 15, K = 5;
-	int_t i, j, k, m, n;
-	Indexlist rows(N), cols(N);
-	int_t *rNum, *cNum;
-	real_t err=0.0, errT=0.0;
-	real_t *Av, *X, *Y, *x, *y, *xc, *yc;
-
-	// prepare index lists
-	m = (M-3)/4;
-	n = (N-3)/4;
-	for (i = 0; i < m; i++) { rows.addNumber(M-1 - 2*i); rows.addNumber(2*i); }
-	for (i = 0; i < n; i++) { cols.addNumber(N-1 - 2*i); cols.addNumber(2*i); }
-	m *= 2;
-	n *= 2;
-
-	rows.getNumberArray(&rNum);
-	fprintf(stdFile, "Rows: ");
-	for (i = 0; i < m; i++) fprintf(stdFile, " %2d", (int)(rNum[i]) );
-	fprintf(stdFile, "\n");
-
-	cols.getNumberArray(&cNum);
-	fprintf(stdFile, "Cols: ");
-	for (i = 0; i < n; i++) fprintf(stdFile, " %2d", (int)(cNum[i]) );
-	fprintf(stdFile, "\n");
-
-	// prepare input matrices
-	Av = new real_t[M*N];
-	X = new real_t[n*K];
-	Y = new real_t[m*K];
-	x = new real_t[n*K];
-	y = new real_t[m*K];
-	xc = new real_t[n*K];
-	yc = new real_t[m*K];
-
-	DenseMatrix A(M, N, N, Av);
-	for (i = 0; i < M*N; i++) Av[i] = -0.5*N*M + (real_t)i;
-	for (i = 0; i < n*K; i++) X[i] = 1.0 / (real_t)(i+1);
-	for (i = 0; i < m*K; i++) Y[i] = 1.0 / (real_t)(i+1);
-
-	// multiply
-	A.times(&rows, &cols, K, 1.0, X, n, 0.0, y, m);
-
-	// check result
-	for (j = 0; j < m; j++)
-	{
-		for (k = 0; k < K; k++)
-		{
-			yc[j+k*m] = -y[j+k*m];
-			for (i = 0; i < n; i++)
-				yc[j+k*m] += Av[cNum[i]+rNum[j]*N] * X[i+k*n];
-			if (getAbs(yc[j+k*m]) > err) err = getAbs(yc[j+k*m]);
-		}
-	}
-	fprintf(stdFile, "Indexlist submatrix; error: %9.2e\n", err);
-
-	// transpose multiply
-	A.transTimes(&rows, &cols, K, 1.0, Y, m, 0.0, x, n);
-
-	// check result
-	errT = 0.0;
-	for (j = 0; j < n; j++)
-	{
-		for (k = 0; k < K; k++)
-		{
-			xc[j+k*n] = -x[j+k*n];
-			for (i = 0; i < m; i++)
-				xc[j+k*n] += Av[cNum[j]+rNum[i]*N] * Y[i+k*m];
-			if (getAbs(xc[j+k*n]) > errT) errT = getAbs(xc[j+k*n]);
-		}
-	}
-	fprintf(stdFile, "Indexlist transpose submatrix; error: %9.2e\n", errT);
-
-	// check result
-
-	// clean up
-	delete[] yc;
-	delete[] xc;
-	delete[] y;
-	delete[] x;
-	delete[] Y;
-	delete[] X;
-	A.free ();	// or delete[] Av;
-
-	QPOASES_TEST_FOR_TOL( err ,1e-13 )
-	QPOASES_TEST_FOR_TOL( errT,1e-14 )
-
-	return TEST_PASSED;
-}
-
-
-/** Obtain column of sparse matrix. */
-int spGetCol()
-{
-	long j, i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[4];
-	real_t *val = new real_t[10];
-	real_t *col = new real_t[4];
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  6 ]
-	 *  [  1  0  7 ]
-	 *  [  2  0  8 ]
-	 *  [  0  4  9 ]
-	 *  [  0  5 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 5; jc[3] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; ir[3] = 3; ir[4] = 4;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; ir[8] = 3; ir[9] = 4;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix A(5, 3, ir, jc, val);
-
-	Indexlist rows(4);
-
-	rows.addNumber(2);
-	rows.addNumber(4);
-	rows.addNumber(3);
-	rows.addNumber(0);
-
-	/* Indexed matrix:
-	 *
-	 *  [  2  0  8 ]
-	 *  [  0  5 10 ]
-	 *  [  0  4  9 ]
-	 *  [  0  3  6 ]
-	 */
-
-	for (j = 0; j < 3; j++)
-	{
-		fprintf(stdFile, "Column %ld:\n", j);
-		A.getCol( (int_t)j, &rows, 1.0, col );
-		for (i = 0; i < 4; i++)
-			fprintf(stdFile, " %3.0f\n", col[i]);
-	}
-				
-	delete[] col;
-	A.free ();	// or delete[] val,jc,ir;
-
-	return TEST_PASSED;
-}
-
-
-/** Obtain row of sparse matrix. */
-int spGetRow()
-{
-	long j, i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[6];
-	real_t *val = new real_t[10];
-	real_t *row = new real_t[4];
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  4  6  0 ]
-	 *  [  1  0  0  7  9 ]
-	 *  [  2  0  5  8 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 3; jc[3] = 5; jc[4] = 8; jc[5] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; 
-	ir[3] = 0; ir[4] = 2;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; 
-	ir[8] = 1; ir[9] = 2;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix A(3, 4, ir, jc, val);
-
-	Indexlist cols(4);
-
-	cols.addNumber(2);
-	cols.addNumber(4);
-	cols.addNumber(3);
-	cols.addNumber(1);
-
-	/* Indexed matrix:
-	 *
-	 * [  4  0  6  3 ]
-	 * [  0  9  7  0 ]
-	 * [  5 10  8  0 ]
-	 */
-
-	for (j = 0; j < 3; j++)
-	{
-		A.getRow( (int_t)j, &cols, 1.0, row );
-		for (i = 0; i < 4; i++)
-			fprintf(stdFile, " %3.0f", row[i]);
-		fprintf(stdFile, "\n");
-	}
-				
-	delete[] row;
-	A.free ();
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying sparse matrix. */
-int spTimes()
-{
-	long i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[6];
-	real_t *val = new real_t[10];
-
-	real_t *x = new real_t[5*2];
-	real_t *y = new real_t[3*2];
-
-	real_t Ax[] = {-23, -11, -26, 42, 74, 99};
-	real_t ATy[] = {-63, -69, -222, -423, -359, 272, 126, 663, 1562, 1656};
-	real_t err=0.0, errT=0.0;
-
-	for (i = 0; i < 10; i++) x[i] = -4.0 + (double)i;
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  4  6  0 ]
-	 *  [  1  0  0  7  9 ]
-	 *  [  2  0  5  8 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 3; jc[3] = 5; jc[4] = 8; jc[5] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; 
-	ir[3] = 0; ir[4] = 2;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; 
-	ir[8] = 1; ir[9] = 2;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix A(3, 5, ir, jc, val);	// reference to ir, jc, val
-
-	A.times(2, 1.0, x, 5, 0.0, y, 3);
-	
-	for (i = 0; i < 6; i++)
-		if (getAbs(y[i] - Ax[i]) > err) err = getAbs(y[i] - Ax[i]);
-	fprintf(stdFile, "Error in sparse A*x: %9.2e\n", err);
-
-	A.transTimes(2, 1.0, y, 3, 0.0, x, 5);
-
-	errT = 0.0;
-	for (i = 0; i < 10; i++)
-		if (getAbs(x[i] - ATy[i]) > errT) errT = getAbs(x[i] - ATy[i]);
-	fprintf(stdFile, "Error in sparse A'*x: %9.2e\n", errT);
-
-	A.free ();	// or delete[] val,ir,jc
-	delete[] y;
-	delete[] x;
-
-	QPOASES_TEST_FOR_TOL( err ,1e-15 )
-	QPOASES_TEST_FOR_TOL( errT,1e-15 )
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying sparse matrix via index lists. */
-int spIndTimes()
-{
-	const long N = 4;
-	long i, j;
-	long nRows = 2 * N + 1;
-	long nCols = N;
-	long nnz = 3 * N;
-	sparse_int_t *ir = new sparse_int_t[nnz];
-	sparse_int_t *jc = new sparse_int_t[nCols+1];
-	real_t *val = new real_t[nnz];
-	real_t *xc = new real_t[3*2];
-	real_t *yc = new real_t[4*2];
-	real_t Ax[] = {0.31, 0.05, 0.06, 0.30, 0.76, 0.20, 0.24, 0.60};
-	real_t ATy[] = {0.278, 0.000, 0.548, 0.776, 0.000, 1.208};
-	real_t err=0.0, errT=0.0;
-
-	Indexlist rows(4), cols(3), allcols( (int_t)nCols );
-
-	rows.addNumber(2);
-	rows.addNumber(4);
-	rows.addNumber(3);
-	rows.addNumber(0);
-
-	cols.addNumber(1);
-	cols.addNumber(3);
-	cols.addNumber(0);
-
-	for (i = 0; i < nCols; i++) 
-		allcols.addNumber( (int_t)i );
-
-	// build test matrix
-	for (i = 0; i <= N; i++) jc[i] = (sparse_int_t)(3*i);
-	for (j = 0; j < N; j++) 
-		for (i = 0; i < 3; i++)
-		{
-			ir[j*3+i] = (sparse_int_t)(2*j + i);
-			val[j*3+i] = 1.0 - 0.1 * (double)(j*3+i);
-		}
-	SparseMatrix A( (int_t)nRows, (int_t)nCols, ir, jc, val );
-
-	fprintf(stdFile, "Test matrix A =\n");
-	for (j = 0; j < nRows; j++)
-	{
-		A.getRow( (int_t)j, &allcols, 1.0, xc );
-		for (i = 0; i < nCols; i++)
-			fprintf(stdFile, "%6.2f", xc[i]);
-		fprintf(stdFile, "\n");
-	}
-
-	for (i = 0; i < 6; i++)
-		xc[i] = (1.0 + (double)i) * 0.1;
-
-	A.times(&rows, &cols, 2, 1.0, xc, 3, 0.0, yc, 4, BT_TRUE);
-
-	for (i = 0; i < 8; i++)
-		if (getAbs(yc[i] - Ax[i]) > err)
-			err = getAbs(yc[i] - Ax[i]);
-	fprintf(stdFile, "Error in sparse indexed A*x: %9.2e\n", err);
-
-	A.transTimes(&rows, &cols, 2, 1.0, yc, 4, 0.0, xc, 3);
-	errT = 0.0;
-	for (i = 0; i < 6; i++)
-		if (getAbs(xc[i] - ATy[i]) > errT)
-			errT = getAbs(xc[i] - ATy[i]);
-	fprintf(stdFile, "Error in sparse indexed A'*y: %9.2e\n", errT);
-
-	delete[] xc;
-	delete[] yc;
-	A.free ();
-
-	QPOASES_TEST_FOR_TOL( err ,1e-15 )
-	QPOASES_TEST_FOR_TOL( errT,1e-15 )
-
-	return TEST_PASSED;
-}
-
-
-/** Obtain column of sparse row matrix. */
-int sprGetCol()
-{
-	long j, i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[4];
-	real_t *val = new real_t[10];
-	real_t *col = new real_t[4];
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  6 ]
-	 *  [  1  0  7 ]
-	 *  [  2  0  8 ]
-	 *  [  0  4  9 ]
-	 *  [  0  5 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 5; jc[3] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; ir[3] = 3; ir[4] = 4;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; ir[8] = 3; ir[9] = 4;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix Ac(5, 3, ir, jc, val);
-	real_t *Acv = Ac.full(); // row major format
-	SparseMatrixRow A(5, 3, 3, Acv);
-	delete[] Acv;
-	Ac.free ();	// or delete[] val,jc,ir;
-
-	Indexlist rows(4);
-
-	rows.addNumber(2);
-	rows.addNumber(4);
-	rows.addNumber(3);
-	rows.addNumber(0);
-
-	/* Indexed matrix:
-	 *
-	 *  [  2  0  8 ]
-	 *  [  0  5 10 ]
-	 *  [  0  4  9 ]
-	 *  [  0  3  6 ]
-	 */
-
-	for (j = 0; j < 3; j++)
-	{
-		fprintf(stdFile, "Column %ld:\n", j);
-		A.getCol( (int_t)j, &rows, 1.0, col );
-		for (i = 0; i < 4; i++)
-			fprintf(stdFile, " %3.0f\n", col[i]);
-	}
-				
-	delete[] col;
-	A.free ();	// or delete[] val,jc,ir;
-
-	return TEST_PASSED;
-}
-
-
-/** Obtain row of sparse row matrix. */
-int sprGetRow()
-{
-	long j, i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[6];
-	real_t *val = new real_t[10];
-	real_t *row = new real_t[4];
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  4  6  0 ]
-	 *  [  1  0  0  7  9 ]
-	 *  [  2  0  5  8 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 3; jc[3] = 5; jc[4] = 8; jc[5] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; 
-	ir[3] = 0; ir[4] = 2;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; 
-	ir[8] = 1; ir[9] = 2;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix Ac(3, 5, ir, jc, val);
-	real_t *Acv = Ac.full(); // row major format
-	SparseMatrixRow A(3, 5, 5, Acv);
-	delete[] Acv;
-	Ac.free ();	// or delete[] val,jc,ir;
-
-	Indexlist cols(4);
-
-	cols.addNumber(2);
-	cols.addNumber(4);
-	cols.addNumber(3);
-	cols.addNumber(1);
-
-	/* Indexed matrix:
-	 *
-	 * [  4  0  6  3 ]
-	 * [  0  9  7  0 ]
-	 * [  5 10  8  0 ]
-	 */
-
-	for (j = 0; j < 3; j++)
-	{
-		A.getRow( (int_t)j, &cols, 1.0, row );
-		for (i = 0; i < 4; i++)
-			fprintf(stdFile, " %3.0f", row[i]);
-		fprintf(stdFile, "\n");
-	}
-				
-	delete[] row;
-	A.free ();
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying sparse row matrix. */
-int sprTimes()
-{
-	long i;
-	sparse_int_t *ir = new sparse_int_t[10];
-	sparse_int_t *jc = new sparse_int_t[6];
-	real_t *val = new real_t[10];
-
-	real_t *x = new real_t[5*2];
-	real_t *y = new real_t[3*2];
-
-	real_t Ax[] = {-23, -11, -26, 42, 74, 99};
-	real_t ATy[] = {-63, -69, -222, -423, -359, 272, 126, 663, 1562, 1656};
-	real_t err=0.0, errT=0.0;
-
-	for (i = 0; i < 10; i++) x[i] = -4.0 + (double)i;
-
-	/* Test matrix:
-	 *
-	 *  [  0  3  4  6  0 ]
-	 *  [  1  0  0  7  9 ]
-	 *  [  2  0  5  8 10 ]
-	 */
-
-	jc[0] = 0; jc[1] = 2; jc[2] = 3; jc[3] = 5; jc[4] = 8; jc[5] = 10;
-	ir[0] = 1; ir[1] = 2;
-	ir[2] = 0; 
-	ir[3] = 0; ir[4] = 2;
-	ir[5] = 0; ir[6] = 1; ir[7] = 2; 
-	ir[8] = 1; ir[9] = 2;
-	for (i = 0; i < 10; i++) val[i] = 1.0 + (double)i;
-
-	SparseMatrix Ac(3, 5, ir, jc, val);	// reference to ir, jc, val
-	real_t *Acv = Ac.full(); // row major format
-	SparseMatrixRow A(3, 5, 5, Acv);
-	delete[] Acv;
-	Ac.free ();	// or delete[] val,jc,ir;
-
-	A.times(2, 1.0, x, 5, 0.0, y, 3);
-	
-	for (i = 0; i < 6; i++)
-		if (getAbs(y[i] - Ax[i]) > err) err = getAbs(y[i] - Ax[i]);
-	fprintf(stdFile, "Error in sparse A*x: %9.2e\n", err);
-
-	A.transTimes(2, 1.0, y, 3, 0.0, x, 5);
-
-	errT = 0.0;
-	for (i = 0; i < 10; i++)
-		if (getAbs(x[i] - ATy[i]) > errT) errT = getAbs(x[i] - ATy[i]);
-	fprintf(stdFile, "Error in sparse A'*x: %9.2e\n", errT);
-
-	A.free ();	// or delete[] val,ir,jc
-	delete[] y;
-	delete[] x;
-
-	QPOASES_TEST_FOR_TOL( err ,1e-15 )
-	QPOASES_TEST_FOR_TOL( errT,1e-15 )
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when multiplying sparse row matrix via index lists. */
-int sprIndTimes()
-{
-	const long N = 4;
-	long i, j;
-	long nRows = 2 * N + 1;
-	long nCols = N;
-	long nnz = 3 * N;
-	sparse_int_t *ir = new sparse_int_t[nnz];
-	sparse_int_t *jc = new sparse_int_t[nCols+1];
-	real_t *val = new real_t[nnz];
-	real_t *xc = new real_t[3*2];
-	real_t *yc = new real_t[4*2];
-	real_t Ax[] = {0.31, 0.05, 0.06, 0.30, 0.76, 0.20, 0.24, 0.60};
-	real_t ATy[] = {0.278, 0.000, 0.548, 0.776, 0.000, 1.208};
-	real_t err=0.0, errT=0.0;
-
-	Indexlist rows(4), cols(3), allcols( (int_t)nCols );
-
-	rows.addNumber(2);
-	rows.addNumber(4);
-	rows.addNumber(3);
-	rows.addNumber(0);
-
-	cols.addNumber(1);
-	cols.addNumber(3);
-	cols.addNumber(0);
-
-	for (i = 0; i < nCols; i++) 
-		allcols.addNumber( (int_t)i );
-
-	// build test matrix
-	for (i = 0; i <= N; i++) jc[i] = (sparse_int_t)(3*i);
-	for (j = 0; j < N; j++) 
-		for (i = 0; i < 3; i++)
-		{
-			ir[j*3+i] = (sparse_int_t)(2*j + i);
-			val[j*3+i] = 1.0 - 0.1 * (double)(j*3+i);
-		}
-	SparseMatrix Ac( (int_t)nRows, (int_t)nCols, ir, jc, val);
-	real_t *Acv = Ac.full(); // row major format
-	SparseMatrixRow A( (int_t)nRows, (int_t)nCols, (int_t)nCols, Acv);
-	delete[] Acv;
-	Ac.free ();	// or delete[] val,jc,ir;
-
-	fprintf(stdFile, "Test matrix A =\n");
-	for (j = 0; j < nRows; j++)
-	{
-		A.getRow( (int_t)j, &allcols, 1.0, xc );
-		for (i = 0; i < nCols; i++)
-			fprintf(stdFile, "%6.2f", xc[i]);
-		fprintf(stdFile, "\n");
-	}
-
-	for (i = 0; i < 6; i++)
-		xc[i] = (1.0 + (double)i) * 0.1;
-
-	A.times(&rows, &cols, 2, 1.0, xc, 3, 0.0, yc, 4, BT_TRUE);
-
-	for (i = 0; i < 8; i++)
-		if (getAbs(yc[i] - Ax[i]) > err)
-			err = getAbs(yc[i] - Ax[i]);
-	fprintf(stdFile, "Error in sparse indexed A*x: %9.2e\n", err);
-
-	A.transTimes(&rows, &cols, 2, 1.0, yc, 4, 0.0, xc, 3);
-	for (i = 0; i < 3; i++)
-	{
-		for (j = 0; j < 2; j++)
-			fprintf(stdFile, "%6.2f", ATy[i + j*3]);
-		fprintf(stdFile, "\n");
-	}
-	for (i = 0; i < 3; i++)
-	{
-		for (j = 0; j < 2; j++)
-			fprintf(stdFile, "%6.2f", xc[i + j*3]);
-		fprintf(stdFile, "\n");
-	}
-	for (i = 0; i < 6; i++)
-		if (getAbs(xc[i] - ATy[i]) > errT)
-			errT = getAbs(xc[i] - ATy[i]);
-	fprintf(stdFile, "Error in sparse indexed A'*y: %9.2e\n", errT);
-
-	delete[] xc;
-	delete[] yc;
-	A.free ();
-
-	QPOASES_TEST_FOR_TOL( err ,1e-15 )
-	QPOASES_TEST_FOR_TOL( errT,1e-15 )
-
-	return TEST_PASSED;
-}
-
-
-/** Compare deviations when using bilinear multiplication with dense matrix. */
-int symmetry()
-{
-	int_t i,j;
-	real_t *Hv = new real_t[6*6];
-	real_t *Z = new real_t[6*3];
-	real_t *ZHZd = new real_t[3*3];
-	real_t *ZHZs = new real_t[3*3];
-	real_t ZHZv[] = {0.144, 0.426, 0.708, 0.426, 1.500, 2.574, 0.708, 2.574, 4.440};
-	real_t err=0.0, errS=0.0;
-	SymDenseMat *Hd;
-	SymSparseMat *Hs;
-	Indexlist *cols = new Indexlist(6);
-
-	for (i = 0; i < 36; i++) Hv[i] = 0.0;
-	for (i = 0; i < 6; i++) Hv[i*7] = 1.0 - 0.1 * i;
-	for (i = 0; i < 5; i++) Hv[i*7+1] = Hv[i*7+6] = -0.1 * (i+1);
-
-	Hd = new SymDenseMat(6, 6, 6, Hv);	// deep-copy from Hv
-	Hs = new SymSparseMat(6, 6, 6, Hv);	// deep-copy from Hv
-	Hs->createDiagInfo();
-
-	for (i = 0; i < 6; ++i)
-	{
-		for (j = 0; j < 6; ++j)
-			fprintf (stdFile, "%3.3f ", Hv[i*6+j]);
-		fprintf (stdFile, "\n");
-	}
-	fprintf (stdFile, "\n");
-	
-	cols->addNumber(3);
-	cols->addNumber(0);
-	cols->addNumber(4);
-	cols->addNumber(1);
-	for (i = 0; i < 18; i++) Z[i] = 0.1 * (i+1);
-
-	fprintf (stdFile, "\n");
-	for (i = 0; i < 6; ++i)
-	{
-		for (j = 0; j < 3; ++j)
-			fprintf (stdFile, "%3.3f ", Z[i+j*6]);
-		fprintf (stdFile, "\n");
-	}
-	fprintf (stdFile, "\n");
-	
-	Hd->bilinear(cols, 3, Z, 6, ZHZd, 3);
-
-	for (i = 0; i < 9; i++)
-		if (getAbs(ZHZd[i] - ZHZv[i]) > err)
-			err = getAbs(ZHZd[i] - ZHZv[i]);
-	fprintf(stdFile, "Error in indexed dense bilinear form: %9.2e\n", err);
-
-	Hs->bilinear(cols, 3, Z, 6, ZHZs, 3);
-	
-	for (i = 0; i < 3; ++i)
-	{
-		for (j = 0; j < 3; ++j)
-			fprintf (stdFile, "%3.3f ", ZHZd[i*3+j]);
-		fprintf (stdFile, "\n");
-	}
-	fprintf (stdFile, "\n");
-
-	for (i = 0; i < 3; ++i)
-	{
-		for (j = 0; j < 3; ++j)
-			fprintf (stdFile, "%3.3f ", ZHZv[i*3+j]);
-		fprintf (stdFile, "\n");
-	}
-	fprintf (stdFile, "\n");
-
-	for (i = 0; i < 9; i++)
-		if (getAbs(ZHZs[i] - ZHZv[i]) > errS)
-			errS = getAbs(ZHZs[i] - ZHZv[i]);
-	fprintf(stdFile, "Error in indexed sparse bilinear form: %9.2e\n", errS);
-
-	delete cols;
-	delete Hs;
-	delete Hd;
-	delete[] ZHZs;
-	delete[] ZHZd;
-	delete[] Z;
-	delete[] Hv;
-
-	QPOASES_TEST_FOR_TOL( err ,1e-15 )
-	QPOASES_TEST_FOR_TOL( errS,1e-15 )
-
-	return TEST_PASSED;
-}
-
-
-/** Run various tests on matrix classes. */
-int main()
-{
-	int errorCount = TEST_PASSED;
-	
-	errorCount += sumOfSquares();
-	errorCount += hilbert();
-	errorCount += submatrix();
-	errorCount += indexDenseSubmatrix();
-
-	errorCount += spGetCol();
-	errorCount += spGetRow();
-	errorCount += spTimes();
-	errorCount += spIndTimes();
-
-	errorCount += sprGetCol();
-	errorCount += sprGetRow();
-	errorCount += sprTimes();
-	errorCount += sprIndTimes();
-
-	errorCount += symmetry();
-	
-	return errorCount;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices2.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices2.cpp
deleted file mode 100644
index ee9614f..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices2.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_matrices2.cpp
- *	\author Hans Joachim Ferreau,Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Unit test for Matrix classes.
- */
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-#include "test_qrecipe_data.hpp"
-
-
-/** Compare deviations when performing matrix operations. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-	
-	int_t i;
-
-	real_t errH=0.0, errA=0.0;
-	real_t v[180];
-	real_t resHs[180];
-	real_t resHd[180];
-	real_t resAs[91];
-	real_t resAd[91];
-	
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	SparseMatrix *A = new SparseMatrix(91, 180, A_ir, A_jc, A_val);
-
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	real_t* A_full = A->full();
-
-	//print( A_full,91,180 );
-
-
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-	DenseMatrix *Ad = new DenseMatrix(91,180,180,A_full);
-
-	for( i=0; i<180; ++i )
-		v[i] = 2.0 * ((real_t)rand()) / ((real_t)RAND_MAX) - 1.0;
-	
-	H ->times(1, 1.0, v, 180, 0.0, resHs, 180);
-	Hd->times(1, 1.0, v, 180, 0.0, resHd, 180);
-	
-	A ->times(1, 1.0, v, 180, 0.0, resAs, 91);
-	Ad->times(1, 1.0, v, 180, 0.0, resAd, 91);
-
-	
-	for ( i=0; i<180; ++i )
-		if ( getAbs(resHs[i] - resHd[i]) > errH)
-			errH = getAbs(resHs[i] - resHd[i]);
-	
-	fprintf(stdFile, "maximum difference in H*v: %9.2e\n", errH);
-	
-	
-	for ( i=0; i<91; ++i )
-		if ( getAbs(resAs[i] - resAd[i]) > errA)
-			errA = getAbs(resAs[i] - resAd[i]);
-	
-	fprintf(stdFile, "maximum difference in A*v: %9.2e\n", errA);
-
-	delete H;
-	delete A;
-	delete[] H_full;
-	delete[] A_full;
-	delete Hd;
-	delete Ad;
-
-	
-	QPOASES_TEST_FOR_TOL( errH,1e-13 )
-	QPOASES_TEST_FOR_TOL( errA,1e-13 )
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices3.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices3.cpp
deleted file mode 100644
index 9b002b0..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_matrices3.cpp
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_matrices3.cpp
- *	\author Hans Joachim Ferreau,Andreas Potschka, Christian Kirches
- *	\version 3.2
- *	\date 2014-2015
- *
- *	Unit test for Matrix classes.
- */
-
-
-#include <stdlib.h>
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-#include "test_qrecipe_data.hpp"
-
-
-/** Compare deviations when performing matrix operations. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-	
-	int_t i;
-
-	real_t errH=0.0;
-	real_t v[180];
-	real_t resHn[180];
-	real_t resHt[180];
-	
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-
-	for( i=0; i<180; ++i )
-		v[i] = 2.0 * ((real_t)rand()) / ((real_t)RAND_MAX) - 1.0;
-	
-	Hd->times(     1, 1.0, v, 180, 0.0, resHn, 180);
-	Hd->transTimes(1, 1.0, v, 180, 0.0, resHt, 180);
-	
-	for ( i=0; i<180; ++i )
-		if ( getAbs(resHn[i] - resHt[i]) > errH)
-			errH = getAbs(resHn[i] - resHt[i]);
-	
-	fprintf(stdFile, "maximum difference in H*v vs. H'*v: %9.2e\n", errH);
-	
-	delete H;
-	delete[] H_full;
-	delete Hd;
-	
-	
-	QPOASES_TEST_FOR_TOL( errH,1e-15 )
-	
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe.cpp
deleted file mode 100644
index 966f220..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe.cpp
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_qrecipe.cpp
- *	\author Andreas Potschka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-#include "test_qrecipe_data.hpp"
-
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	long i;
-	int_t nWSR;
-	real_t tic, toc;
-	real_t errP=0.0, errD=0.0;
-	real_t *x1 = new real_t[180];
-	real_t *y1 = new real_t[271];
-	real_t *x2 = new real_t[180];
-	real_t *y2 = new real_t[271];
-
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	SparseMatrix *A = new SparseMatrix(91, 180, A_ir, A_jc, A_val);
-
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	real_t* A_full = A->full();
-
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-	DenseMatrix *Ad = new DenseMatrix(91,180,180,A_full);
-
-	/* solve with dense matrices */
-	nWSR = 1000;
-	QProblem qrecipeD(180, 91);
-	tic = getCPUtime();
-	qrecipeD.init(Hd, g, Ad, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeD.getPrimalSolution(x1);
-	qrecipeD.getDualSolution(y1);
-
-	fprintf(stdFile, "Solved dense problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* Compute KKT tolerances */
-	real_t statD, feasD, cmplD;
-	SolutionAnalysis analyzerD;
-
-	analyzerD.getKktViolation( &qrecipeD, &statD,&feasD,&cmplD );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n\n", statD,feasD,cmplD );
-
-
-	/* solve with sparse matrices */
-	nWSR = 1000;
-	QProblem qrecipeS(180, 91);
-	tic = getCPUtime();
-	qrecipeS.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeS.getPrimalSolution(x2);
-	qrecipeS.getDualSolution(y2);
-
-	fprintf(stdFile, "Solved sparse problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-	
-	/* Compute KKT tolerances */
-	real_t statS, feasS, cmplS;
-	SolutionAnalysis analyzerS;
-
-	analyzerS.getKktViolation( &qrecipeS, &statS,&feasS,&cmplS );
-	printf( "stat = %e\nfeas = %e\ncmpl = %e\n\n", statS,feasS,cmplS );
-
-	/* check distance of solutions */
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x2[i]) > errP)
-			errP = getAbs(x1[i] - x2[i]);
-	fprintf(stdFile, "Primal error: %9.2e\n", errP);
-
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y2[i]) > errD)
-			errD = getAbs(y1[i] - y2[i]);
-	fprintf(stdFile, "Dual error: %9.2e (might not be unique)\n", errD);
-
-	delete H;
-	delete A;
-	delete[] H_full;
-	delete[] A_full;
-	delete Hd;
-	delete Ad;
-
-	delete[] y2;
-	delete[] x2;
-	delete[] y1;
-	delete[] x1;
-
-	QPOASES_TEST_FOR_TOL( statD,1e-14 );
-	QPOASES_TEST_FOR_TOL( feasD,1e-14 );
-	QPOASES_TEST_FOR_TOL( cmplD,1e-13 );
-	
-	QPOASES_TEST_FOR_TOL( statS,1e-14 );
-	QPOASES_TEST_FOR_TOL( feasS,1e-14 );
-	QPOASES_TEST_FOR_TOL( cmplS,1e-13 );
-
-	QPOASES_TEST_FOR_TOL( errP,1e-13 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipeSchur.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipeSchur.cpp
deleted file mode 100644
index e5f9ff2..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipeSchur.cpp
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_qrecipeSchur.cpp
- *	\author Dennis Janka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- *	Comparison between nullspace factorization (dense and sparse) and
- *	Schur complement approach.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-#include "test_qrecipe_data.hpp"
-
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	long i;
-	int_t nWSR;
-	real_t errP1, errP2, errP3, errD1, errD2, errD3, tic, toc;
-	real_t *x1 = new real_t[180];
-	real_t *y1 = new real_t[271];
-	real_t *x2 = new real_t[180];
-	real_t *y2 = new real_t[271];
-	real_t *x3 = new real_t[180];
-	real_t *y3 = new real_t[271];
-
-	/* create sparse matrices */
-	SymSparseMat *H = new SymSparseMat(180, 180, H_ir, H_jc, H_val);
-	SparseMatrix *A = new SparseMatrix(91, 180, A_ir, A_jc, A_val);
-
-	H->createDiagInfo();
-
-	real_t* H_full = H->full();
-	real_t* A_full = A->full();
-
-	SymDenseMat *Hd = new SymDenseMat(180,180,180,H_full);
-	DenseMatrix *Ad = new DenseMatrix(91,180,180,A_full);
-
-	/* solve with dense matrices */
-	nWSR = 1000;
-	QProblem qrecipeD(180, 91);
-	tic = getCPUtime();
-	qrecipeD.init(Hd, g, Ad, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeD.getPrimalSolution(x1);
-	qrecipeD.getDualSolution(y1);
-
-	fprintf(stdFile, "Solved dense problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* solve with sparse matrices (nullspace factorization) */
-	nWSR = 1000;
-	QProblem qrecipeS(180, 91);
-	tic = getCPUtime();
-	qrecipeS.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeS.getPrimalSolution(x2);
-	qrecipeS.getDualSolution(y2);
-
-	fprintf(stdFile, "Solved sparse problem in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-
-	/* solve with sparse matrices (Schur complement) */
-	#ifndef SOLVER_NONE
-	nWSR = 1000;
-	SQProblemSchur qrecipeSchur(180, 91);
-	tic = getCPUtime();
-	qrecipeSchur.init(H, g, A, lb, ub, lbA, ubA, nWSR, 0);
-	toc = getCPUtime();
-	qrecipeSchur.getPrimalSolution(x3);
-	qrecipeSchur.getDualSolution(y3);
-
-	fprintf(stdFile, "Solved sparse problem (Schur complement approach) in %d iterations, %.3f seconds.\n", (int)nWSR, toc-tic);
-	#endif /* SOLVER_NONE */
-
-	/* check distance of solutions */
-	errP1 = 0.0;
-	errP2 = 0.0;
-	errP3 = 0.0;
-	#ifndef SOLVER_NONE
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x2[i]) > errP1)
-			errP1 = getAbs(x1[i] - x2[i]);
-	for (i = 0; i < 180; i++)
-		if (getAbs(x1[i] - x3[i]) > errP2)
-			errP2 = getAbs(x1[i] - x3[i]);
-	for (i = 0; i < 180; i++)
-		if (getAbs(x2[i] - x3[i]) > errP3)
-			errP3 = getAbs(x2[i] - x3[i]);
-	#endif /* SOLVER_NONE */
-	fprintf(stdFile, "Primal error (dense and sparse): %9.2e\n", errP1);
-	fprintf(stdFile, "Primal error (dense and Schur):  %9.2e\n", errP2);
-	fprintf(stdFile, "Primal error (sparse and Schur): %9.2e\n", errP3);
-
-	errD1 = 0.0;
-	errD2 = 0.0;
-	errD3 = 0.0;
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y2[i]) > errD1)
-			errD1 = getAbs(y1[i] - y2[i]);
-	#ifndef SOLVER_NONE
-	for (i = 0; i < 271; i++)
-		if (getAbs(y1[i] - y3[i]) > errD2)
-			errD2 = getAbs(y1[i] - y3[i]);
-	for (i = 0; i < 271; i++)
-		if (getAbs(y2[i] - y3[i]) > errD3)
-			errD3 = getAbs(y2[i] - y3[i]);
-	#endif /* SOLVER_NONE */
-	fprintf(stdFile, "Dual error (dense and sparse): %9.2e  (might not be unique)\n", errD1);
-	fprintf(stdFile, "Dual error (dense and Schur):  %9.2e  (might not be unique)\n", errD2);
-	fprintf(stdFile, "Dual error (sparse and Schur): %9.2e  (might not be unique)\n", errD3);
-
-	delete H;
-	delete A;
-	delete[] H_full;
-	delete[] A_full;
-	delete Hd;
-	delete Ad;
-
-	delete[] y3;
-	delete[] x3;
-	delete[] y2;
-	delete[] x2;
-	delete[] y1;
-	delete[] x1;
-
-	QPOASES_TEST_FOR_TOL( errP1,1e-13 );
-	QPOASES_TEST_FOR_TOL( errP2,1e-13 );
-	QPOASES_TEST_FOR_TOL( errP3,1e-13 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe_data.hpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe_data.hpp
deleted file mode 100644
index 70334a9..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_qrecipe_data.hpp
+++ /dev/null
@@ -1,401 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_qrecipe.cpp
- *	\author Andreas Potschka
- *	\version 3.2
- *	\date 2007-2015
- *
- *	QRECIPE example from the CUTEr test set with sparse matrices.
- */
-
-
-USING_NAMESPACE_QPOASES
-
-
-
-const real_t Inf = INFTY;
-
-sparse_int_t H_jc[] = { 0,  4,  8, 12, 16, 20, 20, 20, 20, 20, 20,
-	                   24, 28, 32, 36, 40, 40, 40, 40, 40, 40,
-					   44, 48, 52, 56, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
-					   64, 68, 72, 76, 80, 80, 80, 80, 80, 80,
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
-					   80, 80, 80, 80, 80, 80 };
-
-sparse_int_t H_ir[] = {
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38, 
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38, 
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38, 
-	0, 10, 20, 34, 1, 11, 21, 35, 2, 12, 22, 36, 3, 13, 23, 37, 4, 14, 24, 38};
-
-real_t H_val[] = {10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1,
-	1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 1,
-	10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 1, 10, 1,
-	1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10, 1, 1, 1, 10};
-
-sparse_int_t A_jc[] = {
-	  0,  10,  20,  30,  40,  50,  60,  70,  80,  90, 100, 110, 120,
-	130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270,
-	280, 290, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312,
-	313, 314, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 331,
-	333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361,
-	363, 365, 367, 369, 371, 373, 383, 393, 403, 405, 408, 410, 413, 415, 418,
-	420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448,
-	450, 452, 454, 456, 458, 460, 462, 472, 482, 492, 494, 497, 499, 502, 504,
-	507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535,
-	537, 539, 541, 543, 545, 547, 549, 551, 561, 571, 581, 583, 586, 588, 591,
-	593, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609,
-	610, 611, 612, 613, 614, 615, 616, 617, 618, 628, 638, 648, 650, 653, 655,
-	658, 660, 663};
-
-sparse_int_t A_ir[] = {0, 14, 35, 36, 71, 72, 85, 86, 87, 88, 1, 14, 35, 36, 71, 72, 85,
-	86, 87, 88, 2, 14, 35, 36, 71, 72, 85, 86, 87, 88, 3, 14, 35, 36, 71, 72,
-	85, 86, 87, 88, 4, 14, 35, 36, 71, 72, 85, 86, 87, 88, 5, 14, 35, 36, 71,
-	72, 85, 86, 87, 88, 6, 14, 35, 36, 71, 72, 85, 86, 87, 88, 7, 14, 35, 36,
-	71, 72, 85, 86, 87, 88, 8, 14, 35, 36, 71, 72, 85, 86, 87, 88, 9, 14, 35,
-	36, 71, 72, 85, 86, 87, 88, 0, 15, 37, 38, 69, 70, 79, 80, 81, 82, 1, 15,
-	37, 38, 69, 70, 79, 80, 81, 82, 2, 15, 37, 38, 69, 70, 79, 80, 81, 82, 3,
-	15, 37, 38, 69, 70, 79, 80, 81, 82, 4, 15, 37, 38, 69, 70, 79, 80, 81, 82,
-	5, 15, 37, 38, 69, 70, 79, 80, 81, 82, 6, 15, 37, 38, 69, 70, 79, 80, 81,
-	82, 7, 15, 37, 38, 69, 70, 79, 80, 81, 82, 8, 15, 37, 38, 69, 70, 79, 80,
-	81, 82, 9, 15, 37, 38, 69, 70, 79, 80, 81, 82, 0, 16, 39, 40, 67, 68, 73,
-	74, 75, 76, 1, 16, 39, 40, 67, 68, 73, 74, 75, 76, 2, 16, 39, 40, 67, 68,
-	73, 74, 75, 76, 3, 16, 39, 40, 67, 68, 73, 74, 75, 76, 4, 16, 39, 40, 67,
-	68, 73, 74, 75, 76, 5, 16, 39, 40, 67, 68, 73, 74, 75, 76, 6, 16, 39, 40,
-	67, 68, 73, 74, 75, 76, 7, 16, 39, 40, 67, 68, 73, 74, 75, 76, 8, 16, 39,
-	40, 67, 68, 73, 74, 75, 76, 9, 16, 39, 40, 67, 68, 73, 74, 75, 76, 10, 11,
-	12, 13, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 47, 48, 49, 50, 51,
-	52, 53, 54, 55, 56, 57, 47, 58, 48, 59, 49, 60, 50, 61, 51, 62, 52, 63, 53,
-	64, 54, 65, 55, 66, 46, 56, 45, 57, 47, 58, 48, 59, 49, 60, 50, 61, 51, 62,
-	52, 63, 53, 64, 54, 65, 55, 66, 46, 56, 45, 57, 10, 14, 71, 72, 85, 86, 87,
-	88, 89, 90, 11, 15, 69, 70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74,
-	75, 76, 77, 78, 35, 90, 36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78,
-	44, 58, 43, 59, 42, 60, 41, 61, 34, 62, 33, 63, 32, 64, 31, 65, 30, 66, 29,
-	46, 28, 45, 44, 58, 43, 59, 42, 60, 41, 61, 34, 62, 33, 63, 32, 64, 31, 65,
-	30, 66, 29, 46, 28, 45, 10, 14, 71, 72, 85, 86, 87, 88, 89, 90, 11, 15, 69,
-	70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74, 75, 76, 77, 78, 35, 90,
-	36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78, 27, 44, 26, 43, 25, 42,
-	24, 41, 23, 34, 22, 33, 21, 32, 20, 31, 19, 30, 18, 29, 17, 28, 27, 44, 26,
-	43, 25, 42, 24, 41, 23, 34, 22, 33, 21, 32, 20, 31, 19, 30, 18, 29, 17, 28,
-	10, 14, 71, 72, 85, 86, 87, 88, 89, 90, 11, 15, 69, 70, 79, 80, 81, 82, 83,
-	84, 12, 16, 67, 68, 73, 74, 75, 76, 77, 78, 35, 90, 36, 89, 90, 37, 84, 38,
-	83, 84, 39, 78, 40, 77, 78, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 27,
-	26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 10, 14, 71, 72, 85, 86, 87, 88, 89,
-	90, 11, 15, 69, 70, 79, 80, 81, 82, 83, 84, 12, 16, 67, 68, 73, 74, 75, 76,
-	77, 78, 35, 90, 36, 89, 90, 37, 84, 38, 83, 84, 39, 78, 40, 77, 78};
-
-real_t A_val[] = {
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.8678200000000004e+01,
- 9.3617050000000006e+01,  1.6000000000000000e+01,  8.1999999999999993e+00,
- 9.9000000000000000e+01,  8.0000000000000000e+01,  1.2000000000000000e+01,
- 9.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.0062830000000005e+01,  9.9224010000000007e+01,  1.0000000000000000e+02,
- 2.1100000000000001e+01,  1.0000000000000000e+02,  1.0000000000000000e+02,
- 1.1400000000000000e+02,  1.1680000000000000e+02, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.4697360000000003e+01,  8.3801220000000001e+01,
--8.1999999999999993e+00,  2.0000000000000000e+00,  9.0000000000000000e+01,
- 2.3999999999999999e+00, -1.2000000000000000e+01, -1.4800000000000001e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.9194209999999998e+01,
- 9.0175110000000004e+01,  4.3000000000000000e+01,  8.0000000000000000e+00,
- 1.0000000000000000e+02,  9.5000000000000000e+01,  9.0000000000000000e+00,
- 2.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.8568219999999997e+01,  8.5996200000000002e+01, -1.2500000000000000e+01,
- 1.0000000000000000e+00,  9.6500000000000000e+01,  4.0000000000000000e+00,
--1.8000000000000000e+01, -2.1899999999999999e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.2922240000000002e+01,  8.6963380000000001e+01,
- 6.5000000000000000e+01,  1.2500000000000000e+01,  1.0000000000000000e+02,
- 9.8000000000000000e+01,  4.9000000000000000e+01,  3.7000000000000000e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.2592740000000006e+01,
- 9.3147599999999997e+01, -1.2000000000000000e+01,  1.0000000000000000e+00,
- 9.6500000000000000e+01,  4.0000000000000000e+00, -1.8000000000000000e+01,
--2.1899999999999999e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.6506460000000004e+01,  7.8210250000000002e+01,  7.9000000000000000e+01,
- 1.2000000000000000e+01,  1.0000000000000000e+02,  9.5000000000000000e+01,
- 6.8000000000000000e+01,  6.1000000000000000e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.8357460000000003e+01,  9.4257840000000002e+01,
- 1.2500000000000000e+02,  6.1299999999999997e+01,  1.0000000000000000e+02,
- 1.0000000000000000e+02,  1.4500000000000000e+02,  1.4500000000000000e+02,
--1.0000000000000000e+00,  1.0000000000000000e+00,  9.0590469999999996e+01,
- 1.0582863000000000e+02,  6.2000000000000002e+00,  6.0000000000000000e+00,
- 9.7000000000000000e+01,  2.8500000000000000e+01,  4.0000000000000000e+00,
- 3.6000000000000001e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.8678200000000004e+01,  9.3617050000000006e+01,  1.6000000000000000e+01,
- 8.1999999999999993e+00,  9.9000000000000000e+01,  8.0000000000000000e+01,
- 1.2000000000000000e+01,  9.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.0062830000000005e+01,  9.9224010000000007e+01,
- 1.0000000000000000e+02,  2.1100000000000001e+01,  1.0000000000000000e+02,
- 1.0000000000000000e+02,  1.1400000000000000e+02,  1.1680000000000000e+02,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.4697360000000003e+01,
- 8.3801220000000001e+01, -8.1999999999999993e+00,  2.0000000000000000e+00,
- 9.0000000000000000e+01,  2.3999999999999999e+00, -1.2000000000000000e+01,
--1.4800000000000001e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.9194209999999998e+01,  9.0175110000000004e+01,  4.3000000000000000e+01,
- 8.0000000000000000e+00,  1.0000000000000000e+02,  9.5000000000000000e+01,
- 9.0000000000000000e+00,  2.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.8568219999999997e+01,  8.5996200000000002e+01,
--1.2500000000000000e+01,  1.0000000000000000e+00,  9.6500000000000000e+01,
- 4.0000000000000000e+00, -1.8000000000000000e+01, -2.1899999999999999e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.2922240000000002e+01,
- 8.6963380000000001e+01,  6.5000000000000000e+01,  1.2500000000000000e+01,
- 1.0000000000000000e+02,  9.8000000000000000e+01,  4.9000000000000000e+01,
- 3.7000000000000000e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.2592740000000006e+01,  9.3147599999999997e+01, -1.2000000000000000e+01,
- 1.0000000000000000e+00,  9.6500000000000000e+01,  4.0000000000000000e+00,
--1.8000000000000000e+01, -2.1899999999999999e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.6506460000000004e+01,  7.8210250000000002e+01,
- 7.9000000000000000e+01,  1.2000000000000000e+01,  1.0000000000000000e+02,
- 9.5000000000000000e+01,  6.8000000000000000e+01,  6.1000000000000000e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.8357460000000003e+01,
- 9.4257840000000002e+01,  1.2500000000000000e+02,  6.1299999999999997e+01,
- 1.0000000000000000e+02,  1.0000000000000000e+02,  1.4500000000000000e+02,
- 1.4500000000000000e+02, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 9.0590469999999996e+01,  1.0582863000000000e+02,  6.2000000000000002e+00,
- 6.0000000000000000e+00,  9.7000000000000000e+01,  2.8500000000000000e+01,
- 4.0000000000000000e+00,  3.6000000000000001e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.8678200000000004e+01,  9.3617050000000006e+01,
- 1.6000000000000000e+01,  8.1999999999999993e+00,  9.9000000000000000e+01,
- 8.0000000000000000e+01,  1.2000000000000000e+01,  9.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  8.0062830000000005e+01,
- 9.9224010000000007e+01,  1.0000000000000000e+02,  2.1100000000000001e+01,
- 1.0000000000000000e+02,  1.0000000000000000e+02,  1.1400000000000000e+02,
- 1.1680000000000000e+02, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 7.4697360000000003e+01,  8.3801220000000001e+01, -8.1999999999999993e+00,
- 2.0000000000000000e+00,  9.0000000000000000e+01,  2.3999999999999999e+00,
--1.2000000000000000e+01, -1.4800000000000001e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  7.9194209999999998e+01,  9.0175110000000004e+01,
- 4.3000000000000000e+01,  8.0000000000000000e+00,  1.0000000000000000e+02,
- 9.5000000000000000e+01,  9.0000000000000000e+00,  2.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.8568219999999997e+01,
- 8.5996200000000002e+01, -1.2500000000000000e+01,  1.0000000000000000e+00,
- 9.6500000000000000e+01,  4.0000000000000000e+00, -1.8000000000000000e+01,
--2.1899999999999999e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.2922240000000002e+01,  8.6963380000000001e+01,  6.5000000000000000e+01,
- 1.2500000000000000e+01,  1.0000000000000000e+02,  9.8000000000000000e+01,
- 4.9000000000000000e+01,  3.7000000000000000e+01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  8.2592740000000006e+01,  9.3147599999999997e+01,
--1.2000000000000000e+01,  1.0000000000000000e+00,  9.6500000000000000e+01,
- 4.0000000000000000e+00, -1.8000000000000000e+01, -2.1899999999999999e+01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  7.6506460000000004e+01,
- 7.8210250000000002e+01,  7.9000000000000000e+01,  1.2000000000000000e+01,
- 1.0000000000000000e+02,  9.5000000000000000e+01,  6.8000000000000000e+01,
- 6.1000000000000000e+01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 8.8357460000000003e+01,  9.4257840000000002e+01,  1.2500000000000000e+02,
- 6.1299999999999997e+01,  1.0000000000000000e+02,  1.0000000000000000e+02,
- 1.4500000000000000e+02,  1.4500000000000000e+02, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  9.0590469999999996e+01,  1.0582863000000000e+02,
- 6.2000000000000002e+00,  6.0000000000000000e+00,  9.7000000000000000e+01,
- 2.8500000000000000e+01,  4.0000000000000000e+00,  3.6000000000000001e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00, -1.2000000000000000e-01,
--3.8000000000000000e-01, -5.0000000000000000e-01,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--9.3000000000000000e+01, -8.9000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -8.9000000000000000e+01, -8.5000000000000000e+01,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.1000000000000000e+01,
--8.8000000000000000e+01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.3000000000000000e+01,
--8.9000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--8.9000000000000000e+01, -8.5000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.1000000000000000e+01, -8.8000000000000000e+01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00,  1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.3000000000000000e+01, -8.9000000000000000e+01,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -8.9000000000000000e+01,
--8.5000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--9.1000000000000000e+01, -8.8000000000000000e+01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
--1.0000000000000000e+00, -1.0000000000000000e+00, -1.0000000000000000e+00,
- 1.0000000000000000e+00, -1.0000000000000000e+00, -4.7000000000000000e+01,
--8.6999999999999993e+00, -9.0000000000000000e+01, -5.0000000000000000e+01,
--1.0000000000000000e+01, -1.0000000000000000e+01, -9.3000000000000000e+01,
--8.9000000000000000e+01,  1.0000000000000000e+00, -1.0000000000000000e+00,
--4.7000000000000000e+01, -8.6999999999999993e+00, -9.0000000000000000e+01,
--5.0000000000000000e+01, -1.0000000000000000e+01, -1.0000000000000000e+01,
--8.9000000000000000e+01, -8.5000000000000000e+01,  1.0000000000000000e+00,
--1.0000000000000000e+00, -4.7000000000000000e+01, -8.6999999999999993e+00,
--9.0000000000000000e+01, -5.0000000000000000e+01, -1.0000000000000000e+01,
--1.0000000000000000e+01, -9.1000000000000000e+01, -8.8000000000000000e+01,
--1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 1.0000000000000000e+00,  5.0000000000000000e-01, -1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  1.0000000000000000e+00,
- 5.0000000000000000e-01, -1.0000000000000000e+00,  5.0000000000000000e-01,
--1.0000000000000000e+00,  1.0000000000000000e+00,  5.0000000000000000e-01};
-
-real_t g[] = {+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00, -2e+00,
-	-2e+00, +0e+00, -2e+00, +0e+00, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03,
-	+2e-03, +1e-03, +2e-03, +2e-03, +2e-03, +0e+00, -2e-03, -2e-03, -2e-03,
-	-2e-03, -2e-03, -2e-03, -1e-03, -2e-03, -2e-03, -2e-03, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +2e-03,
-	+2e-03, +2e-03, +2e-03, +2e-03, +2e-03, +1e-03, +2e-03, +2e-03, +2e-03,
-	+0e+00, -2e-03, -2e-03, -2e-03, -2e-03, -2e-03, -2e-03, -1e-03, -2e-03,
-	-2e-03, -2e-03, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03, +2e-03,
-	+1e-03, +2e-03, +2e-03, +2e-03, +0e+00, -2e-03, -2e-03, -2e-03, -2e-03,
-	-2e-03, -2e-03, -1e-03, -2e-03, -2e-03, -2e-03, +0e+00, +0e+00, +0e+00,
-	+0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +1e-01, +1e-01,
-	+1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +1e-01, +0e+00,
-	-1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01, -1e-01,
-	-1e-01, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00, +0e+00,
-	+0e+00};
-
-real_t lb[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, -Inf, 0, -Inf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 5,
-	10, 5, 0, 10, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 10, 5, 10, 5, 0, 10, 0, 5, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 5, 10, 5, 0, 10, 0, 5, 0, 10, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-real_t ub[] = {Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, 0, 92, 39, 87, 29, 0, 20, 0, 28, 20, 71, Inf, 130, 45, 53, 55, 75,
-	112, 0, 73, 480, 154, 121, 50, 30, 77, 20, 0, 18, 0, 5, 20, 71, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, 130, 55, 93, 60, 75, 115, 0, 67,
-	480, 154, 121, 50, 20, 37, 15, 0, 15, 0, 8, 20, 71, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf, Inf, 130, 55, 93, 60, 75, 105, 0, 67, 4980, 154, 110,
-	50, 20, 37, 15, 0, 25, 0, 8, 20, 71, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, 20, 20, 20, 20, 0, 20, 0, 20, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf};
-
-real_t lbA[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -Inf, -Inf,
-	-Inf, -Inf, -Inf, -Inf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0};
-
-real_t ubA[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,
-	Inf, Inf, Inf, Inf};
-
-long H_nnz =  sizeof(H_val) / sizeof(real_t);
-long A_nnz =  sizeof(A_val) / sizeof(real_t);
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_runAllOqpExamples.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_runAllOqpExamples.cpp
deleted file mode 100644
index 93a3ae8..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_runAllOqpExamples.cpp
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_runAllOqpExamples.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2013-2015
- *
- *	Use qpOASES for solving all QP sequences of the Online QP Benchmark 
- *	Collection. In order to run it, you have to download all examples
- *	from http://www.qpOASES.org/onlineQP/.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** Example for qpOASES main function using the OQP interface. */
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	/* 1) Define benchmark arguments. */
-	BooleanType isSparse = BT_FALSE;
-	BooleanType useHotstarts;
-
-	Options options;
-	options.setToMPC();
-	options.printLevel = PL_LOW;
-
-	int_t maxAllowedNWSR;
-	real_t maxNWSR, avgNWSR, maxCPUtime, avgCPUtime;
-	real_t maxStationarity, maxFeasibility, maxComplementarity;
-
-	const int_t numBenchmarks = 4; //5
-	const char *benchmarkPath[numBenchmarks];
-	benchmarkPath[0] = "../testing/cpp/data/oqp/chain80/";
-	benchmarkPath[1] = "../testing/cpp/data/oqp/chain80w/";
-	benchmarkPath[2] = "../testing/cpp/data/oqp/diesel/";
-	benchmarkPath[3] = "../testing/cpp/data/oqp/crane/";
-	//benchmarkPath[4] = "../testing/cpp/data/oqp/CDU/";
-
-
-	/* 2) Run all benchmarks in a loop */
-	for ( int_t ii=0; ii<2*numBenchmarks; ++ii )
-	{
-		if ( ii%2 == 0 )
-			useHotstarts = BT_FALSE;
-		else
-			useHotstarts = BT_TRUE;
-		
-		maxAllowedNWSR = 1000;
-		maxNWSR = 0.0;
-		avgNWSR = 0.0;
-		maxCPUtime = 1000.0; /* seconds */
-		avgCPUtime =    0.0; /* seconds */
-		maxStationarity    = 0.0;
-		maxFeasibility     = 0.0;
-		maxComplementarity = 0.0;
-
-		if ( runOqpBenchmark(	benchmarkPath[ii/2],
-								isSparse,useHotstarts,
-								options,maxAllowedNWSR,
-								maxNWSR,avgNWSR,maxCPUtime,avgCPUtime,
-								maxStationarity,maxFeasibility,maxComplementarity
-								) != SUCCESSFUL_RETURN )
-		{
-			myPrintf( "Something went wrong when running benchmark!\n" );
-			return TEST_DATA_NOT_FOUND;
-		}
-
-		/* 3) Print results. */
-		printf( "\n\n" );
-		if ( useHotstarts == BT_FALSE )
-			printf( "OQP Benchmark Results for %s (cold-starts):\n", benchmarkPath[ii/2] );
-		else
-			printf( "OQP Benchmark Results for %s (hot-starts):\n", benchmarkPath[ii/2] );
-
-		printf( "===========================================================================\n\n" );
-		printf( "maximum CPU time:             %.2f milliseconds\n",1000.0*maxCPUtime );
-		printf( "average CPU time:             %.2f milliseconds\n",1000.0*avgCPUtime );
-		printf( "\n" );
-		printf( "maximum iterations:    %.1f\n",maxNWSR );
-		printf( "average iterations:    %.1f\n",avgNWSR );
-		printf( "\n" );
-		printf( "maximum violation stationarity:     %.3e\n",maxStationarity );
-		printf( "maximum violation feasibility:      %.3e\n",maxFeasibility );
-		printf( "maximum violation complementarity:  %.3e\n",maxComplementarity );
-		printf( "\n" );
-
-		QPOASES_TEST_FOR_TOL( maxStationarity,    1e-9  );
-		QPOASES_TEST_FOR_TOL( maxFeasibility,     1e-11 );
-		QPOASES_TEST_FOR_TOL( maxComplementarity, 1e-10 );
-		
-		switch( ii )
-		{
-			case 0:
-				/* chain80 (cold) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 62.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  7.5 );
-				break;
-
-			case 1:
-				/* chain80 (hot) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 19.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  2.4 );
-				break;
-
-			case 2:
-				/* chain80w (cold) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 84.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <= 10.1 );
-				break;
-
-			case 3:
-				/* chain80w (hot) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 16.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  2.7 );
-				break;
-
-			case 4:
-				/* diesel (cold) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 26.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  0.5 );
-				break;
-
-			case 5:
-				/* diesel (hot) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 22.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  0.3 );
-				break;
-
-			case 6:
-				/* crane (cold) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 64.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <= 44.0 );
-				break;
-
-			case 7:
-				/* crane (hot) */
-				QPOASES_TEST_FOR_TRUE( maxNWSR <= 42.5 );
-				QPOASES_TEST_FOR_TRUE( avgNWSR <=  0.4 );
-				break;
-		}
-	}
-	
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_sebastien1.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_sebastien1.cpp
deleted file mode 100644
index 7ed5ba1..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_sebastien1.cpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_sebastien1.cpp
- *	\author Sebastien B.
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Example that caused troubles in an earlier release.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-
-/** qpOASES main function defining a unit test. */
-int main( )
-{
-	REFER_NAMESPACE_QPOASES real_t solution[2]       = {0.0f, 0.0f};
-	REFER_NAMESPACE_QPOASES real_t expectedFirst[2]  = {0.5f, -1.5f};
-  
-	REFER_NAMESPACE_QPOASES real_t H[2*2] = {1.0f, 0.0f, 0.0f, 0.5f};
-	REFER_NAMESPACE_QPOASES real_t g[2]   = {1.5f, 1.0f};
-
-	REFER_NAMESPACE_QPOASES real_t A[1*2] = {1.0f, 1.0f};
-	REFER_NAMESPACE_QPOASES real_t lbA[1] = {-1.0f};
-	REFER_NAMESPACE_QPOASES real_t ubA[1] = {2.0f};
-
-	REFER_NAMESPACE_QPOASES real_t lb[2]  = {0.5f, -2.0f};
-	REFER_NAMESPACE_QPOASES real_t ub[2]  = {5.0f, 2.0f};
-
-	REFER_NAMESPACE_QPOASES QProblem example(2, 1);
-	REFER_NAMESPACE_QPOASES Options options = example.getOptions();
-	//options.enableFarBounds = REFER_NAMESPACE_QPOASES BT_FALSE;
-	example.setOptions(options);
-	example.setPrintLevel(REFER_NAMESPACE_QPOASES PL_NONE);
-
-	// Solve first QP.
-	REFER_NAMESPACE_QPOASES int_t nWSR = 10;
-	QPOASES_TEST_FOR_TRUE( example.init(H, g, A, lb, ub, lbA, ubA, nWSR, NULL) == REFER_NAMESPACE_QPOASES SUCCESSFUL_RETURN );
-	QPOASES_TEST_FOR_TRUE( example.isSolved() == REFER_NAMESPACE_QPOASES BT_TRUE );
-	example.getPrimalSolution(solution);
-
-	printf( "\nxOpt = [ %e, %e ];\n\n", solution[0],solution[1] );
-
-	for( REFER_NAMESPACE_QPOASES uint_t i=0; i<2; i++ )
-		QPOASES_TEST_FOR_NEAR( solution[i],expectedFirst[i] );
-
-	return TEST_PASSED;
-}
diff --git a/extlibs/qpOASES-3.2.0/testing/cpp/test_vanBarelsUnboundedQP.cpp b/extlibs/qpOASES-3.2.0/testing/cpp/test_vanBarelsUnboundedQP.cpp
deleted file mode 100644
index b0d3d8a..0000000
--- a/extlibs/qpOASES-3.2.0/testing/cpp/test_vanBarelsUnboundedQP.cpp
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- *	This file is part of qpOASES.
- *
- *	qpOASES -- An Implementation of the Online Active Set Strategy.
- *	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
- *	Christian Kirches et al. All rights reserved.
- *
- *	qpOASES is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU Lesser General Public
- *	License as published by the Free Software Foundation; either
- *	version 2.1 of the License, or (at your option) any later version.
- *
- *	qpOASES is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *	See the GNU Lesser General Public License for more details.
- *
- *	You should have received a copy of the GNU Lesser General Public
- *	License along with qpOASES; if not, write to the Free Software
- *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- *
- */
-
-
-/**
- *	\file testing/cpp/test_vanBarelsUnboundedQP.cpp
- *	\author Hans Joachim Ferreau
- *	\version 3.2
- *	\date 2007-2015
- *
- *	Example that causes troubles when hotstarting.
- */
-
-
-
-#include <qpOASES.hpp>
-#include <qpOASES/UnitTesting.hpp>
-
-#include <stdio.h>
-
-
-
-int main( )
-{
-	USING_NAMESPACE_QPOASES
-
-	real_t H[2*2] = { 1.0, 0.0, 0.0, 0.0 };
-	real_t g[2] = { 1.5, 1.0 };
-		
-	Options options;
-	//options.enableFarBounds = BT_FALSE;
-
-	QProblemB qp(2);
-	qp.setOptions( options );
-
-	int_t iter = 10;
-	qp.init( H,g,0,0,iter );
-
-	real_t xOpt[2];
-	qp.getPrimalSolution( xOpt );
-	print( xOpt,2 );
-
-	return TEST_PASSED;
-}
-
-
-/*
- *	end of file
- */
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateExample.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateExample.m
deleted file mode 100644
index 9476d7e..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateExample.m
+++ /dev/null
@@ -1,25 +0,0 @@
-function [ qpData ] = generateExample( nV,nC, isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC, seed, givenH,givenA )
-
-    if ( nargin < 11 )
-        givenA = [];
-        if ( nargin < 10 )
-            givenH = [];
-        end
-    end
-
-    qpFeatures = setupQpFeaturesStruct( );
-    
-    qpFeatures.nV = nV;
-    qpFeatures.nC = nC;
-    
-    qpFeatures.isSparseH = isSparseH;
-    qpFeatures.isSparseA = isSparseA;
-    
-    qpFeatures.hasLowerB = hasLowerB;
-    qpFeatures.hasUpperB = hasUpperB;
-    qpFeatures.hasLowerC = hasLowerC;
-    qpFeatures.hasUpperC = hasUpperC;
-    
-    qpData = generateRandomQp( qpFeatures,seed, givenH,givenA );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateRandomQp.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateRandomQp.m
deleted file mode 100644
index 3fd4fd3..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/generateRandomQp.m
+++ /dev/null
@@ -1,110 +0,0 @@
-function [ qpData ] = generateRandomQp( qpFeatures,randSeed, givenH,givenA )
-
-    if ( nargin < 4 )
-        givenA = [];
-        if ( nargin < 3 )
-            givenH = [];
-        end
-    end
-    
-    if ( isoctave == 0 )
-        if ( nargin < 2 )
-            s = RandStream( 'mt19937ar', 'Seed','shuffle' );
-            RandStream.setGlobalStream(s);
-        else
-            s = RandStream( 'mt19937ar', 'Seed',randSeed );
-            RandStream.setGlobalStream(s);
-        end
-    end
-    
-
-    qpData = setupQpDataStruct( );
-    qpData.nV = qpFeatures.nV;
-    qpData.nC = qpFeatures.nC;
-    
-    
-    % generate random optimal primal solution
-    xFeas = rand( qpFeatures.nV,1 );
-    
-    % generate random optimal dual solution
-    %yOpt = zeros( qpFeatures.nV+qpFeatures.nC,1 );
-    
-    if ( isempty(givenH) > 0 )
-        
-        switch ( qpFeatures.hessianType )
-
-            case 0
-                qpData.H = 100 * rand( qpData.nV,qpData.nV ) - 50;
-                qpData.H = qpData.H' * qpData.H / 2;
-
-            case 1
-                qpData.H = 100 * rand( qpData.nV,round(qpData.nV/2) ) - 50;
-                qpData.H = qpData.H' * qpData.H / 2;
-
-            case 2
-                qpData.H = eye( qpData.nV );
-
-            case 3
-                qpData.H = zeros( qpData.nV,qpData.nV );
-
-        end
-        
-    else
-        qpData.H = givenH;
-    end
-    
-    qpData.g = 1000 * rand( qpFeatures.nV,1 ) - 500;
-    
-    if ( isempty(givenA) > 0 )
-        
-        if ( qpFeatures.nC > 0 )
-            qpData.Ain = 100 * rand( qpData.nC,qpData.nV ) - 50;
-        else
-            qpData.Ain = [];
-        end
-        
-    else
-        qpData.Ain = givenA;
-    end
-    
-    if ( qpFeatures.makeInfeas > 0 )
-        alpha = -0.1;
-        beta  = -0.001;
-    else
-        alpha = 1;
-        beta  = 1;
-    end
-        
-    if ( qpFeatures.hasLowerB > 0 )
-        qpData.lb = xFeas - 3*rand( qpData.nV,1 );
-    else
-        qpData.lb = [];
-    end
-    
-    if ( qpFeatures.hasUpperB > 0 )
-        qpData.ub = xFeas + alpha*3*rand( qpData.nV,1 );
-    else
-        qpData.ub = [];
-    end
-    
-    if ( ( qpFeatures.hasLowerC > 0 ) && ( qpData.nC > 0 ) )
-        qpData.lbA = qpData.Ain*xFeas - 100*rand( qpData.nC,1 );
-    else
-        qpData.lbA = [];
-    end
-    
-    if ( ( qpFeatures.hasUpperC > 0 ) && ( qpData.nC > 0 ) )
-        qpData.ubA = qpData.Ain*xFeas + beta*100*rand( qpData.nC,1 );
-    else
-        qpData.ubA = [];
-    end
-    
-    if ( qpFeatures.isSparseH > 0 )
-        qpData.H = sparse( qpData.H );
-    end
-    
-    if ( qpFeatures.isSparseA > 0 )
-        qpData.Ain = sparse( qpData.Ain );
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/getKktResidual.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/getKktResidual.m
deleted file mode 100644
index 55b17a0..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/getKktResidual.m
+++ /dev/null
@@ -1,134 +0,0 @@
-function [kkt,stat,feas,cmpl] = getKktResidual( H,g,A,lb,ub,lbA,ubA, x,y )
-
-    % Tolerance for dual variables considered zero.
-	dualActiveTolerance = 1.0e3 * eps;
-
-	% Initialize residuals
-    stat = 0.0;
-    feas = 0.0;
-    cmpl = 0.0;
-    
-    if ( isempty(H) == 0 )
-        nV = size( H,1 );
-    else
-        nV = size( g,2 );
-    end
-
-    if ( isempty(A) == 0 )
-        nC = size( A,1 );
-    else
-        nC = 0;
-    end
-
-   
-	%% check stationarity
-	for i=1:nV
-        
-		% g term and variable bounds dual term
-        if ( isempty(g) == 0 )
-            sum = g(i) - y(i);
-        else
-            sum = 0 - y(i);
-        end
-
-		% H*x term
-        if ( isempty(H) == 0 )
-            sum = sum + H(i,:) * x;
-        end
-
-		% A'*y term
-        if ( isempty(A) == 0 )
-            sum = sum - A(:,i)' * y(nV+1:nV+nC);
-        end
-		
-		% update stat
-        if (abs(sum) > stat)
-            stat = abs(sum);
-        end
-        
-	end
-
-    %% check primal feasibility and complementarity
-	% variable bounds
-	for i=1:nV
-
-		% feasibility
-        if ( isempty(lb) == 0 )
-            if (lb(i) - x(i) > feas) 
-				feas = lb(i) - x(i);
-            end
-        end
-
-        if ( isempty(ub) == 0 )
-            if (x(i) - ub(i) > feas) 
-				feas = x(i) - ub(i);
-            end
-        end
-
-		% complementarity
-		prod = 0.0;
-
-        if ( isempty(lb) == 0 )
-             if (y(i) > dualActiveTolerance) % lower bound
-				prod = (x(i) - lb(i)) * y(i);
-            end
-        end
-
-        if ( isempty(ub) == 0 )
-            if (y(i) < -dualActiveTolerance) % upper bound
-				prod = (x(i) - ub(i)) * y(i);
-            end
-        end
-
-        if (abs(prod) > cmpl)
-            cmpl = abs(prod);
-        end
-        
-	end
-    
-	% A*x bounds
-    for i=1:nC
-
-        % compute sum = (A*x)_i
-		sum = 0.0;
-        if ( isempty(A) == 0 )
-            sum = sum + A(i,:) * x;
-        end
-
-		% feasibility
-        if ( isempty(lbA) == 0 )
-            if (lbA(i) - sum > feas) 
-				feas = lbA(i) - sum;
-            end
-        end
-
-        if ( isempty(ubA) == 0 )
-            if (sum - ubA(i) > feas) 
-				feas = sum - ubA(i);
-            end
-        end
-
-		% complementarity
-		prod = 0.0;
-
-        if ( isempty(lbA) == 0 )
-            if (y(nV+i) > dualActiveTolerance) % lower bound
-				prod = (sum - lbA(i)) * y(nV+i);
-            end
-        end
-		
-        if ( isempty(ubA) == 0 )
-            if (y(nV+i) < -dualActiveTolerance) % upper bound
-				prod = (sum - ubA(i)) * y(nV+i);
-            end
-        end
-
-        if (abs(prod) > cmpl)
-            cmpl = abs(prod);
-        end
-        
-    end
-    
-    kkt = max( [stat,feas,cmpl] );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/isoctave.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/isoctave.m
deleted file mode 100644
index e4726d4..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/isoctave.m
+++ /dev/null
@@ -1,21 +0,0 @@
-
-% ISOCTAVE  True if the operating environment is octave.
-%    Usage: t=isoctave();
-% 
-%    Returns 1 if the operating environment is octave, otherwise
-%    0 (Matlab)
-% 
-% ---------------------------------------------------------------
-function t=isoctave()
-%ISOCTAVE  True if the operating environment is octave.
-%   Usage: t=isoctave();
-%
-%   Returns 1 if the operating environment is octave, otherwise
-%   0 (Matlab)
-
-if exist('OCTAVE_VERSION')
-  % Only Octave has this variable.
-  t=1;
-else
-  t=0;
-end;
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpDataStruct.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpDataStruct.m
deleted file mode 100644
index 93d9e3c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpDataStruct.m
+++ /dev/null
@@ -1,18 +0,0 @@
-function [ qpData ] = setupQpDataStruct( )
-
-    qpData = struct(    'H', [], ...        % Hessian matrix
-                        'g', [], ...        % gradient vector
-                        'Aeq', [], ...      % equality constraints matrix
-                        'beq', [], ...      % equality constraints vector
-                        'lb', [], ...       % lower bound vector
-                        'ub', [], ...       % upper bound vector
-                        'Ain', [], ...      % inequality constraints matrix
-                        'lbA', [], ...      % lower constraints vector
-                        'ubA', [], ...      % upper constraints vector
-                        'x0', [], ...       % primal initial guess
-                        'options', [], ...  % QP solver options
-                        'nV', 0, ...        % number of QP variables
-                        'nC', 0 ...         % number of constraints
-                        );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpFeaturesStruct.m b/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpFeaturesStruct.m
deleted file mode 100644
index 903a891..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/auxFiles/setupQpFeaturesStruct.m
+++ /dev/null
@@ -1,21 +0,0 @@
-function [ qpFeatures ] = setupQpFeaturesStruct( )
-
-    qpFeatures = struct(    'nV',  0, ...
-                            'nIB', 0, ...
-                            'nEB', 0, ...
-                            'nC',  0, ...
-                            'nIC', 0, ...
-                            'nEC', 0, ...
-                            'nActB', 0, ...
-                            'nActC', 0, ...
-                            'hasLowerB', 0, ...
-                            'hasUpperB', 0, ...
-                            'hasLowerC', 0, ...
-                            'hasUpperC', 0, ...
-                            'isSparseH', 0, ...
-                            'isSparseA', 0, ...
-                            'makeInfeas', 0, ...
-                            'hessianType', 0 ... % 0 = pos def; 1 = pos sem def; 2 = id; 3 = zero
-                            );
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/data/fetch_matlab_data b/extlibs/qpOASES-3.2.0/testing/matlab/data/fetch_matlab_data
deleted file mode 100755
index 1cd223c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/data/fetch_matlab_data
+++ /dev/null
@@ -1,34 +0,0 @@
-#!/usr/bin/env bash
-
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/matlab/data/fetch_matlab_data
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014-2015
-
-
-svn export https://projects.coin-or.org/svn/qpOASES/misc/testingdata/matlab . --force
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/runAllTests.m b/extlibs/qpOASES-3.2.0/testing/matlab/runAllTests.m
deleted file mode 100644
index f17b0a0..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/runAllTests.m
+++ /dev/null
@@ -1,152 +0,0 @@
-function [ successFlag ] = runAllTests( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-    
-    successFlag = 1;
-    
-    curWarnLevel = warning;
-    warning('off');
-    
-    % add sub-folders to Matlab path
-	setupTestingPaths();
-    
-    clc;
-
-    %% run interface tests
-    fprintf( 'Running qpOASES interface tests... ' )
-    successFlag = updateSuccessFlag( successFlag, runInterfaceTest( 10,20, doPrint,42 ) );
-
-    fprintf( 'Running qpOASES_sequence interface tests... ' )
-    successFlag = updateSuccessFlag( successFlag, runInterfaceSeqTest( 8,5, doPrint,42 ) );
-    
-    
-    %% run functional tests
-    fprintf( 'Running tests with random QPs having identity Hessian... ' )
-    successFlag = updateSuccessFlag( successFlag, runRandomIdHessian( 12,12, doPrint,4242 ) );
-    
-    fprintf( 'Running tests with random QPs having zero Hessian... ' )
-    successFlag = updateSuccessFlag( successFlag, runRandomZeroHessian( 11,41, doPrint,4242 ) );
-    
-    fprintf( 'Running qpOASES passing an empty Hessian matrix argument... ' )
-    successFlag = updateSuccessFlag( successFlag, runEmptyHessianTests( doPrint ) );
-
-    fprintf( 'Running alternativeX0 test... ' )
-    successFlag = updateSuccessFlag( successFlag, runAlternativeX0Test( 50,300,doPrint,4242 ) );
-    
-    fprintf( 'Running testAPrioriKnownSeq1... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestAPrioriKnownSeq1( doPrint ) );
-        
-    fprintf( 'Running testSeq... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestSeq( doPrint ) );
-    
-    fprintf( 'Running testSparse... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestSparse( doPrint ) );
-    
-    fprintf( 'Running testSparse2... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestSparse2( doPrint ) );
-    
-    fprintf( 'Running testSparse3... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestSparse3( doPrint ) );
-    
-    fprintf( 'Running testSparse4... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestSparse4( doPrint ) );
-    
-    fprintf( 'Running simpleSpringExample... ' )
-    successFlag = updateSuccessFlag( successFlag, runSimpleSpringExample( doPrint ) );
-    
-    fprintf( 'Running vanBarelsUnboundedQP... ' )
-    successFlag = updateSuccessFlag( successFlag, runVanBarelsUnboundedQP( doPrint ) );
-    
-    fprintf( 'Running alexInfeas1... ' )
-    successFlag = updateSuccessFlag( successFlag, runAlexInfeas1( doPrint ) );
-    
-    %fprintf( 'Running alexInfeas2... ' )
-    %successFlag = updateSuccessFlag( successFlag, runAlexInfeas2( doPrint ) );
-
-    %fprintf( 'Running QAP8... ' )
-    %successFlag = updateSuccessFlag( successFlag, runQAP( doPrint ) );
-    
-    fprintf( 'Running testWorkingSetLI... ' )
-    successFlag = updateSuccessFlag( successFlag, runTestWorkingSetLI( doPrint ) );
-    
-    fprintf( 'Running runExternalCholeskyTests... ' )
-    successFlag = updateSuccessFlag( successFlag, runExternalCholeskyTests( doPrint ) );
-
-    fprintf( 'Running EXAMPEL1... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkEXAMPLE1( 10,doPrint ) );
-	
-    fprintf( 'Running EXAMPLE1A... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkEXAMPLE1A( 10,doPrint ) );
-	
-    fprintf( 'Running EXAMPLE1B... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkEXAMPLE1B( 10,doPrint ) );
-
-	fprintf( 'Running CHAIN1... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkCHAIN1( 20,doPrint ) );
-	
-    fprintf( 'Running CHAIN1A... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkCHAIN1A( 20,doPrint ) );
-
-	fprintf( 'Running CRANE1... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkCRANE1( 100,doPrint ) );
-
-    fprintf( 'Running CRANE2... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkCRANE2( 100,doPrint ) );
-
-    fprintf( 'Running CRANE3... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkCRANE3( 100,doPrint ) );
-	
-	fprintf( 'Running EQUALITY1... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkEQUALITY1( 100,doPrint ) );
-
-    fprintf( 'Running EQUALITY2... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkEQUALITY2( 3200,doPrint ) );
-
-    %fprintf( 'Running IDHESSIAN1... ' );
-	%successFlag = updateSuccessFlag( successFlag, runBenchmarkIDHESSIAN1( 1200,doPrint ) );
-
-    fprintf( 'Running DIESEL... ' );
-    successFlag = updateSuccessFlag( successFlag, runBenchmarkDIESEL( 230,doPrint ) );
-    
-    fprintf( 'Running QSHARE1B... ' )
-    successFlag = updateSuccessFlag( successFlag, runQSHARE1B( doPrint ) );
-
-    
-    
-    %% display results
-    disp( ' ' );
-    
-    if ( successFlag == 0 )
-        disp( 'At least one test failed!' );
-    else
-        disp( 'All available tests passed successfully!' );
-    end
-
-    warning( curWarnLevel );
-    
-end
-
-
-function [ newSuccessFlag ] = updateSuccessFlag( curSuccessFlag,curResult )
-
-    switch ( curResult )
-        
-        case 0
-            newSuccessFlag = 0;
-            fprintf( 'failed!\n' );
-        
-        case 1          
-            newSuccessFlag = curSuccessFlag;
-            fprintf( 'passed!\n' );
-            
-        case -1
-            newSuccessFlag = curSuccessFlag;
-            fprintf( 'problem data missing!\n' );
-            
-        otherwise
-            error( 'Unknown success flag!' );
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/setupTestingPaths.m b/extlibs/qpOASES-3.2.0/testing/matlab/setupTestingPaths.m
deleted file mode 100644
index 6373d11..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/setupTestingPaths.m
+++ /dev/null
@@ -1,14 +0,0 @@
-function [] = setupTestingPaths( )
-
-    addpath(genpath(pwd));
-    addpath(genpath([pwd 'auxFiles']));
-    addpath(genpath([pwd 'data']));
-    addpath(genpath([pwd 'tests']));
-    
-    if isoctave 
-		addpath('../../interfaces/octave/');
-	else
-		addpath('../../interfaces/matlab/');
-	end
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas1.m
deleted file mode 100644
index d1977ed..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas1.m
+++ /dev/null
@@ -1,30 +0,0 @@
-function [ successFlag ] = runAlexInfeas1( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-    try
-        data = load( 'alexInfeas1.mat' );
-    catch
-        successFlag = -1;
-        return;
-    end
-    
-    options1 = qpOASES_options( 'default', 'printLevel',-2*doPrint );
-    
-    [x1,dummy,exitflag1] = qpOASES( data.H,data.g,data.A, ...
-                data.lb,data.ub,data.lbA,data.ubA, options1 ); %#ok<*NASGU>
-
-    % should return "QP infeasible"
-    if ( exitflag1 == -2 )
-        successFlag = 1;
-    else
-        if ( doPrint > 0 )
-            disp( [data.lbA data.A*x1 data.ubA] );
-        end
-    end
-   
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas2.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas2.m
deleted file mode 100644
index 730a01c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlexInfeas2.m
+++ /dev/null
@@ -1,35 +0,0 @@
-function [ successFlag ] = runAlexInfeas2( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-    try
-        data = load( 'alexInfeas2.mat' );
-    catch
-        successFlag = -1;
-        return;
-    end
-    
-    options1 = qpOASES_options( 'default', 'printLevel',-2*doPrint,... 
-                                           'maxIter',7000, 'enableFlippingBounds',0,...
-                                           'terminationTolerance',1e7*eps);
-                                       
-    options2 = qpOASES_options( 'MPC', 'printLevel',-2*doPrint,... 
-                                       'maxIter',3000, 'terminationTolerance',1e8*eps );
-    
-    [x1,dummy,exitflag1] = qpOASES( data.H,data.g,data.A, ...
-                data.lb,data.ub,data.lbA,data.ubA, options1 ); %#ok<*NASGU>
-
-    % should return "QP infeasible"
-    if ( exitflag1 == -2 )
-        successFlag = 1;
-    else
-        if ( doPrint > 0 )
-            %disp( [data.lbA data.A*x1 data.ubA] );
-        end
-    end
-   
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlternativeX0Test.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlternativeX0Test.m
deleted file mode 100644
index 3178ed2..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runAlternativeX0Test.m
+++ /dev/null
@@ -1,84 +0,0 @@
-function [ successFlag ] = runAlternativeX0Test( nV,nC, doPrint,seed )
-    
-    if ( nargin < 4 )
-        seed = 4242;
-        if ( nargin < 3 )
-            doPrint = 0;
-            if ( nargin < 2 )
-                nC = 300;
-                if ( nargin < 1 )
-                    nV = 50;
-                end
-            end
-        end
-    end
-
-    successFlag = 1;
-    TOL = eps;
-    
-    qpData = generateExample( nV,nC, 0,0, 0,1,1,1, seed );
-    
-    H = qpData.H;
-	g = qpData.g;
-    A = [qpData.Aeq;qpData.Ain];
-	lb = qpData.lb;
-    ub = qpData.ub;
-    lbA = [qpData.beq;qpData.lbA];
-    ubA = [qpData.beq;qpData.ubA];
-    
-    x0 = nV*rand( nV,1 );
-    
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-    auxInput = qpOASES_auxInput( 'x0',x0 );
-    
-    [ x1,f1,e1,i1,l1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],x0 );
-    [ x2,f2,e2,i2,l2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-    [ x3,f3,e3,i3,l3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,x0 );
-    [ x4,f4,e4,i4,l4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-    
-    if ( ( norm(x1-x2) > TOL ) || ...
-         ( norm(x1-x3) > TOL ) || ...
-         ( norm(x1-x4) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in x')
-        end
-        successFlag = 0;
-    end
-    
-    if ( ( norm(f1-f2) > TOL ) || ...
-         ( norm(f1-f3) > TOL ) || ...
-         ( norm(f1-f4) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in fval')
-        end
-        successFlag = 0;
-    end
-    
-    if ( ( norm(e1-e2) > TOL ) || ...
-         ( norm(e1-e3) > TOL ) || ...
-         ( norm(e1-e4) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in exitflag')
-        end
-        successFlag = 0;
-    end
-    
-    if ( ( norm(i1-i2) > TOL ) || ...
-         ( norm(i1-i3) > TOL ) || ...
-         ( norm(i1-i4) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in iter')
-        end
-        successFlag = 0;
-    end
-    
-    if ( ( norm(l1-l2) > TOL ) || ...
-         ( norm(l1-l3) > TOL ) || ...
-         ( norm(l1-l4) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in lambda')
-        end
-        successFlag = 0;
-    end
-		
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1.m
deleted file mode 100644
index 4aa70b1..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1.m
+++ /dev/null
@@ -1,60 +0,0 @@
-function [ successFlag ] = runBenchmarkCHAIN1( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-    
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-    
-    try
-        load 'benchmarkCHAIN1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    iter = zeros(1,nP);
-
-	options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-    %options = qpOASES_options( 'maxIter',nWSR );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda,ws] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-            %disp(ws')
-		else
-			[x,obj,status,nWSRout,lambda,ws] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-            %disp(ws')
-        end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-        
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-        iter(:,i) = nWSRout;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-    
-    if ( ( maxViolation < 9e-13 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-	
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1A.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1A.m
deleted file mode 100644
index 65311f6..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCHAIN1A.m
+++ /dev/null
@@ -1,61 +0,0 @@
-function [ successFlag ] = runBenchmarkCHAIN1A( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-    
-    try
-        load 'benchmarkCHAIN1A.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-    %options = qpOASES_options( 'reliable', 'maxIter',500,'printLevel',1 );
-% ,'enableRamping',0,'enableFlippingBounds',0,'enableFullLITests',0,'enableDriftCorrection',0
-  
-  
-	for jj=1:1
-  
-	for i=1:nP
-		%disp(i);
-		if ( i == 1 )
-            [QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),lb(:,i),ub(:,i),options );
-		else
-            [x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),options );
-        end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),[],lb(:,i),ub(:,i),[],[], x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    end
-    
-    if ( ( maxViolation < 1e-14 ) && ( status == 0 ) )
-        successFlag = 1;
-    end   
-	
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE1.m
deleted file mode 100644
index 4243ccf..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE1.m
+++ /dev/null
@@ -1,55 +0,0 @@
-function [ successFlag ] = runBenchmarkCRANE1( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkCRANE1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-
-	options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-    for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 3e-9 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-	
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE2.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE2.m
deleted file mode 100644
index 7f7d47f..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE2.m
+++ /dev/null
@@ -1,56 +0,0 @@
-function [ successFlag ] = runBenchmarkCRANE2( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkCRANE2.mat';
-	catch
-        successFlag = -1;
-        return;
-    end
-    
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-    
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'm',QP,H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 1e-11 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE3.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE3.m
deleted file mode 100644
index 80caac9..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkCRANE3.m
+++ /dev/null
@@ -1,55 +0,0 @@
-function [ successFlag ] = runBenchmarkCRANE3( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-    try
-        load 'benchmarkCRANE3.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 5e-11 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkDIESEL.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkDIESEL.m
deleted file mode 100644
index ad6c585..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkDIESEL.m
+++ /dev/null
@@ -1,59 +0,0 @@
-function [ successFlag ] = runBenchmarkDIESEL( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-    try
-        load 'benchmarkDIESEL.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-		nEC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    iter = zeros(1,nP);
-
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-    %options = qpOASES_options( 'maxIter',nWSR );
-    %options = qpOASES_options( 'maxIter',nWSR, 'initialStatusBounds',0 );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-        end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-        
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-        iter(:,i) = nWSRout;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-    
-    if ( ( maxViolation < 6e-13 ) && ( status == 0 ) )
-        successFlag = 1;
-    end	
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY1.m
deleted file mode 100644
index b304b42..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY1.m
+++ /dev/null
@@ -1,56 +0,0 @@
-function [ successFlag ] = runBenchmarkEQUALITY1( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkEQUALITY1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-   	if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 4e-15 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY2.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY2.m
deleted file mode 100644
index bd7c48d..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEQUALITY2.m
+++ /dev/null
@@ -1,60 +0,0 @@
-function [ successFlag ] = runBenchmarkEQUALITY2( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkEQUALITY2.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-   	if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-   
-    %H = H;
-    %lbA(65:320) = lbA(65:320) - 0.000000000;
-    %ubA(65:320) = ubA(65:320) + 0.000000000;
-
-	options = qpOASES_options( 'maxIter',nWSR, 'enableEqualities',1, 'printLevel',2*doPrint );
-    %options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',-2 );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 3e-7 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1.m
deleted file mode 100644
index 7706aff..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1.m
+++ /dev/null
@@ -1,56 +0,0 @@
-function [ successFlag ] = runBenchmarkEXAMPLE1( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkEXAMPLE1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-	
-    if ( ( maxViolation < 1e-12 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1A.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1A.m
deleted file mode 100644
index ba91b9e..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1A.m
+++ /dev/null
@@ -1,56 +0,0 @@
-function [ successFlag ] = runBenchmarkEXAMPLE1A( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-    maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkEXAMPLE1A.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:2
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H(:,:,i),g(:,i),A(:,:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'm',QP,H(:,:,i),g(:,i),A(:,:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H(:,:,i),g(:,i),A(:,:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 3e-13 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1B.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1B.m
deleted file mode 100644
index 36e933f..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkEXAMPLE1B.m
+++ /dev/null
@@ -1,56 +0,0 @@
-function [ successFlag ] = runBenchmarkEXAMPLE1B( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkEXAMPLE1B.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-    
-	%options = qpOASES_options( 'maxIter',nWSR );
-    options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),lb(:,i),ub(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),options );
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),[],lb(:,i),ub(:,i),[],[], x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 3e-12 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkIDHESSIAN1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkIDHESSIAN1.m
deleted file mode 100644
index d97797f..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runBenchmarkIDHESSIAN1.m
+++ /dev/null
@@ -1,59 +0,0 @@
-function [ successFlag ] = runBenchmarkIDHESSIAN1( nWSR,doPrint )
-
-	if ( nargin < 2 )
-		doPrint = 0;
-	end
-
-    successFlag = 0;
-	maxViolation = 0;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkIDHESSIAN1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-	
-    if ( exist( 'A','var' ) )
-        [nC,nV] = size(A);
-    else
-        nC = 0;
-    end
-    [nV,nP] = size(g);
-
-    xOpt = zeros(nV,nP);
-    yOpt = zeros(nV+nC,nP);
-    objOpt = zeros(1,nP);
-       
-	options = qpOASES_options( 'maxIter',nWSR, 'printLevel',-2*doPrint );
-    %options = qpOASES_options( 'fast','maxIter',nWSR, 'printLevel',2 );
-    
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i)-1e-11,ubA(:,i)+1e-11,options );
-			%disp(status);
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i)-1e-11,ubA(:,i)+1e-11,options );
-			%disp(status);
-		end
-
-		[ maxViolationTMP ] = getKktResidual( H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i), x,lambda );
-		maxViolation = max( [maxViolation,maxViolationTMP] );
-
-        xOpt(:,i) = x;
-        yOpt(:,i) = lambda;
-        objOpt(:,i) = obj;
-	end
-	
-	qpOASES_sequence( 'c',QP );
-
-    if ( ( maxViolation < 8e-6 ) && ( status == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runEmptyHessianTests.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runEmptyHessianTests.m
deleted file mode 100644
index 46ade51..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runEmptyHessianTests.m
+++ /dev/null
@@ -1,261 +0,0 @@
-function [ successFlag ] = runEmptyHessianTests( doPrint )
-
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-    
-    successFlag = 1;
-    
-    TOL = 100*eps;
-	
-	options = qpOASES_options( 'maxIter',100, 'enableEqualities',1, 'printLevel',-2*doPrint );
-    auxInput0   = qpOASES_auxInput( 'hessianType',0 );
-    auxInput1   = qpOASES_auxInput( 'hessianType',1 );
-    auxInputErr = qpOASES_auxInput( 'hessianType',2 );
-
-    
-    load 'benchmarkEXAMPLE1.mat';
-    
-    %% test qpOASES with zero Hessian
-    [ x1,obj1,status1,nWSRout1,lambda1 ] = qpOASES( 0*H,g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options );
-    [ x2,obj2,status2,nWSRout2,lambda2 ] = qpOASES( [],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options );
-    [ x3,obj3,status3,nWSRout3,lambda3 ] = qpOASES( [],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInput0 );
-    [ x4,obj4,status4,nWSRout4,lambda4 ] = qpOASES( [],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInputErr );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 ) || ( status3 ~= 0 ) || ( status4 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL ) || ( norm(x1-x3) > TOL ) || ( norm(x1-x4) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL ) || ( norm(obj1-obj3) > TOL ) || ( norm(obj1-obj4) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL ) || ( norm(lambda1-lambda3) > TOL ) || ( norm(lambda1-lambda4) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    %% test qpOASES_sequence with zero Hessian
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',0*H,g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options ); %#ok<NASGU>
-	[x1,obj1,status1,nWSRout1,lambda1]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',[],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options ); %#ok<NASGU>
-	[x2,obj2,status2,nWSRout2,lambda2]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',[],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInput0 ); %#ok<NASGU>
-	[x3,obj3,status3,nWSRout3,lambda3]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',[],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInputErr ); %#ok<NASGU>
-	[x4,obj4,status4,nWSRout4,lambda4]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 ) || ( status3 ~= 0 ) || ( status4 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL ) || ( norm(x1-x3) > TOL ) || ( norm(x1-x4) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL ) || ( norm(obj1-obj3) > TOL ) || ( norm(obj1-obj4) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL ) || ( norm(lambda1-lambda3) > TOL ) || ( norm(lambda1-lambda4) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    %% test qpOASES with ID Hessian
-    [ x1,obj1,status1,nWSRout1,lambda1 ] = qpOASES( eye(2),g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options );
-    [ x2,obj2,status2,nWSRout2,lambda2 ] = qpOASES( [],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInput1 );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    %% test qpOASES_sequence with ID Hessian
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',eye(2),g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options ); %#ok<NASGU>
-	[x1,obj1,status1,nWSRout1,lambda1]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0] = qpOASES_sequence( 'i',[],g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInput1 ); %#ok<NASGU>
-	[x2,obj2,status2,nWSRout2,lambda2]    = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    load 'benchmarkEXAMPLE1B.mat';
-    
-    %% test qpOASES (simply bounded) with zero Hessian
-    [ x1,obj1,status1,nWSRout1,lambda1 ] = qpOASES( 0*H,g(:,1),lb(:,1),ub(:,1),options );
-    [ x2,obj2,status2,nWSRout2,lambda2 ] = qpOASES( [],g(:,1),lb(:,1),ub(:,1),options );
-    [ x3,obj3,status3,nWSRout3,lambda3 ] = qpOASES( [],g(:,1),lb(:,1),ub(:,1),options,auxInput0 );
-    [ x4,obj4,status4,nWSRout4,lambda4 ] = qpOASES( [],g(:,1),lb(:,1),ub(:,1),options,auxInputErr );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 ) || ( status3 ~= 0 ) || ( status4 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL ) || ( norm(x1-x3) > TOL ) || ( norm(x1-x4) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL ) || ( norm(obj1-obj3) > TOL ) || ( norm(obj1-obj4) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL ) || ( norm(lambda1-lambda3) > TOL ) || ( norm(lambda1-lambda4) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    %% test qpOASES (simply bounded) with ID Hessian
-    [ x1,obj1,status1,nWSRout1,lambda1 ] = qpOASES( eye(2),g(:,1),lb(:,1),ub(:,1),options );
-    [ x2,obj2,status2,nWSRout2,lambda2 ] = qpOASES( [],g(:,1),lb(:,1),ub(:,1),options,auxInput1 );
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runExternalCholeskyTests.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runExternalCholeskyTests.m
deleted file mode 100644
index 2434478..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runExternalCholeskyTests.m
+++ /dev/null
@@ -1,214 +0,0 @@
-function [ successFlag ] = runExternalCholeskyTests( doPrint )
-
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-    
-    successFlag = 1;
-    
-    TOL = 1e4*eps;
-	
-    load 'benchmarkCHAIN1.mat';
-    
-	options  = qpOASES_options( 'MPC', 'printLevel',2*doPrint );
-    auxInput = qpOASES_auxInput( 'R',chol(H) );
-    
-    %% test qpOASES
-    [ x1,obj1,status1,nWSRout1,lambda1,auxOut1 ] = qpOASES( H,g(:,10),A,lb(:,10),ub(:,10),lbA(:,10),ubA(:,10),options );
-    [ x2,obj2,status2,nWSRout2,lambda2,auxOut2 ] = qpOASES( H,g(:,10),A,lb(:,10),ub(:,10),lbA(:,10),ubA(:,10),options,auxInput );
-    
-    if doPrint
-        disp( ['Runtime without R: ', num2str(auxOut1.cpuTime),'s'] )
-        disp( ['Runtime with    R: ', num2str(auxOut2.cpuTime),'s'] )
-        disp( ' ' );
-    end
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error' );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    
-    %% test qpOASES_sequence
-    [QP,x0,obj0,status0,nWSRout0,lambda0,auxOut1] = qpOASES_sequence( 'i',H,g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options );
-	[x1,obj1,status1,nWSRout1,lambda1]            = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0,auxOut2] = qpOASES_sequence( 'i',H,g(:,1),A,lb(:,1),ub(:,1),lbA(:,1),ubA(:,1),options,auxInput );
-	[x2,obj2,status2,nWSRout2,lambda2]            = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),lbA(:,2),ubA(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    if doPrint
-        disp( ['Runtime without R: ', num2str(auxOut1.cpuTime),'s'] )
-        disp( ['Runtime with    R: ', num2str(auxOut2.cpuTime),'s'] )
-        disp( ' ' )
-    end
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-
-        
-    %% test simply bounded QP
-    load 'benchmarkCHAIN1A.mat';
-    
-	options  = qpOASES_options( 'MPC', 'printLevel',0*doPrint );
-    auxInput = qpOASES_auxInput( 'R',chol(H) );
-    
-    %% test qpOASES
-    [ x1,obj1,status1,nWSRout1,lambda1,auxOut1 ] = qpOASES( H,g(:,10),lb(:,10),ub(:,10),options );
-    [ x2,obj2,status2,nWSRout2,lambda2,auxOut2 ] = qpOASES( H,g(:,10),lb(:,10),ub(:,10),options,auxInput );
-    
-    if doPrint
-        disp( ['Runtime without R: ', num2str(auxOut1.cpuTime),'s'] )
-        disp( ['Runtime with    R: ', num2str(auxOut2.cpuTime),'s'] )
-        disp( ' ' );
-    end
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error' );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    %% test qpOASES_sequence
-    [QP,x0,obj0,status0,nWSRout0,lambda0,auxOut1] = qpOASES_sequence( 'i',H,g(:,1),lb(:,1),ub(:,1),options );
-	[x1,obj1,status1,nWSRout1,lambda1]            = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    [QP,x0,obj0,status0,nWSRout0,lambda0,auxOut2] = qpOASES_sequence( 'i',H,g(:,1),lb(:,1),ub(:,1),options,auxInput );
-	[x2,obj2,status2,nWSRout2,lambda2]            = qpOASES_sequence( 'h',QP,g(:,2),lb(:,2),ub(:,2),options );
-    qpOASES_sequence( 'c',QP );
-    
-    if doPrint
-        disp( ['Runtime without R: ', num2str(auxOut1.cpuTime),'s'] )
-        disp( ['Runtime with    R: ', num2str(auxOut2.cpuTime),'s'] )
-        disp( ' ' )
-    end
-    
-    if ( status1 ~= 0 ) || ( status2 ~= 0 )
-        if doPrint
-            disp( 'error'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(x1-x2) > TOL )
-        if doPrint
-            disp( 'error in primal solution'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(obj1-obj2) > TOL )
-        if doPrint
-            disp( 'error in objective function value'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(nWSRout1-nWSRout2) > 0.5 )
-        if doPrint
-            disp( 'error in numer of iterations'  );
-        end
-        successFlag = 0;
-    end
-    
-    if ( norm(lambda1-lambda2) > TOL )
-        if doPrint
-            disp( 'error in dual solution'  );
-        end
-        successFlag = 0;
-    end
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceSeqTest.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceSeqTest.m
deleted file mode 100644
index 88c06ec..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceSeqTest.m
+++ /dev/null
@@ -1,436 +0,0 @@
-function [ successFlag ] = runInterfaceSeqTest( nV,nC, doPrint,seed )
-
-    if ( nargin < 4 )
-        seed = 42;
-        if ( nargin < 3 )
-            doPrint = 1;
-            if ( nargin < 2 )
-                nC = 10;
-                if ( nargin < 1 )
-                    nV = 5;
-                end
-            end
-        end
-    end
-    
-    successFlag = 1;
-
-    for isSparseH=0:1
-        for isSparseA=0:1
-            successFlag = runSeveralInterfaceSeqTests( successFlag, nV,nC,isSparseH,isSparseA, doPrint,seed );
-        end
-    end
-    
-end
-
-
-
-function [ successFlag ] = runSeveralInterfaceSeqTests( successFlag, nV,nC, isSparseH,isSparseA, doPrint,seed )
-
-    %% test without or empty A matrix
-    for hasA=0:1
-        for changeMat=0:hasA % cannot change matrices if QProblemB object is instantiated
-            for hasLowerB=0:1
-                for hasUpperB=0:1
-                    for hasOptions=0:2
-                        for hasX0=0:2
-                            for hasWS=0:2
-                                curSuccessFLAG = runSingleInterfaceSeqTest( nV,0,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,0,0,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                                successFlag = min( successFlag,curSuccessFLAG );
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-    %% test with non-empty A matrix
-    for hasLowerB=0:1
-        for hasUpperB=0:1
-            for hasLowerC=0:1
-                for hasUpperC=0:1
-                    for hasOptions=0:2
-                        for hasX0=0:2
-                            for hasWS=0:2
-                                for changeMat=0:1
-                                    curSuccessFLAG = runSingleInterfaceSeqTest( nV,nC,1,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                                    successFlag = min( successFlag,curSuccessFLAG );
-                                end
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-end
-
-
-function [ successFlag ] = runSingleInterfaceSeqTest( nV,nC,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed )
-
-    successFlag = 0;
-
-    qpData1 = generateExample( nV,nC, isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC, seed );
-    if ( changeMat > 0 )
-        qpData2 = generateExample( nV,nC, isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC, seed+1 );
-    else
-        qpData2 = generateExample( nV,nC, isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC, seed+1,qpData1.H,qpData1.Ain );
-    end
-
-    if ( changeMat == 0 )
-        string = 'Testing qpOASES_sequence( ''i/h/c'',H';
-    else
-        string = 'Testing qpOASES_sequence( ''i/m/c'',H';
-    end
-    
-    if ( isSparseH > 0 )
-        string = [string,'s,g'];
-    else
-        string = [string,'d,g'];
-    end
-    
-    if ( nC > 0 )
-        if ( isSparseA > 0 )
-            string = [string,',As'];
-        else
-            string = [string,',Ad'];
-        end
-    else
-        if ( hasA > 0 )
-            string = [string,',[]'];
-        end
-    end
-    
-    if ( hasLowerB > 0 )
-        string = [string,',lb'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasUpperB > 0 )
-        string = [string,',ub'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasLowerC > 0 )
-        string = [string,',lbA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    if ( hasUpperC > 0 )
-        string = [string,',ubA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    switch ( hasOptions )
-        case 1
-            string = [string,',opt'];
-        
-        case 2
-            string = [string,',[] '];
-            
-        case 0
-            if ( ( hasX0 > 0 ) || ( hasWS > 0 ) )
-                string = [string,',[] '];
-            end
-    end
-
-    switch ( hasX0 )
-        case 1
-            string = [string,',{x0'];
-        
-        case 2
-            string = [string,',{[]'];
-            
-        case 0
-            if ( hasWS > 0 )
-                string = [string,',{[]'];
-            end
-    end
-    
-    switch ( hasWS )
-        case 1
-            string = [string,',WS}'];
-        
-        case 2
-            string = [string,',[]}'];
-    end
-
-    string = [string,' )... '];
-    if ( doPrint > 0 )
-        disp( string );
-    end
-    
-    curSuccessFlag = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat );
-    if ( curSuccessFlag > 0 )
-        string = [string,'pass!'];
-        successFlag = 1;
-    else
-        string = [string,'fail!'];
-    end
-    
-    if ( doPrint > 0 )
-        disp( string );
-        if ( curSuccessFlag == 0 )
-            pause(0.1);
-        end
-    end
-    
-end
-
-function [ successFlag ] = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat, doPrint )
-
-    if ( nargin < 8 )
-        doPrint = 1;
-    end
-
-    %TOL = 1e-15;
-    KKTTOL = 1e-6;
-
-    successFlag = 0;
-    
-    H1 = qpData1.H;
-	g1 = qpData1.g;
-    A1 = [qpData1.Aeq;qpData1.Ain];
-	lb1 = qpData1.lb;
-    ub1 = qpData1.ub;
-    lbA1 = [qpData1.beq;qpData1.lbA];
-    ubA1 = [qpData1.beq;qpData1.ubA];
-    
-    if ( changeMat > 0 )
-        H2 = qpData2.H;
-    else
-        H2 = H1;
-    end
-	g2 = qpData2.g;
-    if ( changeMat > 0 )
-        A2 = [qpData2.Aeq;qpData2.Ain];
-    else
-        A2 = A1;
-    end
-	lb2 = qpData2.lb;
-    ub2 = qpData2.ub;
-    lbA2 = [qpData2.beq;qpData2.lbA];
-    ubA2 = [qpData2.beq;qpData2.ubA];
-
-    [nV,dummy] = size(H1); %#ok<NASGU>
-    [nC,dummy] = size(A1); %#ok<NASGU>
-    
-    if ( hasWS > 0 )
-        if ( hasWS == 1 )
-            wsB = 0 * ones( nV,1 );
-            wsC = 0 * ones( nC,1 );
-        else
-            wsB = [];
-            wsC = [];
-        end
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0,'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-
-            %auxInput = qpOASES_auxInput( 'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-            auxInput = qpOASES_auxInput( 'guessedWorkingSetB',wsB );
-            
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,[] ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,[] ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-        
-    else % hasWS == 0
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0 );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-                    
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1 ); %#ok<NASGU>
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 ); %#ok<NASGU>
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1 ); %#ok<NASGU>
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 ); %#ok<NASGU>
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-
-    end % hasWS
-
-
-    kktTol1 = getKktResidual( H1,g1,A1,lb1,ub1,lbA1,ubA1, x1,l1 );
-    
-    if ( changeMat > 0 )
-		kktTol2 = getKktResidual( H2,g2,A2,lb2,ub2,lbA2,ubA2, x2,l2 );
-    else
-		kktTol2 = getKktResidual( H1,g2,A1,lb2,ub2,lbA2,ubA2, x2,l2 );
-    end
-    
-    if ( ( kktTol1 <= KKTTOL ) && ( e1 >= 0 ) && ( kktTol2 <= KKTTOL ) && ( e2 >= 0 ) )
-        successFlag = 1;
-    else
-        if ( doPrint > 0 )
-            if ( ( kktTol1 > KKTTOL ) || ( kktTol2 > KKTTOL ) )
-                disp( ['kkt error: ',num2str(kktTol1),'/',num2str(kktTol2)] )
-            else
-                disp('exitflag<0')
-            end
-        end
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceTest.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceTest.m
deleted file mode 100644
index 55a5c7b..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runInterfaceTest.m
+++ /dev/null
@@ -1,462 +0,0 @@
-function [ successFlag ] = runInterfaceTest( nV,nC, doPrint,seed )
-
-    if ( nargin < 4 )
-        seed = 42;
-        if ( nargin < 3 )
-            doPrint = 1;
-            if ( nargin < 2 )
-                nC = 10;
-                if ( nargin < 1 )
-                    nV = 5;
-                end
-            end
-        end
-    end
-    
-    successFlag = 1;
-
-    for isSparseH=0:1
-        for isSparseA=0:1
-            successFlag = runSeveralInterfaceTests( successFlag, nV,nC,isSparseH,isSparseA, doPrint,seed );
-        end
-    end
-    
-end
-
-
-
-function [ successFLAG ] = runSeveralInterfaceTests( successFLAG, nV,nC, isSparseH,isSparseA, doPrint,seed )
-
-    %% test without or empty A matrix
-    for hasA=0:1
-        for hasLowerB=0:1
-            for hasUpperB=0:1
-                for hasOptions=0:2
-                    for hasX0=0:1
-                        for hasWS=0:2
-                            if ( ( hasWS ~= 2 ) || ( hasA ~= 0 ) || ( hasOptions == 1 ) || ( hasX0 ~= 0 ) )
-                                curSuccessFLAG = runSingleInterfaceTest( nV,0,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,0,0,hasOptions,hasX0,hasWS, doPrint,seed );
-                                successFLAG = min( successFLAG,curSuccessFLAG );
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-    %% test with non-empty A matrix
-    for hasLowerB=0:1
-        for hasUpperB=0:1
-            for hasLowerC=0:1
-                for hasUpperC=0:1
-                    for hasOptions=0:2
-                        for hasX0=0:1
-                            for hasWS=0:2
-                                curSuccessFLAG = runSingleInterfaceTest( nV,nC,1,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS, doPrint,seed );
-                                successFLAG = min( successFLAG,curSuccessFLAG );
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-end
-
-
-function [ successFLAG ] = runSingleInterfaceTest( nV,nC,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS, doPrint,seed )
-
-    successFLAG = 0;
-
-    qpData = generateExample( nV,nC, isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC, seed );
-
-    string = 'Testing qpOASES( H';
-    
-    if ( isSparseH > 0 )
-        string = [string,'s,g'];
-    else
-        string = [string,'d,g'];
-    end
-    
-    if ( nC > 0 )
-        if ( isSparseA > 0 )
-            string = [string,',As'];
-        else
-            string = [string,',Ad'];
-        end
-    else
-        if ( hasA > 0 )
-            string = [string,',[]'];
-        end
-    end
-    
-    if ( hasLowerB > 0 )
-        string = [string,',lb'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasUpperB > 0 )
-        string = [string,',ub'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasLowerC > 0 )
-        string = [string,',lbA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    if ( hasUpperC > 0 )
-        string = [string,',ubA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    switch ( hasOptions )
-        case 1
-            string = [string,',opt'];
-        
-        case 2
-            string = [string,',[] '];
-            
-        case 0
-            if ( ( hasX0 > 0 ) || ( hasWS > 0 ) )
-                string = [string,',[] '];
-            end
-    end
-
-    switch ( hasX0 )
-        case 1
-            string = [string,',{x0'];
-        
-        case 2
-            string = [string,',{[]'];
-            
-        case 0
-            if ( hasWS > 0 )
-                string = [string,',{[]'];
-            end
-    end
-    
-    switch ( hasWS )
-        case 1
-            string = [string,',WS}'];
-        
-        case 2
-            string = [string,',[]}'];
-    end
-
-    string = [string,' )... '];
-    if ( doPrint > 0 )
-        %disp( string );
-    end
-    
-    curSuccessFlag = callQpOases( qpData,hasA,hasOptions,hasX0,hasWS, 1 );
-    if ( curSuccessFlag > 0 )
-        string = [string,'pass!'];
-        successFLAG = 1;
-    else
-        string = [string,'fail!'];
-    end
-    
-    if ( doPrint > 0 )
-        disp( string );
-        if ( curSuccessFlag == 0 )
-            pause;
-        end
-    end
-    
-end
-
-function [ successFLAG ] = callQpOases( qpData,hasA,hasOptions,hasX0,hasWS, doPrint )
-
-    if ( nargin < 6 )
-        doPrint = 1;
-    end
-
-    TOL = 1e-15;
-    KKTTOL = 1e-6;
-
-    successFLAG = 0;
-    
-    H = qpData.H;
-	g = qpData.g;
-    A = [qpData.Aeq;qpData.Ain];
-	lb = qpData.lb;
-    ub = qpData.ub;
-    lbA = [qpData.beq;qpData.lbA];
-    ubA = [qpData.beq;qpData.ubA];
-
-    [nV,dummy] = size(H); %#ok<NASGU>
-    [nC,dummy] = size(A); %#ok<NASGU>
-    
-    if ( hasWS > 0 )
-        if ( hasWS == 1 )
-            wsB = 0 * ones( nV,1 );
-            wsC = 0 * ones( nC,1 );
-        else
-            wsB = [];
-            wsC = [];
-        end
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0,'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput ); %#ok<NASGU>
-                else                        
-                    [ x1 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,options,auxInput ); %#ok<NASGU>
-                end
-            else
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,[],auxInput ); %#ok<NASGU>
-                end
-            end
-
-        else % hasX0 == 0
-
-            %auxInput = qpOASES_auxInput( 'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-            auxInput = qpOASES_auxInput( 'guessedWorkingSetC',wsC );
-            
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-                
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,options,auxInput ); %#ok<NASGU>
-                end
-            else
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,[],auxInput ); %#ok<NASGU>
-                end
-            end
-
-        end % hasX0
-        
-    else % hasWS == 0
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0 );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,options,auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,options,auxInput ); %#ok<NASGU>
-                end
-                    
-            else
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,[],auxInput ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,[],auxInput );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,[],auxInput ); %#ok<NASGU>
-                end
-            end
-
-        else % hasX0 == 0
-            
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA,options ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub,options );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub,options );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub,options );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub,options );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub,options );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub,options ); %#ok<NASGU>
-                end
-            else
-                if ( hasA > 0 )
-                    [ x1 ] = qpOASES( H,g,A,lb,ub,lbA,ubA );
-                    [ x2,f2 ] = qpOASES( H,g,A,lb,ub,lbA,ubA );
-                    [ x3,f3,e3 ] = qpOASES( H,g,A,lb,ub,lbA,ubA );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,A,lb,ub,lbA,ubA );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,A,lb,ub,lbA,ubA );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,A,lb,ub,lbA,ubA ); %#ok<NASGU>
-                else
-                    [ x1 ] = qpOASES( H,g,lb,ub );
-                    [ x2,f2 ] = qpOASES( H,g,lb,ub );
-                    [ x3,f3,e3 ] = qpOASES( H,g,lb,ub );
-                    [ x4,f4,e4,i4 ] = qpOASES( H,g,lb,ub );
-                    [ x5,f5,e5,i5,l5 ] = qpOASES( H,g,lb,ub );
-                    [ x6,f6,e6,i6,l6,w6 ] = qpOASES( H,g,lb,ub ); %#ok<NASGU>
-                end
-            end
-
-        end % hasX0
-
-    end % hasWS
-
-    % check whether all calls lead to same optimal solution
-    % independent from output arguments
-    if ( ( norm(x1-x2) > TOL ) || ...
-         ( norm(x1-x3) > TOL ) || ...
-         ( norm(x1-x4) > TOL ) || ...
-         ( norm(x1-x5) > TOL ) || ...
-         ( norm(x1-x6) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in x')
-        end
-        return;
-    end
-    
-    if ( ( norm(f2-f3) > TOL ) || ...
-         ( norm(f2-f4) > TOL ) || ...
-         ( norm(f2-f5) > TOL ) || ...
-         ( norm(f2-f6) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in fval')
-        end
-        return;
-    end
-
-    if ( ( norm(e3-e4) > TOL ) || ...
-         ( norm(e3-e5) > TOL ) || ...
-         ( norm(e3-e6) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in exitflag')
-        end
-        return;
-    end
-
-    if ( ( norm(i4-i5) > TOL ) || ...
-         ( norm(i4-i6) > TOL ) )
-        if ( doPrint > 0 )
-            disp('diff in iter')
-        end
-        return;
-    end
-    
-    if ( norm(l5-l6) > TOL )
-        if ( doPrint > 0 )
-            disp('diff in lambda')
-        end
-        return;
-    end
-    
-    
-    kktTol = getKktResidual( H,g,A,lb,ub,lbA,ubA, x6,l6 );
-    
-    if ( ( kktTol <= KKTTOL ) && ( e6 >= 0 ) )
-        successFLAG = 1;
-    else
-        if ( doPrint > 0 )
-            disp( ['kkt error: ',num2str(kktTol)] )
-        end
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQAP8.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQAP8.m
deleted file mode 100644
index 58660d9..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQAP8.m
+++ /dev/null
@@ -1,37 +0,0 @@
-function [ successFlag ] = runQAP8( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-
-    try
-        load 'QAP8.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-    options = qpOASES_options('default', 'maxIter',30000, 'printLevel',-2*doPrint );
-    tic
-    [x, fval, status, nWSRout, y] = qpOASES(sparse(QP.H), QP.f, ...
-        sparse(QP.C), QP.lb, QP.ub, QP.cl, QP.cu, options);
-    t = toc;
-    
-    if ( doPrint > 0 )
-        disp( ['solution time: ',num2str(t),' seconds'] );
-    end
-    
-    if ( ( status == 0 ) && ( nWSRout < 23200 ) )
-        successFlag = 1;
-    end
-    
-    % check error and print
-    if doPrint
-        [stat, feas, cmpl] = qpresidual(S.B, S.b1, S.C, S.cl1, S.cu1, x, -y);
-        fprintf( '%d iters in %.3fs to tolerance %.2e\n', nWSRout, t, max([stat,feas,cmpl]) );
-        fprintf( 'Status: %d\n', status );
-    end
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQSHARE1B.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQSHARE1B.m
deleted file mode 100644
index c1ba1e2..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runQSHARE1B.m
+++ /dev/null
@@ -1,44 +0,0 @@
-function [ successFlag ] = runQSHARE1B( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-
-    try
-        load 'QSHARE1B.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-    
-    options = qpOASES_options('default', 'maxIter',600, 'maxCpuTime',2.0, 'printLevel',-2*doPrint );
-    auxInput = qpOASES_auxInput( 'hessianType',[] );
-    tic
-    [xD,fvalD,exitflagD,iterD,lambdaD] = qpOASES( H,g,A,lb,ub,lbA,ubA,options,auxInput );
-    tD = toc;
-    kktD = getKktResidual( H,g,A,lb,ub,lbA,ubA, xD,lambdaD );
-    
-    if ( doPrint > 0 )
-        disp( ['dense kkt tol:        ',num2str(kktD, '%.3e')] );
-        disp( ['dense solution time:  ',num2str(tD),' seconds'] );
-		disp( ['dense #iterations:    ',num2str(iterD),] );
-    end
-    
-    tic
-    [xS,fvalS,exitflagS,iterS,lambdaS] = qpOASES( sparse(H),g,sparse(A),lb,ub,lbA,ubA,options );
-    tS = toc;
-    kktS = getKktResidual( H,g,A,lb,ub,lbA,ubA, xS,lambdaS );
-    
-    if ( doPrint > 0 )
-        disp( ['sparse kkt tol:       ',num2str(kktS, '%.3e')] );
-        disp( ['sparse solution time: ',num2str(tS),' seconds'] );
-		disp( ['sparse #iterations:   ',num2str(iterS),] );
-    end
-    
-    if ( ( exitflagD == 0 ) && ( kktD < 1e-6 ) && ( exitflagS == 0 ) && ( kktS < 1e-6 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomIdHessian.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomIdHessian.m
deleted file mode 100644
index 81199f7..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomIdHessian.m
+++ /dev/null
@@ -1,435 +0,0 @@
-function [ successFlag ] = runRandomIdHessian( nV,nC, doPrint,seed )
-
-    if ( nargin < 4 )
-        seed = 42;
-        if ( nargin < 3 )
-            doPrint = 1;
-            if ( nargin < 2 )
-                nC = 10;
-                if ( nargin < 1 )
-                    nV = 5;
-                end
-            end
-        end
-    end
-    
-    successFlag = 1;
-
-    for isSparseH=0:1
-        for isSparseA=0:1
-            successFlag = runSeveralIdSeqTests( successFlag, nV,nC,isSparseH,isSparseA, doPrint,seed );
-        end
-    end
-    
-end
-
-
-function [ successFlag ] = runSeveralIdSeqTests( successFlag, nV,nC, isSparseH,isSparseA, doPrint,seed )
-
-    %% test without or empty A matrix
-    for hasA=0:1
-        for changeMat=0:hasA % cannot change matrices if QProblemB object is instantiated
-            for hasLowerB=0:1
-                for hasUpperB=0:1
-                    for hasOptions=0:1
-                        for hasX0=0:2
-                            for hasWS=0:2
-                                curSuccessFLAG = runSingleIdSeqTest( nV,0,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,0,0,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                                successFlag = min( successFlag,curSuccessFLAG );
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-    %% test with non-empty A matrix
-    for hasLowerB=0:1
-        for hasUpperB=0:1
-            for hasLowerC=0:1
-                for hasUpperC=0:1
-                    for hasOptions=0:1
-                        for hasX0=0:2
-                            for hasWS=0:2
-                                for changeMat=0:1
-                                    curSuccessFLAG = runSingleIdSeqTest( nV,nC,1,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                                    successFlag = min( successFlag,curSuccessFLAG );
-                                end
-                            end
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-end
-
-
-function [ successFlag ] = runSingleIdSeqTest( nV,nC,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed )
-
-    successFlag = 0;
-
-    qpFeatures = setupQpFeaturesStruct( );
-    
-    qpFeatures.nV = nV;
-    qpFeatures.nC = nC;
-    
-    qpFeatures.isSparseH = isSparseH;
-    qpFeatures.isSparseA = isSparseA;
-    
-    qpFeatures.hasLowerB = hasLowerB;
-    qpFeatures.hasUpperB = hasUpperB;
-    qpFeatures.hasLowerC = hasLowerC;
-    qpFeatures.hasUpperC = hasUpperC;
-    
-    qpFeatures.hessianType = 2;
-    
-    qpData1 = generateRandomQp( qpFeatures,seed );
-    qpData2 = generateRandomQp( qpFeatures,seed );
-
-    if ( changeMat == 0 )
-        string = 'Testing qpOASES_sequence( ''i/h/c'',ID';
-    else
-        string = 'Testing qpOASES_sequence( ''i/m/c'',ID';
-    end
-    
-    if ( isSparseH > 0 )
-        string = [string,'s,g'];
-    else
-        string = [string,'d,g'];
-    end
-    
-    if ( nC > 0 )
-        if ( isSparseA > 0 )
-            string = [string,',As'];
-        else
-            string = [string,',Ad'];
-        end
-    else
-        if ( hasA > 0 )
-            string = [string,',[]'];
-        end
-    end
-    
-    if ( hasLowerB > 0 )
-        string = [string,',lb'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasUpperB > 0 )
-        string = [string,',ub'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasLowerC > 0 )
-        string = [string,',lbA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    if ( hasUpperC > 0 )
-        string = [string,',ubA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    switch ( hasOptions )
-        case 1
-            string = [string,',opt'];
-        
-        case 2
-            string = [string,',[] '];
-            
-        case 0
-            if ( ( hasX0 > 0 ) || ( hasWS > 0 ) )
-                string = [string,',[] '];
-            end
-    end
-
-    switch ( hasX0 )
-        case 1
-            string = [string,',{x0'];
-        
-        case 2
-            string = [string,',{[]'];
-            
-        case 0
-            if ( hasWS > 0 )
-                string = [string,',{[]'];
-            end
-    end
-    
-    switch ( hasWS )
-        case 1
-            string = [string,',WS}'];
-        
-        case 2
-            string = [string,',[]}'];
-    end
-
-    string = [string,' )... '];
-    if ( doPrint > 0 )
-        %disp( string );
-    end
-    
-    curSuccessFlag = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat,doPrint );
-    if ( curSuccessFlag > 0 )
-        string = [string,'pass!'];
-        successFlag = 1;
-    else
-        string = [string,'fail!'];
-    end
-    
-    if ( doPrint > 0 )
-        disp( string );
-        if ( curSuccessFlag == 0 )
-            pause;
-        end
-    end
-    
-end
-
-
-
-function [ successFlag ] = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat, doPrint )
-
-    if ( nargin < 8 )
-        doPrint = 1;
-    end
-
-    TOL = 1e-15;
-    KKTTOL = 1e-6;
-
-    successFlag = 0;
-    
-    H1 = qpData1.H;
-	g1 = qpData1.g;
-    A1 = [qpData1.Aeq;qpData1.Ain];
-	lb1 = qpData1.lb;
-    ub1 = qpData1.ub;
-    lbA1 = [qpData1.beq;qpData1.lbA];
-    ubA1 = [qpData1.beq;qpData1.ubA];
-    
-    H2 = qpData2.H;
-	g2 = qpData2.g;
-    A2 = [qpData2.Aeq;qpData2.Ain];
-	lb2 = qpData2.lb;
-    ub2 = qpData2.ub;
-    lbA2 = [qpData2.beq;qpData2.lbA];
-    ubA2 = [qpData2.beq;qpData2.ubA];
-
-    [nV,dummy] = size(H1);
-    [nC,dummy] = size(A1);
-    
-    if ( hasWS > 0 )
-        if ( hasWS == 1 )
-            wsB = 0 * ones( nV,1 );
-            wsC = 0 * ones( nC,1 );
-        else
-            wsB = [];
-            wsC = [];
-        end
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0,'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else                        
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-            
-            auxInput = qpOASES_auxInput( 'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,[] );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,[] );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-        
-    else % hasWS == 0
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0 );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-                    
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options();
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1 );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1 );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-
-    end % hasWS
-
-
-    kktTol1 = getKktResidual( H1,g1,A1,lb1,ub1,lbA1,ubA1, x1,l1 );
-    
-    if ( changeMat > 0 )
-		kktTol2 = getKktResidual( H2,g2,A2,lb2,ub2,lbA2,ubA2, x2,l2 );
-	else
-		kktTol2 = getKktResidual( H1,g2,A1,lb2,ub2,lbA2,ubA2, x2,l2 );
-	end
-    
-    if ( ( kktTol1 <= KKTTOL ) && ( e1 >= 0 ) && ( kktTol2 <= KKTTOL ) && ( e2 >= 0 ) )
-        successFlag = 1;
-    else
-        if ( doPrint > 0 )
-            disp( ['kkt error: ',num2str(kktTol1),'/',num2str(kktTol2)] )
-        end
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomZeroHessian.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomZeroHessian.m
deleted file mode 100644
index 5fc4b91..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runRandomZeroHessian.m
+++ /dev/null
@@ -1,433 +0,0 @@
-function [ successFlag ] = runRandomZeroHessian( nV,nC, doPrint,seed )
-
-    if ( nargin < 4 )
-        seed = 42;
-        if ( nargin < 3 )
-            doPrint = 1;
-            if ( nargin < 2 )
-                nC = 10;
-                if ( nargin < 1 )
-                    nV = 5;
-                end
-            end
-        end
-    end
-    
-    successFlag = 1;
-
-    for isSparseH=0:1
-        for isSparseA=0:1
-            successFlag = runSeveralIdSeqTests( successFlag, nV,nC,isSparseH,isSparseA, doPrint,seed );
-        end
-    end
-    
-end
-
-
-function [ successFlag ] = runSeveralIdSeqTests( successFlag, nV,nC, isSparseH,isSparseA, doPrint,seed )
-
-    %% test without or empty A matrix
-    % {
-    for hasA=0:1
-        for changeMat=0:hasA % cannot change matrices if QProblemB object is instantiated
-            for hasOptions=1:1
-                for hasX0=0:2
-                    for hasWS=0:2
-                        curSuccessFLAG = runSingleIdSeqTest( nV,0,hasA,isSparseH,isSparseA, 1,1,0,0,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                        successFlag = min( successFlag,curSuccessFLAG );
-                    end
-                end
-            end
-        end
-    end
-    %}
-    
-    %% test with non-empty A matrix
-    for hasLowerC=0:1
-        for hasUpperC=0:1
-            for hasOptions=1:1
-                for hasX0=0:2
-                    for hasWS=0:2
-                        for changeMat=0:1
-                            curSuccessFLAG = runSingleIdSeqTest( nV,nC,1,isSparseH,isSparseA, 1,1,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed );
-                            successFlag = min( successFlag,curSuccessFLAG );
-                        end
-                    end
-                end
-            end
-        end
-    end
-    
-end
-
-
-function [ successFlag ] = runSingleIdSeqTest( nV,nC,hasA,isSparseH,isSparseA, hasLowerB,hasUpperB,hasLowerC,hasUpperC,hasOptions,hasX0,hasWS,changeMat, doPrint,seed )
-
-    successFlag = 0;
-
-    qpFeatures = setupQpFeaturesStruct( );
-    
-    qpFeatures.nV = nV;
-    qpFeatures.nC = nC;
-    
-    qpFeatures.isSparseH = isSparseH;
-    qpFeatures.isSparseA = isSparseA;
-    
-    qpFeatures.hasLowerB = hasLowerB;
-    qpFeatures.hasUpperB = hasUpperB;
-    qpFeatures.hasLowerC = hasLowerC;
-    qpFeatures.hasUpperC = hasUpperC;
-    
-    qpFeatures.hessianType = 3;
-    
-    qpData1 = generateRandomQp( qpFeatures,seed );
-    qpData2 = generateRandomQp( qpFeatures,seed );
-
-    if ( changeMat == 0 )
-        string = 'Testing qpOASES_sequence( ''i/h/c'',0';
-    else
-        string = 'Testing qpOASES_sequence( ''i/m/c'',0';
-    end
-    
-    if ( isSparseH > 0 )
-        string = [string,'s,g'];
-    else
-        string = [string,'d,g'];
-    end
-    
-    if ( nC > 0 )
-        if ( isSparseA > 0 )
-            string = [string,',As'];
-        else
-            string = [string,',Ad'];
-        end
-    else
-        if ( hasA > 0 )
-            string = [string,',[]'];
-        end
-    end
-    
-    if ( hasLowerB > 0 )
-        string = [string,',lb'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasUpperB > 0 )
-        string = [string,',ub'];
-    else
-        string = [string,',[]'];
-    end
-    
-    if ( hasLowerC > 0 )
-        string = [string,',lbA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    if ( hasUpperC > 0 )
-        string = [string,',ubA'];
-    else
-        if ( hasA > 0 )
-            string = [string,',[] '];
-        end
-    end
-    
-    switch ( hasOptions )
-        case 1
-            string = [string,',opt'];
-        
-        case 2
-            string = [string,',[] '];
-            
-        case 0
-            if ( ( hasX0 > 0 ) || ( hasWS > 0 ) )
-                string = [string,',[] '];
-            end
-    end
-
-    switch ( hasX0 )
-        case 1
-            string = [string,',{x0'];
-        
-        case 2
-            string = [string,',{[]'];
-            
-        case 0
-            if ( hasWS > 0 )
-                string = [string,',{[]'];
-            end
-    end
-    
-    switch ( hasWS )
-        case 1
-            string = [string,',WS}'];
-        
-        case 2
-            string = [string,',[]}'];
-    end
-
-    string = [string,' )... '];
-    if ( doPrint > 0 )
-        %disp( string );
-    end
-    
-	%try
-    curSuccessFlag = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat,doPrint );
-	%catch
-	%curSuccessFlag = 0;
-	%end
-    if ( curSuccessFlag > 0 )
-        string = [string,'pass!'];
-        successFlag = 1;
-    else
-        string = [string,'fail!'];
-    end
-    
-    if ( doPrint > 0 )
-        disp( string );
-        if ( curSuccessFlag == 0 )
-            %pause;
-        end
-    end
-    
-end
-
-
-
-function [ successFlag ] = callQpOasesSeq( qpData1,qpData2,hasA,hasOptions,hasX0,hasWS,changeMat, doPrint )
-
-    if ( nargin < 8 )
-        doPrint = 1;
-    end
-
-    TOL = 1e-15;
-    KKTTOL = 1e-6;
-
-    successFlag = 0;
-    
-    H1 = qpData1.H;
-	g1 = qpData1.g;
-    A1 = [qpData1.Aeq;qpData1.Ain];
-	lb1 = qpData1.lb;
-    ub1 = qpData1.ub;
-    lbA1 = [qpData1.beq;qpData1.lbA];
-    ubA1 = [qpData1.beq;qpData1.ubA];
-    
-    H2 = qpData2.H;
-	g2 = qpData2.g;
-    A2 = [qpData2.Aeq;qpData2.Ain];
-	lb2 = qpData2.lb;
-    ub2 = qpData2.ub;
-    lbA2 = [qpData2.beq;qpData2.lbA];
-    ubA2 = [qpData2.beq;qpData2.ubA];
-
-    [nV,dummy] = size(H1);
-    [nC,dummy] = size(A1);
-    
-    if ( hasWS > 0 )
-        if ( hasWS == 1 )
-            wsB = 0 * ones( nV,1 );
-            wsC = 0 * ones( nC,1 );
-        else
-            wsB = [];
-            wsC = [];
-        end
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0,'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options( 'fast' );
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else                        
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-
-            auxInput = qpOASES_auxInput( 'guessedWorkingSetB',wsB,'guessedWorkingSetC',wsC );
-            
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options( 'fast' );
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,[] );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,[] );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-        
-    else % hasWS == 0
-        
-        if ( hasX0 > 0 )
-            if ( hasX0 == 1 )
-                x0 = -1e-3 * ones( nV,1 );
-            else
-                x0 = [];
-            end
-            
-            auxInput = qpOASES_auxInput( 'x0',x0 );
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options( 'fast' );
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options,auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options,auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-                    
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,[],auxInput );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,[],auxInput );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        else % hasX0 == 0
-
-            if ( hasOptions > 0 )
-                if ( hasOptions == 1 )
-                    options = qpOASES_options( 'fast' );
-                else
-                    options = [];
-                end
-
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1,options );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2,options );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2,options );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1,options );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,options );
-                    qpOASES_sequence( 'c',QP );
-                end
-            else
-                if ( hasA > 0 )
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,A1,lb1,ub1,lbA1,ubA1 );
-                    if ( changeMat > 0 )
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'm',QP,H2,g2,A2,lb2,ub2,lbA2,ubA2 );
-                    else
-                        [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2,lbA2,ubA2 );
-                    end
-                    qpOASES_sequence( 'c',QP );
-                else
-                    [ QP,x1,f1,e1,i1,l1,w1 ] = qpOASES_sequence( 'i',H1,g1,lb1,ub1 );
-                    [ x2,f2,e2,i2,l2,w2 ] = qpOASES_sequence( 'h',QP,g2,lb2,ub2 );
-                    qpOASES_sequence( 'c',QP );
-                end
-            end
-
-        end % hasX0
-
-    end % hasWS
-
-
-    kktTol1 = getKktResidual( H1,g1,A1,lb1,ub1,lbA1,ubA1, x1,l1 );
-    
-    if ( changeMat > 0 )
-		kktTol2 = getKktResidual( H2,g2,A2,lb2,ub2,lbA2,ubA2, x2,l2 );
-	else
-		kktTol2 = getKktResidual( H1,g2,A1,lb2,ub2,lbA2,ubA2, x2,l2 );
-	end
-    
-    if ( ( kktTol1 <= KKTTOL ) && ( e1 >= 0 ) && ( kktTol2 <= KKTTOL ) && ( e2 >= 0 ) )
-        successFlag = 1;
-    else
-        if ( doPrint > 0 )
-            disp( ['kkt error: ',num2str(kktTol1),'/',num2str(kktTol2)] )
-        end
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runSimpleSpringExample.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runSimpleSpringExample.m
deleted file mode 100644
index 2f494a6..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runSimpleSpringExample.m
+++ /dev/null
@@ -1,34 +0,0 @@
-function [ successFlag ] = runSimpleSpringExample( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-    % parameter
-    k1 = 100;
-    k2 = 100;
-
-    m = 1;
-    g = 9.81;
-
-    % QP data
-    H = [ k1,0; 0,k2 ];
-    g = [ m*g; 0 ];
-
-    lb = [ 0; 0 ];
-    ub = [ 1; 1 ];
-
-    A = [ 1,1 ];
-    lbA = 1;
-    ubA = 1;
-
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-    [x,fval,exitflag,iter] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-
-    if ( ( exitflag == 0 ) && ( iter < 5 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestAPrioriKnownSeq1.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestAPrioriKnownSeq1.m
deleted file mode 100644
index 7f963cd..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestAPrioriKnownSeq1.m
+++ /dev/null
@@ -1,87 +0,0 @@
-function [ successFlag ] = runTestAPrioriKnownSeq1( doPrint )
-
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 1;
-    TOL = eps;
-
-    clear H g A lb ub lbA ubA;
-	
-    try
-        load 'benchmarkCRANE1.mat';
-    catch
-        successFlag = -1;
-        return;
-    end
-
-    [nC,nV] = size(A);
-    [nV,nP] = size(g);
-
-    xOptSeq = zeros(nV,nP);
-    objOptSeq = zeros(1,nP);
-    statusSeq = zeros(1,nP);
-    iterSeq = zeros(1,nP);
-    yOptSeq = zeros(nV+nC,nP);
-
-	options = qpOASES_options( 'fast','maxIter',100, 'printLevel',2*doPrint );
-
-	for i=1:nP
-		%disp(i);
-
-		if ( i == 1 )
-			[QP,x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'i',H,g(:,i),A,lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		else
-			[x,obj,status,nWSRout,lambda] = qpOASES_sequence( 'h',QP,g(:,i),lb(:,i),ub(:,i),lbA(:,i),ubA(:,i),options );
-		end
-
-        xOptSeq(:,i) = x;
-        objOptSeq(:,i) = obj;
-        statusSeq(:,i) = status;
-        iterSeq(:,i) = nWSRout;
-        yOptSeq(:,i) = lambda;
-        
-    end
-	
-	qpOASES_sequence( 'c',QP );
-    
-    
-    [xOptAPKSeq,objOptAPKSeq,statusAPKSeq,iterAPKSeq,yOptAPKSeq] = qpOASES( H,g,A,lb,ub,lbA,ubA,options );
-    
-    if ( norm( xOptSeq-xOptAPKSeq ) > TOL )
-        successFlag = 0;
-        if ( doPrint > 0 )
-            disp( 'xOpt error' )
-        end
-    end
-    
-    if ( norm( objOptSeq-objOptAPKSeq ) > TOL )
-        successFlag = 0;
-        if ( doPrint > 0 )
-            disp( 'objOpt error' )
-        end
-    end
-    
-    if ( sum( statusSeq~=statusAPKSeq ) > 0 )
-        successFlag = 0;
-        if ( doPrint > 0 )
-            disp( 'status error' )
-        end
-    end
-    
-    if ( sum( iterSeq~=iterAPKSeq ) > 0 )
-        successFlag = 0;
-        if ( doPrint > 0 )
-            disp( 'iter error' )
-        end
-    end
-    
-    if ( norm( yOptSeq-yOptAPKSeq ) > TOL )
-        successFlag = 0;
-        if ( doPrint > 0 )
-            disp( 'yOpt error' )
-        end
-    end
-	
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSeq.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSeq.m
deleted file mode 100644
index 00c4fe8..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSeq.m
+++ /dev/null
@@ -1,104 +0,0 @@
-function [ successFlag ] = runTestSeq( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 1;
-    
-
-    % test case constants
-    m = 50;
-    n = 100;
-    nMajSeq = 8;
-    nMinSeq = 4;
-    nSeq = nMajSeq * nMinSeq;
-    p = 2; % interpolation monomial power
-    fldim = 5; % feedback law dimension
-
-    % generate start and end problem
-    Ls = sprand(n, n, 0.03);
-    Hs = Ls' * Ls + 1e-8 * eye(n);
-    As = sprand(m, n, 0.05);
-
-    % negative (!) definite Hessian
-    Le = sprand(n, n, 0.03);
-    He = -Le' * Le;
-    Ae = sprand(m, n, 0.05);
-
-    lbAs = -rand(m,1);
-    ubAs = rand(m,1); 
-    ubs = ones(n,1);
-    lbs = -ones(n,1);
-    gs = 10*rand(n,1);
-
-    lbAe = -rand(m,1);
-    ubAe = rand(m,1); 
-    ube = ones(n,1);
-    lbe = -ones(n,1);
-    ge = 10*rand(n,1);
-
-    % monomial interpolation
-    tmaj = 1 - (1:1/(1-nMajSeq):0).^p;
-    for i = 1:nMajSeq
-        tau = tmaj(i);
-        H{i} = (1-tau) * Hs + tau * He;
-        A{i} = (1-tau) * As + tau * Ae;
-    end
-    t = 1 - (1:1/(1-nSeq):0).^p;
-    for i = 1:nSeq
-        tau = t(i);
-        lbA{i} = (1-tau) * lbAs + tau * lbAe;
-        ubA{i} = (1-tau) * ubAs + tau * ubAe;
-        lb{i} = (1-tau) * lbs + tau * lbe;
-        ub{i} = (1-tau) * ubs + tau * ube;
-        g{i} = (1-tau) * gs + tau * ge;
-    end
-
-    x = zeros(n,1);
-
-    if ~exist('cumIters', 'var')
-        cumIters = zeros(nSeq, 1);
-    end
-
-    % solve sequence of QPs
-    if ( doPrint > 0 )
-        fprintf('%3s %5s\n', 'seq', 'iters')
-    end
-    
-    for i = 1:nSeq
-        if i == 1
-            [QP, x, fval, exitflag, iter, lambda] = qpOASES_sequence('i', ...
-                H{i}, g{i}, A{i}, lb{i}, ub{i}, lbA{i}, ubA{i}, x);
-        else
-            if mod(i-1, nMinSeq) == 0
-                j = (i-1) / nMinSeq + 1;
-                [x, fval, exitflag, iter, lambda] = qpOASES_sequence('m', QP, ...
-                    H{j}, g{i}, A{j}, lb{i}, ub{i}, lbA{i}, ubA{i});
-            else
-                [x, fval, exitflag, iter, lambda] = qpOASES_sequence('h', QP, ...
-                    g{i}, lb{i}, ub{i}, lbA{i}, ubA{i});
-            end
-        end
-        
-        if ( doPrint > 0 )
-            fprintf('%3d %5d\n', i, iter)
-        end
-        
-        cumIters(i) = cumIters(i) + iter;
-        
-        if ( exitflag ~= 0 )
-            successFlag = 0;
-        end
-    end
-
-    % solve EQP
-    V0 = zeros(n, fldim);
-    Lambda = eye(m, fldim);
-    [X, Y] = qpOASES_sequence('e', QP, V0, V0, V0, Lambda, Lambda);
-    FL = X(1:fldim,:);
-
-    % clear
-    qpOASES_sequence('c', QP)
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse.m
deleted file mode 100644
index 272c689..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse.m
+++ /dev/null
@@ -1,33 +0,0 @@
-function [ successFlag ] = runTestSparse( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-
-
-    m = 50;
-    n = 100;
-
-    L = sprand(n, n, 0.03);
-    H = L' * L;
-    A = sprand(m, n, 0.05);
-
-    lbA = -rand(m,1);
-    ubA = rand(m,1); 
-    ub = ones(n,1);
-    lb = -ones(n,1);
-    g = 10*rand(n,1);
-    
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-
-    [x1,dummy1,exitflag1,iter1] = qpOASES(full(H), g, full(A), lb, ub, lbA, ubA, options);
-    [x2,dummy1,exitflag2,iter2] = qpOASES(H, g, A, lb, ub, lbA, ubA, options);
-    
-    if ( ( exitflag1 == 0 ) && ( exitflag2 == 0 ) && ( iter1 == iter2 ) ...
-            && ( norm(x1-x2) < 1e-10 ) )
-        successFlag = 1;
-    end
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse2.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse2.m
deleted file mode 100644
index fc1f816..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse2.m
+++ /dev/null
@@ -1,33 +0,0 @@
-function [ successFlag ] = runTestSparse2( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-
-    m = 50;
-    n = 100;
-
-    L = sprand(n, n, 0.03);
-    H = L' * L;
-    A = sprand(m, n, 0.05);
-
-    lbA = -rand(m,1);
-    ubA = rand(m,1); 
-    ub = ones(n,1);
-    lb = -ones(n,1);
-    g = 10*rand(n,1);
-
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-    
-    [QP,dummy1,dummy2,exitflag1] = qpOASES_sequence( 'i', H, g, A, lb, ub, lbA, ubA, options );
-    [dummy1,dummy2,exitflag2] = qpOASES_sequence( 'h',QP, g*2, lb, ub, lbA, ubA );
-    qpOASES_sequence( 'c',QP );
-    
-    if ( ( exitflag1 == 0 ) && ( exitflag2 == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse3.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse3.m
deleted file mode 100644
index c4f870c..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse3.m
+++ /dev/null
@@ -1,39 +0,0 @@
-function [ successFlag ] = runTestSparse3( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-
-    
-    m = 50;
-    n = 100;
-
-    L = sprand(n, n, 0.03);
-    H = L' * L;
-    A = sprand(m, n, 0.05);
-
-    lbA = -rand(m,1);
-    ubA = rand(m,1); 
-    ub = ones(n,1);
-    lb = -ones(n,1);
-    g = 10*rand(n,1);
-
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-    
-    
-    [QP,dummy1,dummy2,exitflag1] = qpOASES_sequence( 'i', H, g, A, lb, ub, lbA, ubA, options );
-
-    L = sprand(n, n, 0.03);
-    H = L' * L;
-    A = sprand(m, n, 0.05);
-
-    [dummy1,dummy2,exitflag2] = qpOASES_sequence( 'm',QP, H, g*2, A, lb, ub, lbA, ubA );
-    qpOASES_sequence( 'c',QP );
-    
-    if ( ( exitflag1 == 0 ) && ( exitflag2 == 0 ) )
-        successFlag = 1;
-    end
-    
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse4.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse4.m
deleted file mode 100644
index 7c468e4..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestSparse4.m
+++ /dev/null
@@ -1,29 +0,0 @@
-function [ successFlag ] = runTestSparse4( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-    
-    n = 100;
-
-    L = sprand(n, n, 0.03);
-    H = L' * L;
-
-    ub = ones(n,1);
-    lb = -ones(n,1);
-    g = 10*rand(n,1);
-    
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint );
-
-    [QP,dummy1,dummy2,exitflag1] = qpOASES_sequence( 'i', H, g, lb, ub, options );
-    [dummy1,dummy2,exitflag2] = qpOASES_sequence( 'h',QP, g*2, lb, ub );
-    qpOASES_sequence( 'c',QP );
-
-    if ( ( exitflag1 == 0 ) && ( exitflag2 == 0 ) )
-        successFlag = 1;
-    end
-
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestWorkingSetLI.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestWorkingSetLI.m
deleted file mode 100644
index 3cdfeb4..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runTestWorkingSetLI.m
+++ /dev/null
@@ -1,50 +0,0 @@
-function [ successFlag ] = runTestWorkingSetLI( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 1;
-    
-    qpFeatures = setupQpFeaturesStruct( );
-    
-    qpFeatures.nV = 20;
-    qpFeatures.nC = 100;
-    
-    qpFeatures.isSparseH = 0;
-    qpFeatures.isSparseA = 0;
-    
-    qpFeatures.hasLowerB = 1;
-    qpFeatures.hasUpperB = 1;
-    qpFeatures.hasLowerC = 1;
-    qpFeatures.hasUpperC = 1;
-    
-    qpFeatures.makeInfeas = 1;
-    
-    options = qpOASES_options( 'default', 'printLevel',2*doPrint, 'initialStatusBounds',0 );
-    
-    exitflag = 0;
-    counter = 0;
-    
-    while ( ( exitflag ~= -42 ) && ( counter < 100 ) )
-        
-        counter = counter+1;
-        
-        qpData = generateRandomQp( qpFeatures );
-        B = [ eye( qpFeatures.nV ); qpData.Ain ];
-    
-        [x,dummy1,exitflag,dummy2,dummy3,auxOutput] = qpOASES( qpData.H,qpData.g,qpData.Ain, ...
-                qpData.lb,qpData.ub,qpData.lbA,qpData.ubA, options ); %#ok<*NASGU>
-            
-        WS = [auxOutput.workingSetB; auxOutput.workingSetC];
-        nAct = sum( WS~=0 );
-        Bact = B( WS~=0,: );
-
-        if ( nAct ~= rank(Bact) )
-            successFlag = 0;
-            return;
-        end
-        
-    end
-   
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runVanBarelsUnboundedQP.m b/extlibs/qpOASES-3.2.0/testing/matlab/tests/runVanBarelsUnboundedQP.m
deleted file mode 100644
index 9198342..0000000
--- a/extlibs/qpOASES-3.2.0/testing/matlab/tests/runVanBarelsUnboundedQP.m
+++ /dev/null
@@ -1,25 +0,0 @@
-function [ successFlag ] = runVanBarelsUnboundedQP( doPrint )
-    
-    if ( nargin < 1 )
-        doPrint = 0;
-    end
-
-    successFlag = 0;
-    
-    try
-        data = load( 'vanBarelsUnboundedQP.mat' );
-    catch
-        successFlag = -1;
-        return;
-    end
-    
-    options1 = qpOASES_options( 'default', 'printLevel',-1*doPrint );
-    
-    [dummy1,dummy2,exitflag1,iter1] = qpOASES( data.H,data.g,data.lb,data.ub,options1 ); %#ok<*NASGU>
-
-    % should return "QP unbounded"
-    if ( exitflag1 == -3 )
-        successFlag = 1;
-    end
-   
-end
diff --git a/extlibs/qpOASES-3.2.0/testing/runUnitTests b/extlibs/qpOASES-3.2.0/testing/runUnitTests
deleted file mode 100755
index 3a1203e..0000000
--- a/extlibs/qpOASES-3.2.0/testing/runUnitTests
+++ /dev/null
@@ -1,110 +0,0 @@
-#!/usr/bin/env bash
-
-##
-##	This file is part of qpOASES.
-##
-##	qpOASES -- An Implementation of the Online Active Set Strategy.
-##	Copyright (C) 2007-2015 by Hans Joachim Ferreau, Andreas Potschka,
-##	Christian Kirches et al. All rights reserved.
-##
-##	qpOASES is free software; you can redistribute it and/or
-##	modify it under the terms of the GNU Lesser General Public
-##	License as published by the Free Software Foundation; either
-##	version 2.1 of the License, or (at your option) any later version.
-##
-##	qpOASES is distributed in the hope that it will be useful,
-##	but WITHOUT ANY WARRANTY; without even the implied warranty of
-##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-##	See the GNU Lesser General Public License for more details.
-##
-##	You should have received a copy of the GNU Lesser General Public
-##	License along with qpOASES; if not, write to the Free Software
-##	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-##
-
-
-
-##
-##	Filename:  testing/runUnitTests
-##	Author:    Hans Joachim Ferreau
-##	Version:   3.2
-##	Date:      2014-2015
-
-# defining colors for output
-red='\e[0;31m'
-green='\e[0;32m'
-NC='\e[0m' # No Color
-
-# runs a number of examples to detect malfunctioning of the code
-
-function runTest {
-	echo -n "Running unit test $2 $3... "
-
-	$2 $3 > dummy.txt;
-	retVal=$?;
-	rm -rf dummy.txt;
-
-	if [ $retVal == 0 ]; then
-		echo -e "${green}passed!${NC}"
-	else
-		if [ $retVal == 99 ]; then
-			echo "problem data missing!"
-		else
-			echo -e "${red}failed!${NC}"
-			counter=$[counter+1];
-		fi
-	fi
-}
-
-
-cd ..;
-make testing;
-cd testing;
-
-counter=0;
-
-# run unit tests
-runTest $counter ../bin/test_matrices;
-runTest $counter ../bin/test_matrices2;
-runTest $counter ../bin/test_matrices3;
-runTest $counter ../bin/test_indexlist;
-
-runTest $counter ../bin/test_example1;
-runTest $counter ../bin/test_example1a;
-runTest $counter ../bin/test_example1b;
-runTest $counter ../bin/test_example2;
-runTest $counter ../bin/test_example4;
-runTest $counter ../bin/test_example5;
-runTest $counter ../bin/test_exampleLP;
-runTest $counter ../bin/test_qrecipe;
-runTest $counter ../bin/test_qrecipeSchur;
-runTest $counter ../bin/test_infeasible1;
-runTest $counter ../bin/test_hs268;
-
-runTest $counter ../bin/test_example6;
-runTest $counter ../bin/test_example7;
-runTest $counter ../bin/test_sebastien1;
-runTest $counter ../bin/test_vanBarelsUnboundedQP;
-runTest $counter ../bin/test_janick1;
-runTest $counter ../bin/test_janick2;
-runTest $counter ../bin/test_constraintProduct1;
-runTest $counter ../bin/test_constraintProduct2;
-runTest $counter ../bin/test_guessedWS1;
-runTest $counter ../bin/test_externalChol1;
-runTest $counter ../bin/test_gradientShift;
-runTest $counter ../bin/test_runAllOqpExamples;
-
-runTest $counter ../bin/test_bench Odd;
-runTest $counter ../bin/test_bench Ods;
-#runTest $counter ../bin/test_bench Ord;
-#runTest $counter ../bin/test_bench Ors;
-runTest $counter ../bin/test_bench Omd;
-#runTest $counter ../bin/test_bench Oms;
-
-
-if [ $counter == 0 ]; then
-	echo -e "${green}All available tests passed successfully!${NC}"
-else
-	echo -e "${red}$counter test(s) failed!${NC}"
-	exit 1
-fi
-- 
2.34.1

